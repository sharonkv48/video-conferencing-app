"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stream-io";
exports.ids = ["vendor-chunks/@stream-io"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/@stream-io/video-client/dist/index.es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* binding */ AudioSettingsDefaultDeviceEnum),\n/* harmony export */   AudioSettingsRequestDefaultDeviceEnum: () => (/* binding */ AudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   AxiosError: () => (/* reexport safe */ axios__WEBPACK_IMPORTED_MODULE_1__.AxiosError),\n/* harmony export */   Browsers: () => (/* binding */ browsers),\n/* harmony export */   Call: () => (/* binding */ Call),\n/* harmony export */   CallState: () => (/* binding */ CallState),\n/* harmony export */   CallType: () => (/* binding */ CallType),\n/* harmony export */   CallTypes: () => (/* binding */ CallTypes),\n/* harmony export */   CallingState: () => (/* binding */ CallingState),\n/* harmony export */   CameraManager: () => (/* binding */ CameraManager),\n/* harmony export */   CameraManagerState: () => (/* binding */ CameraManagerState),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* binding */ CreateDeviceRequestPushProviderEnum),\n/* harmony export */   DebounceType: () => (/* binding */ DebounceType),\n/* harmony export */   DynascaleManager: () => (/* binding */ DynascaleManager),\n/* harmony export */   ErrorFromResponse: () => (/* binding */ ErrorFromResponse),\n/* harmony export */   InputMediaDeviceManager: () => (/* binding */ InputMediaDeviceManager),\n/* harmony export */   InputMediaDeviceManagerState: () => (/* binding */ InputMediaDeviceManagerState),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* binding */ LayoutSettingsNameEnum),\n/* harmony export */   LayoutSettingsRequestNameEnum: () => (/* binding */ LayoutSettingsRequestNameEnum),\n/* harmony export */   MicrophoneManager: () => (/* binding */ MicrophoneManager),\n/* harmony export */   MicrophoneManagerState: () => (/* binding */ MicrophoneManagerState),\n/* harmony export */   OwnCapability: () => (/* binding */ OwnCapability),\n/* harmony export */   RecordSettingsRequestModeEnum: () => (/* binding */ RecordSettingsRequestModeEnum),\n/* harmony export */   RecordSettingsRequestQualityEnum: () => (/* binding */ RecordSettingsRequestQualityEnum),\n/* harmony export */   RxUtils: () => (/* binding */ rxUtils),\n/* harmony export */   ScreenShareManager: () => (/* binding */ ScreenShareManager),\n/* harmony export */   ScreenShareState: () => (/* binding */ ScreenShareState),\n/* harmony export */   SfuEvents: () => (/* binding */ events),\n/* harmony export */   SfuModels: () => (/* binding */ models),\n/* harmony export */   SpeakerManager: () => (/* binding */ SpeakerManager),\n/* harmony export */   SpeakerState: () => (/* binding */ SpeakerState),\n/* harmony export */   StreamSfuClient: () => (/* binding */ StreamSfuClient),\n/* harmony export */   StreamVideoClient: () => (/* binding */ StreamVideoClient),\n/* harmony export */   StreamVideoReadOnlyStateStore: () => (/* binding */ StreamVideoReadOnlyStateStore),\n/* harmony export */   StreamVideoServerClient: () => (/* binding */ StreamVideoServerClient),\n/* harmony export */   StreamVideoWriteableStateStore: () => (/* binding */ StreamVideoWriteableStateStore),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* binding */ TranscriptionSettingsModeEnum),\n/* harmony export */   TranscriptionSettingsRequestModeEnum: () => (/* binding */ TranscriptionSettingsRequestModeEnum),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* binding */ VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoSettingsRequestCameraFacingEnum: () => (/* binding */ VideoSettingsRequestCameraFacingEnum),\n/* harmony export */   ViewportTracker: () => (/* binding */ ViewportTracker),\n/* harmony export */   VisibilityState: () => (/* binding */ VisibilityState),\n/* harmony export */   checkIfAudioOutputChangeSupported: () => (/* binding */ checkIfAudioOutputChangeSupported),\n/* harmony export */   combineComparators: () => (/* binding */ combineComparators),\n/* harmony export */   conditional: () => (/* binding */ conditional),\n/* harmony export */   createSoundDetector: () => (/* binding */ createSoundDetector),\n/* harmony export */   defaultSortPreset: () => (/* binding */ defaultSortPreset),\n/* harmony export */   descending: () => (/* binding */ descending),\n/* harmony export */   deviceIds$: () => (/* binding */ deviceIds$),\n/* harmony export */   disposeOfMediaStream: () => (/* binding */ disposeOfMediaStream),\n/* harmony export */   dominantSpeaker: () => (/* binding */ dominantSpeaker),\n/* harmony export */   getAudioDevices: () => (/* binding */ getAudioDevices),\n/* harmony export */   getAudioOutputDevices: () => (/* binding */ getAudioOutputDevices),\n/* harmony export */   getAudioStream: () => (/* binding */ getAudioStream),\n/* harmony export */   getClientDetails: () => (/* binding */ getClientDetails),\n/* harmony export */   getDeviceInfo: () => (/* binding */ getDeviceInfo),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   getOSInfo: () => (/* binding */ getOSInfo),\n/* harmony export */   getScreenShareStream: () => (/* binding */ getScreenShareStream),\n/* harmony export */   getSdkInfo: () => (/* binding */ getSdkInfo),\n/* harmony export */   getVideoDevices: () => (/* binding */ getVideoDevices),\n/* harmony export */   getVideoStream: () => (/* binding */ getVideoStream),\n/* harmony export */   getWebRTCInfo: () => (/* binding */ getWebRTCInfo),\n/* harmony export */   livestreamOrAudioRoomSortPreset: () => (/* binding */ livestreamOrAudioRoomSortPreset),\n/* harmony export */   logLevels: () => (/* binding */ logLevels),\n/* harmony export */   logToConsole: () => (/* binding */ logToConsole),\n/* harmony export */   name: () => (/* binding */ name),\n/* harmony export */   noopComparator: () => (/* binding */ noopComparator),\n/* harmony export */   paginatedLayoutSortPreset: () => (/* binding */ paginatedLayoutSortPreset),\n/* harmony export */   pinned: () => (/* binding */ pinned),\n/* harmony export */   publishingAudio: () => (/* binding */ publishingAudio),\n/* harmony export */   publishingVideo: () => (/* binding */ publishingVideo),\n/* harmony export */   reactionType: () => (/* binding */ reactionType),\n/* harmony export */   role: () => (/* binding */ role),\n/* harmony export */   screenSharing: () => (/* binding */ screenSharing),\n/* harmony export */   setDeviceInfo: () => (/* binding */ setDeviceInfo),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setLogger: () => (/* binding */ setLogger),\n/* harmony export */   setOSInfo: () => (/* binding */ setOSInfo),\n/* harmony export */   setSdkInfo: () => (/* binding */ setSdkInfo),\n/* harmony export */   setWebRTCInfo: () => (/* binding */ setWebRTCInfo),\n/* harmony export */   speakerLayoutSortPreset: () => (/* binding */ speakerLayoutSortPreset),\n/* harmony export */   speaking: () => (/* binding */ speaking)\n/* harmony export */ });\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webrtc-adapter */ \"(ssr)/./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/message-type.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js\");\n/* harmony import */ var _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @protobuf-ts/runtime-rpc */ \"(ssr)/./node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js\");\n/* harmony import */ var _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @protobuf-ts/runtime-rpc */ \"(ssr)/./node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\n/* harmony import */ var _protobuf_ts_twirp_transport__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @protobuf-ts/twirp-transport */ \"(ssr)/./node_modules/@protobuf-ts/twirp-transport/build/es2015/twirp-transport.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/merge.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/pairwise.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/of.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/debounce.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/timer.js\");\n/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdp-transform */ \"(ssr)/./node_modules/sdp-transform/lib/index.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ua-parser-js */ \"(ssr)/./node_modules/ua-parser-js/src/ua-parser.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var isomorphic_ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! isomorphic-ws */ \"(ssr)/./node_modules/isomorphic-ws/node.js\");\n/* harmony import */ var isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(isomorphic_ws__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jsonwebtoken */ \"(ssr)/./node_modules/jsonwebtoken/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! base64-js */ \"(ssr)/./node_modules/base64-js/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @export\n */ const AudioSettingsDefaultDeviceEnum = {\n    SPEAKER: \"speaker\",\n    EARPIECE: \"earpiece\"\n};\n/**\n * @export\n */ const AudioSettingsRequestDefaultDeviceEnum = {\n    SPEAKER: \"speaker\",\n    EARPIECE: \"earpiece\"\n};\n/**\n * @export\n */ const CreateDeviceRequestPushProviderEnum = {\n    FIREBASE: \"firebase\",\n    APN: \"apn\",\n    HUAWEI: \"huawei\",\n    XIAOMI: \"xiaomi\"\n};\n/**\n * @export\n */ const LayoutSettingsNameEnum = {\n    SPOTLIGHT: \"spotlight\",\n    GRID: \"grid\",\n    SINGLE_PARTICIPANT: \"single-participant\",\n    MOBILE: \"mobile\",\n    CUSTOM: \"custom\"\n};\n/**\n * @export\n */ const LayoutSettingsRequestNameEnum = {\n    SPOTLIGHT: \"spotlight\",\n    GRID: \"grid\",\n    SINGLE_PARTICIPANT: \"single-participant\",\n    MOBILE: \"mobile\",\n    CUSTOM: \"custom\"\n};\n/**\n * All possibility of string to use\n * @export\n */ const OwnCapability = {\n    BLOCK_USERS: \"block-users\",\n    CREATE_CALL: \"create-call\",\n    CREATE_REACTION: \"create-reaction\",\n    END_CALL: \"end-call\",\n    JOIN_BACKSTAGE: \"join-backstage\",\n    JOIN_CALL: \"join-call\",\n    JOIN_ENDED_CALL: \"join-ended-call\",\n    MUTE_USERS: \"mute-users\",\n    PIN_FOR_EVERYONE: \"pin-for-everyone\",\n    READ_CALL: \"read-call\",\n    REMOVE_CALL_MEMBER: \"remove-call-member\",\n    SCREENSHARE: \"screenshare\",\n    SEND_AUDIO: \"send-audio\",\n    SEND_VIDEO: \"send-video\",\n    START_BROADCAST_CALL: \"start-broadcast-call\",\n    START_RECORD_CALL: \"start-record-call\",\n    START_TRANSCRIPTION_CALL: \"start-transcription-call\",\n    STOP_BROADCAST_CALL: \"stop-broadcast-call\",\n    STOP_RECORD_CALL: \"stop-record-call\",\n    STOP_TRANSCRIPTION_CALL: \"stop-transcription-call\",\n    UPDATE_CALL: \"update-call\",\n    UPDATE_CALL_MEMBER: \"update-call-member\",\n    UPDATE_CALL_PERMISSIONS: \"update-call-permissions\",\n    UPDATE_CALL_SETTINGS: \"update-call-settings\"\n};\n/**\n * @export\n */ const RecordSettingsRequestModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const RecordSettingsRequestQualityEnum = {\n    _360P: \"360p\",\n    _480P: \"480p\",\n    _720P: \"720p\",\n    _1080P: \"1080p\",\n    _1440P: \"1440p\"\n};\n/**\n * @export\n */ const TranscriptionSettingsModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const TranscriptionSettingsRequestModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const VideoSettingsCameraFacingEnum = {\n    FRONT: \"front\",\n    BACK: \"back\",\n    EXTERNAL: \"external\"\n};\n/**\n * @export\n */ const VideoSettingsRequestCameraFacingEnum = {\n    FRONT: \"front\",\n    BACK: \"back\",\n    EXTERNAL: \"external\"\n};\nclass ErrorFromResponse extends Error {\n}\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n *  The JSON representation for `NullValue` is JSON `null`.\n *\n * @generated from protobuf enum google.protobuf.NullValue\n */ var NullValue;\n(function(NullValue) {\n    /**\n     * Null value.\n     *\n     * @generated from protobuf enum value: NULL_VALUE = 0;\n     */ NullValue[NullValue[\"NULL_VALUE\"] = 0] = \"NULL_VALUE\";\n})(NullValue || (NullValue = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass Struct$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Struct\", [\n            {\n                no: 1,\n                name: \"fields\",\n                kind: \"map\",\n                K: 9 /*ScalarType.STRING*/ ,\n                V: {\n                    kind: \"message\",\n                    T: ()=>Value\n                }\n            }\n        ]);\n    }\n    /**\n     * Encode `Struct` to JSON object.\n     */ internalJsonWrite(message, options) {\n        let json = {};\n        for (let [k, v] of Object.entries(message.fields)){\n            json[k] = Value.toJson(v);\n        }\n        return json;\n    }\n    /**\n     * Decode `Struct` from JSON object.\n     */ internalJsonRead(json, options, target) {\n        if (!(0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.isJsonObject)(json)) throw new globalThis.Error(\"Unable to parse message \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json) + \".\");\n        if (!target) target = this.create();\n        for (let [k, v] of globalThis.Object.entries(json)){\n            target.fields[k] = Value.fromJson(v);\n        }\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.fields = {};\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* map<string, google.protobuf.Value> fields */ 1:\n                    this.binaryReadMap1(message.fields, reader, options);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    binaryReadMap1(map, reader, options) {\n        let len = reader.uint32(), end = reader.pos + len, key, val;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = Value.internalBinaryRead(reader, reader.uint32(), options);\n                    break;\n                default:\n                    throw new globalThis.Error(\"unknown map entry field for field google.protobuf.Struct.fields\");\n            }\n        }\n        map[key ?? \"\"] = val ?? Value.create();\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* map<string, google.protobuf.Value> fields = 1; */ for (let k of globalThis.Object.keys(message.fields)){\n            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork().tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(k);\n            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork();\n            Value.internalBinaryWrite(message.fields[k], writer, options);\n            writer.join().join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Struct\n */ const Struct = new Struct$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Value$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Value\", [\n            {\n                no: 1,\n                name: \"null_value\",\n                kind: \"enum\",\n                oneof: \"kind\",\n                T: ()=>[\n                        \"google.protobuf.NullValue\",\n                        NullValue\n                    ]\n            },\n            {\n                no: 2,\n                name: \"number_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 1 /*ScalarType.DOUBLE*/ \n            },\n            {\n                no: 3,\n                name: \"string_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"bool_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 5,\n                name: \"struct_value\",\n                kind: \"message\",\n                oneof: \"kind\",\n                T: ()=>Struct\n            },\n            {\n                no: 6,\n                name: \"list_value\",\n                kind: \"message\",\n                oneof: \"kind\",\n                T: ()=>ListValue\n            }\n        ]);\n    }\n    /**\n     * Encode `Value` to JSON value.\n     */ internalJsonWrite(message, options) {\n        if (message.kind.oneofKind === undefined) throw new globalThis.Error();\n        switch(message.kind.oneofKind){\n            case undefined:\n                throw new globalThis.Error();\n            case \"boolValue\":\n                return message.kind.boolValue;\n            case \"nullValue\":\n                return null;\n            case \"numberValue\":\n                let numberValue = message.kind.numberValue;\n                if (typeof numberValue == \"number\" && !Number.isFinite(numberValue)) throw new globalThis.Error();\n                return numberValue;\n            case \"stringValue\":\n                return message.kind.stringValue;\n            case \"listValue\":\n                let listValueField = this.fields.find((f)=>f.no === 6);\n                if (listValueField?.kind !== \"message\") throw new globalThis.Error();\n                return listValueField.T().toJson(message.kind.listValue);\n            case \"structValue\":\n                let structValueField = this.fields.find((f)=>f.no === 5);\n                if (structValueField?.kind !== \"message\") throw new globalThis.Error();\n                return structValueField.T().toJson(message.kind.structValue);\n        }\n    }\n    /**\n     * Decode `Value` from JSON value.\n     */ internalJsonRead(json, options, target) {\n        if (!target) target = this.create();\n        switch(typeof json){\n            case \"number\":\n                target.kind = {\n                    oneofKind: \"numberValue\",\n                    numberValue: json\n                };\n                break;\n            case \"string\":\n                target.kind = {\n                    oneofKind: \"stringValue\",\n                    stringValue: json\n                };\n                break;\n            case \"boolean\":\n                target.kind = {\n                    oneofKind: \"boolValue\",\n                    boolValue: json\n                };\n                break;\n            case \"object\":\n                if (json === null) {\n                    target.kind = {\n                        oneofKind: \"nullValue\",\n                        nullValue: NullValue.NULL_VALUE\n                    };\n                } else if (globalThis.Array.isArray(json)) {\n                    target.kind = {\n                        oneofKind: \"listValue\",\n                        listValue: ListValue.fromJson(json)\n                    };\n                } else {\n                    target.kind = {\n                        oneofKind: \"structValue\",\n                        structValue: Struct.fromJson(json)\n                    };\n                }\n                break;\n            default:\n                throw new globalThis.Error(\"Unable to parse \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json));\n        }\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.kind = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* google.protobuf.NullValue null_value */ 1:\n                    message.kind = {\n                        oneofKind: \"nullValue\",\n                        nullValue: reader.int32()\n                    };\n                    break;\n                case /* double number_value */ 2:\n                    message.kind = {\n                        oneofKind: \"numberValue\",\n                        numberValue: reader.double()\n                    };\n                    break;\n                case /* string string_value */ 3:\n                    message.kind = {\n                        oneofKind: \"stringValue\",\n                        stringValue: reader.string()\n                    };\n                    break;\n                case /* bool bool_value */ 4:\n                    message.kind = {\n                        oneofKind: \"boolValue\",\n                        boolValue: reader.bool()\n                    };\n                    break;\n                case /* google.protobuf.Struct struct_value */ 5:\n                    message.kind = {\n                        oneofKind: \"structValue\",\n                        structValue: Struct.internalBinaryRead(reader, reader.uint32(), options, message.kind.structValue)\n                    };\n                    break;\n                case /* google.protobuf.ListValue list_value */ 6:\n                    message.kind = {\n                        oneofKind: \"listValue\",\n                        listValue: ListValue.internalBinaryRead(reader, reader.uint32(), options, message.kind.listValue)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* google.protobuf.NullValue null_value = 1; */ if (message.kind.oneofKind === \"nullValue\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.kind.nullValue);\n        /* double number_value = 2; */ if (message.kind.oneofKind === \"numberValue\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit64).double(message.kind.numberValue);\n        /* string string_value = 3; */ if (message.kind.oneofKind === \"stringValue\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.kind.stringValue);\n        /* bool bool_value = 4; */ if (message.kind.oneofKind === \"boolValue\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.kind.boolValue);\n        /* google.protobuf.Struct struct_value = 5; */ if (message.kind.oneofKind === \"structValue\") Struct.internalBinaryWrite(message.kind.structValue, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.ListValue list_value = 6; */ if (message.kind.oneofKind === \"listValue\") ListValue.internalBinaryWrite(message.kind.listValue, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Value\n */ const Value = new Value$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ListValue$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.ListValue\", [\n            {\n                no: 1,\n                name: \"values\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Value\n            }\n        ]);\n    }\n    /**\n     * Encode `ListValue` to JSON array.\n     */ internalJsonWrite(message, options) {\n        return message.values.map((v)=>Value.toJson(v));\n    }\n    /**\n     * Decode `ListValue` from JSON array.\n     */ internalJsonRead(json, options, target) {\n        if (!globalThis.Array.isArray(json)) throw new globalThis.Error(\"Unable to parse \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json));\n        if (!target) target = this.create();\n        let values = json.map((v)=>Value.fromJson(v));\n        target.values.push(...values);\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.values = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated google.protobuf.Value values */ 1:\n                    message.values.push(Value.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated google.protobuf.Value values = 1; */ for(let i = 0; i < message.values.length; i++)Value.internalBinaryWrite(message.values[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.ListValue\n */ const ListValue = new ListValue$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Timestamp$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Timestamp\", [\n            {\n                no: 1,\n                name: \"seconds\",\n                kind: \"scalar\",\n                T: 3 /*ScalarType.INT64*/ \n            },\n            {\n                no: 2,\n                name: \"nanos\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    /**\n     * Creates a new `Timestamp` for the current time.\n     */ now() {\n        const msg = this.create();\n        const ms = Date.now();\n        msg.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = ms % 1000 * 1000000;\n        return msg;\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript Date.\n     */ toDate(message) {\n        return new Date(_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1000000));\n    }\n    /**\n     * Converts a JavaScript Date to a `Timestamp`.\n     */ fromDate(date) {\n        const msg = this.create();\n        const ms = date.getTime();\n        msg.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = ms % 1000 * 1000000;\n        return msg;\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */ internalJsonWrite(message, options) {\n        let ms = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(message.seconds).toNumber() * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) throw new Error(\"Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (message.nanos < 0) throw new Error(\"Unable to encode invalid Timestamp to JSON. Nanos must not be negative.\");\n        let z = \"Z\";\n        if (message.nanos > 0) {\n            let nanosStr = (message.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            else if (nanosStr.substring(6) === \"000\") z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            else z = \".\" + nanosStr + \"Z\";\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */ internalJsonRead(json, options, target) {\n        if (typeof json !== \"string\") throw new Error(\"Unable to parse Timestamp from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json) + \".\");\n        let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) throw new Error(\"Unable to parse Timestamp from JSON. Invalid format.\");\n        let ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) throw new Error(\"Unable to parse Timestamp from JSON. Invalid value.\");\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) throw new globalThis.Error(\"Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (!target) target = this.create();\n        target.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(ms / 1000).toString();\n        target.nanos = 0;\n        if (matches[7]) target.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.seconds = \"0\";\n        message.nanos = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int64 seconds */ 1:\n                    message.seconds = reader.int64().toString();\n                    break;\n                case /* int32 nanos */ 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int64 seconds = 1; */ if (message.seconds !== \"0\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int64(message.seconds);\n        /* int32 nanos = 2; */ if (message.nanos !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.nanos);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Timestamp\n */ const Timestamp = new Timestamp$Type();\n/**\n * @generated from protobuf enum stream.video.sfu.models.PeerType\n */ var PeerType;\n(function(PeerType) {\n    /**\n     * todo fix me (marcelo)\n     *\n     * @generated from protobuf enum value: PEER_TYPE_PUBLISHER_UNSPECIFIED = 0;\n     */ PeerType[PeerType[\"PUBLISHER_UNSPECIFIED\"] = 0] = \"PUBLISHER_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: PEER_TYPE_SUBSCRIBER = 1;\n     */ PeerType[PeerType[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n})(PeerType || (PeerType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.ConnectionQuality\n */ var ConnectionQuality;\n(function(ConnectionQuality) {\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_UNSPECIFIED = 0;\n     */ ConnectionQuality[ConnectionQuality[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_POOR = 1;\n     */ ConnectionQuality[ConnectionQuality[\"POOR\"] = 1] = \"POOR\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_GOOD = 2;\n     */ ConnectionQuality[ConnectionQuality[\"GOOD\"] = 2] = \"GOOD\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_EXCELLENT = 3;\n     */ ConnectionQuality[ConnectionQuality[\"EXCELLENT\"] = 3] = \"EXCELLENT\";\n})(ConnectionQuality || (ConnectionQuality = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_LOW_UNSPECIFIED = 0;\n     */ VideoQuality[VideoQuality[\"LOW_UNSPECIFIED\"] = 0] = \"LOW_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_MID = 1;\n     */ VideoQuality[VideoQuality[\"MID\"] = 1] = \"MID\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_HIGH = 2;\n     */ VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_OFF = 3;\n     */ VideoQuality[VideoQuality[\"OFF\"] = 3] = \"OFF\";\n})(VideoQuality || (VideoQuality = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_UNSPECIFIED = 0;\n     */ TrackType[TrackType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_AUDIO = 1;\n     */ TrackType[TrackType[\"AUDIO\"] = 1] = \"AUDIO\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_VIDEO = 2;\n     */ TrackType[TrackType[\"VIDEO\"] = 2] = \"VIDEO\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_SCREEN_SHARE = 3;\n     */ TrackType[TrackType[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_SCREEN_SHARE_AUDIO = 4;\n     */ TrackType[TrackType[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackType || (TrackType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.ErrorCode\n */ var ErrorCode;\n(function(ErrorCode) {\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_UNSPECIFIED = 0;\n     */ ErrorCode[ErrorCode[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_NOT_FOUND = 100;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_NOT_FOUND\"] = 100] = \"PUBLISH_TRACK_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACKS_MISMATCH = 101;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACKS_MISMATCH\"] = 101] = \"PUBLISH_TRACKS_MISMATCH\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_OUT_OF_ORDER = 102;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_OUT_OF_ORDER\"] = 102] = \"PUBLISH_TRACK_OUT_OF_ORDER\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND = 103;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND\"] = 103] = \"PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_LIVE_ENDED = 104;\n     */ ErrorCode[ErrorCode[\"LIVE_ENDED\"] = 104] = \"LIVE_ENDED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_NOT_FOUND = 200;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_NOT_FOUND\"] = 200] = \"PARTICIPANT_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATING_OUT = 201;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATING_OUT\"] = 201] = \"PARTICIPANT_MIGRATING_OUT\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATION_FAILED = 202;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATION_FAILED\"] = 202] = \"PARTICIPANT_MIGRATION_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATING = 203;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATING\"] = 203] = \"PARTICIPANT_MIGRATING\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_RECONNECT_FAILED = 204;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_RECONNECT_FAILED\"] = 204] = \"PARTICIPANT_RECONNECT_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MEDIA_TRANSPORT_FAILURE = 205;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MEDIA_TRANSPORT_FAILURE\"] = 205] = \"PARTICIPANT_MEDIA_TRANSPORT_FAILURE\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_CALL_NOT_FOUND = 300;\n     */ ErrorCode[ErrorCode[\"CALL_NOT_FOUND\"] = 300] = \"CALL_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_REQUEST_VALIDATION_FAILED = 400;\n     */ ErrorCode[ErrorCode[\"REQUEST_VALIDATION_FAILED\"] = 400] = \"REQUEST_VALIDATION_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_UNAUTHENTICATED = 401;\n     */ ErrorCode[ErrorCode[\"UNAUTHENTICATED\"] = 401] = \"UNAUTHENTICATED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PERMISSION_DENIED = 403;\n     */ ErrorCode[ErrorCode[\"PERMISSION_DENIED\"] = 403] = \"PERMISSION_DENIED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_TOO_MANY_REQUESTS = 429;\n     */ ErrorCode[ErrorCode[\"TOO_MANY_REQUESTS\"] = 429] = \"TOO_MANY_REQUESTS\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_INTERNAL_SERVER_ERROR = 500;\n     */ ErrorCode[ErrorCode[\"INTERNAL_SERVER_ERROR\"] = 500] = \"INTERNAL_SERVER_ERROR\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_SFU_SHUTTING_DOWN = 600;\n     */ ErrorCode[ErrorCode[\"SFU_SHUTTING_DOWN\"] = 600] = \"SFU_SHUTTING_DOWN\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_SFU_FULL = 700;\n     */ ErrorCode[ErrorCode[\"SFU_FULL\"] = 700] = \"SFU_FULL\";\n})(ErrorCode || (ErrorCode = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.SdkType\n */ var SdkType;\n(function(SdkType) {\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_UNSPECIFIED = 0;\n     */ SdkType[SdkType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_REACT = 1;\n     */ SdkType[SdkType[\"REACT\"] = 1] = \"REACT\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_ANGULAR = 2;\n     */ SdkType[SdkType[\"ANGULAR\"] = 2] = \"ANGULAR\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_ANDROID = 3;\n     */ SdkType[SdkType[\"ANDROID\"] = 3] = \"ANDROID\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_IOS = 4;\n     */ SdkType[SdkType[\"IOS\"] = 4] = \"IOS\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_FLUTTER = 5;\n     */ SdkType[SdkType[\"FLUTTER\"] = 5] = \"FLUTTER\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_REACT_NATIVE = 6;\n     */ SdkType[SdkType[\"REACT_NATIVE\"] = 6] = \"REACT_NATIVE\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_UNITY = 7;\n     */ SdkType[SdkType[\"UNITY\"] = 7] = \"UNITY\";\n})(SdkType || (SdkType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.TrackUnpublishReason\n */ var TrackUnpublishReason;\n(function(TrackUnpublishReason) {\n    /**\n     * Default value which is used when the specific reason\n     * for muting the track is not known.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_UNSPECIFIED = 0;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * Represents user muting their tracks.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_USER_MUTED = 1;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"USER_MUTED\"] = 1] = \"USER_MUTED\";\n    /**\n     * Represents muting the track because the permission to\n     * publish the track has been revoked.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_PERMISSION_REVOKED = 2;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"PERMISSION_REVOKED\"] = 2] = \"PERMISSION_REVOKED\";\n    /**\n     * Represents muting the track due to moderation actions.\n     * This is different from permission revoked because the\n     * participant can unmute themselves here whereas in case\n     * of \"permission revoke\" it is not possible until the\n     * call permissions are updated.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_MODERATION = 3;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"MODERATION\"] = 3] = \"MODERATION\";\n})(TrackUnpublishReason || (TrackUnpublishReason = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.GoAwayReason\n */ var GoAwayReason;\n(function(GoAwayReason) {\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_UNSPECIFIED = 0;\n     */ GoAwayReason[GoAwayReason[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_SHUTTING_DOWN = 1;\n     */ GoAwayReason[GoAwayReason[\"SHUTTING_DOWN\"] = 1] = \"SHUTTING_DOWN\";\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_REBALANCE = 2;\n     */ GoAwayReason[GoAwayReason[\"REBALANCE\"] = 2] = \"REBALANCE\";\n})(GoAwayReason || (GoAwayReason = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallState$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.CallState\", [\n            {\n                no: 1,\n                name: \"participants\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Participant\n            },\n            {\n                no: 2,\n                name: \"started_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 3,\n                name: \"participant_count\",\n                kind: \"message\",\n                T: ()=>ParticipantCount\n            },\n            {\n                no: 4,\n                name: \"pins\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Pin\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.participants = [];\n        message.pins = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.models.Participant participants */ 1:\n                    message.participants.push(Participant.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* google.protobuf.Timestamp started_at */ 2:\n                    message.startedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startedAt);\n                    break;\n                case /* stream.video.sfu.models.ParticipantCount participant_count */ 3:\n                    message.participantCount = ParticipantCount.internalBinaryRead(reader, reader.uint32(), options, message.participantCount);\n                    break;\n                case /* repeated stream.video.sfu.models.Pin pins */ 4:\n                    message.pins.push(Pin.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.models.Participant participants = 1; */ for(let i = 0; i < message.participants.length; i++)Participant.internalBinaryWrite(message.participants[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp started_at = 2; */ if (message.startedAt) Timestamp.internalBinaryWrite(message.startedAt, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.ParticipantCount participant_count = 3; */ if (message.participantCount) ParticipantCount.internalBinaryWrite(message.participantCount, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.models.Pin pins = 4; */ for(let i = 0; i < message.pins.length; i++)Pin.internalBinaryWrite(message.pins[i], writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.CallState\n */ const CallState$1 = new CallState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantCount$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ParticipantCount\", [\n            {\n                no: 1,\n                name: \"total\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"anonymous\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.total = 0;\n        message.anonymous = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 total */ 1:\n                    message.total = reader.uint32();\n                    break;\n                case /* uint32 anonymous */ 2:\n                    message.anonymous = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 total = 1; */ if (message.total !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.total);\n        /* uint32 anonymous = 2; */ if (message.anonymous !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.anonymous);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ParticipantCount\n */ const ParticipantCount = new ParticipantCount$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Pin$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Pin\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Pin\n */ const Pin = new Pin$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Participant$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Participant\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"published_tracks\",\n                kind: \"enum\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"joined_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 5,\n                name: \"track_lookup_prefix\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"connection_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ConnectionQuality\",\n                        ConnectionQuality,\n                        \"CONNECTION_QUALITY_\"\n                    ]\n            },\n            {\n                no: 7,\n                name: \"is_speaking\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 8,\n                name: \"is_dominant_speaker\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 9,\n                name: \"audio_level\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 10,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 11,\n                name: \"image\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 12,\n                name: \"custom\",\n                kind: \"message\",\n                T: ()=>Struct\n            },\n            {\n                no: 13,\n                name: \"roles\",\n                kind: \"scalar\",\n                repeat: 2 /*RepeatType.UNPACKED*/ ,\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.publishedTracks = [];\n        message.trackLookupPrefix = \"\";\n        message.connectionQuality = 0;\n        message.isSpeaking = false;\n        message.isDominantSpeaker = false;\n        message.audioLevel = 0;\n        message.name = \"\";\n        message.image = \"\";\n        message.roles = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackType published_tracks */ 3:\n                    if (wireType === _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited) for(let e = reader.int32() + reader.pos; reader.pos < e;)message.publishedTracks.push(reader.int32());\n                    else message.publishedTracks.push(reader.int32());\n                    break;\n                case /* google.protobuf.Timestamp joined_at */ 4:\n                    message.joinedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.joinedAt);\n                    break;\n                case /* string track_lookup_prefix */ 5:\n                    message.trackLookupPrefix = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ConnectionQuality connection_quality */ 6:\n                    message.connectionQuality = reader.int32();\n                    break;\n                case /* bool is_speaking */ 7:\n                    message.isSpeaking = reader.bool();\n                    break;\n                case /* bool is_dominant_speaker */ 8:\n                    message.isDominantSpeaker = reader.bool();\n                    break;\n                case /* float audio_level */ 9:\n                    message.audioLevel = reader.float();\n                    break;\n                case /* string name */ 10:\n                    message.name = reader.string();\n                    break;\n                case /* string image */ 11:\n                    message.image = reader.string();\n                    break;\n                case /* google.protobuf.Struct custom */ 12:\n                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);\n                    break;\n                case /* repeated string roles */ 13:\n                    message.roles.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.models.TrackType published_tracks = 3; */ if (message.publishedTracks.length) {\n            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork();\n            for(let i = 0; i < message.publishedTracks.length; i++)writer.int32(message.publishedTracks[i]);\n            writer.join();\n        }\n        /* google.protobuf.Timestamp joined_at = 4; */ if (message.joinedAt) Timestamp.internalBinaryWrite(message.joinedAt, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string track_lookup_prefix = 5; */ if (message.trackLookupPrefix !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.trackLookupPrefix);\n        /* stream.video.sfu.models.ConnectionQuality connection_quality = 6; */ if (message.connectionQuality !== 0) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.connectionQuality);\n        /* bool is_speaking = 7; */ if (message.isSpeaking !== false) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isSpeaking);\n        /* bool is_dominant_speaker = 8; */ if (message.isDominantSpeaker !== false) writer.tag(8, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isDominantSpeaker);\n        /* float audio_level = 9; */ if (message.audioLevel !== 0) writer.tag(9, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.audioLevel);\n        /* string name = 10; */ if (message.name !== \"\") writer.tag(10, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string image = 11; */ if (message.image !== \"\") writer.tag(11, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.image);\n        /* google.protobuf.Struct custom = 12; */ if (message.custom) Struct.internalBinaryWrite(message.custom, writer.tag(12, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated string roles = 13; */ for(let i = 0; i < message.roles.length; i++)writer.tag(13, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.roles[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Participant\n */ const Participant = new Participant$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass StreamQuality$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.StreamQuality\", [\n            {\n                no: 1,\n                name: \"video_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.VideoQuality\",\n                        VideoQuality,\n                        \"VIDEO_QUALITY_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.videoQuality = 0;\n        message.userId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.VideoQuality video_quality */ 1:\n                    message.videoQuality = reader.int32();\n                    break;\n                case /* string user_id */ 2:\n                    message.userId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.VideoQuality video_quality = 1; */ if (message.videoQuality !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.videoQuality);\n        /* string user_id = 2; */ if (message.userId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.StreamQuality\n */ const StreamQuality = new StreamQuality$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoDimension$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.VideoDimension\", [\n            {\n                no: 1,\n                name: \"width\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"height\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.width = 0;\n        message.height = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 width */ 1:\n                    message.width = reader.uint32();\n                    break;\n                case /* uint32 height */ 2:\n                    message.height = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 width = 1; */ if (message.width !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.width);\n        /* uint32 height = 2; */ if (message.height !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.height);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.VideoDimension\n */ const VideoDimension = new VideoDimension$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoLayer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.VideoLayer\", [\n            {\n                no: 1,\n                name: \"rid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"video_dimension\",\n                kind: \"message\",\n                T: ()=>VideoDimension\n            },\n            {\n                no: 4,\n                name: \"bitrate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"fps\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 6,\n                name: \"quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.VideoQuality\",\n                        VideoQuality,\n                        \"VIDEO_QUALITY_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.rid = \"\";\n        message.bitrate = 0;\n        message.fps = 0;\n        message.quality = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string rid */ 1:\n                    message.rid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.VideoDimension video_dimension */ 2:\n                    message.videoDimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.videoDimension);\n                    break;\n                case /* uint32 bitrate */ 4:\n                    message.bitrate = reader.uint32();\n                    break;\n                case /* uint32 fps */ 5:\n                    message.fps = reader.uint32();\n                    break;\n                case /* stream.video.sfu.models.VideoQuality quality */ 6:\n                    message.quality = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string rid = 1; */ if (message.rid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.rid);\n        /* stream.video.sfu.models.VideoDimension video_dimension = 2; */ if (message.videoDimension) VideoDimension.internalBinaryWrite(message.videoDimension, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* uint32 bitrate = 4; */ if (message.bitrate !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.bitrate);\n        /* uint32 fps = 5; */ if (message.fps !== 0) writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.fps);\n        /* stream.video.sfu.models.VideoQuality quality = 6; */ if (message.quality !== 0) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.quality);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.VideoLayer\n */ const VideoLayer = new VideoLayer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Codec$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Codec\", [\n            {\n                no: 1,\n                name: \"payload_type\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"fmtp_line\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"clock_rate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"encoding_parameters\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"feedbacks\",\n                kind: \"scalar\",\n                repeat: 2 /*RepeatType.UNPACKED*/ ,\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.payloadType = 0;\n        message.name = \"\";\n        message.fmtpLine = \"\";\n        message.clockRate = 0;\n        message.encodingParameters = \"\";\n        message.feedbacks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 payload_type */ 1:\n                    message.payloadType = reader.uint32();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string fmtp_line */ 3:\n                    message.fmtpLine = reader.string();\n                    break;\n                case /* uint32 clock_rate */ 4:\n                    message.clockRate = reader.uint32();\n                    break;\n                case /* string encoding_parameters */ 5:\n                    message.encodingParameters = reader.string();\n                    break;\n                case /* repeated string feedbacks */ 6:\n                    message.feedbacks.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 payload_type = 1; */ if (message.payloadType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.payloadType);\n        /* string name = 2; */ if (message.name !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string fmtp_line = 3; */ if (message.fmtpLine !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.fmtpLine);\n        /* uint32 clock_rate = 4; */ if (message.clockRate !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.clockRate);\n        /* string encoding_parameters = 5; */ if (message.encodingParameters !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.encodingParameters);\n        /* repeated string feedbacks = 6; */ for(let i = 0; i < message.feedbacks.length; i++)writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.feedbacks[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Codec\n */ const Codec = new Codec$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nlet ICETrickle$Type$1 = class ICETrickle$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ICETrickle\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"ice_candidate\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.iceCandidate = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string ice_candidate */ 2:\n                    message.iceCandidate = reader.string();\n                    break;\n                case /* string session_id */ 3:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string ice_candidate = 2; */ if (message.iceCandidate !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.iceCandidate);\n        /* string session_id = 3; */ if (message.sessionId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n};\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ICETrickle\n */ const ICETrickle$1 = new ICETrickle$Type$1();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackInfo$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.TrackInfo\", [\n            {\n                no: 1,\n                name: \"track_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 5,\n                name: \"layers\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoLayer\n            },\n            {\n                no: 6,\n                name: \"mid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 7,\n                name: \"dtx\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 8,\n                name: \"stereo\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 9,\n                name: \"red\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.trackId = \"\";\n        message.trackType = 0;\n        message.layers = [];\n        message.mid = \"\";\n        message.dtx = false;\n        message.stereo = false;\n        message.red = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string track_id */ 1:\n                    message.trackId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType track_type */ 2:\n                    message.trackType = reader.int32();\n                    break;\n                case /* repeated stream.video.sfu.models.VideoLayer layers */ 5:\n                    message.layers.push(VideoLayer.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* string mid */ 6:\n                    message.mid = reader.string();\n                    break;\n                case /* bool dtx */ 7:\n                    message.dtx = reader.bool();\n                    break;\n                case /* bool stereo */ 8:\n                    message.stereo = reader.bool();\n                    break;\n                case /* bool red */ 9:\n                    message.red = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string track_id = 1; */ if (message.trackId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.trackId);\n        /* stream.video.sfu.models.TrackType track_type = 2; */ if (message.trackType !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* repeated stream.video.sfu.models.VideoLayer layers = 5; */ for(let i = 0; i < message.layers.length; i++)VideoLayer.internalBinaryWrite(message.layers[i], writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string mid = 6; */ if (message.mid !== \"\") writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.mid);\n        /* bool dtx = 7; */ if (message.dtx !== false) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.dtx);\n        /* bool stereo = 8; */ if (message.stereo !== false) writer.tag(8, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.stereo);\n        /* bool red = 9; */ if (message.red !== false) writer.tag(9, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.red);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.TrackInfo\n */ const TrackInfo = new TrackInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Call$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Call\", [\n            {\n                no: 1,\n                name: \"type\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"created_by_user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"host_user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 5,\n                name: \"custom\",\n                kind: \"message\",\n                T: ()=>Struct\n            },\n            {\n                no: 6,\n                name: \"created_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 7,\n                name: \"updated_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.type = \"\";\n        message.id = \"\";\n        message.createdByUserId = \"\";\n        message.hostUserId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string type */ 1:\n                    message.type = reader.string();\n                    break;\n                case /* string id */ 2:\n                    message.id = reader.string();\n                    break;\n                case /* string created_by_user_id */ 3:\n                    message.createdByUserId = reader.string();\n                    break;\n                case /* string host_user_id */ 4:\n                    message.hostUserId = reader.string();\n                    break;\n                case /* google.protobuf.Struct custom */ 5:\n                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);\n                    break;\n                case /* google.protobuf.Timestamp created_at */ 6:\n                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);\n                    break;\n                case /* google.protobuf.Timestamp updated_at */ 7:\n                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string type = 1; */ if (message.type !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.type);\n        /* string id = 2; */ if (message.id !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.id);\n        /* string created_by_user_id = 3; */ if (message.createdByUserId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.createdByUserId);\n        /* string host_user_id = 4; */ if (message.hostUserId !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.hostUserId);\n        /* google.protobuf.Struct custom = 5; */ if (message.custom) Struct.internalBinaryWrite(message.custom, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp created_at = 6; */ if (message.createdAt) Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp updated_at = 7; */ if (message.updatedAt) Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Call\n */ const Call$1 = new Call$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nlet Error$Type$1 = class Error$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Error\", [\n            {\n                no: 1,\n                name: \"code\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ErrorCode\",\n                        ErrorCode,\n                        \"ERROR_CODE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"message\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"should_retry\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.code = 0;\n        message.message = \"\";\n        message.shouldRetry = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.ErrorCode code */ 1:\n                    message.code = reader.int32();\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                case /* bool should_retry */ 3:\n                    message.shouldRetry = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.ErrorCode code = 1; */ if (message.code !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.code);\n        /* string message = 2; */ if (message.message !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.message);\n        /* bool should_retry = 3; */ if (message.shouldRetry !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.shouldRetry);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n};\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Error\n */ const Error$2 = new Error$Type$1();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ClientDetails$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ClientDetails\", [\n            {\n                no: 1,\n                name: \"sdk\",\n                kind: \"message\",\n                T: ()=>Sdk\n            },\n            {\n                no: 2,\n                name: \"os\",\n                kind: \"message\",\n                T: ()=>OS\n            },\n            {\n                no: 3,\n                name: \"browser\",\n                kind: \"message\",\n                T: ()=>Browser\n            },\n            {\n                no: 4,\n                name: \"device\",\n                kind: \"message\",\n                T: ()=>Device\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Sdk sdk */ 1:\n                    message.sdk = Sdk.internalBinaryRead(reader, reader.uint32(), options, message.sdk);\n                    break;\n                case /* stream.video.sfu.models.OS os */ 2:\n                    message.os = OS.internalBinaryRead(reader, reader.uint32(), options, message.os);\n                    break;\n                case /* stream.video.sfu.models.Browser browser */ 3:\n                    message.browser = Browser.internalBinaryRead(reader, reader.uint32(), options, message.browser);\n                    break;\n                case /* stream.video.sfu.models.Device device */ 4:\n                    message.device = Device.internalBinaryRead(reader, reader.uint32(), options, message.device);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Sdk sdk = 1; */ if (message.sdk) Sdk.internalBinaryWrite(message.sdk, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.OS os = 2; */ if (message.os) OS.internalBinaryWrite(message.os, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Browser browser = 3; */ if (message.browser) Browser.internalBinaryWrite(message.browser, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Device device = 4; */ if (message.device) Device.internalBinaryWrite(message.device, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ClientDetails\n */ const ClientDetails = new ClientDetails$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Sdk$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Sdk\", [\n            {\n                no: 1,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.SdkType\",\n                        SdkType,\n                        \"SDK_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"major\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"minor\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"patch\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.type = 0;\n        message.major = \"\";\n        message.minor = \"\";\n        message.patch = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.SdkType type */ 1:\n                    message.type = reader.int32();\n                    break;\n                case /* string major */ 2:\n                    message.major = reader.string();\n                    break;\n                case /* string minor */ 3:\n                    message.minor = reader.string();\n                    break;\n                case /* string patch */ 4:\n                    message.patch = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.SdkType type = 1; */ if (message.type !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* string major = 2; */ if (message.major !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.major);\n        /* string minor = 3; */ if (message.minor !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.minor);\n        /* string patch = 4; */ if (message.patch !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.patch);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Sdk\n */ const Sdk = new Sdk$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass OS$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.OS\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"architecture\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        message.architecture = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                case /* string architecture */ 3:\n                    message.architecture = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        /* string architecture = 3; */ if (message.architecture !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.architecture);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.OS\n */ const OS = new OS$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Browser$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Browser\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Browser\n */ const Browser = new Browser$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Device$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Device\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Device\n */ const Device = new Device$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallGrants$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.CallGrants\", [\n            {\n                no: 1,\n                name: \"can_publish_audio\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 2,\n                name: \"can_publish_video\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 3,\n                name: \"can_screenshare\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.canPublishAudio = false;\n        message.canPublishVideo = false;\n        message.canScreenshare = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool can_publish_audio */ 1:\n                    message.canPublishAudio = reader.bool();\n                    break;\n                case /* bool can_publish_video */ 2:\n                    message.canPublishVideo = reader.bool();\n                    break;\n                case /* bool can_screenshare */ 3:\n                    message.canScreenshare = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool can_publish_audio = 1; */ if (message.canPublishAudio !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canPublishAudio);\n        /* bool can_publish_video = 2; */ if (message.canPublishVideo !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canPublishVideo);\n        /* bool can_screenshare = 3; */ if (message.canScreenshare !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canScreenshare);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.CallGrants\n */ const CallGrants = new CallGrants$Type();\nvar models = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Browser: Browser,\n    Call: Call$1,\n    CallGrants: CallGrants,\n    CallState: CallState$1,\n    ClientDetails: ClientDetails,\n    Codec: Codec,\n    get ConnectionQuality () {\n        return ConnectionQuality;\n    },\n    Device: Device,\n    Error: Error$2,\n    get ErrorCode () {\n        return ErrorCode;\n    },\n    get GoAwayReason () {\n        return GoAwayReason;\n    },\n    ICETrickle: ICETrickle$1,\n    OS: OS,\n    Participant: Participant,\n    ParticipantCount: ParticipantCount,\n    get PeerType () {\n        return PeerType;\n    },\n    Pin: Pin,\n    Sdk: Sdk,\n    get SdkType () {\n        return SdkType;\n    },\n    StreamQuality: StreamQuality,\n    TrackInfo: TrackInfo,\n    get TrackType () {\n        return TrackType;\n    },\n    get TrackUnpublishReason () {\n        return TrackUnpublishReason;\n    },\n    VideoDimension: VideoDimension,\n    VideoLayer: VideoLayer,\n    get VideoQuality () {\n        return VideoQuality;\n    }\n});\n/* eslint-disable */ // @generated by protobuf-ts 2.9.3 with parameter long_type_string,client_generic,server_none,eslint_disable\n// @generated from protobuf file \"video/sfu/signal_rpc/signal.proto\" (package \"stream.video.sfu.signal\", syntax proto3)\n// tslint:disable\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendStatsRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendStatsRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"subscriber_stats\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"publisher_stats\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"webrtc_version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 5,\n                name: \"sdk\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"sdk_version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.subscriberStats = \"\";\n        message.publisherStats = \"\";\n        message.webrtcVersion = \"\";\n        message.sdk = \"\";\n        message.sdkVersion = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* string subscriber_stats */ 2:\n                    message.subscriberStats = reader.string();\n                    break;\n                case /* string publisher_stats */ 3:\n                    message.publisherStats = reader.string();\n                    break;\n                case /* string webrtc_version */ 4:\n                    message.webrtcVersion = reader.string();\n                    break;\n                case /* string sdk */ 5:\n                    message.sdk = reader.string();\n                    break;\n                case /* string sdk_version */ 6:\n                    message.sdkVersion = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* string subscriber_stats = 2; */ if (message.subscriberStats !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.subscriberStats);\n        /* string publisher_stats = 3; */ if (message.publisherStats !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.publisherStats);\n        /* string webrtc_version = 4; */ if (message.webrtcVersion !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.webrtcVersion);\n        /* string sdk = 5; */ if (message.sdk !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdk);\n        /* string sdk_version = 6; */ if (message.sdkVersion !== \"\") writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdkVersion);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendStatsRequest\n */ const SendStatsRequest = new SendStatsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendStatsResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendStatsResponse\", [\n            {\n                no: 1,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 1:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 1; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendStatsResponse\n */ const SendStatsResponse = new SendStatsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestartRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICERestartRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.peerType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.PeerType peer_type */ 2:\n                    message.peerType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.PeerType peer_type = 2; */ if (message.peerType !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICERestartRequest\n */ const ICERestartRequest = new ICERestartRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestartResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICERestartResponse\", [\n            {\n                no: 1,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 1:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 1; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICERestartResponse\n */ const ICERestartResponse = new ICERestartResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateMuteStatesRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateMuteStatesRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"mute_states\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackMuteState\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.muteStates = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackMuteState mute_states */ 3:\n                    message.muteStates.push(TrackMuteState.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.signal.TrackMuteState mute_states = 3; */ for(let i = 0; i < message.muteStates.length; i++)TrackMuteState.internalBinaryWrite(message.muteStates[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateMuteStatesRequest\n */ const UpdateMuteStatesRequest = new UpdateMuteStatesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateMuteStatesResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateMuteStatesResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateMuteStatesResponse\n */ const UpdateMuteStatesResponse = new UpdateMuteStatesResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackMuteState$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.TrackMuteState\", [\n            {\n                no: 1,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.trackType = 0;\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.TrackType track_type */ 1:\n                    message.trackType = reader.int32();\n                    break;\n                case /* bool muted */ 2:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.TrackType track_type = 1; */ if (message.trackType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* bool muted = 2; */ if (message.muted !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.TrackMuteState\n */ const TrackMuteState = new TrackMuteState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioMuteChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.AudioMuteChanged\", [\n            {\n                no: 1,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool muted */ 1:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool muted = 1; */ if (message.muted !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.AudioMuteChanged\n */ new AudioMuteChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoMuteChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.VideoMuteChanged\", [\n            {\n                no: 2,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool muted */ 2:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool muted = 2; */ if (message.muted !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.VideoMuteChanged\n */ new VideoMuteChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateSubscriptionsRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateSubscriptionsRequest\", [\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackSubscriptionDetails\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.tracks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackSubscriptionDetails tracks */ 3:\n                    message.tracks.push(TrackSubscriptionDetails.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.signal.TrackSubscriptionDetails tracks = 3; */ for(let i = 0; i < message.tracks.length; i++)TrackSubscriptionDetails.internalBinaryWrite(message.tracks[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateSubscriptionsRequest\n */ const UpdateSubscriptionsRequest = new UpdateSubscriptionsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateSubscriptionsResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateSubscriptionsResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateSubscriptionsResponse\n */ const UpdateSubscriptionsResponse = new UpdateSubscriptionsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackSubscriptionDetails$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.TrackSubscriptionDetails\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"dimension\",\n                kind: \"message\",\n                T: ()=>VideoDimension\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.trackType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType track_type */ 3:\n                    message.trackType = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.VideoDimension dimension */ 4:\n                    message.dimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.dimension);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType track_type = 3; */ if (message.trackType !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* stream.video.sfu.models.VideoDimension dimension = 4; */ if (message.dimension) VideoDimension.internalBinaryWrite(message.dimension, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.TrackSubscriptionDetails\n */ const TrackSubscriptionDetails = new TrackSubscriptionDetails$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendAnswerRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendAnswerRequest\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string sdp */ 2:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 3:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string sdp = 2; */ if (message.sdp !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 3; */ if (message.sessionId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendAnswerRequest\n */ const SendAnswerRequest = new SendAnswerRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendAnswerResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendAnswerResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendAnswerResponse\n */ const SendAnswerResponse = new SendAnswerResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICETrickleResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICETrickleResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICETrickleResponse\n */ const ICETrickleResponse = new ICETrickleResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SetPublisherRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SetPublisherRequest\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackInfo\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        message.tracks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackInfo tracks */ 3:\n                    message.tracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.models.TrackInfo tracks = 3; */ for(let i = 0; i < message.tracks.length; i++)TrackInfo.internalBinaryWrite(message.tracks[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SetPublisherRequest\n */ const SetPublisherRequest = new SetPublisherRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SetPublisherResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SetPublisherResponse\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"ice_restart\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        message.iceRestart = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* bool ice_restart */ 3:\n                    message.iceRestart = reader.bool();\n                    break;\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* bool ice_restart = 3; */ if (message.iceRestart !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.iceRestart);\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SetPublisherResponse\n */ const SetPublisherResponse = new SetPublisherResponse$Type();\n/**\n * @generated ServiceType for protobuf service stream.video.sfu.signal.SignalServer\n */ const SignalServer = new _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_14__.ServiceType(\"stream.video.sfu.signal.SignalServer\", [\n    {\n        name: \"SetPublisher\",\n        options: {},\n        I: SetPublisherRequest,\n        O: SetPublisherResponse\n    },\n    {\n        name: \"SendAnswer\",\n        options: {},\n        I: SendAnswerRequest,\n        O: SendAnswerResponse\n    },\n    {\n        name: \"IceTrickle\",\n        options: {},\n        I: ICETrickle$1,\n        O: ICETrickleResponse\n    },\n    {\n        name: \"UpdateSubscriptions\",\n        options: {},\n        I: UpdateSubscriptionsRequest,\n        O: UpdateSubscriptionsResponse\n    },\n    {\n        name: \"UpdateMuteStates\",\n        options: {},\n        I: UpdateMuteStatesRequest,\n        O: UpdateMuteStatesResponse\n    },\n    {\n        name: \"IceRestart\",\n        options: {},\n        I: ICERestartRequest,\n        O: ICERestartResponse\n    },\n    {\n        name: \"SendStats\",\n        options: {},\n        I: SendStatsRequest,\n        O: SendStatsResponse\n    }\n]);\n/**\n * @generated from protobuf enum stream.video.sfu.event.VideoLayerSetting.Priority\n */ var VideoLayerSetting_Priority;\n(function(VideoLayerSetting_Priority) {\n    /**\n     * @generated from protobuf enum value: PRIORITY_HIGH_UNSPECIFIED = 0;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"HIGH_UNSPECIFIED\"] = 0] = \"HIGH_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_LOW = 1;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"LOW\"] = 1] = \"LOW\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_MEDIUM = 2;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"MEDIUM\"] = 2] = \"MEDIUM\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_VERY_LOW = 3;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"VERY_LOW\"] = 3] = \"VERY_LOW\";\n})(VideoLayerSetting_Priority || (VideoLayerSetting_Priority = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass SfuEvent$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SfuEvent\", [\n            {\n                no: 1,\n                name: \"subscriber_offer\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>SubscriberOffer\n            },\n            {\n                no: 2,\n                name: \"publisher_answer\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>PublisherAnswer\n            },\n            {\n                no: 3,\n                name: \"connection_quality_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ConnectionQualityChanged\n            },\n            {\n                no: 4,\n                name: \"audio_level_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>AudioLevelChanged\n            },\n            {\n                no: 5,\n                name: \"ice_trickle\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ICETrickle$1\n            },\n            {\n                no: 6,\n                name: \"change_publish_quality\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ChangePublishQuality\n            },\n            {\n                no: 10,\n                name: \"participant_joined\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ParticipantJoined\n            },\n            {\n                no: 11,\n                name: \"participant_left\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ParticipantLeft\n            },\n            {\n                no: 12,\n                name: \"dominant_speaker_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>DominantSpeakerChanged\n            },\n            {\n                no: 13,\n                name: \"join_response\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>JoinResponse\n            },\n            {\n                no: 14,\n                name: \"health_check_response\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>HealthCheckResponse\n            },\n            {\n                no: 16,\n                name: \"track_published\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>TrackPublished\n            },\n            {\n                no: 17,\n                name: \"track_unpublished\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>TrackUnpublished\n            },\n            {\n                no: 18,\n                name: \"error\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>Error$1\n            },\n            {\n                no: 19,\n                name: \"call_grants_updated\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>CallGrantsUpdated\n            },\n            {\n                no: 20,\n                name: \"go_away\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>GoAway\n            },\n            {\n                no: 21,\n                name: \"ice_restart\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ICERestart\n            },\n            {\n                no: 22,\n                name: \"pins_updated\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>PinsChanged\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.eventPayload = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.SubscriberOffer subscriber_offer */ 1:\n                    message.eventPayload = {\n                        oneofKind: \"subscriberOffer\",\n                        subscriberOffer: SubscriberOffer.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.subscriberOffer)\n                    };\n                    break;\n                case /* stream.video.sfu.event.PublisherAnswer publisher_answer */ 2:\n                    message.eventPayload = {\n                        oneofKind: \"publisherAnswer\",\n                        publisherAnswer: PublisherAnswer.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.publisherAnswer)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ConnectionQualityChanged connection_quality_changed */ 3:\n                    message.eventPayload = {\n                        oneofKind: \"connectionQualityChanged\",\n                        connectionQualityChanged: ConnectionQualityChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.connectionQualityChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.event.AudioLevelChanged audio_level_changed */ 4:\n                    message.eventPayload = {\n                        oneofKind: \"audioLevelChanged\",\n                        audioLevelChanged: AudioLevelChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.audioLevelChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.models.ICETrickle ice_trickle */ 5:\n                    message.eventPayload = {\n                        oneofKind: \"iceTrickle\",\n                        iceTrickle: ICETrickle$1.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.iceTrickle)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ChangePublishQuality change_publish_quality */ 6:\n                    message.eventPayload = {\n                        oneofKind: \"changePublishQuality\",\n                        changePublishQuality: ChangePublishQuality.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.changePublishQuality)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ParticipantJoined participant_joined */ 10:\n                    message.eventPayload = {\n                        oneofKind: \"participantJoined\",\n                        participantJoined: ParticipantJoined.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.participantJoined)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ParticipantLeft participant_left */ 11:\n                    message.eventPayload = {\n                        oneofKind: \"participantLeft\",\n                        participantLeft: ParticipantLeft.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.participantLeft)\n                    };\n                    break;\n                case /* stream.video.sfu.event.DominantSpeakerChanged dominant_speaker_changed */ 12:\n                    message.eventPayload = {\n                        oneofKind: \"dominantSpeakerChanged\",\n                        dominantSpeakerChanged: DominantSpeakerChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.dominantSpeakerChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.event.JoinResponse join_response */ 13:\n                    message.eventPayload = {\n                        oneofKind: \"joinResponse\",\n                        joinResponse: JoinResponse.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.joinResponse)\n                    };\n                    break;\n                case /* stream.video.sfu.event.HealthCheckResponse health_check_response */ 14:\n                    message.eventPayload = {\n                        oneofKind: \"healthCheckResponse\",\n                        healthCheckResponse: HealthCheckResponse.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.healthCheckResponse)\n                    };\n                    break;\n                case /* stream.video.sfu.event.TrackPublished track_published */ 16:\n                    message.eventPayload = {\n                        oneofKind: \"trackPublished\",\n                        trackPublished: TrackPublished.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.trackPublished)\n                    };\n                    break;\n                case /* stream.video.sfu.event.TrackUnpublished track_unpublished */ 17:\n                    message.eventPayload = {\n                        oneofKind: \"trackUnpublished\",\n                        trackUnpublished: TrackUnpublished.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.trackUnpublished)\n                    };\n                    break;\n                case /* stream.video.sfu.event.Error error */ 18:\n                    message.eventPayload = {\n                        oneofKind: \"error\",\n                        error: Error$1.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.error)\n                    };\n                    break;\n                case /* stream.video.sfu.event.CallGrantsUpdated call_grants_updated */ 19:\n                    message.eventPayload = {\n                        oneofKind: \"callGrantsUpdated\",\n                        callGrantsUpdated: CallGrantsUpdated.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.callGrantsUpdated)\n                    };\n                    break;\n                case /* stream.video.sfu.event.GoAway go_away */ 20:\n                    message.eventPayload = {\n                        oneofKind: \"goAway\",\n                        goAway: GoAway.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.goAway)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ICERestart ice_restart */ 21:\n                    message.eventPayload = {\n                        oneofKind: \"iceRestart\",\n                        iceRestart: ICERestart.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.iceRestart)\n                    };\n                    break;\n                case /* stream.video.sfu.event.PinsChanged pins_updated */ 22:\n                    message.eventPayload = {\n                        oneofKind: \"pinsUpdated\",\n                        pinsUpdated: PinsChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.pinsUpdated)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.SubscriberOffer subscriber_offer = 1; */ if (message.eventPayload.oneofKind === \"subscriberOffer\") SubscriberOffer.internalBinaryWrite(message.eventPayload.subscriberOffer, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.PublisherAnswer publisher_answer = 2; */ if (message.eventPayload.oneofKind === \"publisherAnswer\") PublisherAnswer.internalBinaryWrite(message.eventPayload.publisherAnswer, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ConnectionQualityChanged connection_quality_changed = 3; */ if (message.eventPayload.oneofKind === \"connectionQualityChanged\") ConnectionQualityChanged.internalBinaryWrite(message.eventPayload.connectionQualityChanged, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.AudioLevelChanged audio_level_changed = 4; */ if (message.eventPayload.oneofKind === \"audioLevelChanged\") AudioLevelChanged.internalBinaryWrite(message.eventPayload.audioLevelChanged, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.ICETrickle ice_trickle = 5; */ if (message.eventPayload.oneofKind === \"iceTrickle\") ICETrickle$1.internalBinaryWrite(message.eventPayload.iceTrickle, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ChangePublishQuality change_publish_quality = 6; */ if (message.eventPayload.oneofKind === \"changePublishQuality\") ChangePublishQuality.internalBinaryWrite(message.eventPayload.changePublishQuality, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ParticipantJoined participant_joined = 10; */ if (message.eventPayload.oneofKind === \"participantJoined\") ParticipantJoined.internalBinaryWrite(message.eventPayload.participantJoined, writer.tag(10, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ParticipantLeft participant_left = 11; */ if (message.eventPayload.oneofKind === \"participantLeft\") ParticipantLeft.internalBinaryWrite(message.eventPayload.participantLeft, writer.tag(11, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.DominantSpeakerChanged dominant_speaker_changed = 12; */ if (message.eventPayload.oneofKind === \"dominantSpeakerChanged\") DominantSpeakerChanged.internalBinaryWrite(message.eventPayload.dominantSpeakerChanged, writer.tag(12, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.JoinResponse join_response = 13; */ if (message.eventPayload.oneofKind === \"joinResponse\") JoinResponse.internalBinaryWrite(message.eventPayload.joinResponse, writer.tag(13, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.HealthCheckResponse health_check_response = 14; */ if (message.eventPayload.oneofKind === \"healthCheckResponse\") HealthCheckResponse.internalBinaryWrite(message.eventPayload.healthCheckResponse, writer.tag(14, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.TrackPublished track_published = 16; */ if (message.eventPayload.oneofKind === \"trackPublished\") TrackPublished.internalBinaryWrite(message.eventPayload.trackPublished, writer.tag(16, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.TrackUnpublished track_unpublished = 17; */ if (message.eventPayload.oneofKind === \"trackUnpublished\") TrackUnpublished.internalBinaryWrite(message.eventPayload.trackUnpublished, writer.tag(17, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.Error error = 18; */ if (message.eventPayload.oneofKind === \"error\") Error$1.internalBinaryWrite(message.eventPayload.error, writer.tag(18, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.CallGrantsUpdated call_grants_updated = 19; */ if (message.eventPayload.oneofKind === \"callGrantsUpdated\") CallGrantsUpdated.internalBinaryWrite(message.eventPayload.callGrantsUpdated, writer.tag(19, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.GoAway go_away = 20; */ if (message.eventPayload.oneofKind === \"goAway\") GoAway.internalBinaryWrite(message.eventPayload.goAway, writer.tag(20, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ICERestart ice_restart = 21; */ if (message.eventPayload.oneofKind === \"iceRestart\") ICERestart.internalBinaryWrite(message.eventPayload.iceRestart, writer.tag(21, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.PinsChanged pins_updated = 22; */ if (message.eventPayload.oneofKind === \"pinsUpdated\") PinsChanged.internalBinaryWrite(message.eventPayload.pinsUpdated, writer.tag(22, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SfuEvent\n */ const SfuEvent = new SfuEvent$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PinsChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.PinsChanged\", [\n            {\n                no: 1,\n                name: \"pins\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Pin\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.pins = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.models.Pin pins */ 1:\n                    message.pins.push(Pin.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.models.Pin pins = 1; */ for(let i = 0; i < message.pins.length; i++)Pin.internalBinaryWrite(message.pins[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.PinsChanged\n */ const PinsChanged = new PinsChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Error$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.Error\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.Error\n */ const Error$1 = new Error$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICETrickle$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ICETrickle\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"ice_candidate\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.iceCandidate = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string ice_candidate */ 2:\n                    message.iceCandidate = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string ice_candidate = 2; */ if (message.iceCandidate !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.iceCandidate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ICETrickle\n */ const ICETrickle = new ICETrickle$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestart$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ICERestart\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ICERestart\n */ const ICERestart = new ICERestart$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SfuRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SfuRequest\", [\n            {\n                no: 1,\n                name: \"join_request\",\n                kind: \"message\",\n                oneof: \"requestPayload\",\n                T: ()=>JoinRequest\n            },\n            {\n                no: 2,\n                name: \"health_check_request\",\n                kind: \"message\",\n                oneof: \"requestPayload\",\n                T: ()=>HealthCheckRequest\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.requestPayload = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.JoinRequest join_request */ 1:\n                    message.requestPayload = {\n                        oneofKind: \"joinRequest\",\n                        joinRequest: JoinRequest.internalBinaryRead(reader, reader.uint32(), options, message.requestPayload.joinRequest)\n                    };\n                    break;\n                case /* stream.video.sfu.event.HealthCheckRequest health_check_request */ 2:\n                    message.requestPayload = {\n                        oneofKind: \"healthCheckRequest\",\n                        healthCheckRequest: HealthCheckRequest.internalBinaryRead(reader, reader.uint32(), options, message.requestPayload.healthCheckRequest)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.JoinRequest join_request = 1; */ if (message.requestPayload.oneofKind === \"joinRequest\") JoinRequest.internalBinaryWrite(message.requestPayload.joinRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.HealthCheckRequest health_check_request = 2; */ if (message.requestPayload.oneofKind === \"healthCheckRequest\") HealthCheckRequest.internalBinaryWrite(message.requestPayload.healthCheckRequest, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SfuRequest\n */ const SfuRequest = new SfuRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HealthCheckRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.HealthCheckRequest\", []);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message, writer, options) {\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.HealthCheckRequest\n */ const HealthCheckRequest = new HealthCheckRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HealthCheckResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.HealthCheckResponse\", [\n            {\n                no: 1,\n                name: \"participant_count\",\n                kind: \"message\",\n                T: ()=>ParticipantCount\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.ParticipantCount participant_count */ 1:\n                    message.participantCount = ParticipantCount.internalBinaryRead(reader, reader.uint32(), options, message.participantCount);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.ParticipantCount participant_count = 1; */ if (message.participantCount) ParticipantCount.internalBinaryWrite(message.participantCount, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.HealthCheckResponse\n */ const HealthCheckResponse = new HealthCheckResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackPublished$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.TrackPublished\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.type = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 4:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType type = 3; */ if (message.type !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* stream.video.sfu.models.Participant participant = 4; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.TrackPublished\n */ const TrackPublished = new TrackPublished$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackUnpublished$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.TrackUnpublished\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"cause\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackUnpublishReason\",\n                        TrackUnpublishReason,\n                        \"TRACK_UNPUBLISH_REASON_\"\n                    ]\n            },\n            {\n                no: 5,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.type = 0;\n        message.cause = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.TrackUnpublishReason cause */ 4:\n                    message.cause = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 5:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType type = 3; */ if (message.type !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* stream.video.sfu.models.TrackUnpublishReason cause = 4; */ if (message.cause !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.cause);\n        /* stream.video.sfu.models.Participant participant = 5; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.TrackUnpublished\n */ const TrackUnpublished = new TrackUnpublished$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass JoinRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.JoinRequest\", [\n            {\n                no: 1,\n                name: \"token\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"subscriber_sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"client_details\",\n                kind: \"message\",\n                T: ()=>ClientDetails\n            },\n            {\n                no: 5,\n                name: \"migration\",\n                kind: \"message\",\n                T: ()=>Migration\n            },\n            {\n                no: 6,\n                name: \"fast_reconnect\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.token = \"\";\n        message.sessionId = \"\";\n        message.subscriberSdp = \"\";\n        message.fastReconnect = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string token */ 1:\n                    message.token = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* string subscriber_sdp */ 3:\n                    message.subscriberSdp = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ClientDetails client_details */ 4:\n                    message.clientDetails = ClientDetails.internalBinaryRead(reader, reader.uint32(), options, message.clientDetails);\n                    break;\n                case /* stream.video.sfu.event.Migration migration */ 5:\n                    message.migration = Migration.internalBinaryRead(reader, reader.uint32(), options, message.migration);\n                    break;\n                case /* bool fast_reconnect */ 6:\n                    message.fastReconnect = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string token = 1; */ if (message.token !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.token);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* string subscriber_sdp = 3; */ if (message.subscriberSdp !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.subscriberSdp);\n        /* stream.video.sfu.models.ClientDetails client_details = 4; */ if (message.clientDetails) ClientDetails.internalBinaryWrite(message.clientDetails, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.Migration migration = 5; */ if (message.migration) Migration.internalBinaryWrite(message.migration, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* bool fast_reconnect = 6; */ if (message.fastReconnect !== false) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.fastReconnect);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.JoinRequest\n */ const JoinRequest = new JoinRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Migration$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.Migration\", [\n            {\n                no: 1,\n                name: \"from_sfu_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"announced_tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackInfo\n            },\n            {\n                no: 3,\n                name: \"subscriptions\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackSubscriptionDetails\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.fromSfuId = \"\";\n        message.announcedTracks = [];\n        message.subscriptions = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string from_sfu_id */ 1:\n                    message.fromSfuId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackInfo announced_tracks */ 2:\n                    message.announcedTracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackSubscriptionDetails subscriptions */ 3:\n                    message.subscriptions.push(TrackSubscriptionDetails.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string from_sfu_id = 1; */ if (message.fromSfuId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.fromSfuId);\n        /* repeated stream.video.sfu.models.TrackInfo announced_tracks = 2; */ for(let i = 0; i < message.announcedTracks.length; i++)TrackInfo.internalBinaryWrite(message.announcedTracks[i], writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.signal.TrackSubscriptionDetails subscriptions = 3; */ for(let i = 0; i < message.subscriptions.length; i++)TrackSubscriptionDetails.internalBinaryWrite(message.subscriptions[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.Migration\n */ const Migration = new Migration$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass JoinResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.JoinResponse\", [\n            {\n                no: 1,\n                name: \"call_state\",\n                kind: \"message\",\n                T: ()=>CallState$1\n            },\n            {\n                no: 2,\n                name: \"reconnected\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.reconnected = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.CallState call_state */ 1:\n                    message.callState = CallState$1.internalBinaryRead(reader, reader.uint32(), options, message.callState);\n                    break;\n                case /* bool reconnected */ 2:\n                    message.reconnected = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.CallState call_state = 1; */ if (message.callState) CallState$1.internalBinaryWrite(message.callState, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* bool reconnected = 2; */ if (message.reconnected !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.reconnected);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.JoinResponse\n */ const JoinResponse = new JoinResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantJoined$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ParticipantJoined\", [\n            {\n                no: 1,\n                name: \"call_cid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.callCid = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string call_cid */ 1:\n                    message.callCid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 2:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string call_cid = 1; */ if (message.callCid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.callCid);\n        /* stream.video.sfu.models.Participant participant = 2; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ParticipantJoined\n */ const ParticipantJoined = new ParticipantJoined$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantLeft$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ParticipantLeft\", [\n            {\n                no: 1,\n                name: \"call_cid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.callCid = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string call_cid */ 1:\n                    message.callCid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 2:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string call_cid = 1; */ if (message.callCid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.callCid);\n        /* stream.video.sfu.models.Participant participant = 2; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ParticipantLeft\n */ const ParticipantLeft = new ParticipantLeft$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscriberOffer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SubscriberOffer\", [\n            {\n                no: 1,\n                name: \"ice_restart\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 2,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.iceRestart = false;\n        message.sdp = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool ice_restart */ 1:\n                    message.iceRestart = reader.bool();\n                    break;\n                case /* string sdp */ 2:\n                    message.sdp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool ice_restart = 1; */ if (message.iceRestart !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.iceRestart);\n        /* string sdp = 2; */ if (message.sdp !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SubscriberOffer\n */ const SubscriberOffer = new SubscriberOffer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PublisherAnswer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.PublisherAnswer\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.PublisherAnswer\n */ const PublisherAnswer = new PublisherAnswer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ConnectionQualityChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ConnectionQualityChanged\", [\n            {\n                no: 1,\n                name: \"connection_quality_updates\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>ConnectionQualityInfo\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.connectionQualityUpdates = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.ConnectionQualityInfo connection_quality_updates */ 1:\n                    message.connectionQualityUpdates.push(ConnectionQualityInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.ConnectionQualityInfo connection_quality_updates = 1; */ for(let i = 0; i < message.connectionQualityUpdates.length; i++)ConnectionQualityInfo.internalBinaryWrite(message.connectionQualityUpdates[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ConnectionQualityChanged\n */ const ConnectionQualityChanged = new ConnectionQualityChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ConnectionQualityInfo$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ConnectionQualityInfo\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"connection_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ConnectionQuality\",\n                        ConnectionQuality,\n                        \"CONNECTION_QUALITY_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.connectionQuality = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ConnectionQuality connection_quality */ 3:\n                    message.connectionQuality = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.ConnectionQuality connection_quality = 3; */ if (message.connectionQuality !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.connectionQuality);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ConnectionQualityInfo\n */ const ConnectionQualityInfo = new ConnectionQualityInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DominantSpeakerChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.DominantSpeakerChanged\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.DominantSpeakerChanged\n */ const DominantSpeakerChanged = new DominantSpeakerChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioLevel$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioLevel\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"level\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 4,\n                name: \"is_speaking\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.level = 0;\n        message.isSpeaking = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* float level */ 3:\n                    message.level = reader.float();\n                    break;\n                case /* bool is_speaking */ 4:\n                    message.isSpeaking = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* float level = 3; */ if (message.level !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.level);\n        /* bool is_speaking = 4; */ if (message.isSpeaking !== false) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isSpeaking);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioLevel\n */ const AudioLevel = new AudioLevel$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioLevelChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioLevelChanged\", [\n            {\n                no: 1,\n                name: \"audio_levels\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>AudioLevel\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.audioLevels = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.AudioLevel audio_levels */ 1:\n                    message.audioLevels.push(AudioLevel.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.AudioLevel audio_levels = 1; */ for(let i = 0; i < message.audioLevels.length; i++)AudioLevel.internalBinaryWrite(message.audioLevels[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioLevelChanged\n */ const AudioLevelChanged = new AudioLevelChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioMediaRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioMediaRequest\", [\n            {\n                no: 1,\n                name: \"channel_count\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.channelCount = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int32 channel_count */ 1:\n                    message.channelCount = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int32 channel_count = 1; */ if (message.channelCount !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.channelCount);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioMediaRequest\n */ const AudioMediaRequest = new AudioMediaRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioSender$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioSender\", [\n            {\n                no: 1,\n                name: \"media_request\",\n                kind: \"message\",\n                T: ()=>AudioMediaRequest\n            },\n            {\n                no: 2,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.AudioMediaRequest media_request */ 1:\n                    message.mediaRequest = AudioMediaRequest.internalBinaryRead(reader, reader.uint32(), options, message.mediaRequest);\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 2:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.AudioMediaRequest media_request = 1; */ if (message.mediaRequest) AudioMediaRequest.internalBinaryWrite(message.mediaRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Codec codec = 2; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioSender\n */ const AudioSender = new AudioSender$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoMediaRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoMediaRequest\", [\n            {\n                no: 1,\n                name: \"ideal_height\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 2,\n                name: \"ideal_width\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 3,\n                name: \"ideal_frame_rate\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.idealHeight = 0;\n        message.idealWidth = 0;\n        message.idealFrameRate = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int32 ideal_height */ 1:\n                    message.idealHeight = reader.int32();\n                    break;\n                case /* int32 ideal_width */ 2:\n                    message.idealWidth = reader.int32();\n                    break;\n                case /* int32 ideal_frame_rate */ 3:\n                    message.idealFrameRate = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int32 ideal_height = 1; */ if (message.idealHeight !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealHeight);\n        /* int32 ideal_width = 2; */ if (message.idealWidth !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealWidth);\n        /* int32 ideal_frame_rate = 3; */ if (message.idealFrameRate !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealFrameRate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoMediaRequest\n */ const VideoMediaRequest = new VideoMediaRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoLayerSetting$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoLayerSetting\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"active\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 3,\n                name: \"max_bitrate\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 4,\n                name: \"scale_resolution_down_by\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 5,\n                name: \"priority\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.event.VideoLayerSetting.Priority\",\n                        VideoLayerSetting_Priority,\n                        \"PRIORITY_\"\n                    ]\n            },\n            {\n                no: 6,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            },\n            {\n                no: 7,\n                name: \"max_framerate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.active = false;\n        message.maxBitrate = 0;\n        message.scaleResolutionDownBy = 0;\n        message.priority = 0;\n        message.maxFramerate = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* bool active */ 2:\n                    message.active = reader.bool();\n                    break;\n                case /* int32 max_bitrate */ 3:\n                    message.maxBitrate = reader.int32();\n                    break;\n                case /* float scale_resolution_down_by */ 4:\n                    message.scaleResolutionDownBy = reader.float();\n                    break;\n                case /* stream.video.sfu.event.VideoLayerSetting.Priority priority */ 5:\n                    message.priority = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 6:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                case /* uint32 max_framerate */ 7:\n                    message.maxFramerate = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* bool active = 2; */ if (message.active !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.active);\n        /* int32 max_bitrate = 3; */ if (message.maxBitrate !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.maxBitrate);\n        /* float scale_resolution_down_by = 4; */ if (message.scaleResolutionDownBy !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.scaleResolutionDownBy);\n        /* stream.video.sfu.event.VideoLayerSetting.Priority priority = 5; */ if (message.priority !== 0) writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.priority);\n        /* stream.video.sfu.models.Codec codec = 6; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* uint32 max_framerate = 7; */ if (message.maxFramerate !== 0) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.maxFramerate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoLayerSetting\n */ const VideoLayerSetting = new VideoLayerSetting$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoSender$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoSender\", [\n            {\n                no: 1,\n                name: \"media_request\",\n                kind: \"message\",\n                T: ()=>VideoMediaRequest\n            },\n            {\n                no: 2,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            },\n            {\n                no: 3,\n                name: \"layers\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoLayerSetting\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.layers = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.VideoMediaRequest media_request */ 1:\n                    message.mediaRequest = VideoMediaRequest.internalBinaryRead(reader, reader.uint32(), options, message.mediaRequest);\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 2:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                case /* repeated stream.video.sfu.event.VideoLayerSetting layers */ 3:\n                    message.layers.push(VideoLayerSetting.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.VideoMediaRequest media_request = 1; */ if (message.mediaRequest) VideoMediaRequest.internalBinaryWrite(message.mediaRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Codec codec = 2; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.event.VideoLayerSetting layers = 3; */ for(let i = 0; i < message.layers.length; i++)VideoLayerSetting.internalBinaryWrite(message.layers[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoSender\n */ const VideoSender = new VideoSender$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ChangePublishQuality$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ChangePublishQuality\", [\n            {\n                no: 1,\n                name: \"audio_senders\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>AudioSender\n            },\n            {\n                no: 2,\n                name: \"video_senders\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoSender\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.audioSenders = [];\n        message.videoSenders = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.AudioSender audio_senders */ 1:\n                    message.audioSenders.push(AudioSender.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated stream.video.sfu.event.VideoSender video_senders */ 2:\n                    message.videoSenders.push(VideoSender.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.AudioSender audio_senders = 1; */ for(let i = 0; i < message.audioSenders.length; i++)AudioSender.internalBinaryWrite(message.audioSenders[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.event.VideoSender video_senders = 2; */ for(let i = 0; i < message.videoSenders.length; i++)VideoSender.internalBinaryWrite(message.videoSenders[i], writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ChangePublishQuality\n */ const ChangePublishQuality = new ChangePublishQuality$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallGrantsUpdated$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.CallGrantsUpdated\", [\n            {\n                no: 1,\n                name: \"current_grants\",\n                kind: \"message\",\n                T: ()=>CallGrants\n            },\n            {\n                no: 2,\n                name: \"message\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.message = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.CallGrants current_grants */ 1:\n                    message.currentGrants = CallGrants.internalBinaryRead(reader, reader.uint32(), options, message.currentGrants);\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.CallGrants current_grants = 1; */ if (message.currentGrants) CallGrants.internalBinaryWrite(message.currentGrants, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string message = 2; */ if (message.message !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.message);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.CallGrantsUpdated\n */ const CallGrantsUpdated = new CallGrantsUpdated$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GoAway$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.GoAway\", [\n            {\n                no: 1,\n                name: \"reason\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.GoAwayReason\",\n                        GoAwayReason,\n                        \"GO_AWAY_REASON_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.reason = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.GoAwayReason reason */ 1:\n                    message.reason = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.GoAwayReason reason = 1; */ if (message.reason !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.reason);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.GoAway\n */ const GoAway = new GoAway$Type();\nvar events = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AudioLevel: AudioLevel,\n    AudioLevelChanged: AudioLevelChanged,\n    AudioMediaRequest: AudioMediaRequest,\n    AudioSender: AudioSender,\n    CallGrantsUpdated: CallGrantsUpdated,\n    ChangePublishQuality: ChangePublishQuality,\n    ConnectionQualityChanged: ConnectionQualityChanged,\n    ConnectionQualityInfo: ConnectionQualityInfo,\n    DominantSpeakerChanged: DominantSpeakerChanged,\n    Error: Error$1,\n    GoAway: GoAway,\n    HealthCheckRequest: HealthCheckRequest,\n    HealthCheckResponse: HealthCheckResponse,\n    ICERestart: ICERestart,\n    ICETrickle: ICETrickle,\n    JoinRequest: JoinRequest,\n    JoinResponse: JoinResponse,\n    Migration: Migration,\n    ParticipantJoined: ParticipantJoined,\n    ParticipantLeft: ParticipantLeft,\n    PinsChanged: PinsChanged,\n    PublisherAnswer: PublisherAnswer,\n    SfuEvent: SfuEvent,\n    SfuRequest: SfuRequest,\n    SubscriberOffer: SubscriberOffer,\n    TrackPublished: TrackPublished,\n    TrackUnpublished: TrackUnpublished,\n    VideoLayerSetting: VideoLayerSetting,\n    get VideoLayerSetting_Priority () {\n        return VideoLayerSetting_Priority;\n    },\n    VideoMediaRequest: VideoMediaRequest,\n    VideoSender: VideoSender\n});\nvar VisibilityState;\n(function(VisibilityState) {\n    VisibilityState[\"UNKNOWN\"] = \"UNKNOWN\";\n    VisibilityState[\"VISIBLE\"] = \"VISIBLE\";\n    VisibilityState[\"INVISIBLE\"] = \"INVISIBLE\";\n})(VisibilityState || (VisibilityState = {}));\nvar DebounceType;\n(function(DebounceType) {\n    DebounceType[DebounceType[\"IMMEDIATE\"] = 20] = \"IMMEDIATE\";\n    DebounceType[DebounceType[\"FAST\"] = 100] = \"FAST\";\n    DebounceType[DebounceType[\"MEDIUM\"] = 600] = \"MEDIUM\";\n    DebounceType[DebounceType[\"SLOW\"] = 1200] = \"SLOW\";\n})(DebounceType || (DebounceType = {}));\n/**\n * @generated from protobuf service stream.video.sfu.signal.SignalServer\n */ class SignalServerClient {\n    constructor(_transport){\n        this._transport = _transport;\n        this.typeName = SignalServer.typeName;\n        this.methods = SignalServer.methods;\n        this.options = SignalServer.options;\n    }\n    /**\n     * SetPublisher sends the WebRTC offer for the peer connection used to publish A/V\n     *\n     * @generated from protobuf rpc: SetPublisher(stream.video.sfu.signal.SetPublisherRequest) returns (stream.video.sfu.signal.SetPublisherResponse);\n     */ setPublisher(input, options) {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * answer is sent by the client to the SFU after receiving a subscriber_offer.\n     *\n     * @generated from protobuf rpc: SendAnswer(stream.video.sfu.signal.SendAnswerRequest) returns (stream.video.sfu.signal.SendAnswerResponse);\n     */ sendAnswer(input, options) {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * SendICECandidate sends an ICE candidate to the client\n     *\n     * @generated from protobuf rpc: IceTrickle(stream.video.sfu.models.ICETrickle) returns (stream.video.sfu.signal.ICETrickleResponse);\n     */ iceTrickle(input, options) {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * UpdateSubscribers is used to notify the SFU about the list of video subscriptions\n     * TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user\n     *\n     * @generated from protobuf rpc: UpdateSubscriptions(stream.video.sfu.signal.UpdateSubscriptionsRequest) returns (stream.video.sfu.signal.UpdateSubscriptionsResponse);\n     */ updateSubscriptions(input, options) {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: UpdateMuteStates(stream.video.sfu.signal.UpdateMuteStatesRequest) returns (stream.video.sfu.signal.UpdateMuteStatesResponse);\n     */ updateMuteStates(input, options) {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: IceRestart(stream.video.sfu.signal.ICERestartRequest) returns (stream.video.sfu.signal.ICERestartResponse);\n     */ iceRestart(input, options) {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: SendStats(stream.video.sfu.signal.SendStatsRequest) returns (stream.video.sfu.signal.SendStatsResponse);\n     */ sendStats(input, options) {\n        const method = this.methods[6], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n}\nconst defaultOptions = {\n    baseUrl: \"\",\n    sendJson: true,\n    timeout: 5 * 1000,\n    jsonOptions: {\n        ignoreUnknownFields: true\n    }\n};\nconst withHeaders = (headers)=>{\n    return {\n        interceptUnary (next, method, input, options) {\n            options.meta = {\n                ...options.meta,\n                ...headers\n            };\n            return next(method, input, options);\n        }\n    };\n};\n/**\n * Creates new SignalServerClient instance.\n *\n * @param options the twirp options.\n */ const createSignalClient = (options)=>{\n    const transport = new _protobuf_ts_twirp_transport__WEBPACK_IMPORTED_MODULE_16__.TwirpFetchTransport({\n        ...defaultOptions,\n        ...options\n    });\n    return new SignalServerClient(transport);\n};\n/**\n * Checks whether we are using React Native\n */ const isReactNative = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.product?.toLowerCase() === \"reactnative\";\n};\n// log levels, sorted by verbosity\nconst logLevels = Object.freeze({\n    trace: 0,\n    debug: 1,\n    info: 2,\n    warn: 3,\n    error: 4\n});\nlet logger$4;\nlet level = \"info\";\nconst logToConsole = (logLevel, message, ...args)=>{\n    let logMethod;\n    switch(logLevel){\n        case \"error\":\n            logMethod = console.error;\n            break;\n        case \"warn\":\n            if (isReactNative()) {\n                message = `WARN: ${message}`;\n                logMethod = console.info;\n                break;\n            }\n            logMethod = console.warn;\n            break;\n        case \"info\":\n            logMethod = console.info;\n            break;\n        case \"trace\":\n            logMethod = console.trace;\n            break;\n        default:\n            logMethod = console.log;\n            break;\n    }\n    logMethod(message, ...args);\n};\nconst setLogger = (l, lvl)=>{\n    logger$4 = l;\n    if (lvl) {\n        setLogLevel(lvl);\n    }\n};\nconst setLogLevel = (l)=>{\n    level = l;\n};\nconst getLogger = (withTags)=>{\n    const loggerMethod = logger$4 || logToConsole;\n    const tags = (withTags || []).join(\":\");\n    const result = (logLevel, message, ...args)=>{\n        if (logLevels[logLevel] >= logLevels[level]) {\n            loggerMethod(logLevel, `[${tags}]: ${message}`, ...args);\n        }\n    };\n    return result;\n};\nconst getPreferredCodecs = (kind, preferredCodec, codecToRemove)=>{\n    const logger = getLogger([\n        \"codecs\"\n    ]);\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        logger?.(\"warn\", \"RTCRtpSender.getCapabilities is not supported\");\n        return;\n    }\n    const cap = RTCRtpSender.getCapabilities(kind);\n    if (!cap) return;\n    const matched = [];\n    const partialMatched = [];\n    const unmatched = [];\n    cap.codecs.forEach((c)=>{\n        const codec = c.mimeType.toLowerCase();\n        logger?.(\"debug\", `Found supported codec: ${codec}`);\n        const shouldRemoveCodec = codecToRemove && codec === `${kind}/${codecToRemove.toLowerCase()}`;\n        if (shouldRemoveCodec) return;\n        const matchesCodec = codec === `${kind}/${preferredCodec.toLowerCase()}`;\n        if (!matchesCodec) {\n            unmatched.push(c);\n            return;\n        }\n        // for h264 codecs that have sdpFmtpLine available, use only if the\n        // profile-level-id is 42e01f for cross-browser compatibility\n        if (codec === \"h264\") {\n            if (c.sdpFmtpLine && c.sdpFmtpLine.includes(\"profile-level-id=42e01f\")) {\n                matched.push(c);\n            } else {\n                partialMatched.push(c);\n            }\n            return;\n        }\n        matched.push(c);\n    });\n    const result = [\n        ...matched,\n        ...partialMatched,\n        ...unmatched\n    ];\n    logger?.(\"info\", `Preffered codecs: `, result);\n    return result;\n};\nconst getGenericSdp = async (direction)=>{\n    const tempPc = new RTCPeerConnection();\n    tempPc.addTransceiver(\"video\", {\n        direction\n    });\n    tempPc.addTransceiver(\"audio\", {\n        direction\n    });\n    const offer = await tempPc.createOffer();\n    let sdp = offer.sdp ?? \"\";\n    tempPc.getTransceivers().forEach((t)=>{\n        t.stop();\n    });\n    tempPc.close();\n    return sdp;\n};\nconst sfuEventKinds = {\n    subscriberOffer: undefined,\n    publisherAnswer: undefined,\n    connectionQualityChanged: undefined,\n    audioLevelChanged: undefined,\n    iceTrickle: undefined,\n    changePublishQuality: undefined,\n    participantJoined: undefined,\n    participantLeft: undefined,\n    dominantSpeakerChanged: undefined,\n    joinResponse: undefined,\n    healthCheckResponse: undefined,\n    trackPublished: undefined,\n    trackUnpublished: undefined,\n    error: undefined,\n    callGrantsUpdated: undefined,\n    goAway: undefined,\n    iceRestart: undefined,\n    pinsUpdated: undefined\n};\nconst isSfuEvent = (eventName)=>{\n    return Object.prototype.hasOwnProperty.call(sfuEventKinds, eventName);\n};\nclass Dispatcher {\n    constructor(){\n        this.logger = getLogger([\n            \"Dispatcher\"\n        ]);\n        this.subscribers = {};\n        this.dispatch = (message)=>{\n            const eventKind = message.eventPayload.oneofKind;\n            if (!eventKind) return;\n            const payload = message.eventPayload[eventKind];\n            this.logger(\"debug\", `Dispatching ${eventKind}`, payload);\n            const listeners = this.subscribers[eventKind];\n            if (!listeners) return;\n            for (const fn of listeners){\n                try {\n                    fn(payload);\n                } catch (e) {\n                    this.logger(\"warn\", \"Listener failed with error\", e);\n                }\n            }\n        };\n        this.on = (eventName, fn)=>{\n            var _a;\n            ((_a = this.subscribers)[eventName] ?? (_a[eventName] = [])).push(fn);\n            return ()=>{\n                this.off(eventName, fn);\n            };\n        };\n        this.off = (eventName, fn)=>{\n            this.subscribers[eventName] = (this.subscribers[eventName] || []).filter((f)=>f !== fn);\n        };\n        this.offAll = (eventName)=>{\n            if (eventName) {\n                this.subscribers[eventName] = [];\n            } else {\n                this.subscribers = {};\n            }\n        };\n    }\n}\n/**\n * A buffer for ICE Candidates. Used for ICE Trickle:\n * - https://bloggeek.me/webrtcglossary/trickle-ice/\n */ class IceTrickleBuffer {\n    constructor(){\n        this.subscriberCandidates = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.ReplaySubject();\n        this.publisherCandidates = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.ReplaySubject();\n        this.logger = getLogger([\n            \"sfu-client\"\n        ]);\n        this.push = (iceTrickle)=>{\n            if (iceTrickle.peerType === PeerType.SUBSCRIBER) {\n                this.subscriberCandidates.next(iceTrickle);\n            } else if (iceTrickle.peerType === PeerType.PUBLISHER_UNSPECIFIED) {\n                this.publisherCandidates.next(iceTrickle);\n            } else {\n                this.logger(\"warn\", `ICETrickle, Unknown peer type`, iceTrickle);\n            }\n        };\n    }\n}\nfunction getIceCandidate(candidate) {\n    if (!candidate.usernameFragment) {\n        // react-native-webrtc doesn't include usernameFragment in the candidate\n        const splittedCandidate = candidate.candidate.split(\" \");\n        const ufragIndex = splittedCandidate.findIndex((s)=>s === \"ufrag\") + 1;\n        const usernameFragment = splittedCandidate[ufragIndex];\n        return JSON.stringify({\n            ...candidate,\n            usernameFragment\n        });\n    } else {\n        return JSON.stringify(candidate.toJSON());\n    }\n}\nlet sdkInfo;\nlet osInfo;\nlet deviceInfo;\nlet webRtcInfo;\nconst setSdkInfo = (info)=>{\n    sdkInfo = info;\n};\nconst getSdkInfo = ()=>{\n    return sdkInfo;\n};\nconst setOSInfo = (info)=>{\n    osInfo = info;\n};\nconst getOSInfo = ()=>{\n    return osInfo;\n};\nconst setDeviceInfo = (info)=>{\n    deviceInfo = info;\n};\nconst getDeviceInfo = ()=>{\n    return deviceInfo;\n};\nconst getWebRTCInfo = ()=>{\n    return webRtcInfo;\n};\nconst setWebRTCInfo = (info)=>{\n    webRtcInfo = info;\n};\nconst getClientDetails = ()=>{\n    if (isReactNative()) {\n        // Since RN doesn't support web, sharing browser info is not required\n        return {\n            sdk: getSdkInfo(),\n            os: getOSInfo(),\n            device: getDeviceInfo()\n        };\n    }\n    const userAgent = new ua_parser_js__WEBPACK_IMPORTED_MODULE_3__.UAParser(navigator.userAgent);\n    const { browser, os, device, cpu } = userAgent.getResult();\n    return {\n        sdk: getSdkInfo(),\n        browser: {\n            name: browser.name || navigator.userAgent,\n            version: browser.version || \"\"\n        },\n        os: {\n            name: os.name || \"\",\n            version: os.version || \"\",\n            architecture: cpu.architecture || \"\"\n        },\n        device: {\n            name: [\n                device.vendor,\n                device.model,\n                device.type\n            ].filter(Boolean).join(\" \"),\n            version: \"\"\n        }\n    };\n};\nconst DEFAULT_BITRATE = 1250000;\nconst defaultTargetResolution = {\n    bitrate: DEFAULT_BITRATE,\n    width: 1280,\n    height: 720\n};\n/**\n * Determines the most optimal video layers for simulcasting\n * for the given track.\n *\n * @param videoTrack the video track to find optimal layers for.\n * @param targetResolution the expected target resolution.\n */ const findOptimalVideoLayers = (videoTrack, targetResolution = defaultTargetResolution)=>{\n    const optimalVideoLayers = [];\n    const settings = videoTrack.getSettings();\n    const { width: w = 0, height: h = 0 } = settings;\n    const isRNIos = isReactNative() && getOSInfo()?.name.toLowerCase() === \"ios\";\n    const maxBitrate = getComputedMaxBitrate(targetResolution, w, h);\n    let downscaleFactor = 1;\n    [\n        \"f\",\n        \"h\",\n        \"q\"\n    ].forEach((rid)=>{\n        // Reversing the order [f, h, q] to [q, h, f] as Chrome uses encoding index\n        // when deciding which layer to disable when CPU or bandwidth is constrained.\n        // Encodings should be ordered in increasing spatial resolution order.\n        optimalVideoLayers.unshift({\n            active: true,\n            rid,\n            width: Math.round(w / downscaleFactor),\n            height: Math.round(h / downscaleFactor),\n            maxBitrate: Math.round(maxBitrate / downscaleFactor),\n            scaleResolutionDownBy: downscaleFactor,\n            // Simulcast on iOS React-Native requires all encodings to share the same framerate\n            maxFramerate: {\n                f: 30,\n                h: isRNIos ? 30 : 25,\n                q: isRNIos ? 30 : 20\n            }[rid]\n        });\n        downscaleFactor *= 2;\n    });\n    // for simplicity, we start with all layers enabled, then this function\n    // will clear/reassign the layers that are not needed\n    return withSimulcastConstraints(settings, optimalVideoLayers);\n};\n/**\n * Computes the maximum bitrate for a given resolution.\n * If the current resolution is lower than the target resolution,\n * we want to proportionally reduce the target bitrate.\n * If the current resolution is higher than the target resolution,\n * we want to use the target bitrate.\n *\n * @param targetResolution the target resolution.\n * @param currentWidth the current width of the track.\n * @param currentHeight the current height of the track.\n */ const getComputedMaxBitrate = (targetResolution, currentWidth, currentHeight)=>{\n    // if the current resolution is lower than the target resolution,\n    // we want to proportionally reduce the target bitrate\n    const { width: targetWidth, height: targetHeight } = targetResolution;\n    if (currentWidth < targetWidth || currentHeight < targetHeight) {\n        const currentPixels = currentWidth * currentHeight;\n        const targetPixels = targetWidth * targetHeight;\n        const reductionFactor = currentPixels / targetPixels;\n        return Math.round(targetResolution.bitrate * reductionFactor);\n    }\n    return targetResolution.bitrate;\n};\n/**\n * Browsers have different simulcast constraints for different video resolutions.\n *\n * This function modifies the provided list of video layers according to the\n * current implementation of simulcast constraints in the Chromium based browsers.\n *\n * https://chromium.googlesource.com/external/webrtc/+/refs/heads/main/media/engine/simulcast.cc#90\n */ const withSimulcastConstraints = (settings, optimalVideoLayers)=>{\n    let layers;\n    const size = Math.max(settings.width || 0, settings.height || 0);\n    if (size <= 320) {\n        // provide only one layer 320x240 (q), the one with the highest quality\n        layers = optimalVideoLayers.filter((layer)=>layer.rid === \"f\");\n    } else if (size <= 640) {\n        // provide two layers, 160x120 (q) and 640x480 (h)\n        layers = optimalVideoLayers.filter((layer)=>layer.rid !== \"h\");\n    } else {\n        // provide three layers for sizes > 640x480\n        layers = optimalVideoLayers;\n    }\n    const ridMapping = [\n        \"q\",\n        \"h\",\n        \"f\"\n    ];\n    return layers.map((layer, index)=>({\n            ...layer,\n            rid: ridMapping[index]\n        }));\n};\nconst findOptimalScreenSharingLayers = (videoTrack, preferences)=>{\n    const settings = videoTrack.getSettings();\n    return [\n        {\n            active: true,\n            rid: \"q\",\n            width: settings.width || 0,\n            height: settings.height || 0,\n            scaleResolutionDownBy: 1,\n            maxBitrate: preferences?.maxBitrate ?? 3000000,\n            maxFramerate: preferences?.maxFramerate ?? 30\n        }\n    ];\n};\nconst trackTypeToParticipantStreamKey = (trackType)=>{\n    switch(trackType){\n        case TrackType.SCREEN_SHARE:\n            return \"screenShareStream\";\n        case TrackType.SCREEN_SHARE_AUDIO:\n            return \"screenShareAudioStream\";\n        case TrackType.VIDEO:\n            return \"videoStream\";\n        case TrackType.AUDIO:\n            return \"audioStream\";\n        case TrackType.UNSPECIFIED:\n            throw new Error(\"Track type is unspecified\");\n        default:\n            const exhaustiveTrackTypeCheck = trackType;\n            throw new Error(`Unknown track type: ${exhaustiveTrackTypeCheck}`);\n    }\n};\nconst muteTypeToTrackType = (muteType)=>{\n    switch(muteType){\n        case \"audio\":\n            return TrackType.AUDIO;\n        case \"video\":\n            return TrackType.VIDEO;\n        case \"screenshare\":\n            return TrackType.SCREEN_SHARE;\n        case \"screenshare_audio\":\n            return TrackType.SCREEN_SHARE_AUDIO;\n        default:\n            const exhaustiveMuteTypeCheck = muteType;\n            throw new Error(`Unknown mute type: ${exhaustiveMuteTypeCheck}`);\n    }\n};\n/**\n * Checks if the provided update is a function patch.\n *\n * @param update the value to check.\n */ const isFunctionPatch = (update)=>typeof update === \"function\";\n/**\n * Gets the current value of an observable, or undefined if the observable has\n * not emitted a value yet.\n *\n * @param observable$ the observable to get the value from.\n */ const getCurrentValue = (observable$)=>{\n    let value;\n    let err = undefined;\n    (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n        observable$\n    ]).subscribe({\n        next: ([v])=>{\n            value = v;\n        },\n        error: (e)=>{\n            err = e;\n        }\n    }).unsubscribe();\n    if (err) throw err;\n    return value;\n};\n/**\n * Updates the value of the provided Subject.\n * An `update` can either be a new value or a function which takes\n * the current value and returns a new value.\n *\n * @param subject the subject to update.\n * @param update the update to apply to the subject.\n * @return the updated value.\n */ const setCurrentValue = (subject, update)=>{\n    const next = isFunctionPatch(update) ? update(getCurrentValue(subject)) : update;\n    subject.next(next);\n    return next;\n};\n/**\n * Creates a subscription and returns a function to unsubscribe.\n *\n * @param observable the observable to subscribe to.\n * @param handler the handler to call when the observable emits a value.\n */ const createSubscription = (observable, handler)=>{\n    const subscription = observable.subscribe(handler);\n    return ()=>{\n        subscription.unsubscribe();\n    };\n};\nvar rxUtils = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    createSubscription: createSubscription,\n    getCurrentValue: getCurrentValue,\n    setCurrentValue: setCurrentValue\n});\n/**\n * Creates a new combined {@link Comparator<T>} which sorts items by the given comparators.\n * The comparators are applied in the order they are given (left -> right).\n *\n * @param comparators the comparators to use for sorting.\n * @returns a combined {@link Comparator<T>}.\n */ const combineComparators = (...comparators)=>{\n    return (a, b)=>{\n        for (const comparator of comparators){\n            const result = comparator(a, b);\n            if (result !== 0) return result;\n        }\n        return 0;\n    };\n};\n/**\n * Creates a new comparator which sorts items in descending order.\n *\n * @example\n * const byValue = (a, b) => a < b ? - 1 : a > b ? 1 : 0;\n * const byValueDesc = descending(byValue);\n *\n * @param comparator the comparator to wrap.\n */ const descending = (comparator)=>{\n    return (a, b)=>comparator(b, a);\n};\n/**\n * Creates a new comparator which conditionally applies the given comparator.\n *\n * @example\n * const shouldSortByValue = (a, b) => a % 2 === 0; // return false to turn it off\n * const byValue = (a, b) => a < b ? - 1 : a > b ? 1 : 0;\n * const comparator = conditional(shouldSortByValue)(byValue);\n *\n * @param predicate the predicate to use for determining whether to apply the comparator.\n */ const conditional = (predicate)=>{\n    return (comparator)=>{\n        return (a, b)=>{\n            if (!predicate(a, b)) return 0;\n            return comparator(a, b);\n        };\n    };\n};\n/**\n * A no-op comparator which always returns 0.\n */ const noopComparator = ()=>{\n    return ()=>0;\n};\n/**\n * A comparator which sorts participants by the fact that they are the dominant speaker or not.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const dominantSpeaker = (a, b)=>{\n    if (a.isDominantSpeaker && !b.isDominantSpeaker) return -1;\n    if (!a.isDominantSpeaker && b.isDominantSpeaker) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by the fact that they are speaking or not.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const speaking = (a, b)=>{\n    if (a.isSpeaking && !b.isSpeaking) return -1;\n    if (!a.isSpeaking && b.isSpeaking) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by screen sharing status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const screenSharing = (a, b)=>{\n    if (hasScreenShare(a) && !hasScreenShare(b)) return -1;\n    if (!hasScreenShare(a) && hasScreenShare(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by video status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const publishingVideo = (a, b)=>{\n    if (hasVideo(a) && !hasVideo(b)) return -1;\n    if (!hasVideo(a) && hasVideo(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by audio status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const publishingAudio = (a, b)=>{\n    if (hasAudio(a) && !hasAudio(b)) return -1;\n    if (!hasAudio(a) && hasAudio(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which prioritizes participants who are pinned.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const pinned = (a, b)=>{\n    if (a.pin && b.pin) {\n        if (!a.pin.isLocalPin && b.pin.isLocalPin) return -1;\n        if (a.pin.isLocalPin && !b.pin.isLocalPin) return 1;\n        if (a.pin.pinnedAt > b.pin.pinnedAt) return -1;\n        if (a.pin.pinnedAt < b.pin.pinnedAt) return 1;\n    }\n    if (a.pin && !b.pin) return -1;\n    if (!a.pin && b.pin) return 1;\n    return 0;\n};\n/**\n * A comparator creator which will set up a comparator which prioritizes\n * participants who have a specific reaction.\n *\n * @param type the reaction type.\n */ const reactionType = (type)=>{\n    return (a, b)=>{\n        if (a.reaction?.type === type && b.reaction?.type !== type) return -1;\n        if (a.reaction?.type !== type && b.reaction?.type === type) return 1;\n        return 0;\n    };\n};\n/**\n * A comparator creator which will set up a comparator which prioritizes\n * participants who have a specific role.\n *\n * @param roles the roles to prioritize.\n */ const role = (...roles)=>(a, b)=>{\n        if (hasAnyRole(a, roles) && !hasAnyRole(b, roles)) return -1;\n        if (!hasAnyRole(a, roles) && hasAnyRole(b, roles)) return 1;\n        return 0;\n    };\n/**\n * A comparator which sorts participants by name.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const name = (a, b)=>{\n    if (a.name < b.name) return -1;\n    if (a.name > b.name) return 1;\n    return 0;\n};\nconst hasAnyRole = (p, roles)=>(p.roles || []).some((r)=>roles.includes(r));\nconst hasScreenShare = (p)=>p.publishedTracks.includes(TrackType.SCREEN_SHARE);\nconst hasVideo = (p)=>p.publishedTracks.includes(TrackType.VIDEO);\nconst hasAudio = (p)=>p.publishedTracks.includes(TrackType.AUDIO);\n// a comparator decorator which applies the decorated comparator only if the\n// participant is invisible.\n// This ensures stable sorting when all participants are visible.\nconst ifInvisibleBy = conditional((a, b)=>a.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE);\n/**\n * A comparator that applies the decorated comparator when a participant is\n * either invisible or its visibility state isn't known.\n * For visible participants, it ensures stable sorting.\n */ const ifInvisibleOrUnknownBy = conditional((a, b)=>a.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || a.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN || b.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN);\n/**\n * The default sorting preset.\n */ const defaultSortPreset = combineComparators(pinned, screenSharing, ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for speaker layout.\n */ const speakerLayoutSortPreset = combineComparators(pinned, screenSharing, dominantSpeaker, ifInvisibleBy(combineComparators(speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for layouts that don't render all participants but\n * instead, render them in pages.\n */ const paginatedLayoutSortPreset = combineComparators(pinned, ifInvisibleOrUnknownBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for livestreams and audio rooms.\n */ const livestreamOrAudioRoomSortPreset = combineComparators(ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)), role(\"admin\", \"host\", \"speaker\"));\n/**\n * Represents the state of the current call.\n */ var CallingState;\n(function(CallingState) {\n    /**\n     * The call is in an unknown state.\n     */ CallingState[\"UNKNOWN\"] = \"unknown\";\n    /**\n     * The call is in an idle state.\n     */ CallingState[\"IDLE\"] = \"idle\";\n    /**\n     * The call is in the process of ringing.\n     * (User hasn't accepted nor rejected the call yet.)\n     */ CallingState[\"RINGING\"] = \"ringing\";\n    /**\n     * The call is in the process of joining.\n     */ CallingState[\"JOINING\"] = \"joining\";\n    /**\n     * The call is currently active.\n     */ CallingState[\"JOINED\"] = \"joined\";\n    /**\n     * The call has been left.\n     */ CallingState[\"LEFT\"] = \"left\";\n    /**\n     * The call is in the process of reconnecting.\n     */ CallingState[\"RECONNECTING\"] = \"reconnecting\";\n    /**\n     * The call is in the process of migrating from one node to another.\n     */ CallingState[\"MIGRATING\"] = \"migrating\";\n    /**\n     * The call has failed to reconnect.\n     */ CallingState[\"RECONNECTING_FAILED\"] = \"reconnecting-failed\";\n    /**\n     * The call is in offline mode.\n     */ CallingState[\"OFFLINE\"] = \"offline\";\n})(CallingState || (CallingState = {}));\n/**\n * Returns the default egress object - when no egress data is available.\n */ const defaultEgress = {\n    broadcasting: false,\n    hls: {\n        playlist_url: \"\"\n    },\n    rtmps: []\n};\n/**\n * Holds the state of the current call.\n * @react You don't have to use this class directly, as we are exposing the state through Hooks.\n */ class CallState {\n    /**\n     * Creates a new instance of the CallState class.\n     *\n     */ constructor(){\n        this.backstageSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(true);\n        this.blockedUserIdsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.createdAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(new Date());\n        this.endedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.startsAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.updatedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(new Date());\n        this.createdBySubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.customSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject({});\n        this.egressSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.ingressSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.recordingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.sessionSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.settingsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.transcribingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.endedBySubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.thumbnailsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.membersSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.ownCapabilitiesSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.callingStateSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(CallingState.UNKNOWN);\n        this.startedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.participantCountSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(0);\n        this.anonymousParticipantCountSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(0);\n        this.participantsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.callStatsReportSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * A list of comparators that are used to sort the participants.\n         *\n         * @private\n         */ this.sortParticipantsBy = defaultSortPreset;\n        /**\n         * Sets the list of criteria that are used to sort the participants.\n         * To disable sorting, you can pass `noopComparator()`.\n         *\n         * @param comparator the comparator to use to sort the participants.\n         */ this.setSortParticipantsBy = (comparator)=>{\n            this.sortParticipantsBy = comparator;\n            // trigger re-sorting of participants\n            this.setCurrentValue(this.participantsSubject, (ps)=>ps);\n        };\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        /**\n         * Sets the number of participants in the current call.\n         *\n         * @internal\n         * @param count the number of participants.\n         */ this.setParticipantCount = (count)=>{\n            return this.setCurrentValue(this.participantCountSubject, count);\n        };\n        /**\n         * Sets the time the call session actually started.\n         *\n         * @internal\n         * @param startedAt the time the call session actually started.\n         */ this.setStartedAt = (startedAt)=>{\n            return this.setCurrentValue(this.startedAtSubject, startedAt);\n        };\n        /**\n         * Sets the number of anonymous participants in the current call.\n         *\n         * @internal\n         * @param count the number of anonymous participants.\n         */ this.setAnonymousParticipantCount = (count)=>{\n            return this.setCurrentValue(this.anonymousParticipantCountSubject, count);\n        };\n        /**\n         * Sets the list of participants in the current call.\n         *\n         * @internal\n         *\n         * @param participants the list of participants.\n         */ this.setParticipants = (participants)=>{\n            return this.setCurrentValue(this.participantsSubject, participants);\n        };\n        /**\n         * Sets the calling state.\n         *\n         * @internal\n         * @param state the new calling state.\n         */ this.setCallingState = (state)=>{\n            return this.setCurrentValue(this.callingStateSubject, state);\n        };\n        /**\n         * Sets the call stats report.\n         *\n         * @internal\n         * @param report the report to set.\n         */ this.setCallStatsReport = (report)=>{\n            return this.setCurrentValue(this.callStatsReportSubject, report);\n        };\n        /**\n         * Sets the members of the current call.\n         *\n         * @internal\n         * @param members the members to set.\n         */ this.setMembers = (members)=>{\n            this.setCurrentValue(this.membersSubject, members);\n        };\n        /**\n         * Sets the own capabilities.\n         *\n         * @internal\n         * @param capabilities the capabilities to set.\n         */ this.setOwnCapabilities = (capabilities)=>{\n            return this.setCurrentValue(this.ownCapabilitiesSubject, capabilities);\n        };\n        /**\n         * Will try to find the participant with the given sessionId in the current call.\n         *\n         * @param sessionId the sessionId of the participant to find.\n         * @returns the participant with the given sessionId or undefined if not found.\n         */ this.findParticipantBySessionId = (sessionId)=>{\n            return this.participants.find((p)=>p.sessionId === sessionId);\n        };\n        /**\n         * Returns a new lookup table of participants indexed by their session ID.\n         */ this.getParticipantLookupBySessionId = ()=>{\n            return this.participants.reduce((lookupTable, participant)=>{\n                lookupTable[participant.sessionId] = participant;\n                return lookupTable;\n            }, {});\n        };\n        /**\n         * Updates a participant in the current call identified by the given `sessionId`.\n         * If the participant can't be found, this operation is no-op.\n         *\n         * @internal\n         *\n         * @param sessionId the session ID of the participant to update.\n         * @param patch the patch to apply to the participant.\n         * @returns the updated participant or `undefined` if the participant couldn't be found.\n         */ this.updateParticipant = (sessionId, patch)=>{\n            const participant = this.findParticipantBySessionId(sessionId);\n            if (!participant) {\n                this.logger(\"warn\", `Participant with sessionId ${sessionId} not found`);\n                return;\n            }\n            const thePatch = typeof patch === \"function\" ? patch(participant) : patch;\n            const updatedParticipant = {\n                // FIXME OL: this is not a deep merge, we might want to revisit this\n                ...participant,\n                ...thePatch\n            };\n            return this.setParticipants((participants)=>participants.map((p)=>p.sessionId === sessionId ? updatedParticipant : p));\n        };\n        /**\n         * Updates a participant in the current call identified by the given `sessionId`.\n         * If a participant with matching `sessionId` can't be found, the provided\n         * `participant` is added to the list of participants.\n         *\n         * @param sessionId the session ID of the participant to update.\n         * @param participant the participant to update or add.\n         */ this.updateOrAddParticipant = (sessionId, participant)=>{\n            if (!this.findParticipantBySessionId(sessionId)) {\n                return this.setParticipants((participants)=>[\n                        ...participants,\n                        participant\n                    ]);\n            }\n            return this.setParticipants((participants)=>participants.map((p)=>{\n                    if (p.sessionId === sessionId) {\n                        return {\n                            ...p,\n                            ...participant\n                        };\n                    }\n                    return p;\n                }));\n        };\n        /**\n         * Updates all participants in the current call whose session ID is in the given `sessionIds`.\n         * If no patches are provided, this operation is no-op.\n         *\n         * @internal\n         *\n         * @param patch the patch to apply to the participants.\n         * @returns all participants, with all patch applied.\n         */ this.updateParticipants = (patch)=>{\n            if (Object.keys(patch).length === 0) return;\n            return this.setParticipants((participants)=>participants.map((p)=>{\n                    const thePatch = patch[p.sessionId];\n                    if (thePatch) {\n                        return {\n                            ...p,\n                            ...thePatch\n                        };\n                    }\n                    return p;\n                }));\n        };\n        /**\n         * Updates the call state with the data received from the server.\n         *\n         * @internal\n         *\n         * @param event the video event that our backend sent us.\n         */ this.updateFromEvent = (event)=>{\n            const update = this.eventHandlers[event.type];\n            if (update) {\n                update(event);\n            }\n        };\n        /**\n         * Updates the participant pinned state with server side pinning data.\n         *\n         * @param pins the latest pins from the server.\n         */ this.setServerSidePins = (pins)=>{\n            const pinsLookup = pins.reduce((lookup, pin)=>{\n                lookup[pin.sessionId] = Date.now();\n                return lookup;\n            }, {});\n            return this.setParticipants((participants)=>participants.map((participant)=>{\n                    const serverSidePinnedAt = pinsLookup[participant.sessionId];\n                    // the participant is newly pinned\n                    if (serverSidePinnedAt) {\n                        return {\n                            ...participant,\n                            pin: {\n                                isLocalPin: false,\n                                pinnedAt: serverSidePinnedAt\n                            }\n                        };\n                    }\n                    // the participant is no longer pinned server side\n                    // we need to reset the pin\n                    if (participant.pin && !participant.pin.isLocalPin) {\n                        return {\n                            ...participant,\n                            pin: undefined\n                        };\n                    }\n                    // no changes to be applied\n                    return participant;\n                }));\n        };\n        /**\n         * Updates the call state with the data received from the server.\n         *\n         * @internal\n         *\n         * @param call the call response from the server.\n         */ this.updateFromCallResponse = (call)=>{\n            this.setCurrentValue(this.backstageSubject, call.backstage);\n            this.setCurrentValue(this.blockedUserIdsSubject, call.blocked_user_ids);\n            this.setCurrentValue(this.createdAtSubject, new Date(call.created_at));\n            this.setCurrentValue(this.updatedAtSubject, new Date(call.updated_at));\n            this.setCurrentValue(this.startsAtSubject, call.starts_at ? new Date(call.starts_at) : undefined);\n            this.setCurrentValue(this.endedAtSubject, call.ended_at ? new Date(call.ended_at) : undefined);\n            this.setCurrentValue(this.createdBySubject, call.created_by);\n            this.setCurrentValue(this.customSubject, call.custom);\n            this.setCurrentValue(this.egressSubject, call.egress);\n            this.setCurrentValue(this.ingressSubject, call.ingress);\n            this.setCurrentValue(this.recordingSubject, call.recording);\n            this.setCurrentValue(this.sessionSubject, call.session);\n            this.setCurrentValue(this.settingsSubject, call.settings);\n            this.setCurrentValue(this.transcribingSubject, call.transcribing);\n            this.setCurrentValue(this.thumbnailsSubject, call.thumbnails);\n        };\n        this.updateFromMemberRemoved = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>members.filter((m)=>event.members.indexOf(m.user_id) === -1));\n        };\n        this.updateFromMemberAdded = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>[\n                    ...members,\n                    ...event.members\n                ]);\n        };\n        this.updateFromHLSBroadcastStopped = ()=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: false\n                }));\n        };\n        this.updateFromHLSBroadcastingFailed = ()=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: false\n                }));\n        };\n        this.updateFromHLSBroadcastStarted = (event)=>{\n            this.setCurrentValue(this.egressSubject, (egress = defaultEgress)=>({\n                    ...egress,\n                    broadcasting: true,\n                    hls: {\n                        ...egress.hls,\n                        playlist_url: event.hls_playlist_url\n                    }\n                }));\n        };\n        this.updateFromSessionParticipantLeft = (event)=>{\n            this.setCurrentValue(this.sessionSubject, (session)=>{\n                if (!session) {\n                    this.logger(\"warn\", `Received call.session_participant_left event but no session is available.`, event);\n                    return session;\n                }\n                const { participants, participants_count_by_role } = session;\n                const { user, user_session_id } = event.participant;\n                return {\n                    ...session,\n                    participants: participants.filter((p)=>p.user_session_id !== user_session_id),\n                    participants_count_by_role: {\n                        ...participants_count_by_role,\n                        [user.role]: Math.max(0, (participants_count_by_role[user.role] || 0) - 1)\n                    }\n                };\n            });\n        };\n        this.updateFromSessionParticipantJoined = (event)=>{\n            this.setCurrentValue(this.sessionSubject, (session)=>{\n                if (!session) {\n                    this.logger(\"warn\", `Received call.session_participant_joined event but no session is available.`, event);\n                    return session;\n                }\n                const { participants, participants_count_by_role } = session;\n                const { user, user_session_id } = event.participant;\n                // It could happen that the backend delivers the same participant more than once.\n                // Once with the call.session_started event and once again with the\n                // call.session_participant_joined event. In this case,\n                // we should update the existing participant and prevent duplicating it.\n                let shouldInsertParticipant = true;\n                const updatedParticipants = participants.map((p)=>{\n                    if (p.user_session_id === user_session_id) {\n                        shouldInsertParticipant = false;\n                        return event.participant;\n                    }\n                    return p;\n                });\n                if (shouldInsertParticipant) {\n                    // this is a new array, we can safely push the new participant\n                    updatedParticipants.push(event.participant);\n                }\n                // If we are updating an existing participant, we don't want to increment\n                // the participant_by_role count.\n                const increment = shouldInsertParticipant ? 1 : 0;\n                return {\n                    ...session,\n                    participants: updatedParticipants,\n                    participants_count_by_role: {\n                        ...participants_count_by_role,\n                        [user.role]: (participants_count_by_role[user.role] || 0) + increment\n                    }\n                };\n            });\n        };\n        this.updateMembers = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>members.map((member)=>{\n                    const memberUpdate = event.members.find((m)=>m.user_id === member.user_id);\n                    return memberUpdate ? memberUpdate : member;\n                }));\n        };\n        this.updateParticipantReaction = (event)=>{\n            const { user, custom, type, emoji_code } = event.reaction;\n            this.setParticipants((participants)=>{\n                return participants.map((p)=>{\n                    // skip if the reaction is not for this participant\n                    if (p.userId !== user.id) return p;\n                    // update the participant with the new reaction\n                    return {\n                        ...p,\n                        reaction: {\n                            type,\n                            emoji_code,\n                            custom\n                        }\n                    };\n                });\n            });\n        };\n        this.unblockUser = (event)=>{\n            this.setCurrentValue(this.blockedUserIdsSubject, (current)=>{\n                if (!current) return current;\n                return current.filter((id)=>id !== event.user.id);\n            });\n        };\n        this.blockUser = (event)=>{\n            this.setCurrentValue(this.blockedUserIdsSubject, (current)=>[\n                    ...current || [],\n                    event.user.id\n                ]);\n        };\n        this.updateOwnCapabilities = (event)=>{\n            if (event.user.id === this.localParticipant?.userId) {\n                this.setCurrentValue(this.ownCapabilitiesSubject, event.own_capabilities);\n            }\n        };\n        this.logger = getLogger([\n            \"CallState\"\n        ]);\n        this.participants$ = this.participantsSubject.asObservable().pipe(// maintain stable-sort by mutating the participants stored\n        // in the original subject\n        (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((ps)=>ps.sort(this.sortParticipantsBy)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.localParticipant$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.isLocalParticipant)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.remoteParticipants$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.filter((p)=>!p.isLocalParticipant)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.pinnedParticipants$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.filter((p)=>!!p.pin)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.dominantSpeaker$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.isDominantSpeaker)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.hasOngoingScreenShare$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.some((p)=>p.publishedTracks.includes(TrackType.SCREEN_SHARE))), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.startedAt$ = this.startedAtSubject.asObservable();\n        this.participantCount$ = this.participantCountSubject.asObservable();\n        this.anonymousParticipantCount$ = this.anonymousParticipantCountSubject.asObservable();\n        this.callStatsReport$ = this.callStatsReportSubject.asObservable();\n        this.members$ = this.membersSubject.asObservable();\n        this.ownCapabilities$ = this.ownCapabilitiesSubject.asObservable();\n        this.callingState$ = this.callingStateSubject.asObservable();\n        this.backstage$ = this.backstageSubject.asObservable();\n        this.blockedUserIds$ = this.blockedUserIdsSubject.asObservable();\n        this.createdAt$ = this.createdAtSubject.asObservable();\n        this.endedAt$ = this.endedAtSubject.asObservable();\n        this.startsAt$ = this.startsAtSubject.asObservable();\n        this.updatedAt$ = this.updatedAtSubject.asObservable();\n        this.createdBy$ = this.createdBySubject.asObservable();\n        this.custom$ = this.customSubject.asObservable();\n        this.egress$ = this.egressSubject.asObservable();\n        this.ingress$ = this.ingressSubject.asObservable();\n        this.recording$ = this.recordingSubject.asObservable();\n        this.session$ = this.sessionSubject.asObservable();\n        this.settings$ = this.settingsSubject.asObservable();\n        this.transcribing$ = this.transcribingSubject.asObservable();\n        this.endedBy$ = this.endedBySubject.asObservable();\n        this.thumbnails$ = this.thumbnailsSubject.asObservable();\n        this.eventHandlers = {\n            // these events are not updating the call state:\n            \"call.closed_caption\": undefined,\n            \"call.permission_request\": undefined,\n            \"call.recording_failed\": undefined,\n            \"call.recording_ready\": undefined,\n            \"call.transcription_started\": undefined,\n            \"call.transcription_stopped\": undefined,\n            \"call.transcription_ready\": undefined,\n            \"call.transcription_failed\": undefined,\n            \"call.user_muted\": undefined,\n            \"connection.error\": undefined,\n            \"connection.ok\": undefined,\n            \"health.check\": undefined,\n            custom: undefined,\n            // events that update call state:\n            \"call.accepted\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.blocked_user\": this.blockUser,\n            \"call.created\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.ended\": (e)=>{\n                this.updateFromCallResponse(e.call);\n                this.setCurrentValue(this.endedBySubject, e.user);\n            },\n            \"call.hls_broadcasting_failed\": this.updateFromHLSBroadcastingFailed,\n            \"call.hls_broadcasting_started\": this.updateFromHLSBroadcastStarted,\n            \"call.hls_broadcasting_stopped\": this.updateFromHLSBroadcastStopped,\n            \"call.live_started\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.member_added\": this.updateFromMemberAdded,\n            \"call.member_removed\": this.updateFromMemberRemoved,\n            \"call.member_updated_permission\": this.updateMembers,\n            \"call.member_updated\": this.updateMembers,\n            \"call.notification\": (e)=>{\n                this.updateFromCallResponse(e.call);\n                this.setMembers(e.members);\n            },\n            \"call.permissions_updated\": this.updateOwnCapabilities,\n            \"call.reaction_new\": this.updateParticipantReaction,\n            \"call.recording_started\": ()=>this.setCurrentValue(this.recordingSubject, true),\n            \"call.recording_stopped\": ()=>this.setCurrentValue(this.recordingSubject, false),\n            \"call.rejected\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.ring\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.session_ended\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.session_participant_joined\": this.updateFromSessionParticipantJoined,\n            \"call.session_participant_left\": this.updateFromSessionParticipantLeft,\n            \"call.session_started\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.unblocked_user\": this.unblockUser,\n            \"call.updated\": (e)=>this.updateFromCallResponse(e.call)\n        };\n    }\n    /**\n     * The server-side counted number of participants connected to the current call.\n     * This number includes the anonymous participants as well.\n     */ get participantCount() {\n        return this.getCurrentValue(this.participantCount$);\n    }\n    /**\n     * The time the call session actually started.\n     * Useful for displaying the call duration.\n     */ get startedAt() {\n        return this.getCurrentValue(this.startedAt$);\n    }\n    /**\n     * The server-side counted number of anonymous participants connected to the current call.\n     * This number includes the anonymous participants as well.\n     */ get anonymousParticipantCount() {\n        return this.getCurrentValue(this.anonymousParticipantCount$);\n    }\n    /**\n     * The list of participants in the current call.\n     */ get participants() {\n        return this.getCurrentValue(this.participants$);\n    }\n    /**\n     * The local participant in the current call.\n     */ get localParticipant() {\n        return this.getCurrentValue(this.localParticipant$);\n    }\n    /**\n     * The list of remote participants in the current call.\n     */ get remoteParticipants() {\n        return this.getCurrentValue(this.remoteParticipants$);\n    }\n    /**\n     * The dominant speaker in the current call.\n     */ get dominantSpeaker() {\n        return this.getCurrentValue(this.dominantSpeaker$);\n    }\n    /**\n     * The list of pinned participants in the current call.\n     */ get pinnedParticipants() {\n        return this.getCurrentValue(this.pinnedParticipants$);\n    }\n    /**\n     * Tell if there is an ongoing screen share in this call.\n     */ get hasOngoingScreenShare() {\n        return this.getCurrentValue(this.hasOngoingScreenShare$);\n    }\n    /**\n     * The calling state.\n     */ get callingState() {\n        return this.getCurrentValue(this.callingState$);\n    }\n    /**\n     * The call stats report.\n     */ get callStatsReport() {\n        return this.getCurrentValue(this.callStatsReport$);\n    }\n    /**\n     * The members of the current call.\n     */ get members() {\n        return this.getCurrentValue(this.members$);\n    }\n    /**\n     * The capabilities of the current user for the current call.\n     */ get ownCapabilities() {\n        return this.getCurrentValue(this.ownCapabilities$);\n    }\n    /**\n     * The backstage state.\n     */ get backstage() {\n        return this.getCurrentValue(this.backstage$);\n    }\n    /**\n     * Will provide the list of blocked user IDs.\n     */ get blockedUserIds() {\n        return this.getCurrentValue(this.blockedUserIds$);\n    }\n    /**\n     * Will provide the time when this call has been created.\n     */ get createdAt() {\n        return this.getCurrentValue(this.createdAt$);\n    }\n    /**\n     * Will provide the time when this call has been ended.\n     */ get endedAt() {\n        return this.getCurrentValue(this.endedAt$);\n    }\n    /**\n     * Will provide the time when this call has been scheduled to start.\n     */ get startsAt() {\n        return this.getCurrentValue(this.startsAt$);\n    }\n    /**\n     * Will provide the time when this call has been updated.\n     */ get updatedAt() {\n        return this.getCurrentValue(this.updatedAt$);\n    }\n    /**\n     * Will provide the user who created this call.\n     */ get createdBy() {\n        return this.getCurrentValue(this.createdBy$);\n    }\n    /**\n     * Will provide the custom data of this call.\n     */ get custom() {\n        return this.getCurrentValue(this.custom$);\n    }\n    /**\n     * Will provide the egress data of this call.\n     */ get egress() {\n        return this.getCurrentValue(this.egress$);\n    }\n    /**\n     * Will provide the ingress data of this call.\n     */ get ingress() {\n        return this.getCurrentValue(this.ingress$);\n    }\n    /**\n     * Will provide the recording state of this call.\n     */ get recording() {\n        return this.getCurrentValue(this.recording$);\n    }\n    /**\n     * Will provide the session data of this call.\n     */ get session() {\n        return this.getCurrentValue(this.session$);\n    }\n    /**\n     * Will provide the settings of this call.\n     */ get settings() {\n        return this.getCurrentValue(this.settings$);\n    }\n    /**\n     * Will provide the transcribing state of this call.\n     */ get transcribing() {\n        return this.getCurrentValue(this.transcribing$);\n    }\n    /**\n     * Will provide the user who ended this call.\n     */ get endedBy() {\n        return this.getCurrentValue(this.endedBy$);\n    }\n    /**\n     * Will provide the thumbnails of this call, if enabled in the call settings.\n     */ get thumbnails() {\n        return this.getCurrentValue(this.thumbnails$);\n    }\n}\nclass StreamVideoWriteableStateStore {\n    constructor(){\n        /**\n         * A store keeping data of a successfully connected user over WS to the coordinator server.\n         */ this.connectedUserSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * A list of {@link Call} objects created/tracked by this client.\n         */ this.callsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        /**\n         * Sets the currently connected user.\n         *\n         * @internal\n         * @param user the user to set as connected.\n         */ this.setConnectedUser = (user)=>{\n            return this.setCurrentValue(this.connectedUserSubject, user);\n        };\n        /**\n         * Sets the list of {@link Call} objects created/tracked by this client.\n         * @param calls\n         */ this.setCalls = (calls)=>{\n            return this.setCurrentValue(this.callsSubject, calls);\n        };\n        /**\n         * Adds a {@link Call} object to the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param call the call to add.\n         */ this.registerCall = (call)=>{\n            if (!this.calls.find((c)=>c.cid === call.cid)) {\n                this.setCalls((calls)=>[\n                        ...calls,\n                        call\n                    ]);\n            }\n        };\n        /**\n         * Removes a {@link Call} object from the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param call the call to remove\n         */ this.unregisterCall = (call)=>{\n            return this.setCalls((calls)=>calls.filter((c)=>c !== call));\n        };\n        /**\n         * Finds a {@link Call} object in the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param type the type of call to find.\n         * @param id the id of the call to find.\n         */ this.findCall = (type, id)=>{\n            return this.calls.find((c)=>c.type === type && c.id === id);\n        };\n        this.connectedUserSubject.subscribe(async (user)=>{\n            // leave all calls when the user disconnects.\n            if (!user) {\n                const logger = getLogger([\n                    \"client-state\"\n                ]);\n                for (const call of this.calls){\n                    if (call.state.callingState === CallingState.LEFT) continue;\n                    logger(\"info\", `User disconnected, leaving call: ${call.cid}`);\n                    await call.leave({\n                        reason: \"client.disconnectUser() called\"\n                    }).catch((err)=>{\n                        logger(\"error\", `Error leaving call: ${call.cid}`, err);\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * The currently connected user.\n     */ get connectedUser() {\n        return this.getCurrentValue(this.connectedUserSubject);\n    }\n    /**\n     * A list of {@link Call} objects created/tracked by this client.\n     */ get calls() {\n        return this.getCurrentValue(this.callsSubject);\n    }\n}\n/**\n * A reactive store that exposes state variables in a reactive manner.\n * You can subscribe to changes of the different state variables.\n * This central store contains all the state variables related to [`StreamVideoClient`](./StreamVideClient.md) and [`Call`](./Call.md).\n */ class StreamVideoReadOnlyStateStore {\n    constructor(store){\n        /**\n         * This method allows you the get the current value of a state variable.\n         *\n         * @param observable the observable to get the current value of.\n         * @returns the current value of the observable.\n         */ this.getCurrentValue = getCurrentValue;\n        // convert and expose subjects as observables\n        this.connectedUser$ = store.connectedUserSubject.asObservable();\n        this.calls$ = store.callsSubject.asObservable();\n    }\n    /**\n     * The current user connected over WS to the backend.\n     */ get connectedUser() {\n        return getCurrentValue(this.connectedUser$);\n    }\n    /**\n     * A list of {@link Call} objects created/tracked by this client.\n     */ get calls() {\n        return getCurrentValue(this.calls$);\n    }\n}\nconst getRtpMap = (line)=>{\n    // Example: a=rtpmap:110 opus/48000/2\n    const rtpRegex = /^a=rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/;\n    // The first captured group is the payload type number, the second captured group is the encoding name, the third captured group is the clock rate, and the fourth captured group is any additional parameters.\n    const rtpMatch = rtpRegex.exec(line);\n    if (rtpMatch) {\n        return {\n            original: rtpMatch[0],\n            payload: rtpMatch[1],\n            codec: rtpMatch[2]\n        };\n    }\n};\nconst getFmtp = (line)=>{\n    // Example: a=fmtp:111 minptime=10; useinbandfec=1\n    const fmtpRegex = /^a=fmtp:(\\d*) (.*)/;\n    const fmtpMatch = fmtpRegex.exec(line);\n    // The first captured group is the payload type number, the second captured group is any additional parameters.\n    if (fmtpMatch) {\n        return {\n            original: fmtpMatch[0],\n            payload: fmtpMatch[1],\n            config: fmtpMatch[2]\n        };\n    }\n};\n/**\n * gets the media section for the specified media type.\n * The media section contains the media type, port, codec, and payload type.\n * Example: m=video 9 UDP/TLS/RTP/SAVPF 100 101 96 97 35 36 102 125 127\n */ const getMedia = (line, mediaType)=>{\n    const regex = new RegExp(`(m=${mediaType} \\\\d+ [\\\\w/]+) ([\\\\d\\\\s]+)`);\n    const match = regex.exec(line);\n    if (match) {\n        return {\n            original: match[0],\n            mediaWithPorts: match[1],\n            codecOrder: match[2]\n        };\n    }\n};\nconst getMediaSection = (sdp, mediaType)=>{\n    let media;\n    const rtpMap = [];\n    const fmtp = [];\n    let isTheRequiredMediaSection = false;\n    sdp.split(/(\\r\\n|\\r|\\n)/).forEach((line)=>{\n        const isValidLine = /^([a-z])=(.*)/.test(line);\n        if (!isValidLine) return;\n        /*\n          NOTE: according to https://www.rfc-editor.org/rfc/rfc8866.pdf\n          Each media description starts with an \"m=\" line and continues to the next media description or the end of the whole session description, whichever comes first\n        */ const type = line[0];\n        if (type === \"m\") {\n            const _media = getMedia(line, mediaType);\n            isTheRequiredMediaSection = !!_media;\n            if (_media) {\n                media = _media;\n            }\n        } else if (isTheRequiredMediaSection && type === \"a\") {\n            const rtpMapLine = getRtpMap(line);\n            const fmtpLine = getFmtp(line);\n            if (rtpMapLine) {\n                rtpMap.push(rtpMapLine);\n            } else if (fmtpLine) {\n                fmtp.push(fmtpLine);\n            }\n        }\n    });\n    if (media) {\n        return {\n            media,\n            rtpMap,\n            fmtp\n        };\n    }\n};\n/**\n * Gets the fmtp line corresponding to opus\n */ const getOpusFmtp = (sdp)=>{\n    const section = getMediaSection(sdp, \"audio\");\n    const rtpMap = section?.rtpMap.find((r)=>r.codec.toLowerCase() === \"opus\");\n    const codecId = rtpMap?.payload;\n    if (codecId) {\n        return section?.fmtp.find((f)=>f.payload === codecId);\n    }\n};\n/**\n * Returns an SDP with DTX enabled or disabled.\n */ const toggleDtx = (sdp, enable)=>{\n    const opusFmtp = getOpusFmtp(sdp);\n    if (opusFmtp) {\n        const matchDtx = /usedtx=(\\d)/.exec(opusFmtp.config);\n        const requiredDtxConfig = `usedtx=${enable ? \"1\" : \"0\"}`;\n        if (matchDtx) {\n            const newFmtp = opusFmtp.original.replace(/usedtx=(\\d)/, requiredDtxConfig);\n            return sdp.replace(opusFmtp.original, newFmtp);\n        } else {\n            const newFmtp = `${opusFmtp.original};${requiredDtxConfig}`;\n            return sdp.replace(opusFmtp.original, newFmtp);\n        }\n    }\n    return sdp;\n};\n/**\n * Enables high-quality audio through SDP munging for the given trackMid.\n *\n * @param sdp the SDP to munge.\n * @param trackMid the trackMid.\n * @param maxBitrate the max bitrate to set.\n */ const enableHighQualityAudio = (sdp, trackMid, maxBitrate = 510000)=>{\n    maxBitrate = Math.max(Math.min(maxBitrate, 510000), 96000);\n    const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);\n    const audioMedia = parsedSdp.media.find((m)=>m.type === \"audio\" && String(m.mid) === trackMid);\n    if (!audioMedia) return sdp;\n    const opusRtp = audioMedia.rtp.find((r)=>r.codec === \"opus\");\n    if (!opusRtp) return sdp;\n    const opusFmtp = audioMedia.fmtp.find((f)=>f.payload === opusRtp.payload);\n    if (!opusFmtp) return sdp;\n    // enable stereo, if not already enabled\n    if (opusFmtp.config.match(/stereo=(\\d)/)) {\n        opusFmtp.config = opusFmtp.config.replace(/stereo=(\\d)/, \"stereo=1\");\n    } else {\n        opusFmtp.config = `${opusFmtp.config};stereo=1`;\n    }\n    // set maxaveragebitrate, to the given value\n    if (opusFmtp.config.match(/maxaveragebitrate=(\\d*)/)) {\n        opusFmtp.config = opusFmtp.config.replace(/maxaveragebitrate=(\\d*)/, `maxaveragebitrate=${maxBitrate}`);\n    } else {\n        opusFmtp.config = `${opusFmtp.config};maxaveragebitrate=${maxBitrate}`;\n    }\n    return sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(parsedSdp);\n};\nconst logger$3 = getLogger([\n    \"Publisher\"\n]);\n/**\n * The `Publisher` is responsible for publishing/unpublishing media streams to/from the SFU\n * @internal\n */ class Publisher {\n    /**\n     * Returns the current connection configuration.\n     *\n     * @internal\n     */ get connectionConfiguration() {\n        if (this.pc.getConfiguration) return this.pc.getConfiguration();\n        return this._connectionConfiguration;\n    }\n    /**\n     * Constructs a new `Publisher` instance.\n     *\n     * @param connectionConfig the connection configuration to use.\n     * @param sfuClient the SFU client to use.\n     * @param state the call state to use.\n     * @param dispatcher the dispatcher to use.\n     * @param isDtxEnabled whether DTX is enabled.\n     * @param isRedEnabled whether RED is enabled.\n     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE once connection goes to `disconnected` state.\n     */ constructor({ connectionConfig, sfuClient, dispatcher, state, isDtxEnabled, isRedEnabled, iceRestartDelay = 2500 }){\n        this.transceiverRegistry = {\n            [TrackType.AUDIO]: undefined,\n            [TrackType.VIDEO]: undefined,\n            [TrackType.SCREEN_SHARE]: undefined,\n            [TrackType.SCREEN_SHARE_AUDIO]: undefined,\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.publishOptionsPerTrackType = new Map();\n        /**\n         * An array maintaining the order how transceivers were added to the peer connection.\n         * This is needed because some browsers (Firefox) don't reliably report\n         * trackId and `mid` parameters.\n         *\n         * @private\n         */ this.transceiverInitOrder = [];\n        this.trackKindMapping = {\n            [TrackType.AUDIO]: \"audio\",\n            [TrackType.VIDEO]: \"video\",\n            [TrackType.SCREEN_SHARE]: \"video\",\n            [TrackType.SCREEN_SHARE_AUDIO]: \"audio\",\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.trackLayersCache = {\n            [TrackType.AUDIO]: undefined,\n            [TrackType.VIDEO]: undefined,\n            [TrackType.SCREEN_SHARE]: undefined,\n            [TrackType.SCREEN_SHARE_AUDIO]: undefined,\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.isIceRestarting = false;\n        this.createPeerConnection = (connectionConfig)=>{\n            const pc = new RTCPeerConnection(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            pc.addEventListener(\"icecandidate\", this.onIceCandidate);\n            pc.addEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n            pc.addEventListener(\"icecandidateerror\", this.onIceCandidateError);\n            pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChange);\n            pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n            pc.addEventListener(\"signalingstatechange\", this.onSignalingStateChange);\n            return pc;\n        };\n        /**\n         * Closes the publisher PeerConnection and cleans up the resources.\n         */ this.close = ({ stopTracks = true } = {})=>{\n            if (stopTracks) {\n                this.stopPublishing();\n                Object.keys(this.transceiverRegistry).forEach((trackType)=>{\n                    // @ts-ignore\n                    this.transceiverRegistry[trackType] = undefined;\n                });\n                Object.keys(this.trackLayersCache).forEach((trackType)=>{\n                    // @ts-ignore\n                    this.trackLayersCache[trackType] = undefined;\n                });\n            }\n            clearTimeout(this.iceRestartTimeout);\n            this.unsubscribeOnIceRestart();\n            this.pc.removeEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n            this.pc.close();\n        };\n        /**\n         * Starts publishing the given track of the given media stream.\n         *\n         * Consecutive calls to this method will replace the stream.\n         * The previous stream will be stopped.\n         *\n         * @param mediaStream the media stream to publish.\n         * @param track the track to publish.\n         * @param trackType the track type to publish.\n         * @param opts the optional publish options to use.\n         */ this.publishStream = async (mediaStream, track, trackType, opts = {})=>{\n            if (track.readyState === \"ended\") {\n                throw new Error(`Can't publish a track that has ended already.`);\n            }\n            let transceiver = this.pc.getTransceivers().find((t)=>t === this.transceiverRegistry[trackType] && t.sender.track && t.sender.track?.kind === this.trackKindMapping[trackType]);\n            /**\n             * An event handler which listens for the 'ended' event on the track.\n             * Once the track has ended, it will notify the SFU and update the state.\n             */ const handleTrackEnded = async ()=>{\n                logger$3(\"info\", `Track ${TrackType[trackType]} has ended, notifying the SFU`);\n                await this.notifyTrackMuteStateChanged(mediaStream, trackType, true);\n                // clean-up, this event listener needs to run only once.\n                track.removeEventListener(\"ended\", handleTrackEnded);\n            };\n            if (!transceiver) {\n                const { settings } = this.state;\n                const targetResolution = settings?.video.target_resolution;\n                const videoEncodings = trackType === TrackType.VIDEO ? findOptimalVideoLayers(track, targetResolution) : trackType === TrackType.SCREEN_SHARE ? findOptimalScreenSharingLayers(track, opts.screenShareSettings) : undefined;\n                let preferredCodec = opts.preferredCodec;\n                if (!preferredCodec && trackType === TrackType.VIDEO) {\n                    if (isReactNative()) {\n                        const osName = getOSInfo()?.name.toLowerCase();\n                        if (osName === \"ipados\") {\n                            // in ipads it was noticed that if vp8 codec is used\n                            // then the bytes sent is 0 in the outbound-rtp\n                            // so we are forcing h264 codec for ipads\n                            preferredCodec = \"H264\";\n                        } else if (osName === \"android\") {\n                            preferredCodec = \"VP8\";\n                        }\n                    }\n                }\n                const codecPreferences = this.getCodecPreferences(trackType, preferredCodec);\n                // listen for 'ended' event on the track as it might be ended abruptly\n                // by an external factor as permission revokes, device disconnected, etc.\n                // keep in mind that `track.stop()` doesn't trigger this event.\n                track.addEventListener(\"ended\", handleTrackEnded);\n                if (!track.enabled) {\n                    track.enabled = true;\n                }\n                transceiver = this.pc.addTransceiver(track, {\n                    direction: \"sendonly\",\n                    streams: trackType === TrackType.VIDEO || trackType === TrackType.SCREEN_SHARE ? [\n                        mediaStream\n                    ] : undefined,\n                    sendEncodings: videoEncodings\n                });\n                logger$3(\"debug\", `Added ${TrackType[trackType]} transceiver`);\n                this.transceiverInitOrder.push(trackType);\n                this.transceiverRegistry[trackType] = transceiver;\n                this.publishOptionsPerTrackType.set(trackType, opts);\n                if (\"setCodecPreferences\" in transceiver && codecPreferences) {\n                    logger$3(\"info\", `Setting ${TrackType[trackType]} codec preferences`, codecPreferences);\n                    transceiver.setCodecPreferences(codecPreferences);\n                }\n            } else {\n                const previousTrack = transceiver.sender.track;\n                // don't stop the track if we are re-publishing the same track\n                if (previousTrack && previousTrack !== track) {\n                    previousTrack.stop();\n                    previousTrack.removeEventListener(\"ended\", handleTrackEnded);\n                    track.addEventListener(\"ended\", handleTrackEnded);\n                }\n                if (!track.enabled) {\n                    track.enabled = true;\n                }\n                await transceiver.sender.replaceTrack(track);\n            }\n            await this.notifyTrackMuteStateChanged(mediaStream, trackType, false);\n        };\n        /**\n         * Stops publishing the given track type to the SFU, if it is currently being published.\n         * Underlying track will be stopped and removed from the publisher.\n         * @param trackType the track type to unpublish.\n         * @param stopTrack specifies whether track should be stopped or just disabled\n         */ this.unpublishStream = async (trackType, stopTrack)=>{\n            const transceiver = this.pc.getTransceivers().find((t)=>t === this.transceiverRegistry[trackType] && t.sender.track);\n            if (transceiver && transceiver.sender.track && (stopTrack ? transceiver.sender.track.readyState === \"live\" : transceiver.sender.track.enabled)) {\n                stopTrack ? transceiver.sender.track.stop() : transceiver.sender.track.enabled = false;\n                // We don't need to notify SFU if unpublishing in response to remote soft mute\n                if (this.state.localParticipant?.publishedTracks.includes(trackType)) {\n                    await this.notifyTrackMuteStateChanged(undefined, trackType, true);\n                }\n            }\n        };\n        /**\n         * Returns true if the given track type is currently being published to the SFU.\n         *\n         * @param trackType the track type to check.\n         */ this.isPublishing = (trackType)=>{\n            const transceiverForTrackType = this.transceiverRegistry[trackType];\n            if (transceiverForTrackType && transceiverForTrackType.sender) {\n                const sender = transceiverForTrackType.sender;\n                return !!sender.track && sender.track.readyState === \"live\" && sender.track.enabled;\n            }\n            return false;\n        };\n        /**\n         * Returns true if the given track type is currently live\n         *\n         * @param trackType the track type to check.\n         */ this.isLive = (trackType)=>{\n            const transceiverForTrackType = this.transceiverRegistry[trackType];\n            if (transceiverForTrackType && transceiverForTrackType.sender) {\n                const sender = transceiverForTrackType.sender;\n                return !!sender.track && sender.track.readyState === \"live\";\n            }\n            return false;\n        };\n        this.notifyTrackMuteStateChanged = async (mediaStream, trackType, isMuted)=>{\n            await this.sfuClient.updateMuteState(trackType, isMuted);\n            const audioOrVideoOrScreenShareStream = trackTypeToParticipantStreamKey(trackType);\n            if (isMuted) {\n                this.state.updateParticipant(this.sfuClient.sessionId, (p)=>({\n                        publishedTracks: p.publishedTracks.filter((t)=>t !== trackType),\n                        [audioOrVideoOrScreenShareStream]: undefined\n                    }));\n            } else {\n                this.state.updateParticipant(this.sfuClient.sessionId, (p)=>{\n                    return {\n                        publishedTracks: p.publishedTracks.includes(trackType) ? p.publishedTracks : [\n                            ...p.publishedTracks,\n                            trackType\n                        ],\n                        [audioOrVideoOrScreenShareStream]: mediaStream\n                    };\n                });\n            }\n        };\n        /**\n         * Stops publishing all tracks and stop all tracks.\n         */ this.stopPublishing = ()=>{\n            logger$3(\"debug\", \"Stopping publishing all tracks\");\n            this.pc.getSenders().forEach((s)=>{\n                s.track?.stop();\n                if (this.pc.signalingState !== \"closed\") {\n                    this.pc.removeTrack(s);\n                }\n            });\n        };\n        this.updateVideoPublishQuality = async (enabledLayers)=>{\n            logger$3(\"info\", \"Update publish quality, requested layers by SFU:\", enabledLayers);\n            const videoSender = this.transceiverRegistry[TrackType.VIDEO]?.sender;\n            if (!videoSender) {\n                logger$3(\"warn\", \"Update publish quality, no video sender found.\");\n                return;\n            }\n            const params = videoSender.getParameters();\n            if (params.encodings.length === 0) {\n                logger$3(\"warn\", \"Update publish quality, No suitable video encoding quality found\");\n                return;\n            }\n            let changed = false;\n            let enabledRids = enabledLayers.filter((ly)=>ly.active).map((ly)=>ly.name);\n            params.encodings.forEach((enc)=>{\n                // flip 'active' flag only when necessary\n                const shouldEnable = enabledRids.includes(enc.rid);\n                if (shouldEnable !== enc.active) {\n                    enc.active = shouldEnable;\n                    changed = true;\n                }\n                if (shouldEnable) {\n                    let layer = enabledLayers.find((vls)=>vls.name === enc.rid);\n                    if (layer !== undefined) {\n                        if (layer.scaleResolutionDownBy >= 1 && layer.scaleResolutionDownBy !== enc.scaleResolutionDownBy) {\n                            logger$3(\"debug\", \"[dynascale]: setting scaleResolutionDownBy from server\", \"layer\", layer.name, \"scale-resolution-down-by\", layer.scaleResolutionDownBy);\n                            enc.scaleResolutionDownBy = layer.scaleResolutionDownBy;\n                            changed = true;\n                        }\n                        if (layer.maxBitrate > 0 && layer.maxBitrate !== enc.maxBitrate) {\n                            logger$3(\"debug\", \"[dynascale] setting max-bitrate from the server\", \"layer\", layer.name, \"max-bitrate\", layer.maxBitrate);\n                            enc.maxBitrate = layer.maxBitrate;\n                            changed = true;\n                        }\n                        if (layer.maxFramerate > 0 && layer.maxFramerate !== enc.maxFramerate) {\n                            logger$3(\"debug\", \"[dynascale]: setting maxFramerate from server\", \"layer\", layer.name, \"max-framerate\", layer.maxFramerate);\n                            enc.maxFramerate = layer.maxFramerate;\n                            changed = true;\n                        }\n                    }\n                }\n            });\n            const activeLayers = params.encodings.filter((e)=>e.active);\n            if (changed) {\n                await videoSender.setParameters(params);\n                logger$3(\"info\", `Update publish quality, enabled rids: `, activeLayers);\n            } else {\n                logger$3(\"info\", `Update publish quality, no change: `, activeLayers);\n            }\n        };\n        /**\n         * Returns the result of the `RTCPeerConnection.getStats()` method\n         * @param selector\n         * @returns\n         */ this.getStats = (selector)=>{\n            return this.pc.getStats(selector);\n        };\n        this.getCodecPreferences = (trackType, preferredCodec)=>{\n            if (trackType === TrackType.VIDEO) {\n                return getPreferredCodecs(\"video\", preferredCodec || \"vp8\");\n            }\n            if (trackType === TrackType.AUDIO) {\n                const defaultAudioCodec = this.isRedEnabled ? \"red\" : \"opus\";\n                const codecToRemove = !this.isRedEnabled ? \"red\" : undefined;\n                return getPreferredCodecs(\"audio\", preferredCodec ?? defaultAudioCodec, codecToRemove);\n            }\n        };\n        this.onIceCandidate = async (e)=>{\n            const { candidate } = e;\n            if (!candidate) {\n                logger$3(\"debug\", \"null ice candidate\");\n                return;\n            }\n            await this.sfuClient.iceTrickle({\n                iceCandidate: getIceCandidate(candidate),\n                peerType: PeerType.PUBLISHER_UNSPECIFIED\n            });\n        };\n        /**\n         * Sets the SFU client to use.\n         *\n         * @param sfuClient the SFU client to use.\n         */ this.setSfuClient = (sfuClient)=>{\n            this.sfuClient = sfuClient;\n        };\n        /**\n         * Performs a migration of this publisher instance to a new SFU.\n         *\n         * Initiates a new `iceRestart` offer/answer exchange with the new SFU.\n         *\n         * @param sfuClient the new SFU client to migrate to.\n         * @param connectionConfig the new connection configuration to use.\n         */ this.migrateTo = async (sfuClient, connectionConfig)=>{\n            this.sfuClient = sfuClient;\n            this.pc.setConfiguration(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            const shouldRestartIce = this.pc.iceConnectionState === \"connected\";\n            if (shouldRestartIce) {\n                // negotiate only if there are tracks to publish\n                await this.negotiate({\n                    iceRestart: true\n                });\n            }\n        };\n        /**\n         * Restarts the ICE connection and renegotiates with the SFU.\n         */ this.restartIce = async ()=>{\n            logger$3(\"debug\", \"Restarting ICE connection\");\n            const signalingState = this.pc.signalingState;\n            if (this.isIceRestarting || signalingState === \"have-local-offer\") {\n                logger$3(\"debug\", \"ICE restart is already in progress\");\n                return;\n            }\n            await this.negotiate({\n                iceRestart: true\n            });\n        };\n        this.onNegotiationNeeded = async ()=>{\n            await this.negotiate();\n        };\n        /**\n         * Initiates a new offer/answer exchange with the currently connected SFU.\n         *\n         * @param options the optional offer options to use.\n         */ this.negotiate = async (options)=>{\n            this.isIceRestarting = options?.iceRestart ?? false;\n            const offer = await this.pc.createOffer(options);\n            let sdp = this.mungeCodecs(offer.sdp);\n            if (sdp && this.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {\n                const transceiver = this.transceiverRegistry[TrackType.SCREEN_SHARE_AUDIO];\n                if (transceiver && transceiver.sender.track) {\n                    const mid = transceiver.mid ?? this.extractMid(sdp, transceiver.sender.track, TrackType.SCREEN_SHARE_AUDIO);\n                    sdp = enableHighQualityAudio(sdp, mid);\n                }\n            }\n            // set the munged SDP back to the offer\n            offer.sdp = sdp;\n            const trackInfos = this.getCurrentTrackInfos(offer.sdp);\n            if (trackInfos.length === 0) {\n                throw new Error(`Can't initiate negotiation without announcing any tracks`);\n            }\n            await this.pc.setLocalDescription(offer);\n            const { response } = await this.sfuClient.setPublisher({\n                sdp: offer.sdp || \"\",\n                tracks: trackInfos\n            });\n            try {\n                await this.pc.setRemoteDescription({\n                    type: \"answer\",\n                    sdp: response.sdp\n                });\n            } catch (e) {\n                logger$3(\"error\", `setRemoteDescription error`, {\n                    sdp: response.sdp,\n                    error: e\n                });\n            }\n            this.isIceRestarting = false;\n            this.sfuClient.iceTrickleBuffer.publisherCandidates.subscribe(async (candidate)=>{\n                try {\n                    const iceCandidate = JSON.parse(candidate.iceCandidate);\n                    await this.pc.addIceCandidate(iceCandidate);\n                } catch (e) {\n                    logger$3(\"warn\", `ICE candidate error`, [\n                        e,\n                        candidate\n                    ]);\n                }\n            });\n        };\n        this.mungeCodecs = (sdp)=>{\n            if (sdp) {\n                sdp = toggleDtx(sdp, this.isDtxEnabled);\n            }\n            return sdp;\n        };\n        this.extractMid = (sdp, track, trackType)=>{\n            if (!sdp) {\n                logger$3(\"warn\", \"No SDP found. Returning empty mid\");\n                return \"\";\n            }\n            logger$3(\"debug\", `No 'mid' found for track. Trying to find it from the Offer SDP`);\n            const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);\n            const media = parsedSdp.media.find((m)=>{\n                return m.type === track.kind && // if `msid` is not present, we assume that the track is the first one\n                (m.msid?.includes(track.id) ?? true);\n            });\n            if (typeof media?.mid === \"undefined\") {\n                logger$3(\"debug\", `No mid found in SDP for track type ${track.kind} and id ${track.id}. Attempting to find a heuristic mid`);\n                const heuristicMid = this.transceiverInitOrder.indexOf(trackType);\n                if (heuristicMid !== -1) {\n                    return String(heuristicMid);\n                }\n                logger$3(\"debug\", \"No heuristic mid found. Returning empty mid\");\n                return \"\";\n            }\n            return String(media.mid);\n        };\n        this.getCurrentTrackInfos = (sdp)=>{\n            sdp = sdp || this.pc.localDescription?.sdp;\n            const { settings } = this.state;\n            const targetResolution = settings?.video.target_resolution;\n            return this.pc.getTransceivers().filter((t)=>t.direction === \"sendonly\" && t.sender.track).map((transceiver)=>{\n                const trackType = Number(Object.keys(this.transceiverRegistry).find((key)=>this.transceiverRegistry[key] === transceiver));\n                const track = transceiver.sender.track;\n                let optimalLayers;\n                if (track.readyState === \"live\") {\n                    const publishOpts = this.publishOptionsPerTrackType.get(trackType);\n                    optimalLayers = trackType === TrackType.VIDEO ? findOptimalVideoLayers(track, targetResolution) : trackType === TrackType.SCREEN_SHARE ? findOptimalScreenSharingLayers(track, publishOpts?.screenShareSettings) : [];\n                    this.trackLayersCache[trackType] = optimalLayers;\n                } else {\n                    // we report the last known optimal layers for ended tracks\n                    optimalLayers = this.trackLayersCache[trackType] || [];\n                    logger$3(\"debug\", `Track ${TrackType[trackType]} is ended. Announcing last known optimal layers`, optimalLayers);\n                }\n                const layers = optimalLayers.map((optimalLayer)=>({\n                        rid: optimalLayer.rid || \"\",\n                        bitrate: optimalLayer.maxBitrate || 0,\n                        fps: optimalLayer.maxFramerate || 0,\n                        quality: this.ridToVideoQuality(optimalLayer.rid || \"\"),\n                        videoDimension: {\n                            width: optimalLayer.width,\n                            height: optimalLayer.height\n                        }\n                    }));\n                const isAudioTrack = [\n                    TrackType.AUDIO,\n                    TrackType.SCREEN_SHARE_AUDIO\n                ].includes(trackType);\n                const trackSettings = track.getSettings();\n                const isStereo = isAudioTrack && trackSettings.channelCount === 2;\n                return {\n                    trackId: track.id,\n                    layers: layers,\n                    trackType,\n                    mid: transceiver.mid ?? this.extractMid(sdp, track, trackType),\n                    stereo: isStereo,\n                    dtx: isAudioTrack && this.isDtxEnabled,\n                    red: isAudioTrack && this.isRedEnabled\n                };\n            });\n        };\n        this.onIceCandidateError = (e)=>{\n            const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;\n            const iceState = this.pc.iceConnectionState;\n            const logLevel = iceState === \"connected\" || iceState === \"checking\" ? \"debug\" : \"warn\";\n            logger$3(logLevel, `ICE Candidate error`, errorMessage);\n        };\n        this.onIceConnectionStateChange = ()=>{\n            const state = this.pc.iceConnectionState;\n            logger$3(\"debug\", `ICE Connection state changed to`, state);\n            const hasNetworkConnection = this.state.callingState !== CallingState.OFFLINE;\n            if (state === \"failed\") {\n                logger$3(\"warn\", `Attempting to restart ICE`);\n                this.restartIce().catch((e)=>{\n                    logger$3(\"error\", `ICE restart error`, e);\n                });\n            } else if (state === \"disconnected\" && hasNetworkConnection) {\n                // when in `disconnected` state, the browser may recover automatically,\n                // hence, we delay the ICE restart\n                logger$3(\"warn\", `Scheduling ICE restart in ${this.iceRestartDelay} ms.`);\n                this.iceRestartTimeout = setTimeout(()=>{\n                    // check if the state is still `disconnected` or `failed`\n                    // as the connection may have recovered (or failed) in the meantime\n                    if (this.pc.iceConnectionState === \"disconnected\" || this.pc.iceConnectionState === \"failed\") {\n                        this.restartIce().catch((e)=>{\n                            logger$3(\"error\", `ICE restart error`, e);\n                        });\n                    } else {\n                        logger$3(\"debug\", `Scheduled ICE restart: connection recovered, canceled.`);\n                    }\n                }, this.iceRestartDelay);\n            }\n        };\n        this.onIceGatheringStateChange = ()=>{\n            logger$3(\"debug\", `ICE Gathering State`, this.pc.iceGatheringState);\n        };\n        this.onSignalingStateChange = ()=>{\n            logger$3(\"debug\", `Signaling state changed`, this.pc.signalingState);\n        };\n        this.ridToVideoQuality = (rid)=>{\n            return rid === \"q\" ? VideoQuality.LOW_UNSPECIFIED : rid === \"h\" ? VideoQuality.MID : VideoQuality.HIGH; // default to HIGH\n        };\n        this.pc = this.createPeerConnection(connectionConfig);\n        this.sfuClient = sfuClient;\n        this.state = state;\n        this.isDtxEnabled = isDtxEnabled;\n        this.isRedEnabled = isRedEnabled;\n        this.iceRestartDelay = iceRestartDelay;\n        this.unsubscribeOnIceRestart = dispatcher.on(\"iceRestart\", async (iceRestart)=>{\n            if (iceRestart.peerType !== PeerType.PUBLISHER_UNSPECIFIED) return;\n            await this.restartIce();\n        });\n    }\n}\nconst logger$2 = getLogger([\n    \"Subscriber\"\n]);\n/**\n * A wrapper around the `RTCPeerConnection` that handles the incoming\n * media streams from the SFU.\n */ class Subscriber {\n    /**\n     * Returns the current connection configuration.\n     *\n     * @internal\n     */ get connectionConfiguration() {\n        if (this.pc.getConfiguration) return this.pc.getConfiguration();\n        return this._connectionConfiguration;\n    }\n    /**\n     * Constructs a new `Subscriber` instance.\n     *\n     * @param sfuClient the SFU client to use.\n     * @param dispatcher the dispatcher to use.\n     * @param state the state of the call.\n     * @param connectionConfig the connection configuration to use.\n     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE when connection goes to `disconnected` state.\n     */ constructor({ sfuClient, dispatcher, state, connectionConfig, iceRestartDelay = 2500 }){\n        this.isIceRestarting = false;\n        /**\n         * Creates a new `RTCPeerConnection` instance with the given configuration.\n         *\n         * @param connectionConfig the connection configuration to use.\n         */ this.createPeerConnection = (connectionConfig)=>{\n            const pc = new RTCPeerConnection(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            pc.addEventListener(\"icecandidate\", this.onIceCandidate);\n            pc.addEventListener(\"track\", this.handleOnTrack);\n            pc.addEventListener(\"icecandidateerror\", this.onIceCandidateError);\n            pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChange);\n            pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n            return pc;\n        };\n        /**\n         * Closes the `RTCPeerConnection` and unsubscribes from the dispatcher.\n         */ this.close = ()=>{\n            clearTimeout(this.iceRestartTimeout);\n            this.unregisterOnSubscriberOffer();\n            this.unregisterOnIceRestart();\n            this.pc.close();\n        };\n        /**\n         * Returns the result of the `RTCPeerConnection.getStats()` method\n         * @param selector\n         * @returns\n         */ this.getStats = (selector)=>{\n            return this.pc.getStats(selector);\n        };\n        /**\n         * Sets the SFU client to use.\n         *\n         * @param sfuClient the SFU client to use.\n         */ this.setSfuClient = (sfuClient)=>{\n            this.sfuClient = sfuClient;\n        };\n        /**\n         * Migrates the subscriber to a new SFU client.\n         *\n         * @param sfuClient the new SFU client to migrate to.\n         * @param connectionConfig the new connection configuration to use.\n         */ this.migrateTo = (sfuClient, connectionConfig)=>{\n            this.setSfuClient(sfuClient);\n            // when migrating, we want to keep the previous subscriber open\n            // until the new one is connected\n            const previousPC = this.pc;\n            // we keep a record of previously available video tracks\n            // so that we can monitor when they become available on the new\n            // subscriber and close the previous one.\n            const trackIdsToMigrate = new Set();\n            previousPC.getReceivers().forEach((r)=>{\n                if (r.track.kind === \"video\") {\n                    trackIdsToMigrate.add(r.track.id);\n                }\n            });\n            // set up a new subscriber peer connection, configured to connect\n            // to the new SFU node\n            const pc = this.createPeerConnection(connectionConfig);\n            let migrationTimeoutId;\n            const cleanupMigration = ()=>{\n                previousPC.close();\n                clearTimeout(migrationTimeoutId);\n            };\n            // When migrating, we want to keep track of the video tracks\n            // that are migrating to the new subscriber.\n            // Once all of them are available, we can close the previous subscriber.\n            const handleTrackMigration = (e)=>{\n                logger$2(\"debug\", `[Migration]: Migrated track: ${e.track.id}, ${e.track.kind}`);\n                trackIdsToMigrate.delete(e.track.id);\n                if (trackIdsToMigrate.size === 0) {\n                    logger$2(\"debug\", `[Migration]: Migration complete`);\n                    pc.removeEventListener(\"track\", handleTrackMigration);\n                    cleanupMigration();\n                }\n            };\n            // When migrating, we want to keep track of the connection state\n            // of the new subscriber.\n            // Once it is connected, we give it a 2-second grace period to receive\n            // all the video tracks that are migrating from the previous subscriber.\n            // After this threshold, we abruptly close the previous subscriber.\n            const handleConnectionStateChange = ()=>{\n                if (pc.connectionState === \"connected\") {\n                    migrationTimeoutId = setTimeout(()=>{\n                        pc.removeEventListener(\"track\", handleTrackMigration);\n                        cleanupMigration();\n                    }, 2000);\n                    pc.removeEventListener(\"connectionstatechange\", handleConnectionStateChange);\n                }\n            };\n            pc.addEventListener(\"track\", handleTrackMigration);\n            pc.addEventListener(\"connectionstatechange\", handleConnectionStateChange);\n            // replace the PeerConnection instance\n            this.pc = pc;\n        };\n        /**\n         * Restarts the ICE connection and renegotiates with the SFU.\n         */ this.restartIce = async ()=>{\n            logger$2(\"debug\", \"Restarting ICE connection\");\n            if (this.pc.signalingState === \"have-remote-offer\") {\n                logger$2(\"debug\", \"ICE restart is already in progress\");\n                return;\n            }\n            const previousIsIceRestarting = this.isIceRestarting;\n            try {\n                this.isIceRestarting = true;\n                await this.sfuClient.iceRestart({\n                    peerType: PeerType.SUBSCRIBER\n                });\n            } catch (e) {\n                // restore the previous state, as our intent for restarting ICE failed\n                this.isIceRestarting = previousIsIceRestarting;\n                throw e;\n            }\n        };\n        this.handleOnTrack = (e)=>{\n            const [primaryStream] = e.streams;\n            // example: `e3f6aaf8-b03d-4911-be36-83f47d37a76a:TRACK_TYPE_VIDEO`\n            const [trackId, trackType] = primaryStream.id.split(\":\");\n            const participantToUpdate = this.state.participants.find((p)=>p.trackLookupPrefix === trackId);\n            logger$2(\"debug\", `[onTrack]: Got remote ${trackType} track for userId: ${participantToUpdate?.userId}`, e.track.id, e.track);\n            if (!participantToUpdate) {\n                logger$2(\"error\", `[onTrack]: Received track for unknown participant: ${trackId}`, e);\n                return;\n            }\n            e.track.addEventListener(\"mute\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track muted: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            e.track.addEventListener(\"unmute\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track unmuted: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            e.track.addEventListener(\"ended\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track ended: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            const streamKindProp = {\n                TRACK_TYPE_AUDIO: \"audioStream\",\n                TRACK_TYPE_VIDEO: \"videoStream\",\n                TRACK_TYPE_SCREEN_SHARE: \"screenShareStream\",\n                TRACK_TYPE_SCREEN_SHARE_AUDIO: \"screenShareAudioStream\"\n            }[trackType];\n            if (!streamKindProp) {\n                logger$2(\"error\", `Unknown track type: ${trackType}`);\n                return;\n            }\n            const previousStream = participantToUpdate[streamKindProp];\n            if (previousStream) {\n                logger$2(\"info\", `[onTrack]: Cleaning up previous remote ${e.track.kind} tracks for userId: ${participantToUpdate.userId}`);\n                previousStream.getTracks().forEach((t)=>{\n                    t.stop();\n                    previousStream.removeTrack(t);\n                });\n            }\n            this.state.updateParticipant(participantToUpdate.sessionId, {\n                [streamKindProp]: primaryStream\n            });\n        };\n        this.onIceCandidate = async (e)=>{\n            const { candidate } = e;\n            if (!candidate) {\n                logger$2(\"debug\", \"null ice candidate\");\n                return;\n            }\n            await this.sfuClient.iceTrickle({\n                iceCandidate: getIceCandidate(candidate),\n                peerType: PeerType.SUBSCRIBER\n            });\n        };\n        this.negotiate = async (subscriberOffer)=>{\n            logger$2(\"info\", `Received subscriberOffer`, subscriberOffer);\n            await this.pc.setRemoteDescription({\n                type: \"offer\",\n                sdp: subscriberOffer.sdp\n            });\n            this.sfuClient.iceTrickleBuffer.subscriberCandidates.subscribe(async (candidate)=>{\n                try {\n                    const iceCandidate = JSON.parse(candidate.iceCandidate);\n                    await this.pc.addIceCandidate(iceCandidate);\n                } catch (e) {\n                    logger$2(\"warn\", `ICE candidate error`, [\n                        e,\n                        candidate\n                    ]);\n                }\n            });\n            const answer = await this.pc.createAnswer();\n            await this.pc.setLocalDescription(answer);\n            await this.sfuClient.sendAnswer({\n                peerType: PeerType.SUBSCRIBER,\n                sdp: answer.sdp || \"\"\n            });\n            this.isIceRestarting = false;\n        };\n        this.onIceConnectionStateChange = ()=>{\n            const state = this.pc.iceConnectionState;\n            logger$2(\"debug\", `ICE connection state changed`, state);\n            // do nothing when ICE is restarting\n            if (this.isIceRestarting) return;\n            const hasNetworkConnection = this.state.callingState !== CallingState.OFFLINE;\n            if (state === \"failed\") {\n                logger$2(\"warn\", `Attempting to restart ICE`);\n                this.restartIce().catch((e)=>{\n                    logger$2(\"error\", `ICE restart failed`, e);\n                });\n            } else if (state === \"disconnected\" && hasNetworkConnection) {\n                // when in `disconnected` state, the browser may recover automatically,\n                // hence, we delay the ICE restart\n                logger$2(\"warn\", `Scheduling ICE restart in ${this.iceRestartDelay} ms.`);\n                this.iceRestartTimeout = setTimeout(()=>{\n                    // check if the state is still `disconnected` or `failed`\n                    // as the connection may have recovered (or failed) in the meantime\n                    if (this.pc.iceConnectionState === \"disconnected\" || this.pc.iceConnectionState === \"failed\") {\n                        this.restartIce().catch((e)=>{\n                            logger$2(\"error\", `ICE restart failed`, e);\n                        });\n                    } else {\n                        logger$2(\"debug\", `Scheduled ICE restart: connection recovered, canceled.`);\n                    }\n                }, 5000);\n            }\n        };\n        this.onIceGatheringStateChange = ()=>{\n            logger$2(\"debug\", `ICE gathering state changed`, this.pc.iceGatheringState);\n        };\n        this.onIceCandidateError = (e)=>{\n            const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;\n            const iceState = this.pc.iceConnectionState;\n            const logLevel = iceState === \"connected\" || iceState === \"checking\" ? \"debug\" : \"warn\";\n            logger$2(logLevel, `ICE Candidate error`, errorMessage);\n        };\n        this.sfuClient = sfuClient;\n        this.state = state;\n        this.iceRestartDelay = iceRestartDelay;\n        this.pc = this.createPeerConnection(connectionConfig);\n        this.unregisterOnSubscriberOffer = dispatcher.on(\"subscriberOffer\", async (subscriberOffer)=>{\n            await this.negotiate(subscriberOffer);\n        });\n        this.unregisterOnIceRestart = dispatcher.on(\"iceRestart\", async (iceRestart)=>{\n            if (iceRestart.peerType !== PeerType.SUBSCRIBER) return;\n            await this.restartIce();\n        });\n    }\n}\nconst createWebSocketSignalChannel = (opts)=>{\n    const logger = getLogger([\n        \"sfu-client\"\n    ]);\n    const { endpoint, onMessage } = opts;\n    const ws = new (isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default())(endpoint);\n    ws.binaryType = \"arraybuffer\"; // do we need this?\n    ws.addEventListener(\"error\", (e)=>{\n        logger(\"error\", \"Signaling WS channel error\", e);\n    });\n    ws.addEventListener(\"close\", (e)=>{\n        logger(\"info\", \"Signaling WS channel is closed\", e);\n    });\n    ws.addEventListener(\"open\", (e)=>{\n        logger(\"info\", \"Signaling WS channel is open\", e);\n    });\n    ws.addEventListener(\"message\", (e)=>{\n        try {\n            const message = e.data instanceof ArrayBuffer ? SfuEvent.fromBinary(new Uint8Array(e.data)) : SfuEvent.fromJsonString(e.data.toString());\n            onMessage(message);\n        } catch (err) {\n            logger(\"error\", \"Failed to decode a message. Check whether the Proto models match.\", {\n                event: e,\n                error: err\n            });\n        }\n    });\n    return ws;\n};\nconst sleep = (m)=>new Promise((r)=>setTimeout(r, m));\nfunction isFunction(value) {\n    return value && (Object.prototype.toString.call(value) === \"[object Function]\" || \"function\" === typeof value || value instanceof Function);\n}\n/**\n * A map of known error codes.\n */ const KnownCodes = {\n    TOKEN_EXPIRED: 40,\n    WS_CLOSED_SUCCESS: 1000,\n    WS_CLOSED_ABRUPTLY: 1006,\n    WS_POLICY_VIOLATION: 1008\n};\n/**\n * retryInterval - A retry interval which increases acc to number of failures\n *\n * @return {number} Duration to wait in milliseconds\n */ function retryInterval(numberOfFailures) {\n    // try to reconnect in 0.25-5 seconds (random to spread out the load from failures)\n    const max = Math.min(500 + numberOfFailures * 2000, 5000);\n    const min = Math.min(Math.max(250, (numberOfFailures - 1) * 2000), 5000);\n    return Math.floor(Math.random() * (max - min) + min);\n}\nfunction randomId() {\n    return generateUUIDv4();\n}\nfunction hex(bytes) {\n    let s = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        s += bytes[i].toString(16).padStart(2, \"0\");\n    }\n    return s;\n}\n// https://tools.ietf.org/html/rfc4122\nfunction generateUUIDv4() {\n    const bytes = getRandomBytes(16);\n    bytes[6] = bytes[6] & 0x0f | 0x40; // version\n    bytes[8] = bytes[8] & 0xbf | 0x80; // variant\n    return hex(bytes.subarray(0, 4)) + \"-\" + hex(bytes.subarray(4, 6)) + \"-\" + hex(bytes.subarray(6, 8)) + \"-\" + hex(bytes.subarray(8, 10)) + \"-\" + hex(bytes.subarray(10, 16));\n}\nfunction getRandomValuesWithMathRandom(bytes) {\n    const max = Math.pow(2, 8 * bytes.byteLength / bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Math.random() * max;\n    }\n}\nconst getRandomValues = (()=>{\n    if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues !== \"undefined\") {\n        return crypto.getRandomValues.bind(crypto);\n    } else if (typeof msCrypto !== \"undefined\") {\n        return msCrypto.getRandomValues.bind(msCrypto);\n    } else {\n        return getRandomValuesWithMathRandom;\n    }\n})();\nfunction getRandomBytes(length) {\n    const bytes = new Uint8Array(length);\n    getRandomValues(bytes);\n    return bytes;\n}\nfunction convertErrorToJson(err) {\n    const jsonObj = {};\n    if (!err) return jsonObj;\n    try {\n        Object.getOwnPropertyNames(err).forEach((key)=>{\n            jsonObj[key] = Object.getOwnPropertyDescriptor(err, key);\n        });\n    } catch (_) {\n        return {\n            error: \"failed to serialize the error\"\n        };\n    }\n    return jsonObj;\n}\n/**\n * isOnline safely return the navigator.online value for browser env\n * if navigator is not in global object, it always return true\n */ function isOnline(logger) {\n    const nav = typeof navigator !== \"undefined\" ? navigator :  false ? 0 : undefined;\n    if (!nav) {\n        logger(\"warn\", \"isOnline failed to access window.navigator and assume browser is online\");\n        return true;\n    }\n    // RN navigator has undefined for onLine\n    if (typeof nav.onLine !== \"boolean\") {\n        return true;\n    }\n    return nav.onLine;\n}\n/**\n * listenForConnectionChanges - Adds an event listener fired on browser going online or offline\n */ function addConnectionEventListeners(cb) {\n    if (false) {}\n}\nfunction removeConnectionEventListeners(cb) {\n    if (false) {}\n}\n/**\n * The client used for exchanging information with the SFU.\n */ class StreamSfuClient {\n    /**\n     * Constructs a new SFU client.\n     *\n     * @param dispatcher the event dispatcher to use.\n     * @param sfuServer the SFU server to connect to.\n     * @param token the JWT token to use for authentication.\n     * @param sessionId the `sessionId` of the currently connected participant.\n     */ constructor({ dispatcher, sfuServer, token, sessionId }){\n        /**\n         * A buffer for ICE Candidates that are received before\n         * the PeerConnections are ready to handle them.\n         */ this.iceTrickleBuffer = new IceTrickleBuffer();\n        /**\n         * A flag indicating whether the client is currently migrating away\n         * from this SFU.\n         */ this.isMigratingAway = false;\n        /**\n         * A flag indicating that the client connection is broken for the current\n         * client and that a fast-reconnect with a new client should be attempted.\n         */ this.isFastReconnecting = false;\n        this.pingIntervalInMs = 10 * 1000;\n        this.unhealthyTimeoutInMs = this.pingIntervalInMs + 5 * 1000;\n        this.close = (code, reason)=>{\n            this.logger(\"debug\", `Closing SFU WS connection: ${code} - ${reason}`);\n            if (this.signalWs.readyState !== this.signalWs.CLOSED) {\n                this.signalWs.close(code, `js-client: ${reason}`);\n            }\n            this.unsubscribeIceTrickle();\n            clearInterval(this.keepAliveInterval);\n            clearTimeout(this.connectionCheckTimeout);\n        };\n        this.updateSubscriptions = async (subscriptions)=>{\n            return retryable(()=>this.rpc.updateSubscriptions({\n                    sessionId: this.sessionId,\n                    tracks: subscriptions\n                }), this.logger);\n        };\n        this.setPublisher = async (data)=>{\n            return retryable(()=>this.rpc.setPublisher({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.sendAnswer = async (data)=>{\n            return retryable(()=>this.rpc.sendAnswer({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.iceTrickle = async (data)=>{\n            return retryable(()=>this.rpc.iceTrickle({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.iceRestart = async (data)=>{\n            return retryable(()=>this.rpc.iceRestart({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.updateMuteState = async (trackType, muted)=>{\n            return this.updateMuteStates({\n                muteStates: [\n                    {\n                        trackType,\n                        muted\n                    }\n                ]\n            });\n        };\n        this.updateMuteStates = async (data)=>{\n            return retryable(()=>this.rpc.updateMuteStates({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.sendStats = async (stats)=>{\n            return retryable(()=>this.rpc.sendStats({\n                    ...stats,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.join = async (data)=>{\n            const joinRequest = JoinRequest.create({\n                ...data,\n                sessionId: this.sessionId,\n                token: this.token\n            });\n            return this.send(SfuRequest.create({\n                requestPayload: {\n                    oneofKind: \"joinRequest\",\n                    joinRequest\n                }\n            }));\n        };\n        this.send = async (message)=>{\n            return this.signalReady.then((signal)=>{\n                if (signal.readyState !== signal.OPEN) return;\n                this.logger(\"debug\", `Sending message to: ${this.edgeName}`, SfuRequest.toJson(message));\n                signal.send(SfuRequest.toBinary(message));\n            });\n        };\n        this.keepAlive = ()=>{\n            clearInterval(this.keepAliveInterval);\n            this.keepAliveInterval = setInterval(()=>{\n                this.logger(\"trace\", \"Sending healthCheckRequest to SFU\");\n                const message = SfuRequest.create({\n                    requestPayload: {\n                        oneofKind: \"healthCheckRequest\",\n                        healthCheckRequest: {}\n                    }\n                });\n                this.send(message).catch((e)=>{\n                    this.logger(\"error\", \"Error sending healthCheckRequest to SFU\", e);\n                });\n            }, this.pingIntervalInMs);\n        };\n        this.scheduleConnectionCheck = ()=>{\n            clearTimeout(this.connectionCheckTimeout);\n            this.connectionCheckTimeout = setTimeout(()=>{\n                if (this.lastMessageTimestamp) {\n                    const timeSinceLastMessage = new Date().getTime() - this.lastMessageTimestamp.getTime();\n                    if (timeSinceLastMessage > this.unhealthyTimeoutInMs) {\n                        this.close(StreamSfuClient.ERROR_CONNECTION_UNHEALTHY, `SFU connection unhealthy. Didn't receive any message for ${this.unhealthyTimeoutInMs}ms`);\n                    }\n                }\n            }, this.unhealthyTimeoutInMs);\n        };\n        this.sessionId = sessionId || generateUUIDv4();\n        this.sfuServer = sfuServer;\n        this.edgeName = sfuServer.edge_name;\n        this.token = token;\n        this.logger = getLogger([\n            \"sfu-client\"\n        ]);\n        const logInterceptor = {\n            interceptUnary: (next, method, input, options)=>{\n                this.logger(\"trace\", `Calling SFU RPC method ${method.name}`, {\n                    input,\n                    options\n                });\n                return next(method, input, options);\n            }\n        };\n        this.rpc = createSignalClient({\n            baseUrl: sfuServer.url,\n            interceptors: [\n                withHeaders({\n                    Authorization: `Bearer ${token}`\n                }),\n                logInterceptor\n            ]\n        });\n        // Special handling for the ICETrickle kind of events.\n        // These events might be triggered by the SFU before the initial RTC\n        // connection is established. In that case, those events (ICE candidates)\n        // need to be buffered and later added to the appropriate PeerConnection\n        // once the remoteDescription is known and set.\n        this.unsubscribeIceTrickle = dispatcher.on(\"iceTrickle\", (iceTrickle)=>{\n            this.iceTrickleBuffer.push(iceTrickle);\n        });\n        this.signalWs = createWebSocketSignalChannel({\n            endpoint: sfuServer.ws_endpoint,\n            onMessage: (message)=>{\n                this.lastMessageTimestamp = new Date();\n                this.scheduleConnectionCheck();\n                dispatcher.dispatch(message);\n            }\n        });\n        this.signalReady = new Promise((resolve)=>{\n            const onOpen = ()=>{\n                this.signalWs.removeEventListener(\"open\", onOpen);\n                this.keepAlive();\n                resolve(this.signalWs);\n            };\n            this.signalWs.addEventListener(\"open\", onOpen);\n        });\n    }\n}\n/**\n * The normal closure code. Used for controlled shutdowns.\n */ StreamSfuClient.NORMAL_CLOSURE = 1000;\n/**\n * The error code used when the SFU connection is unhealthy.\n * Usually, this means that no message has been received from the SFU for\n * a certain amount of time (`connectionCheckTimeout`).\n */ StreamSfuClient.ERROR_CONNECTION_UNHEALTHY = 4001;\n/**\n * The error code used when the SFU connection is broken.\n * Usually, this means that the WS connection has been closed unexpectedly.\n * This error code is used to announce a fast-reconnect.\n */ StreamSfuClient.ERROR_CONNECTION_BROKEN = 4002; // used in fast-reconnects\nconst MAX_RETRIES = 5;\n/**\n * Creates a closure which wraps the given RPC call and retries invoking\n * the RPC until it succeeds or the maximum number of retries is reached.\n *\n * Between each retry, there would be a random delay in order to avoid\n * request bursts towards the SFU.\n *\n * @param rpc the closure around the RPC call to execute.\n * @param logger a logger instance to use.\n * @param <I> the type of the request object.\n * @param <O> the type of the response object.\n */ const retryable = async (rpc, logger)=>{\n    let retryAttempt = 0;\n    let rpcCallResult;\n    do {\n        // don't delay the first invocation\n        if (retryAttempt > 0) {\n            await sleep(retryInterval(retryAttempt));\n        }\n        rpcCallResult = await rpc();\n        logger(\"trace\", `SFU RPC response received for ${rpcCallResult.method.name}`, rpcCallResult);\n        // if the RPC call failed, log the error and retry\n        if (rpcCallResult.response.error) {\n            logger(\"error\", `SFU RPC Error (${rpcCallResult.method.name}):`, rpcCallResult.response.error);\n        }\n        retryAttempt++;\n    }while (rpcCallResult.response.error?.shouldRetry && retryAttempt < MAX_RETRIES);\n    if (rpcCallResult.response.error) {\n        throw rpcCallResult.response.error;\n    }\n    return rpcCallResult;\n};\n/**\n * Event handler that watched the delivery of `call.accepted`.\n * Once the event is received, the call is joined.\n */ const watchCallAccepted = (call)=>{\n    return async function onCallAccepted(event) {\n        // We want to discard the event if it's from the current user\n        if (event.user.id === call.currentUserId) return;\n        const { state } = call;\n        if (event.call.created_by.id === call.currentUserId && state.callingState === CallingState.RINGING) {\n            await call.join();\n        }\n    };\n};\n/**\n * Event handler that watches delivery of `call.rejected` Websocket event.\n * Once the event is received, the call is left.\n */ const watchCallRejected = (call)=>{\n    return async function onCallRejected(event) {\n        // We want to discard the event if it's from the current user\n        if (event.user.id === call.currentUserId) return;\n        const { call: eventCall } = event;\n        const { session: callSession } = eventCall;\n        if (!callSession) {\n            call.logger(\"warn\", \"No call session provided. Ignoring call.rejected event.\", event);\n            return;\n        }\n        const rejectedBy = callSession.rejected_by;\n        const { members, callingState } = call.state;\n        if (callingState !== CallingState.RINGING) {\n            call.logger(\"info\", \"Call is not in ringing mode (it is either accepted or rejected already). Ignoring call.rejected event.\", event);\n            return;\n        }\n        if (call.isCreatedByMe) {\n            const everyoneElseRejected = members.filter((m)=>m.user_id !== call.currentUserId).every((m)=>rejectedBy[m.user_id]);\n            if (everyoneElseRejected) {\n                call.logger(\"info\", \"everyone rejected, leaving the call\");\n                await call.leave({\n                    reason: \"ring: everyone rejected\"\n                });\n            }\n        } else {\n            if (rejectedBy[eventCall.created_by.id]) {\n                call.logger(\"info\", \"call creator rejected, leaving call\");\n                await call.leave({\n                    reason: \"ring: creator rejected\"\n                });\n            }\n        }\n    };\n};\n/**\n * Event handler that watches the delivery of `call.ended` Websocket event.\n */ const watchCallEnded = (call)=>{\n    return async function onCallEnded() {\n        const { callingState } = call.state;\n        if (callingState === CallingState.RINGING || callingState === CallingState.JOINED || callingState === CallingState.JOINING) {\n            await call.leave({\n                reason: \"call.ended event received\"\n            });\n        }\n    };\n};\n/**\n * Event handler that watches for `callGrantsUpdated` events.\n *\n * @param state the call state to update.\n */ const watchCallGrantsUpdated = (state)=>{\n    return function onCallGrantsUpdated(event) {\n        const { currentGrants } = event;\n        if (currentGrants) {\n            const { canPublishAudio, canPublishVideo, canScreenshare } = currentGrants;\n            const update = {\n                [OwnCapability.SEND_AUDIO]: canPublishAudio,\n                [OwnCapability.SEND_VIDEO]: canPublishVideo,\n                [OwnCapability.SCREENSHARE]: canScreenshare\n            };\n            const nextCapabilities = state.ownCapabilities.filter((capability)=>update[capability] !== false);\n            Object.entries(update).forEach(([capability, value])=>{\n                if (value && !nextCapabilities.includes(capability)) {\n                    nextCapabilities.push(capability);\n                }\n            });\n            state.setOwnCapabilities(nextCapabilities);\n        }\n    };\n};\nconst logger$1 = getLogger([\n    \"events\"\n]);\n/**\n * An event responder which handles the `changePublishQuality` event.\n */ const watchChangePublishQuality = (dispatcher, call)=>{\n    return dispatcher.on(\"changePublishQuality\", (e)=>{\n        const { videoSenders } = e;\n        videoSenders.forEach((videoSender)=>{\n            const { layers } = videoSender;\n            call.updatePublishQuality(layers.filter((l)=>l.active));\n        });\n    });\n};\nconst watchConnectionQualityChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"connectionQualityChanged\", (e)=>{\n        const { connectionQualityUpdates } = e;\n        if (!connectionQualityUpdates) return;\n        state.updateParticipants(connectionQualityUpdates.reduce((patches, update)=>{\n            const { sessionId, connectionQuality } = update;\n            patches[sessionId] = {\n                connectionQuality\n            };\n            return patches;\n        }, {}));\n    });\n};\n/**\n * Updates the approximate number of participants in the call by peeking at the\n * health check events that our SFU sends.\n */ const watchParticipantCountChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"healthCheckResponse\", (e)=>{\n        const { participantCount } = e;\n        if (participantCount) {\n            state.setParticipantCount(participantCount.total);\n            state.setAnonymousParticipantCount(participantCount.anonymous);\n        }\n    });\n};\nconst watchLiveEnded = (dispatcher, call)=>{\n    return dispatcher.on(\"error\", (e)=>{\n        if (e.error && e.error.code !== ErrorCode.LIVE_ENDED) return;\n        if (!call.permissionsContext.hasPermission(OwnCapability.JOIN_BACKSTAGE)) {\n            call.leave({\n                reason: \"live ended\"\n            }).catch((err)=>{\n                logger$1(\"error\", \"Failed to leave call after live ended\", err);\n            });\n        }\n    });\n};\n/**\n * Watches and logs the errors reported by the currently connected SFU.\n */ const watchSfuErrorReports = (dispatcher)=>{\n    return dispatcher.on(\"error\", (e)=>{\n        if (!e.error) return;\n        const { error } = e;\n        logger$1(\"error\", \"SFU reported error\", {\n            code: ErrorCode[error.code],\n            message: error.message,\n            shouldRetry: error.shouldRetry\n        });\n    });\n};\n/**\n * Watches for `pinsUpdated` events and updates the pinned state of participants\n * in the call.\n */ const watchPinsUpdated = (state)=>{\n    return function onPinsUpdated(e) {\n        const { pins } = e;\n        state.setServerSidePins(pins);\n    };\n};\n/**\n * An event handler that handles soft mutes.\n *\n * @param call the call.\n */ const handleRemoteSoftMute = (call)=>{\n    return call.on(\"trackUnpublished\", async (event)=>{\n        const { cause, type, sessionId } = event;\n        const { localParticipant } = call.state;\n        if (cause === TrackUnpublishReason.MODERATION && sessionId === localParticipant?.sessionId) {\n            const logger = call.logger;\n            logger(\"info\", `Local participant's ${TrackType[type]} track is muted remotely`);\n            try {\n                if (type === TrackType.VIDEO) {\n                    await call.camera.disable();\n                } else if (type === TrackType.AUDIO) {\n                    await call.microphone.disable();\n                } else {\n                    logger(\"warn\", \"Unsupported track type to soft mute\", TrackType[type]);\n                }\n                if (call.publisher?.isPublishing(type)) {\n                    await call.stopPublish(type);\n                }\n            } catch (error) {\n                logger(\"error\", \"Failed to stop publishing\", error);\n            }\n        }\n    });\n};\n/**\n * An event responder which handles the `participantJoined` event.\n */ const watchParticipantJoined = (state)=>{\n    return function onParticipantJoined(e) {\n        const { participant } = e;\n        if (!participant) return;\n        // `state.updateOrAddParticipant` acts as a safeguard against\n        // potential duplicate events from the SFU.\n        //\n        // Although the SFU should not send duplicate events, we have seen\n        // some race conditions in the past during the `join-flow` where\n        // the SFU would send participant info as part of the `join`\n        // response and then follow up with a `participantJoined` event for\n        // already announced participants.\n        state.updateOrAddParticipant(participant.sessionId, Object.assign(participant, {\n            viewportVisibilityState: {\n                videoTrack: VisibilityState.UNKNOWN,\n                screenShareTrack: VisibilityState.UNKNOWN\n            }\n        }));\n    };\n};\n/**\n * An event responder which handles the `participantLeft` event.\n */ const watchParticipantLeft = (state)=>{\n    return function onParticipantLeft(e) {\n        const { participant } = e;\n        if (!participant) return;\n        state.setParticipants((participants)=>participants.filter((p)=>p.sessionId !== participant.sessionId));\n    };\n};\n/**\n * An event responder which handles the `trackPublished` event.\n * The SFU will send this event when a participant publishes a track.\n */ const watchTrackPublished = (state)=>{\n    return function onTrackPublished(e) {\n        const { type, sessionId, participant } = e;\n        // An optimization for large calls.\n        // After a certain threshold, the SFU would stop emitting `participantJoined`\n        // events, and instead, it would only provide the participant's information\n        // once they start publishing a track.\n        if (participant) {\n            state.updateOrAddParticipant(sessionId, participant);\n        } else {\n            state.updateParticipant(sessionId, (p)=>({\n                    publishedTracks: [\n                        ...p.publishedTracks,\n                        type\n                    ].filter(unique)\n                }));\n        }\n    };\n};\n/**\n * An event responder which handles the `trackUnpublished` event.\n * The SFU will send this event when a participant unpublishes a track.\n */ const watchTrackUnpublished = (state)=>{\n    return function onTrackUnpublished(e) {\n        const { type, sessionId, participant } = e;\n        // An optimization for large calls. See `watchTrackPublished`.\n        if (participant) {\n            state.updateOrAddParticipant(sessionId, participant);\n        } else {\n            state.updateParticipant(sessionId, (p)=>({\n                    publishedTracks: p.publishedTracks.filter((t)=>t !== type)\n                }));\n        }\n    };\n};\nconst unique = (v, i, arr)=>arr.indexOf(v) === i;\n/**\n * Watches for `dominantSpeakerChanged` events.\n */ const watchDominantSpeakerChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"dominantSpeakerChanged\", (e)=>{\n        const { sessionId } = e;\n        if (sessionId === state.dominantSpeaker?.sessionId) return;\n        state.setParticipants((participants)=>participants.map((participant)=>{\n                // mark the new dominant speaker\n                if (participant.sessionId === sessionId) {\n                    return {\n                        ...participant,\n                        isDominantSpeaker: true\n                    };\n                }\n                // unmark the old dominant speaker\n                if (participant.isDominantSpeaker) {\n                    return {\n                        ...participant,\n                        isDominantSpeaker: false\n                    };\n                }\n                return participant; // no change\n            }));\n    });\n};\n/**\n * Watches for `audioLevelChanged` events.\n */ const watchAudioLevelChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"audioLevelChanged\", (e)=>{\n        const { audioLevels } = e;\n        state.updateParticipants(audioLevels.reduce((patches, current)=>{\n            patches[current.sessionId] = {\n                audioLevel: current.level,\n                isSpeaking: current.isSpeaking\n            };\n            return patches;\n        }, {}));\n    });\n};\n/**\n * Registers the default event handlers for a call during its lifecycle.\n *\n * @param call the call to register event handlers for.\n * @param state the call state.\n * @param dispatcher the dispatcher.\n */ const registerEventHandlers = (call, state, dispatcher)=>{\n    const eventHandlers = [\n        call.on(\"call.ended\", watchCallEnded(call)),\n        watchLiveEnded(dispatcher, call),\n        watchSfuErrorReports(dispatcher),\n        watchChangePublishQuality(dispatcher, call),\n        watchConnectionQualityChanged(dispatcher, state),\n        watchParticipantCountChanged(dispatcher, state),\n        call.on(\"participantJoined\", watchParticipantJoined(state)),\n        call.on(\"participantLeft\", watchParticipantLeft(state)),\n        call.on(\"trackPublished\", watchTrackPublished(state)),\n        call.on(\"trackUnpublished\", watchTrackUnpublished(state)),\n        watchAudioLevelChanged(dispatcher, state),\n        watchDominantSpeakerChanged(dispatcher, state),\n        call.on(\"callGrantsUpdated\", watchCallGrantsUpdated(state)),\n        call.on(\"pinsUpdated\", watchPinsUpdated(state)),\n        handleRemoteSoftMute(call)\n    ];\n    if (call.ringing) {\n        // these events are only relevant when the call is ringing\n        eventHandlers.push(registerRingingCallEventHandlers(call));\n    }\n    return ()=>{\n        eventHandlers.forEach((unsubscribe)=>unsubscribe());\n    };\n};\n/**\n * Registers event handlers for a call that is of ringing type.\n *\n * @param call the call to register event handlers for.\n */ const registerRingingCallEventHandlers = (call)=>{\n    const coordinatorRingEvents = {\n        \"call.accepted\": watchCallAccepted(call),\n        \"call.rejected\": watchCallRejected(call)\n    };\n    const eventHandlers = Object.keys(coordinatorRingEvents).map((event)=>{\n        const eventName = event;\n        return call.on(eventName, coordinatorRingEvents[eventName]);\n    });\n    return ()=>{\n        eventHandlers.forEach((unsubscribe)=>unsubscribe());\n    };\n};\n/**\n * Collects all necessary information to join a call, talks to the coordinator\n * and returns the necessary information to join the call.\n *\n * @param httpClient the http client to use.\n * @param type the type of the call.\n * @param id the id of the call.\n * @param data the data for the call.\n */ const join = async (httpClient, type, id, data)=>{\n    const { call, credentials, members, own_capabilities, stats_options } = await doJoin(httpClient, type, id, data);\n    return {\n        connectionConfig: toRtcConfiguration(credentials.ice_servers),\n        sfuServer: credentials.server,\n        token: credentials.token,\n        metadata: call,\n        members,\n        ownCapabilities: own_capabilities,\n        statsOptions: stats_options\n    };\n};\nconst doJoin = async (httpClient, type, id, data)=>{\n    const location = await httpClient.getLocationHint();\n    const request = {\n        ...data,\n        location\n    };\n    return httpClient.post(`/call/${type}/${id}/join`, request);\n};\nconst toRtcConfiguration = (config)=>{\n    if (!config || config.length === 0) return undefined;\n    const rtcConfig = {\n        iceServers: config.map((ice)=>({\n                urls: ice.urls,\n                username: ice.username,\n                credential: ice.password\n            }))\n    };\n    return rtcConfig;\n};\n/**\n * Flatten the stats report into an array of stats objects.\n *\n * @param report the report to flatten.\n */ const flatten$1 = (report)=>{\n    const stats = [];\n    report.forEach((s)=>{\n        stats.push(s);\n    });\n    return stats;\n};\n/**\n * Creates a new StatsReporter instance that collects metrics about the ongoing call and reports them to the state store\n */ const createStatsReporter = ({ subscriber, publisher, state, pollingIntervalInMs = 2000 })=>{\n    const logger = getLogger([\n        \"stats\"\n    ]);\n    const getRawStatsForTrack = async (kind, selector)=>{\n        if (kind === \"subscriber\" && subscriber) {\n            return subscriber.getStats(selector);\n        } else if (kind === \"publisher\" && publisher) {\n            return publisher.getStats(selector);\n        } else {\n            logger(\"warn\", `Can't retrieve RTC stats for ${kind}`);\n            return undefined;\n        }\n    };\n    const getStatsForStream = async (kind, mediaStream)=>{\n        const pc = kind === \"subscriber\" ? subscriber : publisher;\n        const statsForStream = [];\n        for (let track of mediaStream.getTracks()){\n            const report = await pc.getStats(track);\n            const stats = transform(report, {\n                // @ts-ignore\n                trackKind: track.kind,\n                kind\n            });\n            statsForStream.push(stats);\n        }\n        return statsForStream;\n    };\n    const startReportingStatsFor = (sessionId)=>{\n        sessionIdsToTrack.add(sessionId);\n        void run();\n    };\n    const stopReportingStatsFor = (sessionId)=>{\n        sessionIdsToTrack.delete(sessionId);\n        void run();\n    };\n    const sessionIdsToTrack = new Set();\n    /**\n     * The main stats reporting loop.\n     */ const run = async ()=>{\n        const participantStats = {};\n        const sessionIds = new Set(sessionIdsToTrack);\n        if (sessionIds.size > 0) {\n            for (let participant of state.participants){\n                if (!sessionIds.has(participant.sessionId)) continue;\n                const kind = participant.isLocalParticipant ? \"publisher\" : \"subscriber\";\n                try {\n                    const mergedStream = new MediaStream([\n                        ...participant.videoStream?.getVideoTracks() || [],\n                        ...participant.audioStream?.getAudioTracks() || []\n                    ]);\n                    participantStats[participant.sessionId] = await getStatsForStream(kind, mergedStream);\n                    mergedStream.getTracks().forEach((t)=>{\n                        mergedStream.removeTrack(t);\n                    });\n                } catch (e) {\n                    logger(\"error\", `Failed to collect stats for ${kind} if ${participant.userId}`, e);\n                }\n            }\n        }\n        const [subscriberStats, publisherStats] = await Promise.all([\n            subscriber.getStats().then((report)=>transform(report, {\n                    kind: \"subscriber\",\n                    trackKind: \"video\"\n                })).then(aggregate),\n            publisher.getStats().then((report)=>transform(report, {\n                    kind: \"publisher\",\n                    trackKind: \"video\"\n                })).then(aggregate)\n        ]);\n        const [subscriberRawStats, publisherRawStats] = await Promise.all([\n            getRawStatsForTrack(\"subscriber\"),\n            getRawStatsForTrack(\"publisher\")\n        ]);\n        state.setCallStatsReport({\n            datacenter: publisher.sfuClient.edgeName,\n            publisherStats,\n            subscriberStats,\n            subscriberRawStats,\n            publisherRawStats,\n            participants: participantStats,\n            timestamp: Date.now()\n        });\n    };\n    let timeoutId;\n    if (pollingIntervalInMs > 0) {\n        const loop = async ()=>{\n            await run().catch((e)=>{\n                logger(\"debug\", \"Failed to collect stats\", e);\n            });\n            timeoutId = setTimeout(loop, pollingIntervalInMs);\n        };\n        void loop();\n    }\n    const stop = ()=>{\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n    };\n    return {\n        getRawStatsForTrack,\n        getStatsForStream,\n        startReportingStatsFor,\n        stopReportingStatsFor,\n        stop\n    };\n};\n/**\n * Transforms raw RTC stats into a slimmer and uniform across browsers format.\n *\n * @param report the report to transform.\n * @param opts the transform options.\n */ const transform = (report, opts)=>{\n    const { trackKind, kind } = opts;\n    const direction = kind === \"subscriber\" ? \"inbound-rtp\" : \"outbound-rtp\";\n    const stats = flatten$1(report);\n    const streams = stats.filter((stat)=>stat.type === direction && stat.kind === trackKind).map((stat)=>{\n        const rtcStreamStats = stat;\n        const codec = stats.find((s)=>s.type === \"codec\" && s.id === rtcStreamStats.codecId); // FIXME OL: incorrect type!\n        const transport = stats.find((s)=>s.type === \"transport\" && s.id === rtcStreamStats.transportId);\n        let roundTripTime;\n        if (transport && transport.dtlsState === \"connected\") {\n            const candidatePair = stats.find((s)=>s.type === \"candidate-pair\" && s.id === transport.selectedCandidatePairId);\n            roundTripTime = candidatePair?.currentRoundTripTime;\n        }\n        return {\n            bytesSent: rtcStreamStats.bytesSent,\n            bytesReceived: rtcStreamStats.bytesReceived,\n            codec: codec?.mimeType,\n            currentRoundTripTime: roundTripTime,\n            frameHeight: rtcStreamStats.frameHeight,\n            frameWidth: rtcStreamStats.frameWidth,\n            framesPerSecond: rtcStreamStats.framesPerSecond,\n            jitter: rtcStreamStats.jitter,\n            kind: rtcStreamStats.kind,\n            // @ts-ignore: available in Chrome only, TS doesn't recognize this\n            qualityLimitationReason: rtcStreamStats.qualityLimitationReason,\n            rid: rtcStreamStats.rid,\n            ssrc: rtcStreamStats.ssrc\n        };\n    });\n    return {\n        rawStats: report,\n        streams,\n        timestamp: Date.now()\n    };\n};\n/**\n * Aggregates generic stats.\n *\n * @param stats the stats to aggregate.\n */ const aggregate = (stats)=>{\n    const aggregatedStats = {\n        rawReport: stats,\n        totalBytesSent: 0,\n        totalBytesReceived: 0,\n        averageJitterInMs: 0,\n        averageRoundTripTimeInMs: 0,\n        qualityLimitationReasons: \"none\",\n        highestFrameWidth: 0,\n        highestFrameHeight: 0,\n        highestFramesPerSecond: 0,\n        timestamp: Date.now()\n    };\n    let maxArea = -1;\n    const area = (w, h)=>w * h;\n    const qualityLimitationReasons = new Set();\n    const streams = stats.streams;\n    const report = streams.reduce((acc, stream)=>{\n        acc.totalBytesSent += stream.bytesSent || 0;\n        acc.totalBytesReceived += stream.bytesReceived || 0;\n        acc.averageJitterInMs += stream.jitter || 0;\n        acc.averageRoundTripTimeInMs += stream.currentRoundTripTime || 0;\n        // naive calculation of the highest resolution\n        const streamArea = area(stream.frameWidth || 0, stream.frameHeight || 0);\n        if (streamArea > maxArea) {\n            acc.highestFrameWidth = stream.frameWidth || 0;\n            acc.highestFrameHeight = stream.frameHeight || 0;\n            acc.highestFramesPerSecond = stream.framesPerSecond || 0;\n            maxArea = streamArea;\n        }\n        qualityLimitationReasons.add(stream.qualityLimitationReason || \"\");\n        return acc;\n    }, aggregatedStats);\n    if (streams.length > 0) {\n        report.averageJitterInMs = Math.round(report.averageJitterInMs / streams.length * 1000);\n        report.averageRoundTripTimeInMs = Math.round(report.averageRoundTripTimeInMs / streams.length * 1000);\n    }\n    const qualityLimitationReason = [\n        qualityLimitationReasons.has(\"cpu\") && \"cpu\",\n        qualityLimitationReasons.has(\"bandwidth\") && \"bandwidth\",\n        qualityLimitationReasons.has(\"other\") && \"other\"\n    ].filter(Boolean).join(\", \");\n    if (qualityLimitationReason) {\n        report.qualityLimitationReasons = qualityLimitationReason;\n    }\n    return report;\n};\nclass SfuStatsReporter {\n    constructor(sfuClient, { options, clientDetails, subscriber, publisher }){\n        this.logger = getLogger([\n            \"SfuStatsReporter\"\n        ]);\n        this.run = async ()=>{\n            const [subscriberStats, publisherStats] = await Promise.all([\n                this.subscriber.getStats().then(flatten$1).then(JSON.stringify),\n                this.publisher.getStats().then(flatten$1).then(JSON.stringify)\n            ]);\n            await this.sfuClient.sendStats({\n                sdk: this.sdkName,\n                sdkVersion: this.sdkVersion,\n                webrtcVersion: this.webRTCVersion,\n                subscriberStats,\n                publisherStats\n            });\n        };\n        this.start = ()=>{\n            if (this.options.reporting_interval_ms <= 0) return;\n            this.intervalId = setInterval(()=>{\n                this.run().catch((err)=>{\n                    this.logger(\"warn\", \"Failed to report stats\", err);\n                });\n            }, this.options.reporting_interval_ms);\n        };\n        this.stop = ()=>{\n            clearInterval(this.intervalId);\n            this.intervalId = undefined;\n        };\n        this.sfuClient = sfuClient;\n        this.options = options;\n        this.subscriber = subscriber;\n        this.publisher = publisher;\n        const webRTCInfo = getWebRTCInfo();\n        const { sdk, browser } = clientDetails;\n        this.sdkName = sdk && sdk.type === SdkType.REACT ? \"stream-react\" : sdk && sdk.type === SdkType.REACT_NATIVE ? \"stream-react-native\" : \"stream-js\";\n        this.sdkVersion = sdk ? `${sdk.major}.${sdk.minor}.${sdk.patch}` : \"0.0.0-development\";\n        // The WebRTC version if passed from the SDK, it is taken else the browser info is sent.\n        this.webRTCVersion = webRTCInfo?.version || `${browser?.name || \"\"}-${browser?.version || \"\"}` || \"N/A\";\n    }\n}\nconst DEFAULT_THRESHOLD = 0.35;\nclass ViewportTracker {\n    constructor(){\n        /**\n         * @private\n         */ this.elementHandlerMap = new Map();\n        /**\n         * @private\n         */ this.observer = null;\n        // in React children render before viewport is set, add\n        // them to the queue and observe them once the observer is ready\n        /**\n         * @private\n         */ this.queueSet = new Set();\n        /**\n         * Method to set scrollable viewport as root for the IntersectionObserver, returns\n         * cleanup function to be invoked upon disposing of the DOM element to prevent memory leaks\n         *\n         * @param viewportElement\n         * @param options\n         * @returns Unobserve\n         */ this.setViewport = (viewportElement, options)=>{\n            const cleanup = ()=>{\n                this.observer?.disconnect();\n                this.observer = null;\n                this.elementHandlerMap.clear();\n            };\n            this.observer = new IntersectionObserver((entries)=>{\n                entries.forEach((entry)=>{\n                    const handler = this.elementHandlerMap.get(entry.target);\n                    handler?.(entry);\n                });\n            }, {\n                root: viewportElement,\n                ...options,\n                threshold: options?.threshold ?? DEFAULT_THRESHOLD\n            });\n            if (this.queueSet.size) {\n                this.queueSet.forEach(([queueElement, queueHandler])=>{\n                    // check if element which requested observation is\n                    // a child of a viewport element, skip if isn't\n                    if (!viewportElement.contains(queueElement)) return;\n                    this.observer.observe(queueElement);\n                    this.elementHandlerMap.set(queueElement, queueHandler);\n                });\n                this.queueSet.clear();\n            }\n            return cleanup;\n        };\n        /**\n         * Method to set element to observe and handler to be triggered whenever IntersectionObserver\n         * detects a possible change in element's visibility within specified viewport, returns\n         * cleanup function to be invoked upon disposing of the DOM element to prevent memory leaks\n         *\n         * @param element\n         * @param handler\n         * @returns Unobserve\n         */ this.observe = (element, handler)=>{\n            const queueItem = [\n                element,\n                handler\n            ];\n            const cleanup = ()=>{\n                this.elementHandlerMap.delete(element);\n                this.observer?.unobserve(element);\n                this.queueSet.delete(queueItem);\n            };\n            if (this.elementHandlerMap.has(element)) return cleanup;\n            if (!this.observer) {\n                this.queueSet.add(queueItem);\n                return cleanup;\n            }\n            if (this.observer.root.contains(element)) {\n                this.elementHandlerMap.set(element, handler);\n                this.observer.observe(element);\n            }\n            return cleanup;\n        };\n    }\n}\n/**\n * Checks whether the current browser is Safari.\n */ const isSafari = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent || \"\");\n};\n/**\n * Checks whether the current browser is Firefox.\n */ const isFirefox = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.userAgent?.includes(\"Firefox\");\n};\n/**\n * Checks whether the current browser is Google Chrome.\n */ const isChrome = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.userAgent?.includes(\"Chrome\");\n};\nvar browsers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    isChrome: isChrome,\n    isFirefox: isFirefox,\n    isSafari: isSafari\n});\nconst DEFAULT_VIEWPORT_VISIBILITY_STATE = {\n    videoTrack: VisibilityState.UNKNOWN,\n    screenShareTrack: VisibilityState.UNKNOWN\n};\n/**\n * A manager class that handles dynascale related tasks like:\n *\n * - binding video elements to session ids\n * - binding audio elements to session ids\n * - tracking element visibility\n * - updating subscriptions based on viewport visibility\n * - updating subscriptions based on video element dimensions\n * - updating subscriptions based on published tracks\n */ class DynascaleManager {\n    /**\n     * Creates a new DynascaleManager instance.\n     *\n     * @param call the call to manage.\n     */ constructor(call){\n        /**\n         * The viewport tracker instance.\n         */ this.viewportTracker = new ViewportTracker();\n        this.logger = getLogger([\n            \"DynascaleManager\"\n        ]);\n        /**\n         * Will begin tracking the given element for visibility changes within the\n         * configured viewport element (`call.setViewport`).\n         *\n         * @param element the element to track.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         * @returns Untrack.\n         */ this.trackElementVisibility = (element, sessionId, trackType)=>{\n            const cleanup = this.viewportTracker.observe(element, (entry)=>{\n                this.call.state.updateParticipant(sessionId, (participant)=>{\n                    const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;\n                    // observer triggers when the element is \"moved\" to be a fullscreen element\n                    // keep it VISIBLE if that happens to prevent fullscreen with placeholder\n                    const isVisible = entry.isIntersecting || document.fullscreenElement === element ? VisibilityState.VISIBLE : VisibilityState.INVISIBLE;\n                    return {\n                        ...participant,\n                        viewportVisibilityState: {\n                            ...previousVisibilityState,\n                            [trackType]: isVisible\n                        }\n                    };\n                });\n            });\n            return ()=>{\n                cleanup();\n                // reset visibility state to UNKNOWN upon cleanup\n                // so that the layouts that are not actively observed\n                // can still function normally (runtime layout switching)\n                this.call.state.updateParticipant(sessionId, (participant)=>{\n                    const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;\n                    return {\n                        ...participant,\n                        viewportVisibilityState: {\n                            ...previousVisibilityState,\n                            [trackType]: VisibilityState.UNKNOWN\n                        }\n                    };\n                });\n            };\n        };\n        /**\n         * Sets the viewport element to track bound video elements for visibility.\n         *\n         * @param element the viewport element.\n         */ this.setViewport = (element)=>{\n            return this.viewportTracker.setViewport(element);\n        };\n        /**\n         * Binds a DOM <video> element to the given session id.\n         * This method will make sure that the video element will play\n         * the correct video stream for the given session id.\n         *\n         * Under the hood, it would also keep track of the video element dimensions\n         * and update the subscription accordingly in order to optimize the bandwidth.\n         *\n         * If a \"viewport\" is configured, the video element will be automatically\n         * tracked for visibility and the subscription will be updated accordingly.\n         *\n         * @param videoElement the video element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         */ this.bindVideoElement = (videoElement, sessionId, trackType)=>{\n            const boundParticipant = this.call.state.findParticipantBySessionId(sessionId);\n            if (!boundParticipant) return;\n            const requestTrackWithDimensions = (debounceType, dimension)=>{\n                if (dimension && (dimension.width === 0 || dimension.height === 0)) {\n                    // ignore 0x0 dimensions. this can happen when the video element\n                    // is not visible (e.g., has display: none).\n                    // we treat this as \"unsubscription\" as we don't want to keep\n                    // consuming bandwidth for a video that is not visible on the screen.\n                    this.logger(\"debug\", `Ignoring 0x0 dimension`, boundParticipant);\n                    dimension = undefined;\n                }\n                this.call.updateSubscriptionsPartial(trackType, {\n                    [sessionId]: {\n                        dimension\n                    }\n                }, debounceType);\n            };\n            const participant$ = this.call.state.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((participant)=>participant.sessionId === sessionId)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((participant)=>!!participant), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n                bufferSize: 1,\n                refCount: true\n            }));\n            /**\n             * Since the video elements are now being removed from the DOM (React SDK) upon\n             * visibility change, this subscription is not in use an stays here only for the\n             * plain JS integrations where integrators might choose not to remove the video\n             * elements from the DOM.\n             */ // keep copy for resize observer handler\n            let viewportVisibilityState;\n            const viewportVisibilityStateSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((p)=>p.viewportVisibilityState?.[trackType]), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)()).subscribe((nextViewportVisibilityState)=>{\n                // skip initial trigger\n                if (!viewportVisibilityState) {\n                    viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;\n                    return;\n                }\n                viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;\n                if (nextViewportVisibilityState === VisibilityState.INVISIBLE) {\n                    return requestTrackWithDimensions(DebounceType.MEDIUM, undefined);\n                }\n                requestTrackWithDimensions(DebounceType.MEDIUM, {\n                    width: videoElement.clientWidth,\n                    height: videoElement.clientHeight\n                });\n            });\n            let lastDimensions;\n            const resizeObserver = boundParticipant.isLocalParticipant ? null : new ResizeObserver(()=>{\n                const currentDimensions = `${videoElement.clientWidth},${videoElement.clientHeight}`;\n                // skip initial trigger\n                if (!lastDimensions) {\n                    lastDimensions = currentDimensions;\n                    return;\n                }\n                if (lastDimensions === currentDimensions || viewportVisibilityState === VisibilityState.INVISIBLE) {\n                    return;\n                }\n                requestTrackWithDimensions(DebounceType.SLOW, {\n                    width: videoElement.clientWidth,\n                    height: videoElement.clientHeight\n                });\n                lastDimensions = currentDimensions;\n            });\n            resizeObserver?.observe(videoElement);\n            // element renders and gets bound - track subscription gets\n            // triggered first other ones get skipped on initial subscriptions\n            const publishedTracksSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(\"publishedTracks\"), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((p)=>p.publishedTracks.includes(trackType === \"videoTrack\" ? TrackType.VIDEO : TrackType.SCREEN_SHARE)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)()).subscribe((isPublishing)=>{\n                if (isPublishing) {\n                    // the participant just started to publish a track\n                    requestTrackWithDimensions(DebounceType.FAST, {\n                        width: videoElement.clientWidth,\n                        height: videoElement.clientHeight\n                    });\n                } else {\n                    // the participant just stopped publishing a track\n                    requestTrackWithDimensions(DebounceType.FAST, undefined);\n                }\n            });\n            videoElement.autoplay = true;\n            videoElement.playsInline = true;\n            // explicitly marking the element as muted will allow autoplay to work\n            // without prior user interaction:\n            // https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\n            videoElement.muted = true;\n            const streamSubscription = participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(trackType === \"videoTrack\" ? \"videoStream\" : \"screenShareStream\")).subscribe((p)=>{\n                const source = trackType === \"videoTrack\" ? p.videoStream : p.screenShareStream;\n                if (videoElement.srcObject === source) return;\n                videoElement.srcObject = source ?? null;\n                if (isSafari() || isFirefox()) {\n                    setTimeout(()=>{\n                        videoElement.srcObject = source ?? null;\n                        videoElement.play().catch((e)=>{\n                            this.logger(\"warn\", `Failed to play stream`, e);\n                        });\n                    // we add extra delay until we attempt to force-play\n                    // the participant's media stream in Firefox and Safari,\n                    // as they seem to have some timing issues\n                    }, 25);\n                }\n            });\n            return ()=>{\n                requestTrackWithDimensions(DebounceType.FAST, undefined);\n                viewportVisibilityStateSubscription?.unsubscribe();\n                publishedTracksSubscription?.unsubscribe();\n                streamSubscription.unsubscribe();\n                resizeObserver?.disconnect();\n            };\n        };\n        /**\n         * Binds a DOM <audio> element to the given session id.\n         *\n         * This method will make sure that the audio element will\n         * play the correct audio stream for the given session id.\n         *\n         * @param audioElement the audio element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of audio.\n         * @returns a cleanup function that will unbind the audio element.\n         */ this.bindAudioElement = (audioElement, sessionId, trackType)=>{\n            const participant = this.call.state.findParticipantBySessionId(sessionId);\n            if (!participant || participant.isLocalParticipant) return;\n            const participant$ = this.call.state.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.sessionId === sessionId)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((p)=>!!p), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n                bufferSize: 1,\n                refCount: true\n            }));\n            const updateMediaStreamSubscription = participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(trackType === \"screenShareAudioTrack\" ? \"screenShareAudioStream\" : \"audioStream\")).subscribe((p)=>{\n                const source = trackType === \"screenShareAudioTrack\" ? p.screenShareAudioStream : p.audioStream;\n                if (audioElement.srcObject === source) return;\n                setTimeout(()=>{\n                    audioElement.srcObject = source ?? null;\n                    if (audioElement.srcObject) {\n                        audioElement.play().catch((e)=>{\n                            this.logger(\"warn\", `Failed to play stream`, e);\n                        });\n                        // audio output device shall be set after the audio element is played\n                        // otherwise, the browser will not pick it up, and will always\n                        // play audio through the system's default device\n                        const { selectedDevice } = this.call.speaker.state;\n                        if (selectedDevice && \"setSinkId\" in audioElement) {\n                            audioElement.setSinkId(selectedDevice);\n                        }\n                    }\n                });\n            });\n            const sinkIdSubscription = !(\"setSinkId\" in audioElement) ? null : this.call.speaker.state.selectedDevice$.subscribe((deviceId)=>{\n                if (deviceId) {\n                    audioElement.setSinkId(deviceId);\n                }\n            });\n            const volumeSubscription = (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n                this.call.speaker.state.volume$,\n                participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(\"audioVolume\"))\n            ]).subscribe(([volume, p])=>{\n                audioElement.volume = p.audioVolume ?? volume;\n            });\n            audioElement.autoplay = true;\n            return ()=>{\n                sinkIdSubscription?.unsubscribe();\n                volumeSubscription.unsubscribe();\n                updateMediaStreamSubscription.unsubscribe();\n            };\n        };\n        this.call = call;\n    }\n}\n/**\n * Stores the permissions for the current user and exposes\n * a few helper methods which make it easier to work with permissions.\n *\n * This is an internal class meant to be used in combination with\n * a {@link Call} instance.\n *\n * @internal\n */ class PermissionsContext {\n    constructor(){\n        this.permissions = [];\n        /**\n         * Sets the permissions for the current user.\n         *\n         * @param permissions the permissions to set.\n         */ this.setPermissions = (permissions)=>{\n            this.permissions = permissions || [];\n        };\n        /**\n         * Sets the settings for the bound call.\n         * @param settings\n         */ this.setCallSettings = (settings)=>{\n            this.settings = settings;\n        };\n        /**\n         * Checks if the current user has a specific permission.\n         *\n         * @param permission the permission to check for.\n         */ this.hasPermission = (permission)=>{\n            return this.permissions.includes(permission);\n        };\n        /**\n         * Checks if the current user can request a specific permission\n         * within the call.\n         *\n         * @param permission the permission to check for.\n         * @param settings the call settings to check against (optional).\n         */ this.canRequest = (permission, settings = this.settings)=>{\n            if (!settings) return false;\n            const { audio, video, screensharing } = settings;\n            switch(permission){\n                case OwnCapability.SEND_AUDIO:\n                    return audio.access_request_enabled;\n                case OwnCapability.SEND_VIDEO:\n                    return video.access_request_enabled;\n                case OwnCapability.SCREENSHARE:\n                    return screensharing.access_request_enabled;\n                default:\n                    return false;\n            }\n        };\n    }\n}\n/**\n * Represents a call type.\n */ class CallType {\n    /**\n     * Constructs a new CallType.\n     *\n     * @param name the name of the call type.\n     * @param options the options for the call type.\n     */ constructor(name, options = {\n        sortParticipantsBy: defaultSortPreset\n    }){\n        this.name = name;\n        this.options = options;\n    }\n}\n/**\n * A registry of {@link CallType}s.\n * You can register and unregister call types.\n */ class CallTypesRegistry {\n    /**\n     * Constructs a new CallTypesRegistry.\n     *\n     * @param callTypes the initial call types to register.\n     */ constructor(callTypes){\n        /**\n         * Registers a new call type.\n         *\n         * @param callType the call type to register.\n         */ this.register = (callType)=>{\n            this.callTypes[callType.name] = callType;\n        };\n        /**\n         * Unregisters a call type.\n         *\n         * @param name the name of the call type to unregister.\n         */ this.unregister = (name)=>{\n            delete this.callTypes[name];\n        };\n        /**\n         * Gets a call type by name.\n         *\n         * @param name the name of the call type to get.\n         */ this.get = (name)=>{\n            if (!this.callTypes[name]) {\n                this.register(new CallType(name));\n            }\n            return this.callTypes[name];\n        };\n        this.callTypes = callTypes.reduce((acc, callType)=>{\n            acc[callType.name] = callType;\n            return acc;\n        }, {});\n    }\n}\n/**\n * The default call types registry.\n * You can use this instance to dynamically register and unregister call types.\n */ const CallTypes = new CallTypesRegistry([\n    new CallType(\"default\", {\n        sortParticipantsBy: defaultSortPreset\n    }),\n    new CallType(\"development\", {\n        sortParticipantsBy: defaultSortPreset\n    }),\n    new CallType(\"livestream\", {\n        sortParticipantsBy: livestreamOrAudioRoomSortPreset\n    }),\n    new CallType(\"audio_room\", {\n        sortParticipantsBy: livestreamOrAudioRoomSortPreset\n    })\n]);\n/**\n * Returns an Observable that emits the list of available devices\n * that meet the given constraints.\n *\n * @param constraints the constraints to use when requesting the devices.\n * @param kind the kind of devices to enumerate.\n */ const getDevices = (constraints, kind)=>{\n    return new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n        const enumerate = async ()=>{\n            let devices = await navigator.mediaDevices.enumerateDevices();\n            // some browsers report empty device labels (Firefox).\n            // in that case, we need to request permissions (via getUserMedia)\n            // to be able to get the device labels\n            const needsGetUserMedia = devices.some((device)=>device.kind === kind && device.label === \"\");\n            if (needsGetUserMedia) {\n                let mediaStream;\n                try {\n                    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\n                    devices = await navigator.mediaDevices.enumerateDevices();\n                } finally{\n                    if (mediaStream) disposeOfMediaStream(mediaStream);\n                }\n            }\n            return devices;\n        };\n        enumerate().then((devices)=>{\n            // notify subscribers and complete\n            subscriber.next(devices);\n            subscriber.complete();\n        }).catch((error)=>{\n            const logger = getLogger([\n                \"devices\"\n            ]);\n            logger(\"error\", \"Failed to enumerate devices\", error);\n            subscriber.error(error);\n        });\n    });\n};\n/**\n * [Tells if the browser supports audio output change on 'audio' elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n *\n *  */ const checkIfAudioOutputChangeSupported = ()=>{\n    if (typeof document === \"undefined\") return false;\n    const element = document.createElement(\"audio\");\n    return \"setSinkId\" in element;\n};\n/**\n * The default constraints used to request audio devices.\n */ const audioDeviceConstraints = {\n    audio: {\n        autoGainControl: true,\n        noiseSuppression: true,\n        echoCancellation: true\n    }\n};\n/**\n * The default constraints used to request video devices.\n */ const videoDeviceConstraints = {\n    video: {\n        width: 1280,\n        height: 720\n    }\n};\n/**\n * Creates a memoized observable instance\n * that will be created only once and shared between all callers.\n *\n * @param create a function that creates an Observable.\n */ const memoizedObservable = (create)=>{\n    let memoized;\n    return ()=>{\n        if (!memoized) memoized = create();\n        return memoized;\n    };\n};\nconst getDeviceChangeObserver = memoizedObservable(()=>{\n    // Audio and video devices are requested in two separate requests.\n    // That way, users will be presented with two separate prompts\n    // -> they can give access to just camera, or just microphone\n    return new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n        // 'addEventListener' is not available in React Native\n        if (!navigator.mediaDevices.addEventListener) return;\n        const notify = ()=>subscriber.next();\n        navigator.mediaDevices.addEventListener(\"devicechange\", notify);\n        return ()=>{\n            navigator.mediaDevices.removeEventListener(\"devicechange\", notify);\n        };\n    }).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__.debounceTime)(500), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__.concatMap)(()=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__.from)(navigator.mediaDevices.enumerateDevices())), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getAudioDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(audioDeviceConstraints, \"audioinput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getAudioOutputDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(audioDeviceConstraints, \"audiooutput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getVideoDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(videoDeviceConstraints, \"videoinput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\n/**\n * Prompts the user for a permission to use audio devices (if not already granted) and lists the available 'audioinput' devices, if devices are added/removed the list is updated.\n */ const getAudioDevices = ()=>{\n    return getAudioDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"audioinput\")));\n};\n/**\n * Prompts the user for a permission to use video devices (if not already granted) and lists the available 'videoinput' devices, if devices are added/removed the list is updated.\n */ const getVideoDevices = ()=>{\n    return getVideoDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"videoinput\")));\n};\n/**\n * Prompts the user for a permission to use audio devices (if not already granted) and lists the available 'audiooutput' devices, if devices are added/removed the list is updated. Selecting 'audiooutput' device only makes sense if [the browser has support for changing audio output on 'audio' elements](#checkifaudiooutputchangesupported)\n */ const getAudioOutputDevices = ()=>{\n    return getAudioOutputDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"audiooutput\")));\n};\nconst getStream = async (constraints)=>{\n    try {\n        return await navigator.mediaDevices.getUserMedia(constraints);\n    } catch (e) {\n        getLogger([\n            \"devices\"\n        ])(\"error\", `Failed get user media`, {\n            error: e,\n            constraints: constraints\n        });\n        throw e;\n    }\n};\n/**\n * Returns an audio media stream that fulfills the given constraints.\n * If no constraints are provided, it uses the browser's default ones.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n * @param trackConstraints the constraints to use when requesting the stream.\n * @returns the new `MediaStream` fulfilling the given constraints.\n */ const getAudioStream = async (trackConstraints)=>{\n    const constraints = {\n        audio: {\n            ...audioDeviceConstraints.audio,\n            ...trackConstraints\n        }\n    };\n    return getStream(constraints);\n};\n/**\n * Returns a video media stream that fulfills the given constraints.\n * If no constraints are provided, it uses the browser's default ones.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n * @param trackConstraints the constraints to use when requesting the stream.\n * @returns a new `MediaStream` fulfilling the given constraints.\n */ const getVideoStream = async (trackConstraints)=>{\n    const constraints = {\n        video: {\n            ...videoDeviceConstraints.video,\n            ...trackConstraints\n        }\n    };\n    return getStream(constraints);\n};\n/**\n * Prompts the user for a permission to share a screen.\n * If the user grants the permission, a screen sharing stream is returned. Throws otherwise.\n *\n * The callers of this API are responsible to handle the possible errors.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n *\n * @param options any additional options to pass to the [`getDisplayMedia`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia) API.\n */ const getScreenShareStream = async (options)=>{\n    try {\n        return await navigator.mediaDevices.getDisplayMedia({\n            video: true,\n            audio: {\n                channelCount: {\n                    ideal: 2\n                },\n                echoCancellation: false,\n                autoGainControl: false,\n                noiseSuppression: false\n            },\n            // @ts-expect-error - not present in types yet\n            systemAudio: \"include\",\n            ...options\n        });\n    } catch (e) {\n        getLogger([\n            \"devices\"\n        ])(\"error\", \"Failed to get screen share stream\", e);\n        throw e;\n    }\n};\nconst deviceIds$ = typeof navigator !== \"undefined\" && typeof navigator.mediaDevices !== \"undefined\" ? memoizedObservable(()=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__.from)(navigator.mediaDevices.enumerateDevices()), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1)))() : undefined;\n/**\n * Deactivates MediaStream (stops and removes tracks) to be later garbage collected\n *\n * @param stream MediaStream\n * @returns void\n */ const disposeOfMediaStream = (stream)=>{\n    if (!stream.active) return;\n    stream.getTracks().forEach((track)=>{\n        track.stop();\n        stream.removeTrack(track);\n    });\n    // @ts-expect-error release() is present in react-native-webrtc and must be called to dispose the stream\n    if (typeof stream.release === \"function\") {\n        // @ts-expect-error\n        stream.release();\n    }\n};\nclass InputMediaDeviceManager {\n    constructor(call, state, trackType){\n        this.call = call;\n        this.state = state;\n        this.trackType = trackType;\n        /**\n         * if true, stops the media stream when call is left\n         */ this.stopOnLeave = true;\n        this.subscriptions = [];\n        this.isTrackStoppedDueToTrackEnd = false;\n        this.filters = [];\n        /**\n         * Disposes the manager.\n         *\n         * @internal\n         */ this.dispose = ()=>{\n            this.subscriptions.forEach((s)=>s());\n        };\n        this.logger = getLogger([\n            `${TrackType[trackType].toLowerCase()} manager`\n        ]);\n        if (deviceIds$ && !isReactNative() && (this.trackType === TrackType.AUDIO || this.trackType === TrackType.VIDEO)) {\n            this.handleDisconnectedOrReplacedDevices();\n        }\n    }\n    /**\n     * Lists the available audio/video devices\n     *\n     * Note: It prompts the user for a permission to use devices (if not already granted)\n     *\n     * @returns an Observable that will be updated if a device is connected or disconnected\n     */ listDevices() {\n        return this.getDevices();\n    }\n    /**\n     * Starts stream.\n     */ async enable() {\n        if (this.state.status === \"enabled\") return;\n        this.enablePromise = this.unmuteStream();\n        try {\n            await this.enablePromise;\n            this.state.setStatus(\"enabled\");\n            this.enablePromise = undefined;\n        } catch (error) {\n            this.enablePromise = undefined;\n            throw error;\n        }\n    }\n    /**\n     * Stops or pauses the stream based on state.disableMode\n     * @param {boolean} [forceStop=false] when true, stops the tracks regardless of the state.disableMode\n     */ async disable(forceStop = false) {\n        this.state.prevStatus = this.state.status;\n        if (!forceStop && this.state.status === \"disabled\") return;\n        const stopTracks = forceStop || this.state.disableMode === \"stop-tracks\";\n        this.disablePromise = this.muteStream(stopTracks);\n        try {\n            await this.disablePromise;\n            this.state.setStatus(\"disabled\");\n            this.disablePromise = undefined;\n        } catch (error) {\n            this.disablePromise = undefined;\n            throw error;\n        }\n    }\n    /**\n     * If status was previously enabled, it will re-enable the device.\n     */ async resume() {\n        if (this.state.prevStatus === \"enabled\" && this.state.status === \"disabled\") {\n            await this.enable();\n        }\n    }\n    /**\n     * If the current device status is disabled, it will enable the device,\n     * else it will disable it.\n     */ async toggle() {\n        if (this.state.status === \"enabled\") {\n            return this.disable();\n        } else {\n            return this.enable();\n        }\n    }\n    /**\n     * Registers a filter that will be applied to the stream.\n     *\n     * The registered filter will get the existing stream, and it should return\n     * a new stream with the applied filter.\n     *\n     * @param filter the filter to register.\n     * @returns a function that will unregister the filter.\n     */ async registerFilter(filter) {\n        this.filters.push(filter);\n        await this.applySettingsToStream();\n        return async ()=>{\n            this.filters = this.filters.filter((f)=>f !== filter);\n            await this.applySettingsToStream();\n        };\n    }\n    /**\n     * Will set the default constraints for the device.\n     *\n     * @param constraints the constraints to set.\n     */ setDefaultConstraints(constraints) {\n        this.state.setDefaultConstraints(constraints);\n    }\n    /**\n     * Selects a device.\n     *\n     * Note: This method is not supported in React Native\n     * @param deviceId the device id to select.\n     */ async select(deviceId) {\n        if (isReactNative()) {\n            throw new Error(\"This method is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for reference.\");\n        }\n        if (deviceId === this.state.selectedDevice) {\n            return;\n        }\n        this.state.setDevice(deviceId);\n        await this.applySettingsToStream();\n    }\n    async applySettingsToStream() {\n        if (this.state.status === \"enabled\") {\n            await this.muteStream();\n            await this.unmuteStream();\n        }\n    }\n    getTracks() {\n        return this.state.mediaStream?.getTracks() ?? [];\n    }\n    async muteStream(stopTracks = true) {\n        if (!this.state.mediaStream) return;\n        this.logger(\"debug\", `${stopTracks ? \"Stopping\" : \"Disabling\"} stream`);\n        if (this.call.state.callingState === CallingState.JOINED) {\n            await this.stopPublishStream(stopTracks);\n        }\n        this.muteLocalStream(stopTracks);\n        const allEnded = this.getTracks().every((t)=>t.readyState === \"ended\");\n        if (allEnded) {\n            if (this.state.mediaStream && // @ts-expect-error release() is present in react-native-webrtc\n            typeof this.state.mediaStream.release === \"function\") {\n                // @ts-expect-error called to dispose the stream in RN\n                this.state.mediaStream.release();\n            }\n            this.state.setMediaStream(undefined);\n        }\n    }\n    muteTracks() {\n        this.getTracks().forEach((track)=>{\n            if (track.enabled) track.enabled = false;\n        });\n    }\n    unmuteTracks() {\n        this.getTracks().forEach((track)=>{\n            if (!track.enabled) track.enabled = true;\n        });\n    }\n    stopTracks() {\n        this.getTracks().forEach((track)=>{\n            if (track.readyState === \"live\") track.stop();\n        });\n    }\n    muteLocalStream(stopTracks) {\n        if (!this.state.mediaStream) {\n            return;\n        }\n        if (stopTracks) {\n            this.stopTracks();\n        } else {\n            this.muteTracks();\n        }\n    }\n    async unmuteStream() {\n        this.logger(\"debug\", \"Starting stream\");\n        let stream;\n        if (this.state.mediaStream && this.getTracks().every((t)=>t.readyState === \"live\")) {\n            stream = this.state.mediaStream;\n            this.unmuteTracks();\n        } else {\n            const defaultConstraints = this.state.defaultConstraints;\n            const constraints = {\n                ...defaultConstraints,\n                deviceId: this.state.selectedDevice\n            };\n            /**\n             * Chains two media streams together.\n             *\n             * In our case, filters MediaStreams are derived from their parent MediaStream.\n             * However, once a child filter's track is stopped,\n             * the tracks of the parent MediaStream aren't automatically stopped.\n             * This leads to a situation where the camera indicator light is still on\n             * even though the user stopped publishing video.\n             *\n             * This function works around this issue by stopping the parent MediaStream's tracks\n             * as well once the child filter's tracks are stopped.\n             *\n             * It works by patching the stop() method of the child filter's tracks to also stop\n             * the parent MediaStream's tracks of the same type. Here we assume that\n             * the parent MediaStream has only one track of each type.\n             *\n             * @param parentStream the parent MediaStream. Omit for the root stream.\n             */ const chainWith = (parentStream)=>async (filterStream)=>{\n                    if (!parentStream) return filterStream;\n                    // TODO OL: take care of track.enabled property as well\n                    const parent = await parentStream;\n                    filterStream.getTracks().forEach((track)=>{\n                        const originalStop = track.stop;\n                        track.stop = function stop() {\n                            originalStop.call(track);\n                            parent.getTracks().forEach((parentTrack)=>{\n                                if (parentTrack.kind === track.kind) {\n                                    parentTrack.stop();\n                                }\n                            });\n                        };\n                    });\n                    parent.getTracks().forEach((parentTrack)=>{\n                        // When the parent stream abruptly ends, we propagate the event\n                        // to the filter stream.\n                        // This usually happens when the camera/microphone permissions\n                        // are revoked or when the device is disconnected.\n                        const handleParentTrackEnded = ()=>{\n                            filterStream.getTracks().forEach((track)=>{\n                                if (parentTrack.kind !== track.kind) return;\n                                track.stop();\n                                track.dispatchEvent(new Event(\"ended\")); // propagate the event\n                            });\n                        };\n                        parentTrack.addEventListener(\"ended\", handleParentTrackEnded);\n                        this.subscriptions.push(()=>{\n                            parentTrack.removeEventListener(\"ended\", handleParentTrackEnded);\n                        });\n                    });\n                    return filterStream;\n                };\n            // we publish the last MediaStream of the chain\n            stream = await this.filters.reduce((parent, filter)=>parent.then(filter).then(chainWith(parent)), this.getStream(constraints));\n        }\n        if (this.call.state.callingState === CallingState.JOINED) {\n            await this.publishStream(stream);\n        }\n        if (this.state.mediaStream !== stream) {\n            this.state.setMediaStream(stream);\n            this.getTracks().forEach((track)=>{\n                track.addEventListener(\"ended\", async ()=>{\n                    if (this.enablePromise) {\n                        await this.enablePromise;\n                    }\n                    if (this.disablePromise) {\n                        await this.disablePromise;\n                    }\n                    if (this.state.status === \"enabled\") {\n                        this.isTrackStoppedDueToTrackEnd = true;\n                        setTimeout(()=>{\n                            this.isTrackStoppedDueToTrackEnd = false;\n                        }, 2000);\n                        await this.disable();\n                    }\n                });\n            });\n        }\n    }\n    get mediaDeviceKind() {\n        if (this.trackType === TrackType.AUDIO) {\n            return \"audioinput\";\n        }\n        if (this.trackType === TrackType.VIDEO) {\n            return \"videoinput\";\n        }\n        return \"\";\n    }\n    handleDisconnectedOrReplacedDevices() {\n        this.subscriptions.push(createSubscription((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n            deviceIds$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_30__.pairwise)()),\n            this.state.selectedDevice$\n        ]), async ([[prevDevices, currentDevices], deviceId])=>{\n            if (!deviceId) {\n                return;\n            }\n            if (this.enablePromise) {\n                await this.enablePromise;\n            }\n            if (this.disablePromise) {\n                await this.disablePromise;\n            }\n            let isDeviceDisconnected = false;\n            let isDeviceReplaced = false;\n            const currentDevice = this.findDeviceInList(currentDevices, deviceId);\n            const prevDevice = this.findDeviceInList(prevDevices, deviceId);\n            if (!currentDevice && prevDevice) {\n                isDeviceDisconnected = true;\n            } else if (currentDevice && prevDevice && currentDevice.deviceId === prevDevice.deviceId && currentDevice.groupId !== prevDevice.groupId) {\n                isDeviceReplaced = true;\n            }\n            if (isDeviceDisconnected) {\n                await this.disable();\n                this.select(undefined);\n            }\n            if (isDeviceReplaced) {\n                if (this.isTrackStoppedDueToTrackEnd && this.state.status === \"disabled\") {\n                    await this.enable();\n                    this.isTrackStoppedDueToTrackEnd = false;\n                } else {\n                    await this.applySettingsToStream();\n                }\n            }\n        }));\n    }\n    findDeviceInList(devices, deviceId) {\n        return devices.find((d)=>d.deviceId === deviceId && d.kind === this.mediaDeviceKind);\n    }\n}\nclass InputMediaDeviceManagerState {\n    /**\n     * Constructs new InputMediaDeviceManagerState instance.\n     *\n     * @param disableMode the disable mode to use.\n     * @param permissionName the permission name to use for querying.\n     * `undefined` means no permission is required.\n     */ constructor(disableMode = \"stop-tracks\", permissionName = undefined){\n        this.disableMode = disableMode;\n        this.permissionName = permissionName;\n        this.statusSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.mediaStreamSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.selectedDeviceSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.defaultConstraintsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * An Observable that emits the current media stream, or `undefined` if the device is currently disabled.\n         *\n         */ this.mediaStream$ = this.mediaStreamSubject.asObservable();\n        /**\n         * An Observable that emits the currently selected device\n         */ this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * An Observable that emits the device status\n         */ this.status$ = this.statusSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * The default constraints for the device.\n         */ this.defaultConstraints$ = this.defaultConstraintsSubject.asObservable();\n        /**\n         * An observable that will emit `true` if browser/system permission\n         * is granted, `false` otherwise.\n         */ this.hasBrowserPermission$ = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n            const notifyGranted = ()=>subscriber.next(true);\n            const permissionsAPIAvailable = !!navigator?.permissions?.query;\n            if (isReactNative() || !this.permissionName || !permissionsAPIAvailable) {\n                getLogger([\n                    \"devices\"\n                ])(\"warn\", `Permissions can't be queried. Assuming granted.`);\n                return notifyGranted();\n            }\n            let permissionState;\n            const notify = ()=>{\n                subscriber.next(// In some browsers, the 'change' event doesn't reliably emit and hence,\n                // permissionState stays in 'prompt' state forever.\n                // Typically, this happens when a user grants one-time permission.\n                // Instead of checking if a permission is granted, we check if it isn't denied\n                permissionState.state !== \"denied\");\n            };\n            navigator.permissions.query({\n                name: this.permissionName\n            }).then((permissionStatus)=>{\n                permissionState = permissionStatus;\n                permissionState.addEventListener(\"change\", notify);\n                notify();\n            }).catch(()=>{\n                // permission doesn't exist or can't be queried -> assume it's granted\n                // an example would be Firefox,\n                // where neither camera microphone permission can be queried\n                notifyGranted();\n            });\n            return ()=>{\n                permissionState?.removeEventListener(\"change\", notify);\n            };\n        }).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n    }\n    /**\n     * The device status\n     */ get status() {\n        return this.getCurrentValue(this.status$);\n    }\n    /**\n     * The currently selected device\n     */ get selectedDevice() {\n        return this.getCurrentValue(this.selectedDevice$);\n    }\n    /**\n     * The current media stream, or `undefined` if the device is currently disabled.\n     */ get mediaStream() {\n        return this.getCurrentValue(this.mediaStream$);\n    }\n    /**\n     * @internal\n     * @param status\n     */ setStatus(status) {\n        this.setCurrentValue(this.statusSubject, status);\n    }\n    /**\n     * @internal\n     * @param stream the stream to set.\n     */ setMediaStream(stream) {\n        this.setCurrentValue(this.mediaStreamSubject, stream);\n        if (stream) {\n            this.setDevice(this.getDeviceIdFromStream(stream));\n        }\n    }\n    /**\n     * @internal\n     * @param deviceId the device id to set.\n     */ setDevice(deviceId) {\n        this.setCurrentValue(this.selectedDeviceSubject, deviceId);\n    }\n    /**\n     * Gets the default constraints for the device.\n     */ get defaultConstraints() {\n        return this.getCurrentValue(this.defaultConstraints$);\n    }\n    /**\n     * Sets the default constraints for the device.\n     *\n     * @internal\n     * @param constraints the constraints to set.\n     */ setDefaultConstraints(constraints) {\n        this.setCurrentValue(this.defaultConstraintsSubject, constraints);\n    }\n}\nclass CameraManagerState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(\"stop-tracks\", // `camera` is not in the W3C standard yet,\n        // but it's supported by Chrome and Safari.\n        \"camera\");\n        this.directionSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.direction$ = this.directionSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * The preferred camera direction\n     * front - means the camera facing the user\n     * back - means the camera facing the environment\n     */ get direction() {\n        return this.getCurrentValue(this.direction$);\n    }\n    /**\n     * @internal\n     */ setDirection(direction) {\n        this.setCurrentValue(this.directionSubject, direction);\n    }\n    /**\n     * @internal\n     */ setMediaStream(stream) {\n        super.setMediaStream(stream);\n        if (stream) {\n            // RN getSettings() doesn't return facingMode, so we don't verify camera direction\n            const direction = isReactNative() ? this.direction : stream.getVideoTracks()[0]?.getSettings().facingMode === \"environment\" ? \"back\" : \"front\";\n            this.setDirection(direction);\n        }\n    }\n    getDeviceIdFromStream(stream) {\n        return stream.getVideoTracks()[0]?.getSettings().deviceId;\n    }\n}\nclass CameraManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new CameraManagerState(), TrackType.VIDEO);\n        this.targetResolution = {\n            width: 1280,\n            height: 720\n        };\n    }\n    /**\n     * Select the camera direction.\n     *\n     * @param direction the direction of the camera to select.\n     */ async selectDirection(direction) {\n        this.state.setDirection(direction);\n        // Providing both device id and direction doesn't work, so we deselect the device\n        this.state.setDevice(undefined);\n        await this.applySettingsToStream();\n    }\n    /**\n     * Flips the camera direction: if it's front it will change to back, if it's back, it will change to front.\n     *\n     * Note: if there is no available camera with the desired direction, this method will do nothing.\n     * @returns\n     */ async flip() {\n        const newDirection = this.state.direction === \"front\" ? \"back\" : \"front\";\n        await this.selectDirection(newDirection);\n    }\n    /**\n     * @internal\n     */ async selectTargetResolution(resolution) {\n        this.targetResolution.height = resolution.height;\n        this.targetResolution.width = resolution.width;\n        if (this.enablePromise) {\n            try {\n                await this.enablePromise;\n            } catch (error) {\n                // couldn't enable device, target resolution will be applied the next time user attempts to start the device\n                this.logger(\"warn\", \"could not apply target resolution\", error);\n            }\n        }\n        if (this.state.status === \"enabled\") {\n            const { width, height } = this.state.mediaStream.getVideoTracks()[0]?.getSettings();\n            if (width !== this.targetResolution.width || height !== this.targetResolution.height) {\n                await this.applySettingsToStream();\n                this.logger(\"debug\", `${width}x${height} target resolution applied to media stream`);\n            }\n        }\n    }\n    /**\n     * Sets the preferred codec for encoding the video.\n     *\n     * @internal internal use only, not part of the public API.\n     * @param codec the codec to use for encoding the video.\n     */ setPreferredCodec(codec) {\n        this.preferredCodec = codec;\n    }\n    getDevices() {\n        return getVideoDevices();\n    }\n    getStream(constraints) {\n        constraints.width = this.targetResolution.width;\n        constraints.height = this.targetResolution.height;\n        // We can't set both device id and facing mode\n        // Device id has higher priority\n        if (!constraints.deviceId && this.state.direction) {\n            constraints.facingMode = this.state.direction === \"front\" ? \"user\" : \"environment\";\n        }\n        return getVideoStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishVideoStream(stream, {\n            preferredCodec: this.preferredCodec\n        });\n    }\n    stopPublishStream(stopTracks) {\n        return this.call.stopPublish(TrackType.VIDEO, stopTracks);\n    }\n}\nclass MicrophoneManagerState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(\"disable-tracks\", // `microphone` is not in the W3C standard yet,\n        // but it's supported by Chrome and Safari.\n        \"microphone\");\n        this.speakingWhileMutedSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.speakingWhileMuted$ = this.speakingWhileMutedSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * `true` if the user's microphone is muted but they'are speaking.\n     *\n     * This feature is not available in the React Native SDK.\n     */ get speakingWhileMuted() {\n        return this.getCurrentValue(this.speakingWhileMuted$);\n    }\n    /**\n     * @internal\n     */ setSpeakingWhileMuted(isSpeaking) {\n        this.setCurrentValue(this.speakingWhileMutedSubject, isSpeaking);\n    }\n    getDeviceIdFromStream(stream) {\n        return stream.getAudioTracks()[0]?.getSettings().deviceId;\n    }\n}\nconst DETECTION_FREQUENCY_IN_MS = 500;\nconst AUDIO_LEVEL_THRESHOLD$1 = 150;\nconst FFT_SIZE = 128;\n/**\n * Creates a new sound detector.\n *\n * @param audioStream the audio stream to observe. Depending on the provided configuration, this stream might be destroyed when the sound detector is stopped.\n * @param onSoundDetectedStateChanged a callback which is called when the sound state changes.\n * @param options custom options for the sound detector.\n * @returns a clean-up function which once invoked stops the sound detector.\n */ const createSoundDetector = (audioStream, onSoundDetectedStateChanged, options = {})=>{\n    const { detectionFrequencyInMs = DETECTION_FREQUENCY_IN_MS, audioLevelThreshold = AUDIO_LEVEL_THRESHOLD$1, fftSize = FFT_SIZE, destroyStreamOnStop = true } = options;\n    const audioContext = new AudioContext();\n    const analyser = audioContext.createAnalyser();\n    analyser.fftSize = fftSize;\n    const microphone = audioContext.createMediaStreamSource(audioStream);\n    microphone.connect(analyser);\n    const intervalId = setInterval(()=>{\n        const data = new Uint8Array(analyser.frequencyBinCount);\n        analyser.getByteFrequencyData(data);\n        const isSoundDetected = data.some((value)=>value >= audioLevelThreshold);\n        const averagedDataValue = data.reduce((pv, cv)=>pv + cv, 0) / data.length;\n        const percentage = averagedDataValue > audioLevelThreshold ? 100 : Math.round(averagedDataValue / audioLevelThreshold * 100);\n        // When the track is disabled, it takes time for the buffer to empty\n        // This check will ensure that we don't send anything if the track is disabled\n        if (audioStream.getAudioTracks()[0]?.enabled) {\n            onSoundDetectedStateChanged({\n                isSoundDetected,\n                audioLevel: percentage\n            });\n        } else {\n            onSoundDetectedStateChanged({\n                isSoundDetected: false,\n                audioLevel: 0\n            });\n        }\n    }, detectionFrequencyInMs);\n    return async function stop() {\n        clearInterval(intervalId);\n        // clean-up the AudioContext elements\n        microphone.disconnect();\n        analyser.disconnect();\n        await audioContext.close();\n        // stop the stream\n        if (destroyStreamOnStop) {\n            audioStream.getTracks().forEach((track)=>{\n                track.stop();\n                audioStream.removeTrack(track);\n            });\n        }\n    };\n};\n/**\n * Flatten the stats report into an array of stats objects.\n *\n * @param report the report to flatten.\n */ const flatten = (report)=>{\n    const stats = [];\n    report.forEach((s)=>{\n        stats.push(s);\n    });\n    return stats;\n};\nconst AUDIO_LEVEL_THRESHOLD = 0.2;\nclass RNSpeechDetector {\n    constructor(){\n        this.pc1 = new RTCPeerConnection({});\n        this.pc2 = new RTCPeerConnection({});\n    }\n    /**\n     * Starts the speech detection.\n     */ async start() {\n        try {\n            const audioStream = await navigator.mediaDevices.getUserMedia({\n                audio: true\n            });\n            this.pc1.addEventListener(\"icecandidate\", async (e)=>{\n                await this.pc2.addIceCandidate(e.candidate);\n            });\n            this.pc2.addEventListener(\"icecandidate\", async (e)=>{\n                await this.pc1.addIceCandidate(e.candidate);\n            });\n            audioStream.getTracks().forEach((track)=>this.pc1.addTrack(track, audioStream));\n            const offer = await this.pc1.createOffer({});\n            await this.pc2.setRemoteDescription(offer);\n            await this.pc1.setLocalDescription(offer);\n            const answer = await this.pc2.createAnswer();\n            await this.pc1.setRemoteDescription(answer);\n            await this.pc2.setLocalDescription(answer);\n            const audioTracks = audioStream.getAudioTracks();\n            // We need to mute the audio track for this temporary stream, or else you will hear yourself twice while in the call.\n            audioTracks.forEach((track)=>track.enabled = false);\n        } catch (error) {\n            console.error(\"Error connecting and negotiating between PeerConnections:\", error);\n        }\n    }\n    /**\n     * Stops the speech detection and releases all allocated resources.\n     */ stop() {\n        this.pc1.close();\n        this.pc2.close();\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    /**\n     * Public method that detects the audio levels and returns the status.\n     */ onSpeakingDetectedStateChange(onSoundDetectedStateChanged) {\n        this.intervalId = setInterval(async ()=>{\n            const stats = await this.pc1.getStats();\n            const report = flatten(stats);\n            // Audio levels are present inside stats of type `media-source` and of kind `audio`\n            const audioMediaSourceStats = report.find((stat)=>stat.type === \"media-source\" && stat.kind === \"audio\");\n            if (audioMediaSourceStats) {\n                const { audioLevel } = audioMediaSourceStats;\n                if (audioLevel) {\n                    if (audioLevel >= AUDIO_LEVEL_THRESHOLD) {\n                        onSoundDetectedStateChanged({\n                            isSoundDetected: true,\n                            audioLevel\n                        });\n                    } else {\n                        onSoundDetectedStateChanged({\n                            isSoundDetected: false,\n                            audioLevel: 0\n                        });\n                    }\n                }\n            }\n        }, 1000);\n        return ()=>{\n            clearInterval(this.intervalId);\n        };\n    }\n}\nclass MicrophoneManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new MicrophoneManagerState(), TrackType.AUDIO);\n        (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n            this.call.state.callingState$,\n            this.call.state.ownCapabilities$,\n            this.state.selectedDevice$,\n            this.state.status$\n        ]).subscribe(async ([callingState, ownCapabilities, deviceId, status])=>{\n            if (callingState !== CallingState.JOINED) {\n                if (callingState === CallingState.LEFT) {\n                    await this.stopSpeakingWhileMutedDetection();\n                }\n                return;\n            }\n            if (ownCapabilities.includes(OwnCapability.SEND_AUDIO)) {\n                if (status === \"disabled\") {\n                    await this.startSpeakingWhileMutedDetection(deviceId);\n                } else {\n                    await this.stopSpeakingWhileMutedDetection();\n                }\n            } else {\n                await this.stopSpeakingWhileMutedDetection();\n            }\n        });\n    }\n    getDevices() {\n        return getAudioDevices();\n    }\n    getStream(constraints) {\n        return getAudioStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishAudioStream(stream);\n    }\n    stopPublishStream(stopTracks) {\n        return this.call.stopPublish(TrackType.AUDIO, stopTracks);\n    }\n    async startSpeakingWhileMutedDetection(deviceId) {\n        await this.stopSpeakingWhileMutedDetection();\n        if (isReactNative()) {\n            this.rnSpeechDetector = new RNSpeechDetector();\n            await this.rnSpeechDetector.start();\n            const unsubscribe = this.rnSpeechDetector?.onSpeakingDetectedStateChange((event)=>{\n                this.state.setSpeakingWhileMuted(event.isSoundDetected);\n            });\n            this.soundDetectorCleanup = ()=>{\n                unsubscribe();\n                this.rnSpeechDetector?.stop();\n                this.rnSpeechDetector = undefined;\n            };\n        } else {\n            // Need to start a new stream that's not connected to publisher\n            const stream = await this.getStream({\n                deviceId\n            });\n            this.soundDetectorCleanup = createSoundDetector(stream, (event)=>{\n                this.state.setSpeakingWhileMuted(event.isSoundDetected);\n            });\n        }\n    }\n    async stopSpeakingWhileMutedDetection() {\n        if (!this.soundDetectorCleanup) {\n            return;\n        }\n        this.state.setSpeakingWhileMuted(false);\n        try {\n            await this.soundDetectorCleanup();\n        } finally{\n            this.soundDetectorCleanup = undefined;\n        }\n    }\n}\nclass ScreenShareState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(...arguments);\n        this.audioEnabledSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(true);\n        this.settingsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * An Observable that emits the current screen share audio status.\n         */ this.audioEnabled$ = this.audioEnabledSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * An Observable that emits the current screen share settings.\n         */ this.settings$ = this.settingsSubject.asObservable();\n        /**\n         * @internal\n         */ this.getDeviceIdFromStream = (stream)=>{\n            const [track] = stream.getTracks();\n            return track?.getSettings().deviceId;\n        };\n    }\n    /**\n     * The current screen share audio status.\n     */ get audioEnabled() {\n        return this.getCurrentValue(this.audioEnabled$);\n    }\n    /**\n     * Set the current screen share audio status.\n     */ setAudioEnabled(isEnabled) {\n        this.setCurrentValue(this.audioEnabledSubject, isEnabled);\n    }\n    /**\n     * The current screen share settings.\n     */ get settings() {\n        return this.getCurrentValue(this.settings$);\n    }\n    /**\n     * Set the current screen share settings.\n     *\n     * @param settings the screen share settings to set.\n     */ setSettings(settings) {\n        this.setCurrentValue(this.settingsSubject, settings);\n    }\n}\nclass ScreenShareManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new ScreenShareState(), TrackType.SCREEN_SHARE);\n    }\n    /**\n     * Will enable screen share audio options on supported platforms.\n     *\n     * Note: for ongoing screen share, audio won't be enabled until you\n     * re-publish the screen share stream.\n     */ enableScreenShareAudio() {\n        this.state.setAudioEnabled(true);\n    }\n    /**\n     * Will disable screen share audio options on supported platforms.\n     */ async disableScreenShareAudio() {\n        this.state.setAudioEnabled(false);\n        if (this.call.publisher?.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {\n            await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO, true);\n        }\n    }\n    /**\n     * Returns the current screen share settings.\n     */ getSettings() {\n        return this.state.settings;\n    }\n    /**\n     * Sets the current screen share settings.\n     *\n     * @param settings the settings to set.\n     */ setSettings(settings) {\n        this.state.setSettings(settings);\n    }\n    getDevices() {\n        return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_31__.of)([]); // there are no devices to be listed for Screen Share\n    }\n    getStream(constraints) {\n        if (!this.state.audioEnabled) {\n            constraints.audio = false;\n        }\n        return getScreenShareStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishScreenShareStream(stream, {\n            screenShareSettings: this.state.settings\n        });\n    }\n    async stopPublishStream(stopTracks) {\n        await this.call.stopPublish(TrackType.SCREEN_SHARE, stopTracks);\n        await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO, stopTracks);\n    }\n    /**\n     * Overrides the default `select` method to throw an error.\n     *\n     * @param deviceId ignored.\n     */ async select(deviceId) {\n        throw new Error(\"This method is not supported in for Screen Share\");\n    }\n}\nclass SpeakerState {\n    constructor(){\n        this.selectedDeviceSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(\"\");\n        this.volumeSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(1);\n        /**\n         * [Tells if the browser supports audio output change on 'audio' elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n         */ this.isDeviceSelectionSupported = checkIfAudioOutputChangeSupported();\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        this.volume$ = this.volumeSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * The currently selected device\n     *\n     * Note: this feature is not supported in React Native\n     */ get selectedDevice() {\n        return this.getCurrentValue(this.selectedDevice$);\n    }\n    /**\n     * The currently selected volume\n     *\n     * Note: this feature is not supported in React Native\n     */ get volume() {\n        return this.getCurrentValue(this.volume$);\n    }\n    /**\n     * @internal\n     * @param deviceId\n     */ setDevice(deviceId) {\n        this.setCurrentValue(this.selectedDeviceSubject, deviceId);\n    }\n    /**\n     * @internal\n     * @param volume\n     */ setVolume(volume) {\n        this.setCurrentValue(this.volumeSubject, volume);\n    }\n}\nclass SpeakerManager {\n    constructor(call){\n        this.state = new SpeakerState();\n        this.subscriptions = [];\n        /**\n         * Disposes the manager.\n         *\n         * @internal\n         */ this.dispose = ()=>{\n            this.subscriptions.forEach((s)=>s.unsubscribe());\n        };\n        this.call = call;\n        if (deviceIds$ && !isReactNative()) {\n            this.subscriptions.push((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n                deviceIds$,\n                this.state.selectedDevice$\n            ]).subscribe(([devices, deviceId])=>{\n                if (!deviceId) {\n                    return;\n                }\n                const device = devices.find((d)=>d.deviceId === deviceId && d.kind === \"audiooutput\");\n                if (!device) {\n                    this.select(\"\");\n                }\n            }));\n        }\n    }\n    /**\n     * Lists the available audio output devices\n     *\n     * Note: It prompts the user for a permission to use devices (if not already granted)\n     * Note: This method is not supported in React Native\n     *\n     * @returns an Observable that will be updated if a device is connected or disconnected\n     */ listDevices() {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        return getAudioOutputDevices();\n    }\n    /**\n     * Select a device.\n     *\n     * Note: This method is not supported in React Native\n     *\n     * @param deviceId empty string means the system default\n     */ select(deviceId) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        this.state.setDevice(deviceId);\n    }\n    /**\n     * Set the volume of the audio elements\n     * @param volume a number between 0 and 1.\n     *\n     * Note: This method is not supported in React Native\n     */ setVolume(volume) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        if (volume && (volume < 0 || volume > 1)) {\n            throw new Error(\"Volume must be between 0 and 1\");\n        }\n        this.state.setVolume(volume);\n    }\n    /**\n     * Set the volume of a participant.\n     *\n     * Note: This method is not supported in React Native.\n     *\n     * @param sessionId the participant's session id.\n     * @param volume a number between 0 and 1. Set it to `undefined` to use the default volume.\n     */ setParticipantVolume(sessionId, volume) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details\");\n        }\n        if (volume && (volume < 0 || volume > 1)) {\n            throw new Error(\"Volume must be between 0 and 1, or undefined\");\n        }\n        this.call.state.updateParticipant(sessionId, {\n            audioVolume: volume\n        });\n    }\n}\n/**\n * An object representation of a `Call`.\n */ class Call {\n    /**\n     * Constructs a new `Call` instance.\n     *\n     * NOTE: Don't call the constructor directly, instead\n     * Use the [`StreamVideoClient.call`](./StreamVideoClient.md/#call)\n     * method to construct a `Call` instance.\n     */ constructor({ type, id, streamClient, members, ownCapabilities, sortParticipantsBy, clientStore, ringing = false, watching = false }){\n        /**\n         * The state of this call.\n         */ this.state = new CallState();\n        /**\n         * The DynascaleManager instance.\n         */ this.dynascaleManager = new DynascaleManager(this);\n        /**\n         * The permissions context of this call.\n         */ this.permissionsContext = new PermissionsContext();\n        /**\n         * The event dispatcher instance dedicated to this Call instance.\n         * @private\n         */ this.dispatcher = new Dispatcher();\n        this.trackSubscriptionsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject({\n            type: DebounceType.MEDIUM,\n            data: []\n        });\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10;\n        /**\n         * A list hooks/functions to invoke when the call is left.\n         * A typical use case is to clean up some global event handlers.\n         * @private\n         */ this.leaveCallHooks = new Set();\n        this.streamClientEventHandlers = new Map();\n        /**\n         * You can subscribe to WebSocket events provided by the API. To remove a subscription, call the `off` method.\n         * Please note that subscribing to WebSocket events is an advanced use-case.\n         * For most use-cases, it should be enough to watch for state changes.\n         *\n         * @param eventName the event name.\n         * @param fn the event handler.\n         */ this.on = (eventName, fn)=>{\n            if (isSfuEvent(eventName)) {\n                return this.dispatcher.on(eventName, fn);\n            }\n            const offHandler = this.streamClient.on(eventName, (e)=>{\n                const event = e;\n                if (event.call_cid && event.call_cid === this.cid) {\n                    fn(event);\n                }\n            });\n            // keep the 'off' reference returned by the stream client\n            this.streamClientEventHandlers.set(fn, offHandler);\n            return ()=>{\n                this.off(eventName, fn);\n            };\n        };\n        /**\n         * Remove subscription for WebSocket events that were created by the `on` method.\n         *\n         * @param eventName the event name.\n         * @param fn the event handler.\n         */ this.off = (eventName, fn)=>{\n            if (isSfuEvent(eventName)) {\n                return this.dispatcher.off(eventName, fn);\n            }\n            // unsubscribe from the stream client event by using the 'off' reference\n            const registeredOffHandler = this.streamClientEventHandlers.get(fn);\n            if (registeredOffHandler) {\n                registeredOffHandler();\n            }\n        };\n        /**\n         * Leave the call and stop the media streams that were published by the call.\n         */ this.leave = async ({ reject = false, reason = \"user is leaving the call\" } = {})=>{\n            const callingState = this.state.callingState;\n            if (callingState === CallingState.LEFT) {\n                throw new Error(\"Cannot leave call that has already been left.\");\n            }\n            if (callingState === CallingState.JOINING) {\n                await this.assertCallJoined();\n            }\n            if (this.ringing) {\n                // I'm the one who started the call, so I should cancel it.\n                const hasOtherParticipants = this.state.remoteParticipants.length > 0;\n                if (this.isCreatedByMe && !hasOtherParticipants) {\n                    // Signals other users that I have cancelled my call to them\n                    // before they accepted it.\n                    await this.reject();\n                } else if (reject && callingState === CallingState.RINGING) {\n                    // Signals other users that I have rejected the incoming call.\n                    await this.reject();\n                }\n            }\n            this.statsReporter?.stop();\n            this.statsReporter = undefined;\n            this.sfuStatsReporter?.stop();\n            this.sfuStatsReporter = undefined;\n            this.subscriber?.close();\n            this.subscriber = undefined;\n            this.publisher?.close();\n            this.publisher = undefined;\n            this.sfuClient?.close(StreamSfuClient.NORMAL_CLOSURE, reason);\n            this.sfuClient = undefined;\n            this.dispatcher.offAll();\n            this.state.setCallingState(CallingState.LEFT);\n            // Call all leave call hooks, e.g. to clean up global event handlers\n            this.leaveCallHooks.forEach((hook)=>hook());\n            this.clientStore.unregisterCall(this);\n            this.camera.dispose();\n            this.microphone.dispose();\n            this.screenShare.dispose();\n            this.speaker.dispose();\n            const stopOnLeavePromises = [];\n            if (this.camera.stopOnLeave) {\n                stopOnLeavePromises.push(this.camera.disable(true));\n            }\n            if (this.microphone.stopOnLeave) {\n                stopOnLeavePromises.push(this.microphone.disable(true));\n            }\n            if (this.screenShare.stopOnLeave) {\n                stopOnLeavePromises.push(this.screenShare.disable(true));\n            }\n            await Promise.all(stopOnLeavePromises);\n        };\n        /**\n         * Loads the information about the call.\n         *\n         * @param params.ring if set to true, a `call.ring` event will be sent to the call members.\n         * @param params.notify if set to true, a `call.notification` event will be sent to the call members.\n         * @param params.members_limit the total number of members to return as part of the response.\n         */ this.get = async (params)=>{\n            const response = await this.streamClient.get(this.streamClientBasePath, params);\n            if (params?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            this.state.updateFromCallResponse(response.call);\n            this.state.setMembers(response.members);\n            this.state.setOwnCapabilities(response.own_capabilities);\n            if (this.streamClient._hasConnectionID()) {\n                this.watching = true;\n                this.clientStore.registerCall(this);\n            }\n            this.applyDeviceConfig();\n            return response;\n        };\n        /**\n         * Loads the information about the call and creates it if it doesn't exist.\n         *\n         * @param data the data to create the call with.\n         */ this.getOrCreate = async (data)=>{\n            const response = await this.streamClient.post(this.streamClientBasePath, data);\n            if (data?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            this.state.updateFromCallResponse(response.call);\n            this.state.setMembers(response.members);\n            this.state.setOwnCapabilities(response.own_capabilities);\n            if (this.streamClient._hasConnectionID()) {\n                this.watching = true;\n                this.clientStore.registerCall(this);\n            }\n            this.applyDeviceConfig();\n            return response;\n        };\n        /**\n         * Creates a call\n         *\n         * @param data the data to create the call with.\n         */ this.create = async (data)=>{\n            return this.getOrCreate(data);\n        };\n        /**\n         * A shortcut for {@link Call.get} with `ring` parameter set to `true`.\n         * Will send a `call.ring` event to the call members.\n         */ this.ring = async ()=>{\n            return await this.get({\n                ring: true\n            });\n        };\n        /**\n         * A shortcut for {@link Call.get} with `notify` parameter set to `true`.\n         * Will send a `call.notification` event to the call members.\n         */ this.notify = async ()=>{\n            return await this.get({\n                notify: true\n            });\n        };\n        /**\n         * Marks the incoming call as accepted.\n         *\n         * This method should be used only for \"ringing\" call flows.\n         * {@link Call.join} invokes this method automatically for you when joining a call.\n         * Unless you are implementing a custom \"ringing\" flow, you should not use this method.\n         */ this.accept = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/accept`);\n        };\n        /**\n         * Marks the incoming call as rejected.\n         *\n         * This method should be used only for \"ringing\" call flows.\n         * {@link Call.leave} invokes this method automatically for you when you leave or reject this call.\n         * Unless you are implementing a custom \"ringing\" flow, you should not use this method.\n         */ this.reject = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/reject`);\n        };\n        /**\n         * Will start to watch for call related WebSocket events and initiate a call session with the server.\n         *\n         * @returns a promise which resolves once the call join-flow has finished.\n         */ this.join = async (data)=>{\n            const callingState = this.state.callingState;\n            if ([\n                CallingState.JOINED,\n                CallingState.JOINING\n            ].includes(callingState)) {\n                this.logger(\"warn\", \"Join method called twice, you should only call this once\");\n                throw new Error(`Illegal State: Already joined.`);\n            }\n            if (callingState === CallingState.LEFT) {\n                throw new Error(\"Illegal State: Cannot join already left call. Create a new Call instance to join a call.\");\n            }\n            const isMigrating = callingState === CallingState.MIGRATING;\n            const isReconnecting = callingState === CallingState.RECONNECTING;\n            this.state.setCallingState(CallingState.JOINING);\n            this.logger(\"debug\", \"Starting join flow\");\n            if (data?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            if (this.ringing && !this.isCreatedByMe) {\n                // signals other users that I have accepted the incoming call.\n                await this.accept();\n            }\n            let sfuServer;\n            let sfuToken;\n            let connectionConfig;\n            let statsOptions;\n            try {\n                if (this.sfuClient?.isFastReconnecting) {\n                    // use previous SFU configuration and values\n                    connectionConfig = this.publisher?.connectionConfiguration;\n                    sfuServer = this.sfuClient.sfuServer;\n                    sfuToken = this.sfuClient.token;\n                    statsOptions = this.sfuStatsReporter?.options;\n                } else {\n                    // full join flow - let the Coordinator pick a new SFU for us\n                    const call = await join(this.streamClient, this.type, this.id, data);\n                    this.state.updateFromCallResponse(call.metadata);\n                    this.state.setMembers(call.members);\n                    this.state.setOwnCapabilities(call.ownCapabilities);\n                    connectionConfig = call.connectionConfig;\n                    sfuServer = call.sfuServer;\n                    sfuToken = call.token;\n                    statsOptions = call.statsOptions;\n                }\n                if (this.streamClient._hasConnectionID()) {\n                    this.watching = true;\n                    this.clientStore.registerCall(this);\n                }\n            } catch (error) {\n                // restore the previous call state if the join-flow fails\n                this.state.setCallingState(callingState);\n                throw error;\n            }\n            const previousSfuClient = this.sfuClient;\n            const sfuClient = this.sfuClient = new StreamSfuClient({\n                dispatcher: this.dispatcher,\n                sfuServer,\n                token: sfuToken,\n                sessionId: previousSfuClient?.sessionId\n            });\n            /**\n             * A closure which hides away the re-connection logic.\n             */ const reconnect = async (strategy, reason)=>{\n                const currentState = this.state.callingState;\n                if (currentState === CallingState.MIGRATING || currentState === CallingState.RECONNECTING) {\n                    // prevent parallel reconnection attempts\n                    return;\n                }\n                this.reconnectAttempts++;\n                this.state.setCallingState(strategy === \"migrate\" ? CallingState.MIGRATING : CallingState.RECONNECTING);\n                if (strategy === \"migrate\") {\n                    this.logger(\"debug\", `[Migration]: migrating call ${this.cid} away from ${sfuServer.edge_name}`);\n                    sfuClient.isMigratingAway = true;\n                } else {\n                    this.logger(\"debug\", `[Rejoin]: ${strategy} rejoin call ${this.cid} (${this.reconnectAttempts})...`);\n                }\n                // take a snapshot of the current \"local participant\" state\n                // we'll need it for restoring the previous publishing state later\n                const localParticipant = this.state.localParticipant;\n                if (strategy === \"fast\") {\n                    sfuClient.close(StreamSfuClient.ERROR_CONNECTION_BROKEN, `attempting fast reconnect: ${reason}`);\n                } else if (strategy === \"full\") {\n                    // in migration or recovery scenarios, we don't want to\n                    // wait before attempting to reconnect to an SFU server\n                    await sleep(retryInterval(this.reconnectAttempts));\n                    // in full-reconnect, we need to dispose all Peer Connections\n                    this.subscriber?.close();\n                    this.subscriber = undefined;\n                    this.publisher?.close({\n                        stopTracks: false\n                    });\n                    this.publisher = undefined;\n                    this.statsReporter?.stop();\n                    this.statsReporter = undefined;\n                    this.sfuStatsReporter?.stop();\n                    this.sfuStatsReporter = undefined;\n                    // clean up current connection\n                    sfuClient.close(StreamSfuClient.NORMAL_CLOSURE, `attempting full reconnect: ${reason}`);\n                }\n                await this.join({\n                    ...data,\n                    ...strategy === \"migrate\" && {\n                        migrating_from: sfuServer.edge_name\n                    }\n                });\n                // clean up previous connection\n                if (strategy === \"migrate\") {\n                    sfuClient.close(StreamSfuClient.NORMAL_CLOSURE, \"attempting migration\");\n                }\n                this.logger(\"info\", `[Rejoin]: Attempt ${this.reconnectAttempts} successful!`);\n                // we shouldn't be republishing the streams if we're migrating\n                // as the underlying peer connection will take care of it as part\n                // of the ice-restart process\n                if (localParticipant && strategy === \"full\") {\n                    const { audioStream, videoStream, screenShareStream, screenShareAudioStream } = localParticipant;\n                    let screenShare;\n                    if (screenShareStream || screenShareAudioStream) {\n                        screenShare = new MediaStream();\n                        screenShareStream?.getVideoTracks().forEach((track)=>{\n                            screenShare?.addTrack(track);\n                        });\n                        screenShareAudioStream?.getAudioTracks().forEach((track)=>{\n                            screenShare?.addTrack(track);\n                        });\n                    }\n                    // restore previous publishing state\n                    if (audioStream) await this.publishAudioStream(audioStream);\n                    if (videoStream) {\n                        await this.publishVideoStream(videoStream, {\n                            preferredCodec: this.camera.preferredCodec\n                        });\n                    }\n                    if (screenShare) await this.publishScreenShareStream(screenShare);\n                    this.logger(\"info\", `[Rejoin]: State restored. Attempt: ${this.reconnectAttempts}`);\n                }\n            };\n            // reconnect if the connection was closed unexpectedly. example:\n            // - SFU crash or restart\n            // - network change\n            sfuClient.signalReady.then(()=>{\n                // register a handler for the \"goAway\" event\n                const unregisterGoAway = this.dispatcher.on(\"goAway\", (event)=>{\n                    const { reason } = event;\n                    this.logger(\"info\", `[Migration]: Going away from SFU... Reason: ${GoAwayReason[reason]}`);\n                    reconnect(\"migrate\", GoAwayReason[reason]).catch((err)=>{\n                        this.logger(\"warn\", `[Migration]: Failed to migrate to another SFU.`, err);\n                    });\n                });\n                sfuClient.signalWs.addEventListener(\"close\", (e)=>{\n                    // unregister the \"goAway\" handler, as we won't need it anymore for this connection.\n                    // the upcoming re-join will register a new handler anyway\n                    unregisterGoAway();\n                    // do nothing if the connection was closed on purpose\n                    if (e.code === StreamSfuClient.NORMAL_CLOSURE) return;\n                    // do nothing if the connection was closed because of a policy violation\n                    // e.g., the user has been blocked by an admin or moderator\n                    if (e.code === KnownCodes.WS_POLICY_VIOLATION) return;\n                    // When the SFU is being shut down, it sends a goAway message.\n                    // While we migrate to another SFU, we might have the WS connection\n                    // to the old SFU closed abruptly. In this case, we don't want\n                    // to reconnect to the old SFU, but rather to the new one.\n                    const isMigratingAway = e.code === KnownCodes.WS_CLOSED_ABRUPTLY && sfuClient.isMigratingAway;\n                    const isFastReconnecting = e.code === KnownCodes.WS_CLOSED_ABRUPTLY && sfuClient.isFastReconnecting;\n                    if (isMigratingAway || isFastReconnecting) return;\n                    // do nothing if the connection was closed because of a fast reconnect\n                    if (e.code === StreamSfuClient.ERROR_CONNECTION_BROKEN) return;\n                    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                        sfuClient.isFastReconnecting = this.reconnectAttempts === 0;\n                        const strategy = sfuClient.isFastReconnecting ? \"fast\" : \"full\";\n                        reconnect(strategy, `SFU closed the WS with code: ${e.code}`).catch((err)=>{\n                            this.logger(\"error\", `[Rejoin]: ${strategy} rejoin failed for ${this.reconnectAttempts} times. Giving up.`, err);\n                            this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                        });\n                    } else {\n                        this.logger(\"error\", \"[Rejoin]: Reconnect attempts exceeded. Giving up...\");\n                        this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                    }\n                });\n            });\n            // handlers for connection online/offline events\n            const unsubscribeOnlineEvent = this.streamClient.on(\"connection.changed\", async (e)=>{\n                if (e.type !== \"connection.changed\") return;\n                if (!e.online) return;\n                unsubscribeOnlineEvent();\n                const currentCallingState = this.state.callingState;\n                const shouldReconnect = currentCallingState === CallingState.OFFLINE || currentCallingState === CallingState.RECONNECTING_FAILED;\n                if (!shouldReconnect) return;\n                this.logger(\"info\", \"[Rejoin]: Going online...\");\n                let isFirstReconnectAttempt = true;\n                do {\n                    try {\n                        sfuClient.isFastReconnecting = isFirstReconnectAttempt;\n                        await reconnect(isFirstReconnectAttempt ? \"fast\" : \"full\", \"Network: online\");\n                        return; // break the loop if rejoin is successful\n                    } catch (err) {\n                        this.logger(\"error\", `[Rejoin][Network]: Rejoin failed for attempt ${this.reconnectAttempts}`, err);\n                    }\n                    // wait for a bit before trying to reconnect again\n                    await sleep(retryInterval(this.reconnectAttempts));\n                    isFirstReconnectAttempt = false;\n                }while (this.reconnectAttempts < this.maxReconnectAttempts);\n                // if we're here, it means that we've exhausted all the reconnect attempts\n                this.logger(\"error\", `[Rejoin][Network]: Rejoin failed. Giving up.`);\n                this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n            });\n            const unsubscribeOfflineEvent = this.streamClient.on(\"connection.changed\", (e)=>{\n                if (e.type !== \"connection.changed\") return;\n                if (e.online) return;\n                unsubscribeOfflineEvent();\n                this.state.setCallingState(CallingState.OFFLINE);\n            });\n            this.leaveCallHooks.add(()=>{\n                unsubscribeOnlineEvent();\n                unsubscribeOfflineEvent();\n            });\n            if (!this.subscriber) {\n                this.subscriber = new Subscriber({\n                    sfuClient,\n                    dispatcher: this.dispatcher,\n                    state: this.state,\n                    connectionConfig\n                });\n            }\n            if (!this.publisher) {\n                const audioSettings = this.state.settings?.audio;\n                const isDtxEnabled = !!audioSettings?.opus_dtx_enabled;\n                const isRedEnabled = !!audioSettings?.redundant_coding_enabled;\n                this.publisher = new Publisher({\n                    sfuClient,\n                    dispatcher: this.dispatcher,\n                    state: this.state,\n                    connectionConfig,\n                    isDtxEnabled,\n                    isRedEnabled\n                });\n            }\n            if (!this.statsReporter) {\n                this.statsReporter = createStatsReporter({\n                    subscriber: this.subscriber,\n                    publisher: this.publisher,\n                    state: this.state\n                });\n            }\n            const clientDetails = getClientDetails();\n            if (!this.sfuStatsReporter && statsOptions) {\n                this.sfuStatsReporter = new SfuStatsReporter(sfuClient, {\n                    clientDetails,\n                    options: statsOptions,\n                    subscriber: this.subscriber,\n                    publisher: this.publisher\n                });\n                this.sfuStatsReporter.start();\n            }\n            try {\n                // 1. wait for the signal server to be ready before sending \"joinRequest\"\n                sfuClient.signalReady.catch((err)=>this.logger(\"error\", \"Signal ready failed\", err))// prepare a generic SDP and send it to the SFU.\n                // this is a throw-away SDP that the SFU will use to determine\n                // the capabilities of the client (codec support, etc.)\n                .then(()=>getGenericSdp(\"recvonly\")).then((sdp)=>{\n                    const subscriptions = getCurrentValue(this.trackSubscriptionsSubject);\n                    const migration = isMigrating ? {\n                        fromSfuId: data?.migrating_from || \"\",\n                        subscriptions: subscriptions.data || [],\n                        announcedTracks: this.publisher?.getCurrentTrackInfos() || []\n                    } : undefined;\n                    return sfuClient.join({\n                        subscriberSdp: sdp || \"\",\n                        clientDetails,\n                        migration,\n                        fastReconnect: previousSfuClient?.isFastReconnecting ?? false\n                    });\n                });\n                // 2. in parallel, wait for the SFU to send us the \"joinResponse\"\n                // this will throw an error if the SFU rejects the join request or\n                // fails to respond in time\n                const { callState, reconnected } = await this.waitForJoinResponse();\n                if (isReconnecting) {\n                    this.logger(\"debug\", \"[Rejoin] fast reconnected:\", reconnected);\n                }\n                if (isMigrating) {\n                    await this.subscriber.migrateTo(sfuClient, connectionConfig);\n                    await this.publisher.migrateTo(sfuClient, connectionConfig);\n                } else if (isReconnecting) {\n                    if (reconnected) {\n                        // update the SFU client instance on the subscriber and publisher\n                        this.subscriber.setSfuClient(sfuClient);\n                        this.publisher.setSfuClient(sfuClient);\n                        // and perform a full ICE restart on the publisher\n                        await this.publisher.restartIce();\n                    } else if (previousSfuClient?.isFastReconnecting) {\n                        // reconnection wasn't possible, so we need to do a full rejoin\n                        return await reconnect(\"full\", \"re-attempting\").catch((err)=>{\n                            this.logger(\"error\", `[Rejoin]: Rejoin failed forced full rejoin.`, err);\n                        });\n                    }\n                }\n                const currentParticipants = callState?.participants || [];\n                const participantCount = callState?.participantCount;\n                const startedAt = callState?.startedAt ? Timestamp.toDate(callState.startedAt) : new Date();\n                const pins = callState?.pins ?? [];\n                this.state.setParticipants(()=>{\n                    const participantLookup = this.state.getParticipantLookupBySessionId();\n                    return currentParticipants.map((p)=>{\n                        // We need to preserve the local state of the participant\n                        // (e.g. videoDimension, visibilityState, pinnedAt, etc.)\n                        // as it doesn't exist on the server.\n                        const existingParticipant = participantLookup[p.sessionId];\n                        return Object.assign(p, existingParticipant, {\n                            isLocalParticipant: p.sessionId === sfuClient.sessionId,\n                            viewportVisibilityState: existingParticipant?.viewportVisibilityState ?? {\n                                videoTrack: VisibilityState.UNKNOWN,\n                                screenShareTrack: VisibilityState.UNKNOWN\n                            }\n                        });\n                    });\n                });\n                this.state.setParticipantCount(participantCount?.total || 0);\n                this.state.setAnonymousParticipantCount(participantCount?.anonymous || 0);\n                this.state.setStartedAt(startedAt);\n                this.state.setServerSidePins(pins);\n                this.reconnectAttempts = 0; // reset the reconnect attempts counter\n                this.state.setCallingState(CallingState.JOINED);\n                try {\n                    await this.initCamera({\n                        setStatus: true\n                    });\n                    await this.initMic({\n                        setStatus: true\n                    });\n                } catch (error) {\n                    this.logger(\"warn\", \"Camera and/or mic init failed during join call\", error);\n                }\n                // 3. once we have the \"joinResponse\", and possibly reconciled the local state\n                // we schedule a fast subscription update for all remote participants\n                // that were visible before we reconnected or migrated to a new SFU.\n                const { remoteParticipants } = this.state;\n                if (remoteParticipants.length > 0) {\n                    this.updateSubscriptions(remoteParticipants, DebounceType.FAST);\n                }\n                this.logger(\"info\", `Joined call ${this.cid}`);\n            } catch (err) {\n                // join failed, try to rejoin\n                if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                    this.logger(\"error\", `[Rejoin]: Rejoin ${this.reconnectAttempts} failed.`, err);\n                    await reconnect(\"full\", \"previous attempt failed\");\n                    this.logger(\"info\", `[Rejoin]: Rejoin ${this.reconnectAttempts} successful!`);\n                } else {\n                    this.logger(\"error\", `[Rejoin]: Rejoin failed for ${this.reconnectAttempts} times. Giving up.`);\n                    this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                    throw new Error(\"Join failed\");\n                }\n            }\n        };\n        this.waitForJoinResponse = (timeout = 5000)=>{\n            return new Promise((resolve, reject)=>{\n                const unsubscribe = this.on(\"joinResponse\", (event)=>{\n                    clearTimeout(timeoutId);\n                    unsubscribe();\n                    resolve(event);\n                });\n                const timeoutId = setTimeout(()=>{\n                    unsubscribe();\n                    reject(new Error('Waiting for \"joinResponse\" has timed out'));\n                }, timeout);\n            });\n        };\n        /**\n         * Starts publishing the given video stream to the call.\n         * The stream will be stopped if the user changes an input device, or if the user leaves the call.\n         *\n         * Consecutive calls to this method will replace the previously published stream.\n         * The previous video stream will be stopped.\n         *\n         * @param videoStream the video stream to publish.\n         * @param opts the options to use when publishing the stream.\n         */ this.publishVideoStream = async (videoStream, opts = {})=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish video before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [videoTrack] = videoStream.getVideoTracks();\n            if (!videoTrack) {\n                this.logger(\"error\", `There is no video track to publish in the stream.`);\n                return;\n            }\n            await this.publisher.publishStream(videoStream, videoTrack, TrackType.VIDEO, opts);\n        };\n        /**\n         * Starts publishing the given audio stream to the call.\n         * The stream will be stopped if the user changes an input device, or if the user leaves the call.\n         *\n         * Consecutive calls to this method will replace the audio stream that is currently being published.\n         * The previous audio stream will be stopped.\n         *\n         * @param audioStream the audio stream to publish.\n         */ this.publishAudioStream = async (audioStream)=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish audio before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [audioTrack] = audioStream.getAudioTracks();\n            if (!audioTrack) {\n                this.logger(\"error\", `There is no audio track in the stream to publish`);\n                return;\n            }\n            await this.publisher.publishStream(audioStream, audioTrack, TrackType.AUDIO);\n        };\n        /**\n         * Starts publishing the given screen-share stream to the call.\n         *\n         * Consecutive calls to this method will replace the previous screen-share stream.\n         * The previous screen-share stream will be stopped.\n         *\n         * @param screenShareStream the screen-share stream to publish.\n         * @param opts the options to use when publishing the stream.\n         */ this.publishScreenShareStream = async (screenShareStream, opts = {})=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish screen share before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [screenShareTrack] = screenShareStream.getVideoTracks();\n            if (!screenShareTrack) {\n                this.logger(\"error\", `There is no video track in the screen share stream to publish`);\n                return;\n            }\n            await this.publisher.publishStream(screenShareStream, screenShareTrack, TrackType.SCREEN_SHARE, opts);\n            const [screenShareAudioTrack] = screenShareStream.getAudioTracks();\n            if (screenShareAudioTrack) {\n                await this.publisher.publishStream(screenShareStream, screenShareAudioTrack, TrackType.SCREEN_SHARE_AUDIO, opts);\n            }\n        };\n        /**\n         * Stops publishing the given track type to the call, if it is currently being published.\n         * Underlying track will be stopped and removed from the publisher.\n         *\n         * @param trackType the track type to stop publishing.\n         * @param stopTrack if `true` the track will be stopped, else it will be just disabled\n         */ this.stopPublish = async (trackType, stopTrack = true)=>{\n            this.logger(\"info\", `stopPublish ${TrackType[trackType]}, stop tracks: ${stopTrack}`);\n            await this.publisher?.unpublishStream(trackType, stopTrack);\n        };\n        /**\n         * Update track subscription configuration for one or more participants.\n         * You have to create a subscription for each participant for all the different kinds of tracks you want to receive.\n         * You can only subscribe for tracks after the participant started publishing the given kind of track.\n         *\n         * @param trackType the kind of subscription to update.\n         * @param changes the list of subscription changes to do.\n         * @param type the debounce type to use for the update.\n         */ this.updateSubscriptionsPartial = (trackType, changes, type = DebounceType.SLOW)=>{\n            if (trackType === \"video\") {\n                this.logger(\"warn\", `updateSubscriptionsPartial: ${trackType} is deprecated. Please switch to 'videoTrack'`);\n                trackType = \"videoTrack\";\n            } else if (trackType === \"screen\") {\n                this.logger(\"warn\", `updateSubscriptionsPartial: ${trackType} is deprecated. Please switch to 'screenShareTrack'`);\n                trackType = \"screenShareTrack\";\n            }\n            const participants = this.state.updateParticipants(Object.entries(changes).reduce((acc, [sessionId, change])=>{\n                if (change.dimension?.height) {\n                    change.dimension.height = Math.ceil(change.dimension.height);\n                }\n                if (change.dimension?.width) {\n                    change.dimension.width = Math.ceil(change.dimension.width);\n                }\n                const prop = trackType === \"videoTrack\" ? \"videoDimension\" : trackType === \"screenShareTrack\" ? \"screenShareDimension\" : undefined;\n                if (prop) {\n                    acc[sessionId] = {\n                        [prop]: change.dimension\n                    };\n                }\n                return acc;\n            }, {}));\n            if (participants) {\n                this.updateSubscriptions(participants, type);\n            }\n        };\n        this.updateSubscriptions = (participants, type = DebounceType.SLOW)=>{\n            const subscriptions = [];\n            for (const p of participants){\n                // we don't want to subscribe to our own tracks\n                if (p.isLocalParticipant) continue;\n                // NOTE: audio tracks don't have to be requested explicitly\n                // as the SFU will implicitly subscribe us to all of them,\n                // once they become available.\n                if (p.videoDimension && p.publishedTracks.includes(TrackType.VIDEO)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.VIDEO,\n                        dimension: p.videoDimension\n                    });\n                }\n                if (p.screenShareDimension && p.publishedTracks.includes(TrackType.SCREEN_SHARE)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.SCREEN_SHARE,\n                        dimension: p.screenShareDimension\n                    });\n                }\n                if (p.publishedTracks.includes(TrackType.SCREEN_SHARE_AUDIO)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.SCREEN_SHARE_AUDIO\n                    });\n                }\n            }\n            // schedule update\n            this.trackSubscriptionsSubject.next({\n                type,\n                data: subscriptions\n            });\n        };\n        /**\n         * Will enhance the reported stats with additional participant-specific information (`callStatsReport$` state [store variable](./StreamVideoClient.md/#readonlystatestore)).\n         * This is usually helpful when detailed stats for a specific participant are needed.\n         *\n         * @param sessionId the sessionId to start reporting for.\n         */ this.startReportingStatsFor = (sessionId)=>{\n            return this.statsReporter?.startReportingStatsFor(sessionId);\n        };\n        /**\n         * Opposite of `startReportingStatsFor`.\n         * Will turn off stats reporting for a specific participant.\n         *\n         * @param sessionId the sessionId to stop reporting for.\n         */ this.stopReportingStatsFor = (sessionId)=>{\n            return this.statsReporter?.stopReportingStatsFor(sessionId);\n        };\n        /**\n         * Resets the last sent reaction for the user holding the given `sessionId`. This is a local action, it won't reset the reaction on the backend.\n         *\n         * @param sessionId the session id.\n         */ this.resetReaction = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                reaction: undefined\n            });\n        };\n        /**\n         * Sets the list of criteria to sort the participants by.\n         *\n         * @param criteria the list of criteria to sort the participants by.\n         */ this.setSortParticipantsBy = (criteria)=>{\n            return this.state.setSortParticipantsBy(criteria);\n        };\n        /**\n         * Updates the list of video layers to publish.\n         *\n         * @internal\n         * @param enabledLayers the list of layers to enable.\n         */ this.updatePublishQuality = async (enabledLayers)=>{\n            return this.publisher?.updateVideoPublishQuality(enabledLayers);\n        };\n        this.assertCallJoined = ()=>{\n            return new Promise((resolve)=>{\n                this.state.callingState$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((state)=>state !== CallingState.JOINED, true), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_32__.filter)((s)=>s === CallingState.JOINED)).subscribe(()=>resolve());\n            });\n        };\n        /**\n         * Sends a reaction to the other call participants.\n         *\n         * @param reaction the reaction to send.\n         */ this.sendReaction = async (reaction)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/reaction`, reaction);\n        };\n        /**\n         * Blocks the user with the given `userId`.\n         *\n         * @param userId the id of the user to block.\n         */ this.blockUser = async (userId)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/block`, {\n                user_id: userId\n            });\n        };\n        /**\n         * Unblocks the user with the given `userId`.\n         *\n         * @param userId the id of the user to unblock.\n         */ this.unblockUser = async (userId)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/unblock`, {\n                user_id: userId\n            });\n        };\n        /**\n         * Mutes the current user.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteSelf = (type)=>{\n            const myUserId = this.currentUserId;\n            if (myUserId) {\n                return this.muteUser(myUserId, type);\n            }\n        };\n        /**\n         * Mutes all the other participants.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteOthers = (type)=>{\n            const trackType = muteTypeToTrackType(type);\n            if (!trackType) return;\n            const userIdsToMute = [];\n            for (const participant of this.state.remoteParticipants){\n                if (participant.publishedTracks.includes(trackType)) {\n                    userIdsToMute.push(participant.userId);\n                }\n            }\n            return this.muteUser(userIdsToMute, type);\n        };\n        /**\n         * Mutes the user with the given `userId`.\n         *\n         * @param userId the id of the user to mute.\n         * @param type the type of the mute operation.\n         */ this.muteUser = (userId, type)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {\n                user_ids: Array.isArray(userId) ? userId : [\n                    userId\n                ],\n                [type]: true\n            });\n        };\n        /**\n         * Will mute all users in the call.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteAllUsers = (type)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {\n                mute_all_users: true,\n                [type]: true\n            });\n        };\n        /**\n         * Starts recording the call\n         */ this.startRecording = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_recording`, request ? request : {});\n        };\n        /**\n         * Stops recording the call\n         */ this.stopRecording = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_recording`, {});\n        };\n        /**\n         * Starts the transcription of the call.\n         *\n         * @param request the request data.\n         */ this.startTranscription = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_transcription`, request);\n        };\n        /**\n         * Stops the transcription of the call.\n         */ this.stopTranscription = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_transcription`);\n        };\n        /**\n         * Sends a `call.permission_request` event to all users connected to the call. The call settings object contains infomration about which permissions can be requested during a call (for example a user might be allowed to request permission to publish audio, but not video).\n         */ this.requestPermissions = async (data)=>{\n            const { permissions } = data;\n            const canRequestPermissions = permissions.every((permission)=>this.permissionsContext.canRequest(permission));\n            if (!canRequestPermissions) {\n                throw new Error(`You are not allowed to request permissions: ${permissions.join(\", \")}`);\n            }\n            return this.streamClient.post(`${this.streamClientBasePath}/request_permission`, data);\n        };\n        /**\n         * Allows you to grant certain permissions to a user in a call.\n         * The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * Supported permissions that can be granted are:\n         * - `send-audio`\n         * - `send-video`\n         * - `screenshare`\n         *\n         * @param userId the id of the user to grant permissions to.\n         * @param permissions the permissions to grant.\n         */ this.grantPermissions = async (userId, permissions)=>{\n            return this.updateUserPermissions({\n                user_id: userId,\n                grant_permissions: permissions\n            });\n        };\n        /**\n         * Allows you to revoke certain permissions from a user in a call.\n         * The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * Supported permissions that can be revoked are:\n         * - `send-audio`\n         * - `send-video`\n         * - `screenshare`\n         *\n         * @param userId the id of the user to revoke permissions from.\n         * @param permissions the permissions to revoke.\n         */ this.revokePermissions = async (userId, permissions)=>{\n            return this.updateUserPermissions({\n                user_id: userId,\n                revoke_permissions: permissions\n            });\n        };\n        /**\n         * Allows you to grant or revoke a specific permission to a user in a call. The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * When revoking a permission, this endpoint will also mute the relevant track from the user. This is similar to muting a user with the difference that the user will not be able to unmute afterwards.\n         *\n         * Supported permissions that can be granted or revoked: `send-audio`, `send-video` and `screenshare`.\n         *\n         * `call.permissions_updated` event is sent to all members of the call.\n         *\n         */ this.updateUserPermissions = async (data)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/user_permissions`, data);\n        };\n        /**\n         * Starts the livestreaming of the call.\n         *\n         * @param data the request data.\n         * @param params the request params.\n         */ this.goLive = async (data = {}, params)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/go_live`, data, params);\n        };\n        /**\n         * Stops the livestreaming of the call.\n         */ this.stopLive = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_live`, {});\n        };\n        /**\n         * Starts the broadcasting of the call.\n         */ this.startHLS = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_broadcasting`, {});\n        };\n        /**\n         * Stops the broadcasting of the call.\n         */ this.stopHLS = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_broadcasting`, {});\n        };\n        /**\n         * Updates the call settings or custom data.\n         *\n         * @param updates the updates to apply to the call.\n         */ this.update = async (updates)=>{\n            const response = await this.streamClient.patch(`${this.streamClientBasePath}`, updates);\n            const { call, members, own_capabilities } = response;\n            this.state.updateFromCallResponse(call);\n            this.state.setMembers(members);\n            this.state.setOwnCapabilities(own_capabilities);\n            return response;\n        };\n        /**\n         * Ends the call. Once the call is ended, it cannot be re-joined.\n         */ this.endCall = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mark_ended`);\n        };\n        /**\n         * Pins the given session to the top of the participants list.\n         *\n         * @param sessionId the sessionId to pin.\n         */ this.pin = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                pin: {\n                    isLocalPin: true,\n                    pinnedAt: Date.now()\n                }\n            });\n        };\n        /**\n         * Unpins the given session from the top of the participants list.\n         *\n         * @param sessionId the sessionId to unpin.\n         */ this.unpin = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                pin: undefined\n            });\n        };\n        /**\n         * Pins the given session to the top of the participants list for everyone\n         * in the call.\n         * You can execute this method only if you have the `pin-for-everyone` capability.\n         *\n         * @param request the request object.\n         */ this.pinForEveryone = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/pin`, request);\n        };\n        /**\n         * Unpins the given session from the top of the participants list for everyone\n         * in the call.\n         * You can execute this method only if you have the `pin-for-everyone` capability.\n         *\n         * @param request the request object.\n         */ this.unpinForEveryone = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/unpin`, request);\n        };\n        /**\n         * Query call members with filter query. The result won't be stored in call state.\n         * @param request\n         * @returns\n         */ this.queryMembers = (request)=>{\n            return this.streamClient.post(\"/call/members\", {\n                ...request || {},\n                id: this.id,\n                type: this.type\n            });\n        };\n        /**\n         * Will update the call members.\n         *\n         * @param data the request data.\n         */ this.updateCallMembers = async (data)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/members`, data);\n        };\n        /**\n         * Schedules an auto-drop timeout based on the call settings.\n         * Applicable only for ringing calls.\n         */ this.scheduleAutoDrop = ()=>{\n            clearTimeout(this.dropTimeout);\n            this.leaveCallHooks.add(createSubscription(this.state.settings$, (settings)=>{\n                if (!settings) return;\n                // ignore if the call is not ringing\n                if (this.state.callingState !== CallingState.RINGING) return;\n                const timeoutInMs = settings.ring.auto_cancel_timeout_ms;\n                // 0 means no auto-drop\n                if (timeoutInMs <= 0) return;\n                clearTimeout(this.dropTimeout);\n                this.dropTimeout = setTimeout(()=>{\n                    this.leave({\n                        reason: \"ring: timeout\"\n                    }).catch((err)=>{\n                        this.logger(\"error\", \"Failed to drop call\", err);\n                    });\n                }, timeoutInMs);\n            }));\n        };\n        /**\n         * Retrieves the list of recordings for the current call or call session.\n         *\n         * If `callSessionId` is provided, it will return the recordings for that call session.\n         * Otherwise, all recordings for the current call will be returned.\n         *\n         * @param callSessionId the call session id to retrieve recordings for.\n         */ this.queryRecordings = async (callSessionId)=>{\n            let endpoint = this.streamClientBasePath;\n            if (callSessionId) {\n                endpoint = `${endpoint}/${callSessionId}`;\n            }\n            return this.streamClient.get(`${endpoint}/recordings`);\n        };\n        /**\n         * Retrieves the list of transcriptions for the current call.\n         *\n         * @returns the list of transcriptions.\n         */ this.queryTranscriptions = async ()=>{\n            return this.streamClient.get(`${this.streamClientBasePath}/transcriptions`);\n        };\n        /**\n         * Retrieve call statistics for a particular call session (historical).\n         * Here `callSessionID` is mandatory.\n         *\n         * @param callSessionID the call session ID to retrieve statistics for.\n         * @returns The call stats.\n         */ this.getCallStats = async (callSessionID)=>{\n            const endpoint = `${this.streamClientBasePath}/stats/${callSessionID}`;\n            return this.streamClient.get(endpoint);\n        };\n        /**\n         * Sends a custom event to all call participants.\n         *\n         * @param payload the payload to send.\n         */ this.sendCustomEvent = async (payload)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/event`, {\n                custom: payload\n            });\n        };\n        this.applyDeviceConfig = ()=>{\n            this.initCamera({\n                setStatus: false\n            });\n            this.initMic({\n                setStatus: false\n            });\n        };\n        /**\n         * Will begin tracking the given element for visibility changes within the\n         * configured viewport element (`call.setViewport`).\n         *\n         * @param element the element to track.\n         * @param sessionId the session id.\n         * @param trackType the video mode.\n         */ this.trackElementVisibility = (element, sessionId, trackType)=>{\n            return this.dynascaleManager.trackElementVisibility(element, sessionId, trackType);\n        };\n        /**\n         * Sets the viewport element to track bound video elements for visibility.\n         *\n         * @param element the viewport element.\n         */ this.setViewport = (element)=>{\n            return this.dynascaleManager.setViewport(element);\n        };\n        /**\n         * Binds a DOM <video> element to the given session id.\n         * This method will make sure that the video element will play\n         * the correct video stream for the given session id.\n         *\n         * Under the hood, it would also keep track of the video element dimensions\n         * and update the subscription accordingly in order to optimize the bandwidth.\n         *\n         * If a \"viewport\" is configured, the video element will be automatically\n         * tracked for visibility and the subscription will be updated accordingly.\n         *\n         * @param videoElement the video element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         */ this.bindVideoElement = (videoElement, sessionId, trackType)=>{\n            const unbind = this.dynascaleManager.bindVideoElement(videoElement, sessionId, trackType);\n            if (!unbind) return;\n            this.leaveCallHooks.add(unbind);\n            return ()=>{\n                this.leaveCallHooks.delete(unbind);\n                unbind();\n            };\n        };\n        /**\n         * Binds a DOM <audio> element to the given session id.\n         *\n         * This method will make sure that the audio element will\n         * play the correct audio stream for the given session id.\n         *\n         * @param audioElement the audio element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of audio.\n         */ this.bindAudioElement = (audioElement, sessionId, trackType = \"audioTrack\")=>{\n            const unbind = this.dynascaleManager.bindAudioElement(audioElement, sessionId, trackType);\n            if (!unbind) return;\n            this.leaveCallHooks.add(unbind);\n            return ()=>{\n                this.leaveCallHooks.delete(unbind);\n                unbind();\n            };\n        };\n        /**\n         * Binds a DOM <img> element to this call's thumbnail (if enabled in settings).\n         *\n         * @param imageElement the image element to bind to.\n         * @param opts options for the binding.\n         */ this.bindCallThumbnailElement = (imageElement, opts = {})=>{\n            const handleError = ()=>{\n                imageElement.src = opts.fallbackImageSource || \"https://getstream.io/random_svg/?name=x&id=x\";\n            };\n            const unsubscribe = createSubscription(this.state.thumbnails$, (thumbnails)=>{\n                if (!thumbnails) return;\n                imageElement.addEventListener(\"error\", handleError);\n                const thumbnailUrl = new URL(thumbnails.image_url);\n                thumbnailUrl.searchParams.set(\"w\", String(imageElement.clientWidth));\n                thumbnailUrl.searchParams.set(\"h\", String(imageElement.clientHeight));\n                imageElement.src = thumbnailUrl.toString();\n            });\n            return ()=>{\n                unsubscribe();\n                imageElement.removeEventListener(\"error\", handleError);\n            };\n        };\n        this.type = type;\n        this.id = id;\n        this.cid = `${type}:${id}`;\n        this.ringingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(ringing);\n        this.watching = watching;\n        this.streamClient = streamClient;\n        this.clientStore = clientStore;\n        this.streamClientBasePath = `/call/${this.type}/${this.id}`;\n        this.logger = getLogger([\n            \"Call\"\n        ]);\n        const callTypeConfig = CallTypes.get(type);\n        const participantSorter = sortParticipantsBy || callTypeConfig.options.sortParticipantsBy;\n        if (participantSorter) {\n            this.state.setSortParticipantsBy(participantSorter);\n        }\n        this.state.setMembers(members || []);\n        this.state.setOwnCapabilities(ownCapabilities || []);\n        this.state.setCallingState(ringing ? CallingState.RINGING : CallingState.IDLE);\n        this.on(\"all\", (event)=>{\n            // update state with the latest event data\n            this.state.updateFromEvent(event);\n        });\n        this.leaveCallHooks.add(registerEventHandlers(this, this.state, this.dispatcher));\n        this.registerEffects();\n        this.leaveCallHooks.add(createSubscription(this.trackSubscriptionsSubject.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_33__.debounce)((v)=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_34__.timer)(v.type)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((v)=>v.data)), (subscriptions)=>this.sfuClient?.updateSubscriptions(subscriptions)));\n        this.camera = new CameraManager(this);\n        this.microphone = new MicrophoneManager(this);\n        this.speaker = new SpeakerManager(this);\n        this.screenShare = new ScreenShareManager(this);\n    }\n    registerEffects() {\n        this.leaveCallHooks.add(// handles updating the permissions context when the settings change.\n        createSubscription(this.state.settings$, (settings)=>{\n            if (!settings) return;\n            this.permissionsContext.setCallSettings(settings);\n        }));\n        this.leaveCallHooks.add(// handle the case when the user permissions are modified.\n        createSubscription(this.state.ownCapabilities$, (ownCapabilities)=>{\n            // update the permission context.\n            this.permissionsContext.setPermissions(ownCapabilities);\n            if (!this.publisher) return;\n            // check if the user still has publishing permissions and stop publishing if not.\n            const permissionToTrackType = {\n                [OwnCapability.SEND_AUDIO]: TrackType.AUDIO,\n                [OwnCapability.SEND_VIDEO]: TrackType.VIDEO,\n                [OwnCapability.SCREENSHARE]: TrackType.SCREEN_SHARE\n            };\n            for (const [permission, trackType] of Object.entries(permissionToTrackType)){\n                const hasPermission = this.permissionsContext.hasPermission(permission);\n                if (!hasPermission && (this.publisher.isPublishing(trackType) || this.publisher.isLive(trackType))) {\n                    // Stop tracks, then notify device manager\n                    this.stopPublish(trackType).catch((err)=>{\n                        this.logger(\"error\", `Error stopping publish ${trackType}`, err);\n                    }).then(()=>{\n                        if (trackType === TrackType.VIDEO && this.camera.state.status === \"enabled\") {\n                            this.camera.disable().catch((err)=>this.logger(\"error\", `Error disabling camera after permission revoked`, err));\n                        }\n                        if (trackType === TrackType.AUDIO && this.microphone.state.status === \"enabled\") {\n                            this.microphone.disable().catch((err)=>this.logger(\"error\", `Error disabling microphone after permission revoked`, err));\n                        }\n                    });\n                }\n            }\n        }));\n        this.leaveCallHooks.add(// handles the case when the user is blocked by the call owner.\n        createSubscription(this.state.blockedUserIds$, async (blockedUserIds)=>{\n            if (!blockedUserIds || blockedUserIds.length === 0) return;\n            const currentUserId = this.currentUserId;\n            if (currentUserId && blockedUserIds.includes(currentUserId)) {\n                this.logger(\"info\", \"Leaving call because of being blocked\");\n                await this.leave({\n                    reason: \"user blocked\"\n                });\n            }\n        }));\n        this.leaveCallHooks.add(// watch for auto drop cancellation\n        createSubscription(this.state.callingState$, (callingState)=>{\n            if (!this.ringing) return;\n            if (callingState === CallingState.JOINED || callingState === CallingState.JOINING || callingState === CallingState.LEFT) {\n                clearTimeout(this.dropTimeout);\n                this.dropTimeout = undefined;\n            }\n        }));\n        this.leaveCallHooks.add(// \"ringing\" mode effects and event handlers\n        createSubscription(this.ringingSubject, (isRinging)=>{\n            if (!isRinging) return;\n            this.scheduleAutoDrop();\n            if (this.state.callingState === CallingState.IDLE) {\n                this.state.setCallingState(CallingState.RINGING);\n            }\n            this.leaveCallHooks.add(registerRingingCallEventHandlers(this));\n        }));\n    }\n    /**\n     * A flag indicating whether the call is \"ringing\" type of call.\n     */ get ringing() {\n        return getCurrentValue(this.ringingSubject);\n    }\n    /**\n     * Retrieves the current user ID.\n     */ get currentUserId() {\n        return this.clientStore.connectedUser?.id;\n    }\n    /**\n     * A flag indicating whether the call was created by the current user.\n     */ get isCreatedByMe() {\n        return this.state.createdBy?.id === this.currentUserId;\n    }\n    async initCamera(options) {\n        // Wait for any in progress camera operation\n        if (this.camera.enablePromise) {\n            await this.camera.enablePromise;\n        }\n        if (this.camera.disablePromise) {\n            await this.camera.disablePromise;\n        }\n        if (this.state.localParticipant?.videoStream || !this.permissionsContext.hasPermission(\"send-video\")) {\n            return;\n        }\n        // Set camera direction if it's not yet set\n        if (!this.camera.state.direction && !this.camera.state.selectedDevice) {\n            let defaultDirection = \"front\";\n            const backendSetting = this.state.settings?.video.camera_facing;\n            if (backendSetting) {\n                defaultDirection = backendSetting === \"front\" ? \"front\" : \"back\";\n            }\n            this.camera.state.setDirection(defaultDirection);\n        }\n        // Set target resolution\n        const targetResolution = this.state.settings?.video.target_resolution;\n        if (targetResolution) {\n            await this.camera.selectTargetResolution(targetResolution);\n        }\n        if (options.setStatus) {\n            // Publish already that was set before we joined\n            if (this.camera.state.status === \"enabled\" && this.camera.state.mediaStream && !this.publisher?.isPublishing(TrackType.VIDEO)) {\n                await this.publishVideoStream(this.camera.state.mediaStream, {\n                    preferredCodec: this.camera.preferredCodec\n                });\n            }\n            // Start camera if backend config specifies, and there is no local setting\n            if (this.camera.state.status === undefined && this.state.settings?.video.camera_default_on) {\n                await this.camera.enable();\n            }\n        }\n    }\n    async initMic(options) {\n        // Wait for any in progress mic operation\n        if (this.microphone.enablePromise) {\n            await this.microphone.enablePromise;\n        }\n        if (this.microphone.disablePromise) {\n            await this.microphone.disablePromise;\n        }\n        if (this.state.localParticipant?.audioStream || !this.permissionsContext.hasPermission(\"send-audio\")) {\n            return;\n        }\n        if (options.setStatus) {\n            // Publish media stream that was set before we joined\n            if (this.microphone.state.status === \"enabled\" && this.microphone.state.mediaStream && !this.publisher?.isPublishing(TrackType.AUDIO)) {\n                await this.publishAudioStream(this.microphone.state.mediaStream);\n            }\n            // Start mic if backend config specifies, and there is no local setting\n            if (this.microphone.state.status === undefined && this.state.settings?.audio.mic_default_on) {\n                await this.microphone.enable();\n            }\n        }\n    }\n}\nclass InsightMetrics {\n    constructor(){\n        this.connectionStartTimestamp = null;\n        this.wsTotalFailures = 0;\n        this.wsConsecutiveFailures = 0;\n        this.instanceClientId = randomId();\n    }\n}\n/**\n * postInsights is not supposed to be used by end users directly within chat application, and thus is kept isolated\n * from all the client/connection code/logic.\n *\n * @param insightType\n * @param insights\n */ const postInsights = async (insightType, insights)=>{\n    const maxAttempts = 3;\n    for(let i = 0; i < maxAttempts; i++){\n        try {\n            await axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].post(`https://chat-insights.getstream.io/insights/${insightType}`, insights);\n        } catch (e) {\n            await sleep((i + 1) * 3000);\n            continue;\n        }\n        break;\n    }\n};\nfunction buildWsFatalInsight(connection, event) {\n    return {\n        ...event,\n        ...buildWsBaseInsight(connection)\n    };\n}\nfunction buildWsBaseInsight(connection) {\n    const { client } = connection;\n    return {\n        ready_state: connection.ws?.readyState,\n        url: connection._buildUrl(),\n        api_key: client.key,\n        start_ts: client.insightMetrics.connectionStartTimestamp,\n        end_ts: new Date().getTime(),\n        auth_type: client.getAuthType(),\n        token: client.tokenManager.token,\n        user_id: client.userID,\n        user_details: client._user,\n        // device: client.options.device,\n        device: \"browser\",\n        client_id: connection.connectionID,\n        ws_details: connection.ws,\n        ws_consecutive_failures: client.insightMetrics.wsConsecutiveFailures,\n        ws_total_failures: client.insightMetrics.wsTotalFailures,\n        request_id: connection.requestID,\n        online: typeof navigator !== \"undefined\" ? navigator?.onLine : null,\n        user_agent: typeof navigator !== \"undefined\" ? navigator?.userAgent : null,\n        instance_client_id: client.insightMetrics.instanceClientId\n    };\n}\nfunction buildWsSuccessAfterFailureInsight(connection) {\n    return buildWsBaseInsight(connection);\n}\n// Type guards to check WebSocket error type\nconst isCloseEvent = (res)=>res.code !== undefined;\nconst isErrorEvent = (res)=>res.error !== undefined;\n/**\n * StableWSConnection - A WS connection that reconnects upon failure.\n * - the browser will sometimes report that you're online or offline\n * - the WS connection can break and fail (there is a 30s health check)\n * - sometimes your WS connection will seem to work while the user is in fact offline\n * - to speed up online/offline detection you can use the window.addEventListener('offline');\n *\n * There are 4 ways in which a connection can become unhealthy:\n * - websocket.onerror is called\n * - websocket.onclose is called\n * - the health check fails and no event is received for ~40 seconds\n * - the browser indicates the connection is now offline\n *\n * There are 2 assumptions we make about the server:\n * - state can be recovered by querying the channel again\n * - if the servers fails to publish a message to the client, the WS connection is destroyed\n */ class StableWSConnection {\n    constructor(client){\n        this._log = (msg, extra = {}, level = \"info\")=>{\n            this.client.logger(level, \"connection:\" + msg, {\n                ...extra\n            });\n        };\n        this.setClient = (client)=>{\n            this.client = client;\n        };\n        /**\n         * Builds and returns the url for websocket.\n         * @private\n         * @returns url string\n         */ this._buildUrl = ()=>{\n            const params = new URLSearchParams();\n            // const qs = encodeURIComponent(this.client._buildWSPayload(this.requestID));\n            // params.set('json', qs);\n            params.set(\"api_key\", this.client.key);\n            params.set(\"stream-auth-type\", this.client.getAuthType());\n            params.set(\"X-Stream-Client\", this.client.getUserAgent());\n            // params.append('authorization', this.client._getToken()!);\n            return `${this.client.wsBaseURL}/connect?${params.toString()}`;\n        };\n        /**\n         * onlineStatusChanged - this function is called when the browser connects or disconnects from the internet.\n         *\n         * @param {Event} event Event with type online or offline\n         *\n         */ this.onlineStatusChanged = (event)=>{\n            if (event.type === \"offline\") {\n                // mark the connection as down\n                this._log(\"onlineStatusChanged() - Status changing to offline\");\n                // we know that the app is offline so dispatch the unhealthy connection event immediately\n                this._setHealth(false, true);\n            } else if (event.type === \"online\") {\n                // retry right now...\n                // We check this.isHealthy, not sure if it's always\n                // smart to create a new WS connection if the old one is still up and running.\n                // it's possible we didn't miss any messages, so this process is just expensive and not needed.\n                this._log(`onlineStatusChanged() - Status changing to online. isHealthy: ${this.isHealthy}`);\n                if (!this.isHealthy) {\n                    this._reconnect({\n                        interval: 10\n                    });\n                }\n            }\n        };\n        this.onopen = (wsID)=>{\n            if (this.wsID !== wsID) return;\n            const user = this.client.user;\n            if (!user) {\n                this.client.logger(\"error\", `User not set, can't connect to WS`);\n                return;\n            }\n            const token = this.client._getToken();\n            if (!token) {\n                this.client.logger(\"error\", `Token not set, can't connect authenticate`);\n                return;\n            }\n            const authMessage = {\n                token,\n                user_details: {\n                    id: user.id,\n                    name: user.name,\n                    image: user.image,\n                    custom: user.custom\n                }\n            };\n            this.authenticationSent = true;\n            this.ws?.send(JSON.stringify(authMessage));\n            this._log(\"onopen() - onopen callback\", {\n                wsID\n            });\n        };\n        this.onmessage = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this._log(\"onmessage() - onmessage callback\", {\n                event,\n                wsID\n            });\n            const data = typeof event.data === \"string\" ? JSON.parse(event.data) : null;\n            // we wait till the first message before we consider the connection open.\n            // the reason for this is that auth errors and similar errors trigger a ws.onopen and immediately\n            // after that a ws.onclose.\n            if (!this.isResolved && data && data.type === \"connection.error\") {\n                this.isResolved = true;\n                if (data.error) {\n                    // @ts-expect-error - the types of _errorFromWSEvent are incorrect\n                    this.rejectPromise?.(this._errorFromWSEvent(data, false));\n                    return;\n                }\n            }\n            // trigger the event..\n            this.lastEvent = new Date();\n            if (data && (data.type === \"health.check\" || data.type === \"connection.ok\")) {\n                // the initial health-check should come from the client\n                this.scheduleNextPing();\n            }\n            if (data && data.type === \"connection.ok\") {\n                this.resolvePromise?.(data);\n                this._setHealth(true);\n            }\n            if (data && data.type === \"connection.error\" && data.error) {\n                const { code } = data.error;\n                this.isHealthy = false;\n                this.isConnecting = false;\n                this.consecutiveFailures += 1;\n                if (code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                    clearTimeout(this.connectionCheckTimeoutRef);\n                    this._log(\"connect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                    this._reconnect({\n                        refreshToken: true\n                    });\n                }\n            }\n            if (data) {\n                this.client.dispatchEvent(data);\n            }\n            this.scheduleConnectionCheck();\n        };\n        this.onclose = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this._log(\"onclose() - onclose callback - \" + event.code, {\n                event,\n                wsID\n            });\n            if (event.code === KnownCodes.WS_CLOSED_SUCCESS) {\n                // this is a permanent error raised by stream..\n                // usually caused by invalid auth details\n                const error = new Error(`WS connection reject with error ${event.reason}`);\n                error.reason = event.reason;\n                error.code = event.code;\n                error.wasClean = event.wasClean;\n                error.target = event.target;\n                this.rejectPromise?.(error);\n                this._log(`onclose() - WS connection reject with error ${event.reason}`, {\n                    event\n                });\n            } else {\n                this.consecutiveFailures += 1;\n                this.totalFailures += 1;\n                this._setHealth(false);\n                this.isConnecting = false;\n                this.rejectPromise?.(this._errorFromWSEvent(event));\n                this._log(`onclose() - WS connection closed. Calling reconnect ...`, {\n                    event\n                });\n                // reconnect if its an abnormal failure\n                this._reconnect();\n            }\n        };\n        this.onerror = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this.consecutiveFailures += 1;\n            this.totalFailures += 1;\n            this._setHealth(false);\n            this.isConnecting = false;\n            this.rejectPromise?.(this._errorFromWSEvent(event));\n            this._log(`onerror() - WS connection resulted into error`, {\n                event\n            });\n            this._reconnect();\n        };\n        /**\n         * _setHealth - Sets the connection to healthy or unhealthy.\n         * Broadcasts an event in case the connection status changed.\n         *\n         * @param {boolean} healthy boolean indicating if the connection is healthy or not\n         * @param {boolean} dispatchImmediately boolean indicating to dispatch event immediately even if the connection is unhealthy\n         *\n         */ this._setHealth = (healthy, dispatchImmediately = false)=>{\n            if (healthy === this.isHealthy) return;\n            this.isHealthy = healthy;\n            if (this.isHealthy || dispatchImmediately) {\n                this.client.dispatchEvent({\n                    type: \"connection.changed\",\n                    online: this.isHealthy\n                });\n                return;\n            }\n            // we're offline, wait few seconds and fire and event if still offline\n            setTimeout(()=>{\n                if (this.isHealthy) return;\n                this.client.dispatchEvent({\n                    type: \"connection.changed\",\n                    online: this.isHealthy\n                });\n            }, 5000);\n        };\n        /**\n         * _errorFromWSEvent - Creates an error object for the WS event\n         *\n         */ this._errorFromWSEvent = (event, isWSFailure = true)=>{\n            let code;\n            let statusCode;\n            let message;\n            if (isCloseEvent(event)) {\n                code = event.code;\n                statusCode = \"unknown\";\n                message = event.reason;\n            }\n            if (isErrorEvent(event)) {\n                code = event.error.code;\n                statusCode = event.error.StatusCode;\n                message = event.error.message;\n            }\n            // Keeping this `warn` level log, to avoid cluttering of error logs from ws failures.\n            this._log(`_errorFromWSEvent() - WS failed with code ${code}`, {\n                event\n            }, \"warn\");\n            const error = new Error(`WS failed with code ${code} and reason - ${message}`);\n            error.code = code;\n            /**\n             * StatusCode does not exist on any event types but has been left\n             * as is to preserve JS functionality during the TS implementation\n             */ error.StatusCode = statusCode;\n            error.isWSFailure = isWSFailure;\n            return error;\n        };\n        /**\n         * _setupPromise - sets up the this.connectOpen promise\n         */ this._setupConnectionPromise = ()=>{\n            this.isResolved = false;\n            /** a promise that is resolved once ws.open is called */ this.connectionOpen = new Promise((resolve, reject)=>{\n                this.resolvePromise = resolve;\n                this.rejectPromise = reject;\n            });\n        };\n        /**\n         * Schedules a next health check ping for websocket.\n         */ this.scheduleNextPing = ()=>{\n            if (this.healthCheckTimeoutRef) {\n                clearTimeout(this.healthCheckTimeoutRef);\n            }\n            // 30 seconds is the recommended interval (messenger uses this)\n            this.healthCheckTimeoutRef = setTimeout(()=>{\n                // send the healthcheck..., server replies with a health check event\n                const data = [\n                    {\n                        type: \"health.check\",\n                        client_id: this.client.clientID\n                    }\n                ];\n                // try to send on the connection\n                try {\n                    this.ws?.send(JSON.stringify(data));\n                } catch (e) {\n                // error will already be detected elsewhere\n                }\n            }, this.pingInterval);\n        };\n        /**\n         * scheduleConnectionCheck - schedules a check for time difference between last received event and now.\n         * If the difference is more than 35 seconds, it means our health check logic has failed and websocket needs\n         * to be reconnected.\n         */ this.scheduleConnectionCheck = ()=>{\n            if (this.connectionCheckTimeoutRef) {\n                clearTimeout(this.connectionCheckTimeoutRef);\n            }\n            this.connectionCheckTimeoutRef = setTimeout(()=>{\n                const now = new Date();\n                if (this.lastEvent && now.getTime() - this.lastEvent.getTime() > this.connectionCheckTimeout) {\n                    this._log(\"scheduleConnectionCheck - going to reconnect\");\n                    this._setHealth(false);\n                    this._reconnect();\n                }\n            }, this.connectionCheckTimeout);\n        };\n        this.client = client;\n        /** consecutive failures influence the duration of the timeout */ this.consecutiveFailures = 0;\n        /** keep track of the total number of failures */ this.totalFailures = 0;\n        /** We only make 1 attempt to reconnect at the same time.. */ this.isConnecting = false;\n        /** True after the auth payload is sent to the server */ this.authenticationSent = false;\n        /** To avoid reconnect if client is disconnected */ this.isDisconnected = false;\n        /** Boolean that indicates if the connection promise is resolved */ this.isResolved = false;\n        /** Boolean that indicates if we have a working connection to the server */ this.isHealthy = false;\n        /** Incremented when a new WS connection is made */ this.wsID = 1;\n        /** Store the last event time for health checks */ this.lastEvent = null;\n        /** Send a health check message every 25 seconds */ this.pingInterval = 25 * 1000;\n        this.connectionCheckTimeout = this.pingInterval + 10 * 1000;\n        addConnectionEventListeners(this.onlineStatusChanged);\n    }\n    /**\n     * connect - Connect to the WS URL\n     * the default 15s timeout allows between 2~3 tries\n     * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received\n     */ async connect(timeout = 15000) {\n        if (this.isConnecting) {\n            throw Error(`You've called connect twice, can only attempt 1 connection at the time`);\n        }\n        this.isDisconnected = false;\n        try {\n            const healthCheck = await this._connect();\n            this.consecutiveFailures = 0;\n            this._log(`connect() - Established ws connection with healthcheck: ${healthCheck}`);\n        } catch (error) {\n            this.isHealthy = false;\n            this.consecutiveFailures += 1;\n            if (// @ts-ignore\n            error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                this._log(\"connect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                this._reconnect({\n                    refreshToken: true\n                });\n            } else {\n                // @ts-ignore\n                if (!error.isWSFailure) {\n                    // API rejected the connection and we should not retry\n                    throw new Error(JSON.stringify({\n                        // @ts-ignore\n                        code: error.code,\n                        // @ts-ignore\n                        StatusCode: error.StatusCode,\n                        // @ts-ignore\n                        message: error.message,\n                        // @ts-ignore\n                        isWSFailure: error.isWSFailure\n                    }));\n                }\n            }\n        }\n        return await this._waitForHealthy(timeout);\n    }\n    /**\n     * _waitForHealthy polls the promise connection to see if its resolved until it times out\n     * the default 15s timeout allows between 2~3 tries\n     * @param timeout duration(ms)\n     */ async _waitForHealthy(timeout = 15000) {\n        return Promise.race([\n            (async ()=>{\n                const interval = 50; // ms\n                for(let i = 0; i <= timeout; i += interval){\n                    try {\n                        return await this.connectionOpen;\n                    } catch (error) {\n                        if (i === timeout) {\n                            throw new Error(JSON.stringify({\n                                code: error.code,\n                                StatusCode: error.StatusCode,\n                                message: error.message,\n                                isWSFailure: error.isWSFailure\n                            }));\n                        }\n                        await sleep(interval);\n                    }\n                }\n            })(),\n            (async ()=>{\n                await sleep(timeout);\n                this.isConnecting = false;\n                throw new Error(JSON.stringify({\n                    code: \"\",\n                    StatusCode: \"\",\n                    message: \"initial WS connection could not be established\",\n                    isWSFailure: true\n                }));\n            })()\n        ]);\n    }\n    /**\n     * disconnect - Disconnect the connection and doesn't recover...\n     *\n     */ disconnect(timeout) {\n        this._log(`disconnect() - Closing the websocket connection for wsID ${this.wsID}`);\n        this.wsID += 1;\n        this.isConnecting = false;\n        this.isDisconnected = true;\n        // start by removing all the listeners\n        if (this.healthCheckTimeoutRef) {\n            clearInterval(this.healthCheckTimeoutRef);\n        }\n        if (this.connectionCheckTimeoutRef) {\n            clearInterval(this.connectionCheckTimeoutRef);\n        }\n        removeConnectionEventListeners(this.onlineStatusChanged);\n        this.isHealthy = false;\n        // remove ws handlers...\n        if (this.ws && this.ws.removeAllListeners) {\n            this.ws.removeAllListeners();\n        }\n        let isClosedPromise;\n        // and finally close...\n        // Assigning to local here because we will remove it from this before the\n        // promise resolves.\n        const { ws } = this;\n        if (ws && ws.close && ws.readyState === ws.OPEN) {\n            isClosedPromise = new Promise((resolve)=>{\n                const onclose = (event)=>{\n                    this._log(`disconnect() - resolving isClosedPromise ${event ? \"with\" : \"without\"} close frame`, {\n                        event\n                    });\n                    resolve();\n                };\n                ws.onclose = onclose;\n                // In case we don't receive close frame websocket server in time,\n                // lets not wait for more than 1 second.\n                setTimeout(onclose, timeout != null ? timeout : 1000);\n            });\n            this._log(`disconnect() - Manually closed connection by calling client.disconnect()`);\n            ws.close(KnownCodes.WS_CLOSED_SUCCESS, \"Manually closed connection by calling client.disconnect()\");\n        } else {\n            this._log(`disconnect() - ws connection doesn't exist or it is already closed.`);\n            isClosedPromise = Promise.resolve();\n        }\n        delete this.ws;\n        return isClosedPromise;\n    }\n    /**\n     * _connect - Connect to the WS endpoint\n     *\n     * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received\n     */ async _connect() {\n        if (this.isConnecting || this.isDisconnected && this.client.options.enableWSFallback) return; // simply ignore _connect if it's currently trying to connect\n        this.isConnecting = true;\n        this.requestID = randomId();\n        this.client.insightMetrics.connectionStartTimestamp = new Date().getTime();\n        let isTokenReady = false;\n        try {\n            this._log(`_connect() - waiting for token`);\n            await this.client.tokenManager.tokenReady();\n            isTokenReady = true;\n        } catch (e) {\n        // token provider has failed before, so try again\n        }\n        try {\n            if (!isTokenReady) {\n                this._log(`_connect() - tokenProvider failed before, so going to retry`);\n                await this.client.tokenManager.loadToken();\n            }\n            this._setupConnectionPromise();\n            const wsURL = this._buildUrl();\n            this._log(`_connect() - Connecting to ${wsURL}`, {\n                wsURL,\n                requestID: this.requestID\n            });\n            this.ws = new (isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default())(wsURL);\n            this.ws.onopen = this.onopen.bind(this, this.wsID);\n            this.ws.onclose = this.onclose.bind(this, this.wsID);\n            this.ws.onerror = this.onerror.bind(this, this.wsID);\n            this.ws.onmessage = this.onmessage.bind(this, this.wsID);\n            const response = await this.connectionOpen;\n            this.isConnecting = false;\n            if (response) {\n                this.connectionID = response.connection_id;\n                this.client.resolveConnectionId?.(this.connectionID);\n                if (this.client.insightMetrics.wsConsecutiveFailures > 0 && this.client.options.enableInsights) {\n                    postInsights(\"ws_success_after_failure\", buildWsSuccessAfterFailureInsight(this));\n                    this.client.insightMetrics.wsConsecutiveFailures = 0;\n                }\n                return response;\n            }\n        } catch (err) {\n            this.isConnecting = false;\n            // @ts-ignore\n            this._log(`_connect() - Error - `, err);\n            if (this.client.options.enableInsights) {\n                this.client.insightMetrics.wsConsecutiveFailures++;\n                this.client.insightMetrics.wsTotalFailures++;\n                const insights = buildWsFatalInsight(this, convertErrorToJson(err));\n                postInsights?.(\"ws_fatal\", insights);\n            }\n            this.client.rejectConnectionId?.();\n            throw err;\n        }\n    }\n    /**\n     * _reconnect - Retry the connection to WS endpoint\n     *\n     * @param {{ interval?: number; refreshToken?: boolean }} options Following options are available\n     *\n     * - `interval`\t{int}\t\t\tnumber of ms that function should wait before reconnecting\n     * - `refreshToken` {boolean}\treload/refresh user token be refreshed before attempting reconnection.\n     */ async _reconnect(options = {}) {\n        this._log(\"_reconnect() - Initiating the reconnect\");\n        // only allow 1 connection at the time\n        if (this.isConnecting || this.isHealthy) {\n            this._log(\"_reconnect() - Abort (1) since already connecting or healthy\");\n            return;\n        }\n        // reconnect in case of on error or on close\n        // also reconnect if the health check cycle fails\n        let interval = options.interval;\n        if (!interval) {\n            interval = retryInterval(this.consecutiveFailures);\n        }\n        // reconnect, or try again after a little while...\n        await sleep(interval);\n        // Check once again if by some other call to _reconnect is active or connection is\n        // already restored, then no need to proceed.\n        if (this.isConnecting || this.isHealthy) {\n            this._log(\"_reconnect() - Abort (2) since already connecting or healthy\");\n            return;\n        }\n        if (this.isDisconnected && this.client.options.enableWSFallback) {\n            this._log(\"_reconnect() - Abort (3) since disconnect() is called\");\n            return;\n        }\n        this._log(\"_reconnect() - Destroying current WS connection\");\n        // cleanup the old connection\n        this._destroyCurrentWSConnection();\n        if (options.refreshToken) {\n            await this.client.tokenManager.loadToken();\n        }\n        try {\n            await this._connect();\n            this._log(\"_reconnect() - Waiting for recoverCallBack\");\n            // await this.client.recoverState();\n            this._log(\"_reconnect() - Finished recoverCallBack\");\n            this.consecutiveFailures = 0;\n        } catch (error) {\n            this.isHealthy = false;\n            this.consecutiveFailures += 1;\n            if (error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                this._log(\"_reconnect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                return this._reconnect({\n                    refreshToken: true\n                });\n            }\n            // reconnect on WS failures, don't reconnect if there is a code bug\n            if (error.isWSFailure) {\n                this._log(\"_reconnect() - WS failure, so going to try to reconnect\");\n                this._reconnect();\n            }\n        }\n        this._log(\"_reconnect() - == END ==\");\n    }\n    /**\n     * _destroyCurrentWSConnection - Removes the current WS connection\n     *\n     */ _destroyCurrentWSConnection() {\n        // increment the ID, meaning we will ignore all messages from the old\n        // ws connection from now on.\n        this.wsID += 1;\n        try {\n            this?.ws?.removeAllListeners();\n            this?.ws?.close();\n        } catch (e) {\n        // we don't care\n        }\n    }\n}\nfunction isString(arrayOrString) {\n    return typeof arrayOrString === \"string\";\n}\nfunction isMapStringCallback(arrayOrString, callback) {\n    return !!callback && isString(arrayOrString);\n}\nfunction map(arrayOrString, callback) {\n    const res = [];\n    if (isString(arrayOrString) && isMapStringCallback(arrayOrString, callback)) {\n        for(let k = 0, len = arrayOrString.length; k < len; k++){\n            if (arrayOrString.charAt(k)) {\n                const kValue = arrayOrString.charAt(k);\n                const mappedValue = callback(kValue, k, arrayOrString);\n                res[k] = mappedValue;\n            }\n        }\n    } else if (!isString(arrayOrString) && !isMapStringCallback(arrayOrString, callback)) {\n        for(let k = 0, len = arrayOrString.length; k < len; k++){\n            if (k in arrayOrString) {\n                const kValue = arrayOrString[k];\n                const mappedValue = callback(kValue, k, arrayOrString);\n                res[k] = mappedValue;\n            }\n        }\n    }\n    return res;\n}\nconst encodeBase64 = (data)=>(0,base64_js__WEBPACK_IMPORTED_MODULE_8__.fromByteArray)(new Uint8Array(map(data, (char)=>char.charCodeAt(0))));\n// base-64 decoder throws exception if encoded string is not padded by '=' to make string length\n// in multiples of 4. So gonna use our own method for this purpose to keep backwards compatibility\n// https://github.com/beatgammit/base64-js/blob/master/index.js#L26\nconst decodeBase64 = (s)=>{\n    const e = {}, w = String.fromCharCode, L = s.length;\n    let i, b = 0, c, x, l = 0, a, r = \"\";\n    const A = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(i = 0; i < 64; i++){\n        e[A.charAt(i)] = i;\n    }\n    for(x = 0; x < L; x++){\n        c = e[s.charAt(x)];\n        b = (b << 6) + c;\n        l += 6;\n        while(l >= 8){\n            ((a = b >>> (l -= 8) & 0xff) || x < L - 2) && (r += w(a));\n        }\n    }\n    return r;\n};\n/**\n * Creates the JWT token that can be used for a UserSession\n * @method JWTUserToken\n * @memberof signing\n * @private\n * @param {Secret} apiSecret - API Secret key\n * @param {string} userId - The user_id key in the JWT payload\n * @param {UR} [extraData] - Extra that should be part of the JWT token\n * @param {SignOptions} [jwtOptions] - Options that can be past to jwt.sign\n * @return {string} JWT Token\n */ function JWTUserToken(apiSecret, userId, extraData = {}, jwtOptions = {}) {\n    if (typeof userId !== \"string\") {\n        throw new TypeError(\"userId should be a string\");\n    }\n    const payload = {\n        user_id: userId,\n        ...extraData\n    };\n    // make sure we return a clear error when jwt is shimmed (ie. browser build)\n    if ((jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default()) == null || (jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign) == null) {\n        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);\n    }\n    const opts = Object.assign({\n        algorithm: \"HS256\",\n        noTimestamp: true\n    }, jwtOptions);\n    if (payload.iat) {\n        opts.noTimestamp = false;\n    }\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign(payload, apiSecret, opts);\n}\nfunction JWTServerToken(apiSecret, jwtOptions = {}) {\n    const payload = {\n        server: true\n    };\n    const opts = Object.assign({\n        algorithm: \"HS256\",\n        noTimestamp: true\n    }, jwtOptions);\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign(payload, apiSecret, opts);\n}\nfunction UserFromToken(token) {\n    const fragments = token.split(\".\");\n    if (fragments.length !== 3) {\n        return \"\";\n    }\n    const b64Payload = fragments[1];\n    const payload = decodeBase64(b64Payload);\n    const data = JSON.parse(payload);\n    return data.user_id;\n}\n/**\n *\n * @param {string} userId the id of the user\n * @return {string}\n */ function DevToken(userId) {\n    return [\n        \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n        encodeBase64(JSON.stringify({\n            user_id: userId\n        })),\n        \"devtoken\"\n    ].join(\".\");\n}\n/**\n * TokenManager\n *\n * Handles all the operations around user token.\n */ class TokenManager {\n    /**\n     * Constructor\n     *\n     * @param {Secret} secret\n     */ constructor(secret){\n        /**\n         * Set the static string token or token provider.\n         * Token provider should return a token string or a promise which resolves to string token.\n         *\n         * @param {TokenOrProvider} tokenOrProvider - the token or token provider.\n         * @param {UserResponse} user - the user object.\n         * @param {boolean} isAnonymous - whether the user is anonymous or not.\n         */ this.setTokenOrProvider = async (tokenOrProvider, user, isAnonymous)=>{\n            this.validateToken(tokenOrProvider, user, isAnonymous);\n            this.user = user;\n            if (isFunction(tokenOrProvider)) {\n                this.tokenProvider = tokenOrProvider;\n                this.type = \"provider\";\n            }\n            if (typeof tokenOrProvider === \"string\") {\n                this.token = tokenOrProvider;\n                this.type = \"static\";\n            }\n            if (!tokenOrProvider && this.user && this.secret) {\n                this.token = JWTUserToken(this.secret, user.id, {}, {});\n                this.type = \"static\";\n            }\n            await this.loadToken();\n        };\n        /**\n         * Resets the token manager.\n         * Useful for client disconnection or switching user.\n         */ this.reset = ()=>{\n            this.token = undefined;\n            this.user = undefined;\n            this.loadTokenPromise = null;\n        };\n        // Validates the user token.\n        this.validateToken = (tokenOrProvider, user, isAnonymous)=>{\n            // allow empty token for anon user\n            if (user && isAnonymous && !tokenOrProvider) return;\n            // Don't allow empty token for non-server side client.\n            if (!this.secret && !tokenOrProvider) {\n                throw new Error(\"UserWithId token can not be empty\");\n            }\n            if (tokenOrProvider && typeof tokenOrProvider !== \"string\" && !isFunction(tokenOrProvider)) {\n                throw new Error(\"user token should either be a string or a function\");\n            }\n            if (typeof tokenOrProvider === \"string\") {\n                // Allow empty token for anonymous users\n                if (isAnonymous && tokenOrProvider === \"\") return;\n                const tokenUserId = UserFromToken(tokenOrProvider);\n                if (tokenOrProvider != null && (tokenUserId == null || tokenUserId === \"\" || !isAnonymous && tokenUserId !== user.id)) {\n                    throw new Error(\"userToken does not have a user_id or is not matching with user.id\");\n                }\n            }\n        };\n        // Resolves when token is ready. This function is simply to check if loadToken is in progress, in which\n        // case a function should wait.\n        this.tokenReady = ()=>this.loadTokenPromise;\n        // Fetches a token from tokenProvider function and sets in tokenManager.\n        // In case of static token, it will simply resolve to static token.\n        this.loadToken = ()=>{\n            // eslint-disable-next-line no-async-promise-executor\n            this.loadTokenPromise = new Promise(async (resolve, reject)=>{\n                if (this.type === \"static\") {\n                    return resolve(this.token);\n                }\n                if (this.tokenProvider && typeof this.tokenProvider !== \"string\") {\n                    try {\n                        this.token = await this.tokenProvider();\n                    } catch (e) {\n                        return reject(new Error(`Call to tokenProvider failed with message: ${e}`));\n                    }\n                    resolve(this.token);\n                }\n            });\n            return this.loadTokenPromise;\n        };\n        // Returns a current token\n        this.getToken = ()=>{\n            if (this.token) {\n                return this.token;\n            }\n            if (this.user && !this.token) {\n                return this.token;\n            }\n            if (this.secret) {\n                return JWTServerToken(this.secret);\n            }\n            throw new Error(`Both secret and user tokens are not set. Either client.connectUser wasn't called or client.disconnect was called`);\n        };\n        this.isStatic = ()=>this.type === \"static\";\n        this.loadTokenPromise = null;\n        if (secret) {\n            this.secret = secret;\n        }\n        this.type = \"static\";\n        if (this.secret) {\n            this.token = JWTServerToken(this.secret);\n        }\n    }\n}\nconst APIErrorCodes = {\n    \"-1\": {\n        name: \"InternalSystemError\",\n        retryable: true\n    },\n    \"2\": {\n        name: \"AccessKeyError\",\n        retryable: false\n    },\n    \"3\": {\n        name: \"AuthenticationFailedError\",\n        retryable: true\n    },\n    \"4\": {\n        name: \"InputError\",\n        retryable: false\n    },\n    \"6\": {\n        name: \"DuplicateUsernameError\",\n        retryable: false\n    },\n    \"9\": {\n        name: \"RateLimitError\",\n        retryable: true\n    },\n    \"16\": {\n        name: \"DoesNotExistError\",\n        retryable: false\n    },\n    \"17\": {\n        name: \"NotAllowedError\",\n        retryable: false\n    },\n    \"18\": {\n        name: \"EventNotSupportedError\",\n        retryable: false\n    },\n    \"19\": {\n        name: \"ChannelFeatureNotSupportedError\",\n        retryable: false\n    },\n    \"20\": {\n        name: \"MessageTooLongError\",\n        retryable: false\n    },\n    \"21\": {\n        name: \"MultipleNestingLevelError\",\n        retryable: false\n    },\n    \"22\": {\n        name: \"PayloadTooBigError\",\n        retryable: false\n    },\n    \"23\": {\n        name: \"RequestTimeoutError\",\n        retryable: true\n    },\n    \"24\": {\n        name: \"MaxHeaderSizeExceededError\",\n        retryable: false\n    },\n    \"40\": {\n        name: \"AuthErrorTokenExpired\",\n        retryable: false\n    },\n    \"41\": {\n        name: \"AuthErrorTokenNotValidYet\",\n        retryable: false\n    },\n    \"42\": {\n        name: \"AuthErrorTokenUsedBeforeIssuedAt\",\n        retryable: false\n    },\n    \"43\": {\n        name: \"AuthErrorTokenSignatureInvalid\",\n        retryable: false\n    },\n    \"44\": {\n        name: \"CustomCommandEndpointMissingError\",\n        retryable: false\n    },\n    \"45\": {\n        name: \"CustomCommandEndpointCallError\",\n        retryable: true\n    },\n    \"46\": {\n        name: \"ConnectionIDNotFoundError\",\n        retryable: false\n    },\n    \"60\": {\n        name: \"CoolDownError\",\n        retryable: true\n    },\n    \"69\": {\n        name: \"ErrWrongRegion\",\n        retryable: false\n    },\n    \"70\": {\n        name: \"ErrQueryChannelPermissions\",\n        retryable: false\n    },\n    \"71\": {\n        name: \"ErrTooManyConnections\",\n        retryable: true\n    },\n    \"99\": {\n        name: \"AppSuspendedError\",\n        retryable: false\n    }\n};\nfunction isAPIError(error) {\n    return error.code !== undefined;\n}\nfunction isErrorRetryable(error) {\n    if (!error.code) return false;\n    const err = APIErrorCodes[`${error.code}`];\n    if (!err) return false;\n    return err.retryable;\n}\nfunction isConnectionIDError(error) {\n    return error.code === 46; // ConnectionIDNotFoundError\n}\nfunction isWSFailure(err) {\n    if (typeof err.isWSFailure === \"boolean\") {\n        return err.isWSFailure;\n    }\n    try {\n        return JSON.parse(err.message).isWSFailure;\n    } catch (_) {\n        return false;\n    }\n}\nfunction isErrorResponse(res) {\n    return !res.status || res.status < 200 || 300 <= res.status;\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Closed\"] = \"CLOSED\";\n    ConnectionState[\"Connected\"] = \"CONNECTED\";\n    ConnectionState[\"Connecting\"] = \"CONNECTING\";\n    ConnectionState[\"Disconnected\"] = \"DISCONNECTED\";\n    ConnectionState[\"Init\"] = \"INIT\";\n})(ConnectionState || (ConnectionState = {}));\nclass WSConnectionFallback {\n    constructor(client){\n        /** @private */ this._onlineStatusChanged = (event)=>{\n            this._log(`_onlineStatusChanged() - ${event.type}`);\n            if (event.type === \"offline\") {\n                this._setState(ConnectionState.Closed);\n                this.cancelToken?.cancel(\"disconnect() is called\");\n                this.cancelToken = undefined;\n                return;\n            }\n            if (event.type === \"online\" && this.state === ConnectionState.Closed) {\n                this.connect(true);\n            }\n        };\n        /** @private */ this._req = async (params, config, retry)=>{\n            if (!this.cancelToken && !params.close) {\n                this.cancelToken = axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].CancelToken.source();\n            }\n            try {\n                const res = await this.client.doAxiosRequest(\"get\", this.client.baseURL.replace(\":3030\", \":8900\") + \"/longpoll\", undefined, {\n                    config: {\n                        ...config,\n                        cancelToken: this.cancelToken?.token\n                    },\n                    params,\n                    publicEndpoint: true\n                });\n                this.consecutiveFailures = 0; // always reset in case of no error\n                return res;\n            } catch (err) {\n                this.consecutiveFailures += 1;\n                // @ts-ignore\n                if (retry && isErrorRetryable(err)) {\n                    this._log(`_req() - Retryable error, retrying request`);\n                    await sleep(retryInterval(this.consecutiveFailures));\n                    return this._req(params, config, retry);\n                }\n                throw err;\n            }\n        };\n        /** @private */ this._poll = async ()=>{\n            while(this.state === ConnectionState.Connected){\n                try {\n                    const data = await this._req({}, {\n                        timeout: 30000\n                    }, true); // 30s => API responds in 20s if there is no event\n                    if (data.events?.length) {\n                        for(let i = 0; i < data.events.length; i++){\n                            this.client.dispatchEvent(data.events[i]);\n                        }\n                    }\n                } catch (err) {\n                    if (axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].isCancel(err)) {\n                        this._log(`_poll() - axios canceled request`);\n                        return;\n                    }\n                    /** client.doAxiosRequest will take care of TOKEN_EXPIRED error */ // @ts-ignore\n                    if (isConnectionIDError(err)) {\n                        this._log(`_poll() - ConnectionID error, connecting without ID...`);\n                        this._setState(ConnectionState.Disconnected);\n                        this.connect(true);\n                        return;\n                    }\n                    // @ts-ignore\n                    if (isAPIError(err) && !isErrorRetryable(err)) {\n                        this._setState(ConnectionState.Closed);\n                        return;\n                    }\n                    await sleep(retryInterval(this.consecutiveFailures));\n                }\n            }\n        };\n        /**\n         * connect try to open a longpoll request\n         * @param reconnect should be false for first call and true for subsequent calls to keep the connection alive and call recoverState\n         */ this.connect = async (reconnect = false)=>{\n            if (this.state === ConnectionState.Connecting) {\n                this._log(\"connect() - connecting already in progress\", {\n                    reconnect\n                }, \"warn\");\n                return;\n            }\n            if (this.state === ConnectionState.Connected) {\n                this._log(\"connect() - already connected and polling\", {\n                    reconnect\n                }, \"warn\");\n                return;\n            }\n            this._setState(ConnectionState.Connecting);\n            this.connectionID = undefined; // connect should be sent with empty connection_id so API creates one\n            try {\n                const { event } = await this._req({\n                    json: this.client._buildWSPayload()\n                }, {\n                    timeout: 8000\n                }, reconnect);\n                this._setState(ConnectionState.Connected);\n                this.connectionID = event.connection_id;\n                this.client.resolveConnectionId?.();\n                // @ts-expect-error\n                this.client.dispatchEvent(event);\n                this._poll();\n                return event;\n            } catch (err) {\n                this._setState(ConnectionState.Closed);\n                this.client.rejectConnectionId?.();\n                throw err;\n            }\n        };\n        /**\n         * isHealthy checks if there is a connectionID and connection is in Connected state\n         */ this.isHealthy = ()=>{\n            return !!this.connectionID && this.state === ConnectionState.Connected;\n        };\n        this.disconnect = async (timeout = 2000)=>{\n            removeConnectionEventListeners(this._onlineStatusChanged);\n            this._setState(ConnectionState.Disconnected);\n            this.cancelToken?.cancel(\"disconnect() is called\");\n            this.cancelToken = undefined;\n            const connection_id = this.connectionID;\n            this.connectionID = undefined;\n            try {\n                await this._req({\n                    close: true,\n                    connection_id\n                }, {\n                    timeout\n                }, false);\n                this._log(`disconnect() - Closed connectionID`);\n            } catch (err) {\n                this._log(`disconnect() - Failed`, {\n                    err\n                }, \"error\");\n            }\n        };\n        this.client = client;\n        this.state = ConnectionState.Init;\n        this.consecutiveFailures = 0;\n        addConnectionEventListeners(this._onlineStatusChanged);\n    }\n    _log(msg, extra = {}, level = \"info\") {\n        this.client.logger(level, \"WSConnectionFallback:\" + msg, {\n            ...extra\n        });\n    }\n    _setState(state) {\n        this._log(`_setState() - ${state}`);\n        // transition from connecting => connected\n        if (this.state === ConnectionState.Connecting && state === ConnectionState.Connected) {\n            this.client.dispatchEvent({\n                type: \"connection.changed\",\n                online: true\n            });\n        }\n        if (state === ConnectionState.Closed || state === ConnectionState.Disconnected) {\n            this.client.dispatchEvent({\n                type: \"connection.changed\",\n                online: false\n            });\n        }\n        this.state = state;\n    }\n}\nconst logger = getLogger([\n    \"location\"\n]);\nconst HINT_URL = `https://hint.stream-io-video.com/`;\nconst getLocationHint = async (hintUrl = HINT_URL, timeout = 2000)=>{\n    const abortController = new AbortController();\n    const timeoutId = setTimeout(()=>abortController.abort(), timeout);\n    try {\n        const response = await fetch(hintUrl, {\n            method: \"HEAD\",\n            signal: abortController.signal\n        });\n        const awsPop = response.headers.get(\"x-amz-cf-pop\") || \"ERR\";\n        logger(\"debug\", `Location header: ${awsPop}`);\n        return awsPop.substring(0, 3); // AMS1-P2 -> AMS\n    } catch (e) {\n        logger(\"warn\", `Failed to get location hint from ${hintUrl}`, e);\n        return \"ERR\";\n    } finally{\n        clearTimeout(timeoutId);\n    }\n};\nclass StreamClient {\n    /**\n     * Initialize a client.\n     *\n     * @param {string} key - the api key\n     * @param {StreamClientOptions} [options] - additional options, here you can pass custom options to axios instance\n     * @param {string} [options.secret] - the api secret\n     * @param {boolean} [options.browser] - enforce the client to be in browser mode\n     * @param {boolean} [options.warmUp] - default to false, if true, client will open a connection as soon as possible to speed up following requests\n     * @param {Logger} [options.Logger] - custom logger\n     * @param {number} [options.timeout] - default to 3000\n     * @param {httpsAgent} [options.httpsAgent] - custom httpsAgent, in node it's default to https.agent()\n     */ constructor(key, options){\n        this.listeners = {};\n        this.nextRequestAbortController = null;\n        this.devToken = (userID)=>{\n            return DevToken(userID);\n        };\n        this.getAuthType = ()=>{\n            return this.anonymous ? \"anonymous\" : \"jwt\";\n        };\n        this.setBaseURL = (baseURL)=>{\n            this.baseURL = baseURL;\n            this.wsBaseURL = this.baseURL.replace(\"http\", \"ws\").replace(\":3030\", \":8800\");\n        };\n        this.getLocationHint = async (hintUrl, timeout)=>{\n            const hint = await this.locationHint;\n            if (!hint || hint === \"ERR\") {\n                this.locationHint = getLocationHint(hintUrl ?? this.options.locationHintUrl, timeout ?? this.options.locationHintTimeout);\n                return this.locationHint;\n            }\n            return hint;\n        };\n        this._getConnectionID = ()=>this.wsConnection?.connectionID || this.wsFallback?.connectionID;\n        this._hasConnectionID = ()=>Boolean(this._getConnectionID());\n        /**\n         * connectUser - Set the current user and open a WebSocket connection\n         *\n         * @param user Data about this user. IE {name: \"john\"}\n         * @param {TokenOrProvider} userTokenOrProvider Token or provider\n         *\n         * @return {ConnectAPIResponse} Returns a promise that resolves when the connection is setup\n         */ this.connectUser = async (user, userTokenOrProvider)=>{\n            if (!user.id) {\n                throw new Error('The \"id\" field on the user is missing');\n            }\n            /**\n             * Calling connectUser multiple times is potentially the result of a  bad integration, however,\n             * If the user id remains the same we don't throw error\n             */ if (this.userID === user.id && this.setUserPromise) {\n                this.logger(\"warn\", \"Consecutive calls to connectUser is detected, ideally you should only call this function once in your app.\");\n                return this.setUserPromise;\n            }\n            if (this.userID) {\n                throw new Error(\"Use client.disconnect() before trying to connect as a different user. connectUser was called twice.\");\n            }\n            if ((this._isUsingServerAuth() || this.node) && !this.options.allowServerSideConnect) {\n                this.logger(\"warn\", 'Please do not use connectUser server side. connectUser impacts MAU and concurrent connection usage and thus your bill. If you have a valid use-case, add \"allowServerSideConnect: true\" to the client options to disable this warning.');\n            }\n            // we generate the client id client side\n            this.userID = user.id;\n            this.anonymous = false;\n            const setTokenPromise = this._setToken(user, userTokenOrProvider, this.anonymous);\n            this._setUser(user);\n            const wsPromise = this.openConnection();\n            this.setUserPromise = Promise.all([\n                setTokenPromise,\n                wsPromise\n            ]).then((result)=>result[1]);\n            try {\n                return await this.setUserPromise;\n            } catch (err) {\n                if (this.persistUserOnConnectionFailure) {\n                    // cleanup client to allow the user to retry connectUser again\n                    this.closeConnection();\n                } else {\n                    this.disconnectUser();\n                }\n                throw err;\n            }\n        };\n        this._setToken = (user, userTokenOrProvider, isAnonymous)=>this.tokenManager.setTokenOrProvider(userTokenOrProvider, user, isAnonymous);\n        this._setUser = (user)=>{\n            /**\n             * This one is used by the frontend. This is a copy of the current user object stored on backend.\n             * It contains reserved properties and own user properties which are not present in `this._user`.\n             */ this.user = user;\n            this.userID = user.id;\n            // this one is actually used for requests. This is a copy of current user provided to `connectUser` function.\n            this._user = {\n                ...user\n            };\n        };\n        /**\n         * Disconnects the websocket connection, without removing the user set on client.\n         * client.closeConnection will not trigger default auto-retry mechanism for reconnection. You need\n         * to call client.openConnection to reconnect to websocket.\n         *\n         * This is mainly useful on mobile side. You can only receive push notifications\n         * if you don't have active websocket connection.\n         * So when your app goes to background, you can call `client.closeConnection`.\n         * And when app comes back to foreground, call `client.openConnection`.\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming succesful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.closeConnection = async (timeout)=>{\n            if (this.cleaningIntervalRef != null) {\n                clearInterval(this.cleaningIntervalRef);\n                this.cleaningIntervalRef = undefined;\n            }\n            await Promise.all([\n                this.wsConnection?.disconnect(timeout),\n                this.wsFallback?.disconnect(timeout)\n            ]);\n            return Promise.resolve();\n        };\n        /**\n         * Creates a new WebSocket connection with the current user. Returns empty promise, if there is an active connection\n         */ this.openConnection = async ()=>{\n            if (!this.userID) {\n                throw Error(\"UserWithId is not set on client, use client.connectUser or client.connectAnonymousUser instead\");\n            }\n            if (this.wsConnection?.isConnecting && this.wsPromise) {\n                this.logger(\"info\", \"client:openConnection() - connection already in progress\");\n                return this.wsPromise;\n            }\n            if ((this.wsConnection?.isHealthy || this.wsFallback?.isHealthy()) && this._hasConnectionID()) {\n                this.logger(\"info\", \"client:openConnection() - openConnection called twice, healthy connection already exists\");\n                return Promise.resolve();\n            }\n            this.connectionIdPromise = new Promise((resolve, reject)=>{\n                this.resolveConnectionId = resolve;\n                this.rejectConnectionId = reject;\n            });\n            this.clientID = `${this.userID}--${randomId()}`;\n            this.wsPromise = this.connect();\n            return this.wsPromise;\n        };\n        this._normalizeDate = (before)=>{\n            if (before instanceof Date) {\n                before = before.toISOString();\n            }\n            if (before === \"\") {\n                throw new Error(\"Don't pass blank string for since, use null instead if resetting the token revoke\");\n            }\n            return before;\n        };\n        /**\n         * Disconnects the websocket and removes the user from client.\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.disconnectUser = async (timeout)=>{\n            this.logger(\"info\", \"client:disconnect() - Disconnecting the client\");\n            // remove the user specific fields\n            delete this.user;\n            delete this._user;\n            delete this.userID;\n            this.anonymous = false;\n            await this.closeConnection(timeout);\n            this.tokenManager.reset();\n            this.connectionIdPromise = undefined;\n            this.rejectConnectionId = undefined;\n            this.resolveConnectionId = undefined;\n        };\n        this.connectGuestUser = async (user)=>{\n            this.guestUserCreatePromise = this.doAxiosRequest(\"post\", \"/guest\", {\n                user: {\n                    ...user,\n                    role: \"guest\"\n                }\n            }, {\n                publicEndpoint: true\n            });\n            const response = await this.guestUserCreatePromise;\n            this.guestUserCreatePromise.finally(()=>this.guestUserCreatePromise = undefined);\n            return this.connectUser(response.user, response.access_token);\n        };\n        /**\n         * connectAnonymousUser - Set an anonymous user and open a WebSocket connection\n         */ this.connectAnonymousUser = async (user, tokenOrProvider)=>{\n            this.connectionIdPromise = new Promise((resolve, reject)=>{\n                this.resolveConnectionId = resolve;\n                this.rejectConnectionId = reject;\n            });\n            this.anonymous = true;\n            await this._setToken(user, tokenOrProvider, this.anonymous);\n            this._setUser(user);\n            // some endpoints require a connection_id to be resolved.\n            // as anonymous users aren't allowed to open WS connections, we just\n            // resolve the connection_id here.\n            this.resolveConnectionId?.();\n        };\n        /**\n         * on - Listen to events on all channels and users your watching\n         *\n         * client.on('message.new', event => {console.log(\"my new message\", event, channel.state.messages)})\n         *\n         * @param eventName The event type to listen for (optional)\n         * @param callback The callback to call\n         *\n         * @return  Returns a function which, when called, unsubscribes the event handler.\n         */ this.on = (eventName, callback)=>{\n            if (!this.listeners[eventName]) {\n                this.listeners[eventName] = [];\n            }\n            this.logger(\"debug\", `Adding listener for ${eventName} event`);\n            this.listeners[eventName]?.push(callback);\n            return ()=>{\n                this.off(eventName, callback);\n            };\n        };\n        /**\n         * off - Remove the event handler\n         */ this.off = (eventName, callback)=>{\n            if (!this.listeners[eventName]) {\n                this.listeners[eventName] = [];\n            }\n            this.logger(\"debug\", `Removing listener for ${eventName} event`);\n            this.listeners[eventName] = this.listeners[eventName]?.filter((value)=>value !== callback);\n        };\n        this._logApiRequest = (type, url, data, config)=>{\n            this.logger(\"trace\", `client: ${type} - Request - ${url}`, {\n                payload: data,\n                config\n            });\n        };\n        this._logApiResponse = (type, url, response)=>{\n            this.logger(\"trace\", `client:${type} - Response - url: ${url} > status ${response.status}`, {\n                response\n            });\n        };\n        this._logApiError = (type, url, error)=>{\n            this.logger(\"error\", `client:${type} - Error - url: ${url}`, {\n                url,\n                error\n            });\n        };\n        this.doAxiosRequest = async (type, url, data, options = {})=>{\n            if (!options.publicEndpoint) {\n                await Promise.all([\n                    this.tokenManager.tokenReady(),\n                    this.guestUserCreatePromise,\n                    this.connectionIdPromise\n                ]);\n            }\n            const requestConfig = this._enrichAxiosOptions(options);\n            try {\n                let response;\n                this._logApiRequest(type, url, data, requestConfig);\n                switch(type){\n                    case \"get\":\n                        response = await this.axiosInstance.get(url, requestConfig);\n                        break;\n                    case \"delete\":\n                        response = await this.axiosInstance.delete(url, requestConfig);\n                        break;\n                    case \"post\":\n                        response = await this.axiosInstance.post(url, data, requestConfig);\n                        break;\n                    case \"put\":\n                        response = await this.axiosInstance.put(url, data, requestConfig);\n                        break;\n                    case \"patch\":\n                        response = await this.axiosInstance.patch(url, data, requestConfig);\n                        break;\n                    case \"options\":\n                        response = await this.axiosInstance.options(url, requestConfig);\n                        break;\n                    default:\n                        throw new Error(\"Invalid request type\");\n                }\n                this._logApiResponse(type, url, response);\n                this.consecutiveFailures = 0;\n                return this.handleResponse(response);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            } catch (e /**TODO: generalize error types  */ ) {\n                e.client_request_id = requestConfig.headers?.[\"x-client-request-id\"];\n                this.consecutiveFailures += 1;\n                if (e.response) {\n                    this._logApiError(type, url, e.response);\n                    /** connection_fallback depends on this token expiration logic */ if (e.response.data.code === KnownCodes.TOKEN_EXPIRED && !this.tokenManager.isStatic()) {\n                        if (this.consecutiveFailures > 1) {\n                            await sleep(retryInterval(this.consecutiveFailures));\n                        }\n                        await this.tokenManager.loadToken();\n                        return await this.doAxiosRequest(type, url, data, options);\n                    }\n                    return this.handleResponse(e.response);\n                } else {\n                    this._logApiError(type, url, e);\n                    // eslint-disable-next-line no-throw-literal\n                    throw e;\n                }\n            }\n        };\n        this.get = (url, params)=>{\n            return this.doAxiosRequest(\"get\", url, null, {\n                params\n            });\n        };\n        this.put = (url, data, params)=>{\n            return this.doAxiosRequest(\"put\", url, data, {\n                params\n            });\n        };\n        this.post = (url, data, params)=>{\n            return this.doAxiosRequest(\"post\", url, data, {\n                params\n            });\n        };\n        this.patch = (url, data, params)=>{\n            return this.doAxiosRequest(\"patch\", url, data, {\n                params\n            });\n        };\n        this.delete = (url, params)=>{\n            return this.doAxiosRequest(\"delete\", url, null, {\n                params\n            });\n        };\n        this.errorFromResponse = (response)=>{\n            let err;\n            err = new ErrorFromResponse(`Stream error HTTP code: ${response.status}`);\n            if (response.data && response.data.code) {\n                err = new Error(`Stream error code ${response.data.code}: ${response.data.message}`);\n                err.code = response.data.code;\n            }\n            err.response = response;\n            err.status = response.status;\n            return err;\n        };\n        this.handleResponse = (response)=>{\n            const data = response.data;\n            if (isErrorResponse(response)) {\n                throw this.errorFromResponse(response);\n            }\n            return data;\n        };\n        this.dispatchEvent = (event)=>{\n            if (!event.received_at) event.received_at = new Date();\n            this.logger(\"debug\", `Dispatching event: ${event.type}`, event);\n            if (!this.listeners) return;\n            // call generic listeners\n            for (const listener of this.listeners.all || []){\n                listener(event);\n            }\n            // call type specific listeners\n            for (const listener of this.listeners[event.type] || []){\n                listener(event);\n            }\n        };\n        /**\n         * @private\n         */ this.connect = async ()=>{\n            if (!this.userID || !this._user) {\n                throw Error(\"Call connectUser or connectAnonymousUser before starting the connection\");\n            }\n            if (!this.wsBaseURL) {\n                throw Error(\"Websocket base url not set\");\n            }\n            if (!this.clientID) {\n                throw Error(\"clientID is not set\");\n            }\n            if (!this.wsConnection && (this.options.warmUp || this.options.enableInsights)) {\n                this._sayHi();\n            }\n            // The StableWSConnection handles all the reconnection logic.\n            if (this.options.wsConnection && this.node) {\n                // Intentionally avoiding adding ts generics on wsConnection in options since its only useful for unit test purpose.\n                this.options.wsConnection.setClient(this);\n                this.wsConnection = this.options.wsConnection;\n            } else {\n                this.wsConnection = new StableWSConnection(this);\n            }\n            try {\n                // if fallback is used before, continue using it instead of waiting for WS to fail\n                if (this.wsFallback) {\n                    return await this.wsFallback.connect();\n                }\n                this.logger(\"info\", \"StreamClient.connect: this.wsConnection.connect()\");\n                // if WSFallback is enabled, ws connect should timeout faster so fallback can try\n                return await this.wsConnection.connect(this.options.enableWSFallback ? this.defaultWSTimeoutWithFallback : this.defaultWSTimeout);\n            } catch (err) {\n                // run fallback only if it's WS/Network error and not a normal API error\n                // make sure browser is online before even trying the longpoll\n                if (this.options.enableWSFallback && // @ts-ignore\n                isWSFailure(err) && isOnline(this.logger)) {\n                    this.logger(\"warn\", \"client:connect() - WS failed, fallback to longpoll\");\n                    this.dispatchEvent({\n                        type: \"transport.changed\",\n                        mode: \"longpoll\"\n                    });\n                    this.wsConnection._destroyCurrentWSConnection();\n                    this.wsConnection.disconnect().then(); // close WS so no retry\n                    this.wsFallback = new WSConnectionFallback(this);\n                    return await this.wsFallback.connect();\n                }\n                throw err;\n            }\n        };\n        /**\n         * Check the connectivity with server for warmup purpose.\n         *\n         * @private\n         */ this._sayHi = ()=>{\n            const client_request_id = randomId();\n            const opts = {\n                headers: axios__WEBPACK_IMPORTED_MODULE_1__.AxiosHeaders.from({\n                    \"x-client-request-id\": client_request_id\n                })\n            };\n            this.doAxiosRequest(\"get\", this.baseURL + \"/hi\", null, opts).catch((e)=>{\n                if (this.options.enableInsights) {\n                    postInsights(\"http_hi_failed\", {\n                        api_key: this.key,\n                        err: e,\n                        client_request_id\n                    });\n                }\n            });\n        };\n        this.getUserAgent = ()=>{\n            const version = \"0.6.10\";\n            return this.userAgent || `stream-video-javascript-client-${this.node ? \"node\" : \"browser\"}-${version}`;\n        };\n        this.setUserAgent = (userAgent)=>{\n            this.userAgent = userAgent;\n        };\n        /**\n         * _isUsingServerAuth - Returns true if we're using server side auth\n         */ this._isUsingServerAuth = ()=>!!this.secret;\n        this._enrichAxiosOptions = (options = {\n            params: {},\n            headers: {},\n            config: {}\n        })=>{\n            const token = options.publicEndpoint && !this.user ? undefined : this._getToken();\n            const authorization = token ? {\n                Authorization: token\n            } : undefined;\n            let signal = null;\n            if (this.nextRequestAbortController !== null) {\n                signal = this.nextRequestAbortController.signal;\n                this.nextRequestAbortController = null;\n            }\n            if (!options.headers?.[\"x-client-request-id\"]) {\n                options.headers = {\n                    ...options.headers,\n                    \"x-client-request-id\": randomId()\n                };\n            }\n            return {\n                params: {\n                    user_id: this.userID,\n                    connection_id: this._getConnectionID(),\n                    api_key: this.key,\n                    ...options.params\n                },\n                headers: {\n                    ...authorization,\n                    \"stream-auth-type\": options.publicEndpoint && !this.user ? \"anonymous\" : this.getAuthType(),\n                    \"X-Stream-Client\": this.getUserAgent(),\n                    ...options.headers\n                },\n                ...signal ? {\n                    signal\n                } : {},\n                ...options.config,\n                ...this.options.axiosRequestConfig\n            };\n        };\n        this._getToken = ()=>{\n            if (!this.tokenManager) return null;\n            return this.tokenManager.getToken();\n        };\n        /**\n         * encode ws url payload\n         * @private\n         * @returns json string\n         */ this._buildWSPayload = (client_request_id)=>{\n            return JSON.stringify({\n                user_id: this.userID,\n                user_details: this._user,\n                client_request_id\n            });\n        };\n        /**\n         * creates an abort controller that will be used by the next HTTP Request.\n         */ this.createAbortControllerForNextRequest = ()=>{\n            return this.nextRequestAbortController = new AbortController();\n        };\n        /**\n         * createToken - Creates a token to authenticate this user. This function is used server side.\n         * The resulting token should be passed to the client side when the users registers or logs in.\n         *\n         * @param {string} userID The UserWithId ID\n         * @param {number} [exp] The expiration time for the token expressed in the number of seconds since the epoch\n         * @param call_cids for anonymous tokens you have to provide the call cids the use can join\n         *\n         * @return {string} Returns a token\n         */ this.createToken = (userID, exp, iat, call_cids)=>{\n            if (this.secret == null) {\n                throw Error(`tokens can only be created server-side using the API Secret`);\n            }\n            const extra = {};\n            if (exp) {\n                extra.exp = exp;\n            }\n            if (iat) {\n                extra.iat = iat;\n            }\n            if (call_cids) {\n                extra.call_cids = call_cids;\n            }\n            return JWTUserToken(this.secret, userID, extra, {});\n        };\n        // set the key\n        this.key = key;\n        // set the secret\n        this.secret = options?.secret;\n        // set the options... and figure out defaults...\n        const inputOptions = options ? options : {\n            browser: \"undefined\" !== \"undefined\"\n        };\n        this.browser = inputOptions.browser || \"undefined\" !== \"undefined\";\n        this.node = !this.browser;\n        if (this.browser) {\n            this.locationHint = getLocationHint(options?.locationHintUrl, options?.locationHintTimeout);\n        }\n        this.options = {\n            timeout: 5000,\n            withCredentials: false,\n            warmUp: false,\n            ...inputOptions\n        };\n        if (this.node && !this.options.httpsAgent) {\n            this.options.httpsAgent = new (https__WEBPACK_IMPORTED_MODULE_5___default().Agent)({\n                keepAlive: true,\n                keepAliveMsecs: 3000\n            });\n        }\n        this.setBaseURL(this.options.baseURL || \"https://video.stream-io-api.com/video\");\n        if (typeof process !== \"undefined\" && process.env.STREAM_LOCAL_TEST_RUN) {\n            this.setBaseURL(\"http://localhost:3030/video\");\n        }\n        if (typeof process !== \"undefined\" && process.env.STREAM_LOCAL_TEST_HOST) {\n            this.setBaseURL(`http://${process.env.STREAM_LOCAL_TEST_HOST}/video`);\n        }\n        this.axiosInstance = axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].create({\n            ...this.options,\n            baseURL: this.baseURL\n        });\n        // WS connection is initialized when setUser is called\n        this.wsConnection = null;\n        this.wsPromise = null;\n        this.setUserPromise = null;\n        // mapping between channel groups and configs\n        this.anonymous = false;\n        this.persistUserOnConnectionFailure = this.options?.persistUserOnConnectionFailure;\n        // If it is a server-side client, then lets initialize the tokenManager, since token will be\n        // generated from secret.\n        this.tokenManager = new TokenManager(this.secret);\n        this.consecutiveFailures = 0;\n        this.insightMetrics = new InsightMetrics();\n        this.defaultWSTimeoutWithFallback = 6000;\n        this.defaultWSTimeout = 15000;\n        this.logger = isFunction(inputOptions.logger) ? inputOptions.logger : ()=>null;\n    }\n}\n/**\n * A `StreamVideoClient` instance lets you communicate with our API, and authenticate users.\n */ class StreamVideoClient {\n    constructor(apiKeyOrArgs, opts){\n        this.logLevel = \"warn\";\n        this.eventHandlersToUnregister = [];\n        /**\n         * Disconnects the currently connected user from the client.\n         *\n         * If the connection is successfully disconnected, the connected user [state variable](#readonlystatestore) will be updated accordingly\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.disconnectUser = async (timeout)=>{\n            if (!this.streamClient.user && !this.connectionPromise) {\n                return;\n            }\n            const disconnectUser = ()=>this.streamClient.disconnectUser(timeout);\n            this.disconnectionPromise = this.connectionPromise ? this.connectionPromise.then(()=>disconnectUser()) : disconnectUser();\n            this.disconnectionPromise.finally(()=>this.disconnectionPromise = undefined);\n            await this.disconnectionPromise;\n            this.eventHandlersToUnregister.forEach((unregister)=>unregister());\n            this.eventHandlersToUnregister = [];\n            this.writeableStateStore.setConnectedUser(undefined);\n        };\n        /**\n         * You can subscribe to WebSocket events provided by the API.\n         * To remove a subscription, call the `off` method or, execute the returned unsubscribe function.\n         * Please note that subscribing to WebSocket events is an advanced use-case, for most use-cases it should be enough to watch for changes in the reactive [state store](#readonlystatestore).\n         *\n         * @param eventName the event name or 'all'.\n         * @param callback the callback which will be called when the event is emitted.\n         * @returns an unsubscribe function.\n         */ this.on = (eventName, callback)=>{\n            return this.streamClient.on(eventName, callback);\n        };\n        /**\n         * Remove subscription for WebSocket events that were created by the `on` method.\n         *\n         * @param eventName the event name.\n         * @param callback the callback which was passed to the `on` method.\n         */ this.off = (eventName, callback)=>{\n            return this.streamClient.off(eventName, callback);\n        };\n        /**\n         * Creates a new call.\n         *\n         * @param type the type of the call.\n         * @param id the id of the call.\n         */ this.call = (type, id)=>{\n            return new Call({\n                streamClient: this.streamClient,\n                id: id,\n                type: type,\n                clientStore: this.writeableStateStore\n            });\n        };\n        /**\n         * Creates a new guest user with the given data.\n         *\n         * @param data the data for the guest user.\n         */ this.createGuestUser = async (data)=>{\n            return this.streamClient.doAxiosRequest(\"post\", \"/guest\", data, {\n                publicEndpoint: true\n            });\n        };\n        /**\n         * Will query the API for calls matching the given filters.\n         *\n         * @param data the query data.\n         */ this.queryCalls = async (data = {})=>{\n            const response = await this.streamClient.post(\"/calls\", data);\n            const calls = response.calls.map((c)=>{\n                const call = new Call({\n                    streamClient: this.streamClient,\n                    id: c.call.id,\n                    type: c.call.type,\n                    members: c.members,\n                    ownCapabilities: c.own_capabilities,\n                    watching: data.watch,\n                    clientStore: this.writeableStateStore\n                });\n                call.state.updateFromCallResponse(c.call);\n                call.applyDeviceConfig();\n                if (data.watch) {\n                    this.writeableStateStore.registerCall(call);\n                }\n                return call;\n            });\n            return {\n                ...response,\n                calls: calls\n            };\n        };\n        /**\n         * Retrieve the list of available call statistics reports matching a particular condition.\n         *\n         * @param data Filter and sort conditions for retrieving available call report summaries.\n         * @returns List with summary of available call reports matching the condition.\n         */ this.queryCallStats = async (data = {})=>{\n            return this.streamClient.post(`/call/stats`, data);\n        };\n        /**\n         * Returns a list of available data centers available for hosting calls.\n         */ this.edges = async ()=>{\n            return this.streamClient.get(`/edges`);\n        };\n        /**\n         * addDevice - Adds a push device for a user.\n         *\n         * @param {string} id the device id\n         * @param {string} push_provider the push provider name (eg. apn, firebase)\n         * @param {string} push_provider_name user provided push provider name\n         * @param {string} [userID] the user id (defaults to current user)\n         * @param {boolean} [voip_token] enables use of VoIP token for push notifications on iOS platform\n         */ this.addDevice = async (id, push_provider, push_provider_name, userID, voip_token)=>{\n            return await this.streamClient.post(\"/devices\", {\n                id,\n                push_provider,\n                voip_token,\n                ...userID != null ? {\n                    user_id: userID\n                } : {},\n                ...push_provider_name != null ? {\n                    push_provider_name\n                } : {}\n            });\n        };\n        /**\n         * getDevices - Returns the devices associated with a current user\n         * @param {string} [userID] User ID. Only works on serverside\n         */ this.getDevices = async (userID)=>{\n            return await this.streamClient.get(\"/devices\", userID ? {\n                user_id: userID\n            } : {});\n        };\n        /**\n         * removeDevice - Removes the device with the given id.\n         *\n         * @param {string} id The device id\n         * @param {string} [userID] The user id. Only specify this for serverside requests\n         */ this.removeDevice = async (id, userID)=>{\n            return await this.streamClient.delete(\"/devices\", {\n                id,\n                ...userID ? {\n                    user_id: userID\n                } : {}\n            });\n        };\n        /**\n         * A callback that can be used to create ringing calls from push notifications. If the call already exists, it will do nothing.\n         * @param call_cid\n         * @returns\n         */ this.onRingingCall = async (call_cid)=>{\n            // if we find the call and is already ringing, we don't need to create a new call\n            // as client would have received the call.ring state because the app had WS alive when receiving push notifications\n            let call = this.readOnlyStateStore.calls.find((c)=>c.cid === call_cid && c.ringing);\n            if (!call) {\n                // if not it means that WS is not alive when receiving the push notifications and we need to fetch the call\n                const [callType, callId] = call_cid.split(\":\");\n                call = new Call({\n                    streamClient: this.streamClient,\n                    type: callType,\n                    id: callId,\n                    clientStore: this.writeableStateStore,\n                    ringing: true\n                });\n                await call.get();\n            }\n            return call;\n        };\n        /**\n         * Connects the given anonymous user to the client.\n         *\n         * @param user the user to connect.\n         * @param tokenOrProvider a token or a function that returns a token.\n         */ this.connectAnonymousUser = async (user, tokenOrProvider)=>{\n            const connectAnonymousUser = ()=>this.streamClient.connectAnonymousUser(user, tokenOrProvider);\n            this.connectionPromise = this.disconnectionPromise ? this.disconnectionPromise.then(()=>connectAnonymousUser()) : connectAnonymousUser();\n            this.connectionPromise.finally(()=>this.connectionPromise = undefined);\n            return this.connectionPromise;\n        };\n        let logger = logToConsole;\n        let logLevel = \"warn\";\n        if (typeof apiKeyOrArgs === \"string\") {\n            logLevel = opts?.logLevel || logLevel;\n            logger = opts?.logger || logger;\n        } else {\n            logLevel = apiKeyOrArgs.options?.logLevel || logLevel;\n            logger = apiKeyOrArgs.options?.logger || logger;\n        }\n        setLogger(logger, logLevel);\n        this.logger = getLogger([\n            \"client\"\n        ]);\n        if (typeof apiKeyOrArgs === \"string\") {\n            this.streamClient = new StreamClient(apiKeyOrArgs, {\n                persistUserOnConnectionFailure: true,\n                ...opts,\n                logLevel,\n                logger: this.logger\n            });\n        } else {\n            this.streamClient = new StreamClient(apiKeyOrArgs.apiKey, {\n                persistUserOnConnectionFailure: true,\n                ...apiKeyOrArgs.options,\n                logLevel,\n                logger: this.logger\n            });\n            const sdkInfo = getSdkInfo();\n            if (sdkInfo) {\n                this.streamClient.setUserAgent(this.streamClient.getUserAgent() + `-video-${SdkType[sdkInfo.type].toLowerCase()}-sdk-${sdkInfo.major}.${sdkInfo.minor}.${sdkInfo.patch}`);\n            }\n        }\n        this.writeableStateStore = new StreamVideoWriteableStateStore();\n        this.readOnlyStateStore = new StreamVideoReadOnlyStateStore(this.writeableStateStore);\n        if (typeof apiKeyOrArgs !== \"string\") {\n            const user = apiKeyOrArgs.user;\n            const token = apiKeyOrArgs.token || apiKeyOrArgs.tokenProvider;\n            if (user) {\n                this.connectUser(user, token);\n            }\n        }\n    }\n    /**\n     * Return the reactive state store, use this if you want to be notified about changes to the client state\n     */ get state() {\n        return this.readOnlyStateStore;\n    }\n    /**\n     * Connects the given user to the client.\n     * Only one user can connect at a time, if you want to change users, call `disconnectUser` before connecting a new user.\n     * If the connection is successful, the connected user [state variable](#readonlystatestore) will be updated accordingly.\n     *\n     * @param user the user to connect.\n     * @param token a token or a function that returns a token.\n     */ async connectUser(user, token) {\n        if (user.type === \"anonymous\") {\n            user.id = \"!anon\";\n            return this.connectAnonymousUser(user, token);\n        }\n        let connectUser = ()=>{\n            return this.streamClient.connectUser(user, token);\n        };\n        if (user.type === \"guest\") {\n            connectUser = async ()=>{\n                return this.streamClient.connectGuestUser(user);\n            };\n        }\n        this.connectionPromise = this.disconnectionPromise ? this.disconnectionPromise.then(()=>connectUser()) : connectUser();\n        this.connectionPromise?.finally(()=>this.connectionPromise = undefined);\n        const connectUserResponse = await this.connectionPromise;\n        // connectUserResponse will be void if connectUser called twice for the same user\n        if (connectUserResponse?.me) {\n            this.writeableStateStore.setConnectedUser(connectUserResponse.me);\n        }\n        this.eventHandlersToUnregister.push(this.on(\"connection.changed\", (event)=>{\n            if (event.online) {\n                const callsToReWatch = this.writeableStateStore.calls.filter((call)=>call.watching).map((call)=>call.cid);\n                this.logger(\"info\", `Rewatching calls after connection changed ${callsToReWatch.join(\", \")}`);\n                if (callsToReWatch.length > 0) {\n                    this.queryCalls({\n                        watch: true,\n                        filter_conditions: {\n                            cid: {\n                                $in: callsToReWatch\n                            }\n                        },\n                        sort: [\n                            {\n                                field: \"cid\",\n                                direction: 1\n                            }\n                        ]\n                    }).catch((err)=>{\n                        this.logger(\"error\", \"Failed to re-watch calls\", err);\n                    });\n                }\n            }\n        }));\n        this.eventHandlersToUnregister.push(this.on(\"call.created\", (event)=>{\n            const { call, members } = event;\n            if (user.id === call.created_by.id) {\n                this.logger(\"warn\", \"Received `call.created` sent by the current user\");\n                return;\n            }\n            this.logger(\"info\", `New call created and registered: ${call.cid}`);\n            const newCall = new Call({\n                streamClient: this.streamClient,\n                type: call.type,\n                id: call.id,\n                members,\n                clientStore: this.writeableStateStore\n            });\n            newCall.state.updateFromCallResponse(call);\n            this.writeableStateStore.registerCall(newCall);\n        }));\n        this.eventHandlersToUnregister.push(this.on(\"call.ring\", async (event)=>{\n            const { call, members } = event;\n            if (user.id === call.created_by.id) {\n                this.logger(\"debug\", \"Received `call.ring` sent by the current user so ignoring the event\");\n                return;\n            }\n            // The call might already be tracked by the client,\n            // if `call.created` was received before `call.ring`.\n            // In that case, we cleanup the already tracked call.\n            const prevCall = this.writeableStateStore.findCall(call.type, call.id);\n            await prevCall?.leave({\n                reason: \"cleaning-up in call.ring\"\n            });\n            // we create a new call\n            const theCall = new Call({\n                streamClient: this.streamClient,\n                type: call.type,\n                id: call.id,\n                members,\n                clientStore: this.writeableStateStore,\n                ringing: true\n            });\n            theCall.state.updateFromCallResponse(call);\n            // we fetch the latest metadata for the call from the server\n            await theCall.get();\n            this.writeableStateStore.registerCall(theCall);\n        }));\n        return connectUserResponse;\n    }\n    /**\n     * addDevice - Adds a push device for a user.\n     *\n     * @param {string} id the device id\n     * @param {string} push_provider the push provider name (eg. apn, firebase)\n     * @param {string} push_provider_name user provided push provider name\n     * @param {string} [userID] the user id (defaults to current user)\n     */ async addVoipDevice(id, push_provider, push_provider_name, userID) {\n        return await this.addDevice(id, push_provider, push_provider_name, userID, true);\n    }\n}\n/**\n * @deprecated Please use the `@stream-io/node-sdk` package instead.\n *\n * @see https://getstream.io/video/docs/api/\n */ class StreamVideoServerClient extends StreamVideoClient {\n    constructor(apiKey, options){\n        super({\n            apiKey,\n            options\n        });\n        this.getCallTypes = ()=>{\n            return this.streamClient.get(\"/calltypes\");\n        };\n        this.getCallType = (name)=>{\n            return this.streamClient.get(`/calltypes/${name}`);\n        };\n        this.createCallType = (data)=>{\n            return this.streamClient.post(\"/calltypes\", data);\n        };\n        this.deleteCallType = (name)=>{\n            return this.streamClient.delete(`/calltypes/${name}`);\n        };\n        this.updateCallType = (name, data)=>{\n            return this.streamClient.put(`/calltypes/${name}`, data);\n        };\n        this.listExternalStorage = ()=>{\n            return this.streamClient.get(\"/external_storage\");\n        };\n        this.createExternalStorage = (request)=>{\n            return this.streamClient.post(\"/external_storage\", request);\n        };\n        this.deleteExternalStorage = (name)=>{\n            return this.streamClient.delete(`/external_storage/${name}`);\n        };\n        this.updateExternalStorage = (name, request)=>{\n            return this.streamClient.put(`/external_storage/${name}`, request);\n        };\n        this.checkExternalStorage = (name)=>{\n            return this.streamClient.get(`/external_storage/${name}/check`);\n        };\n    }\n    /**\n     * createToken - Creates a token to authenticate this user. This function is used server side.\n     * The resulting token should be passed to the client side when the users register or logs in.\n     *\n     * @param {string} userID The User ID\n     * @param {number} [exp] The expiration time for the token expressed in the number of seconds since the epoch\n     * @param {number} [iat] The timestamp when a token has been issued\n     * @param call_cids for anonymous tokens you have to provide the call cids the use can join\n     *\n     * @return {string} Returns a token\n     */ createToken(userID, exp, iat, call_cids) {\n        return this.streamClient.createToken(userID, exp, iat, call_cids);\n    }\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1jbGllbnQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBQ3lIO0FBQzFFO0FBQzNCO0FBQ1Q7QUFDZ0M7QUFDZ0w7QUFDOU07QUFDRztBQUNGO0FBQ1o7QUFDSztBQUNmO0FBQzBCO0FBRTFDOztDQUVDLEdBQ0QsTUFBTXNDLGlDQUFpQztJQUNuQ0MsU0FBUztJQUNUQyxVQUFVO0FBQ2Q7QUFDQTs7Q0FFQyxHQUNELE1BQU1DLHdDQUF3QztJQUMxQ0YsU0FBUztJQUNUQyxVQUFVO0FBQ2Q7QUFDQTs7Q0FFQyxHQUNELE1BQU1FLHNDQUFzQztJQUN4Q0MsVUFBVTtJQUNWQyxLQUFLO0lBQ0xDLFFBQVE7SUFDUkMsUUFBUTtBQUNaO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyx5QkFBeUI7SUFDM0JDLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxvQkFBb0I7SUFDcEJDLFFBQVE7SUFDUkMsUUFBUTtBQUNaO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyxnQ0FBZ0M7SUFDbENMLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxvQkFBb0I7SUFDcEJDLFFBQVE7SUFDUkMsUUFBUTtBQUNaO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUUsZ0JBQWdCO0lBQ2xCQyxhQUFhO0lBQ2JDLGFBQWE7SUFDYkMsaUJBQWlCO0lBQ2pCQyxVQUFVO0lBQ1ZDLGdCQUFnQjtJQUNoQkMsV0FBVztJQUNYQyxpQkFBaUI7SUFDakJDLFlBQVk7SUFDWkMsa0JBQWtCO0lBQ2xCQyxXQUFXO0lBQ1hDLG9CQUFvQjtJQUNwQkMsYUFBYTtJQUNiQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsc0JBQXNCO0lBQ3RC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QixPQUFPLElBQUksQ0FBQzBWLFlBQVksQ0FBQ3pWLElBQUksQ0FBQyxxQkFBcUJEO1FBQ3ZEO1FBQ0EsSUFBSSxDQUFDeXVCLHFCQUFxQixHQUFHLENBQUNqMUQ7WUFDMUIsT0FBTyxJQUFJLENBQUNrOEMsWUFBWSxDQUFDeGdCLE1BQU0sQ0FBQyxDQUFDLGtCQUFrQixFQUFFMTdCLEtBQUssQ0FBQztRQUMvRDtRQUNBLElBQUksQ0FBQ2sxRCxxQkFBcUIsR0FBRyxDQUFDbDFELE1BQU13bUM7WUFDaEMsT0FBTyxJQUFJLENBQUMwVixZQUFZLENBQUM4VSxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRWh4RCxLQUFLLENBQUMsRUFBRXdtQztRQUM5RDtRQUNBLElBQUksQ0FBQzJ1QixvQkFBb0IsR0FBRyxDQUFDbjFEO1lBQ3pCLE9BQU8sSUFBSSxDQUFDazhDLFlBQVksQ0FBQ3ZpQixHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRTM1QixLQUFLLE1BQU0sQ0FBQztRQUNsRTtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNEK3hELFlBQVkzTSxNQUFNLEVBQUU0TSxHQUFHLEVBQUV6RyxHQUFHLEVBQUUwRyxTQUFTLEVBQUU7UUFDckMsT0FBTyxJQUFJLENBQUMvVixZQUFZLENBQUM2VixXQUFXLENBQUMzTSxRQUFRNE0sS0FBS3pHLEtBQUswRztJQUMzRDtBQUNKO0FBRTZqRCxDQUM3akQsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veW9vbS8uL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL3ZpZGVvLWNsaWVudC9kaXN0L2luZGV4LmVzLmpzP2M5NjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICd3ZWJydGMtYWRhcHRlcic7XG5pbXBvcnQgeyBNZXNzYWdlVHlwZSwgaXNKc29uT2JqZWN0LCB0eXBlb2ZKc29uVmFsdWUsIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwsIFVua25vd25GaWVsZEhhbmRsZXIsIFdpcmVUeXBlLCBQYkxvbmcgfSBmcm9tICdAcHJvdG9idWYtdHMvcnVudGltZSc7XG5pbXBvcnQgeyBTZXJ2aWNlVHlwZSwgc3RhY2tJbnRlcmNlcHQgfSBmcm9tICdAcHJvdG9idWYtdHMvcnVudGltZS1ycGMnO1xuaW1wb3J0IGF4aW9zLCB7IEF4aW9zSGVhZGVycyB9IGZyb20gJ2F4aW9zJztcbmV4cG9ydCB7IEF4aW9zRXJyb3IgfSBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBUd2lycEZldGNoVHJhbnNwb3J0IH0gZnJvbSAnQHByb3RvYnVmLXRzL3R3aXJwLXRyYW5zcG9ydCc7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBCZWhhdmlvclN1YmplY3QsIG1hcCBhcyBtYXAkMSwgc2hhcmVSZXBsYXksIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCB0YWtlV2hpbGUsIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLCBtZXJnZSwgZnJvbSwgT2JzZXJ2YWJsZSwgZGVib3VuY2VUaW1lLCBjb25jYXRNYXAsIHBhaXJ3aXNlLCBvZiwgZmlsdGVyLCBkZWJvdW5jZSwgdGltZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCAqIGFzIFNEUCBmcm9tICdzZHAtdHJhbnNmb3JtJztcbmltcG9ydCB7IFVBUGFyc2VyIH0gZnJvbSAndWEtcGFyc2VyLWpzJztcbmltcG9ydCBXZWJTb2NrZXQgZnJvbSAnaXNvbW9ycGhpYy13cyc7XG5pbXBvcnQgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuaW1wb3J0ICdjcnlwdG8nO1xuaW1wb3J0IHsgZnJvbUJ5dGVBcnJheSB9IGZyb20gJ2Jhc2U2NC1qcyc7XG5cbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0gPSB7XG4gICAgU1BFQUtFUjogJ3NwZWFrZXInLFxuICAgIEVBUlBJRUNFOiAnZWFycGllY2UnLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBBdWRpb1NldHRpbmdzUmVxdWVzdERlZmF1bHREZXZpY2VFbnVtID0ge1xuICAgIFNQRUFLRVI6ICdzcGVha2VyJyxcbiAgICBFQVJQSUVDRTogJ2VhcnBpZWNlJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0gPSB7XG4gICAgRklSRUJBU0U6ICdmaXJlYmFzZScsXG4gICAgQVBOOiAnYXBuJyxcbiAgICBIVUFXRUk6ICdodWF3ZWknLFxuICAgIFhJQU9NSTogJ3hpYW9taScsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IExheW91dFNldHRpbmdzTmFtZUVudW0gPSB7XG4gICAgU1BPVExJR0hUOiAnc3BvdGxpZ2h0JyxcbiAgICBHUklEOiAnZ3JpZCcsXG4gICAgU0lOR0xFX1BBUlRJQ0lQQU5UOiAnc2luZ2xlLXBhcnRpY2lwYW50JyxcbiAgICBNT0JJTEU6ICdtb2JpbGUnLFxuICAgIENVU1RPTTogJ2N1c3RvbScsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IExheW91dFNldHRpbmdzUmVxdWVzdE5hbWVFbnVtID0ge1xuICAgIFNQT1RMSUdIVDogJ3Nwb3RsaWdodCcsXG4gICAgR1JJRDogJ2dyaWQnLFxuICAgIFNJTkdMRV9QQVJUSUNJUEFOVDogJ3NpbmdsZS1wYXJ0aWNpcGFudCcsXG4gICAgTU9CSUxFOiAnbW9iaWxlJyxcbiAgICBDVVNUT006ICdjdXN0b20nLFxufTtcbi8qKlxuICogQWxsIHBvc3NpYmlsaXR5IG9mIHN0cmluZyB0byB1c2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgT3duQ2FwYWJpbGl0eSA9IHtcbiAgICBCTE9DS19VU0VSUzogJ2Jsb2NrLXVzZXJzJyxcbiAgICBDUkVBVEVfQ0FMTDogJ2NyZWF0ZS1jYWxsJyxcbiAgICBDUkVBVEVfUkVBQ1RJT046ICdjcmVhdGUtcmVhY3Rpb24nLFxuICAgIEVORF9DQUxMOiAnZW5kLWNhbGwnLFxuICAgIEpPSU5fQkFDS1NUQUdFOiAnam9pbi1iYWNrc3RhZ2UnLFxuICAgIEpPSU5fQ0FMTDogJ2pvaW4tY2FsbCcsXG4gICAgSk9JTl9FTkRFRF9DQUxMOiAnam9pbi1lbmRlZC1jYWxsJyxcbiAgICBNVVRFX1VTRVJTOiAnbXV0ZS11c2VycycsXG4gICAgUElOX0ZPUl9FVkVSWU9ORTogJ3Bpbi1mb3ItZXZlcnlvbmUnLFxuICAgIFJFQURfQ0FMTDogJ3JlYWQtY2FsbCcsXG4gICAgUkVNT1ZFX0NBTExfTUVNQkVSOiAncmVtb3ZlLWNhbGwtbWVtYmVyJyxcbiAgICBTQ1JFRU5TSEFSRTogJ3NjcmVlbnNoYXJlJyxcbiAgICBTRU5EX0FVRElPOiAnc2VuZC1hdWRpbycsXG4gICAgU0VORF9WSURFTzogJ3NlbmQtdmlkZW8nLFxuICAgIFNUQVJUX0JST0FEQ0FTVF9DQUxMOiAnc3RhcnQtYnJvYWRjYXN0LWNhbGwnLFxuICAgIFNUQVJUX1JFQ09SRF9DQUxMOiAnc3RhcnQtcmVjb3JkLWNhbGwnLFxuICAgIFNUQVJUX1RSQU5TQ1JJUFRJT05fQ0FMTDogJ3N0YXJ0LXRyYW5zY3JpcHRpb24tY2FsbCcsXG4gICAgU1RPUF9CUk9BRENBU1RfQ0FMTDogJ3N0b3AtYnJvYWRjYXN0LWNhbGwnLFxuICAgIFNUT1BfUkVDT1JEX0NBTEw6ICdzdG9wLXJlY29yZC1jYWxsJyxcbiAgICBTVE9QX1RSQU5TQ1JJUFRJT05fQ0FMTDogJ3N0b3AtdHJhbnNjcmlwdGlvbi1jYWxsJyxcbiAgICBVUERBVEVfQ0FMTDogJ3VwZGF0ZS1jYWxsJyxcbiAgICBVUERBVEVfQ0FMTF9NRU1CRVI6ICd1cGRhdGUtY2FsbC1tZW1iZXInLFxuICAgIFVQREFURV9DQUxMX1BFUk1JU1NJT05TOiAndXBkYXRlLWNhbGwtcGVybWlzc2lvbnMnLFxuICAgIFVQREFURV9DQUxMX1NFVFRJTkdTOiAndXBkYXRlLWNhbGwtc2V0dGluZ3MnLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBSZWNvcmRTZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0UXVhbGl0eUVudW0gPSB7XG4gICAgXzM2MFA6ICczNjBwJyxcbiAgICBfNDgwUDogJzQ4MHAnLFxuICAgIF83MjBQOiAnNzIwcCcsXG4gICAgXzEwODBQOiAnMTA4MHAnLFxuICAgIF8xNDQwUDogJzE0NDBwJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNjcmlwdGlvblNldHRpbmdzTW9kZUVudW0gPSB7XG4gICAgQVZBSUxBQkxFOiAnYXZhaWxhYmxlJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBBVVRPX09OOiAnYXV0by1vbicsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0gPSB7XG4gICAgRlJPTlQ6ICdmcm9udCcsXG4gICAgQkFDSzogJ2JhY2snLFxuICAgIEVYVEVSTkFMOiAnZXh0ZXJuYWwnLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1NldHRpbmdzUmVxdWVzdENhbWVyYUZhY2luZ0VudW0gPSB7XG4gICAgRlJPTlQ6ICdmcm9udCcsXG4gICAgQkFDSzogJ2JhY2snLFxuICAgIEVYVEVSTkFMOiAnZXh0ZXJuYWwnLFxufTtcblxuY2xhc3MgRXJyb3JGcm9tUmVzcG9uc2UgZXh0ZW5kcyBFcnJvciB7XG59XG5cbi8qKlxuICogYE51bGxWYWx1ZWAgaXMgYSBzaW5nbGV0b24gZW51bWVyYXRpb24gdG8gcmVwcmVzZW50IHRoZSBudWxsIHZhbHVlIGZvciB0aGVcbiAqIGBWYWx1ZWAgdHlwZSB1bmlvbi5cbiAqXG4gKiAgVGhlIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIGBOdWxsVmFsdWVgIGlzIEpTT04gYG51bGxgLlxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcbiAqL1xudmFyIE51bGxWYWx1ZTtcbihmdW5jdGlvbiAoTnVsbFZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogTnVsbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBOVUxMX1ZBTFVFID0gMDtcbiAgICAgKi9cbiAgICBOdWxsVmFsdWVbTnVsbFZhbHVlW1wiTlVMTF9WQUxVRVwiXSA9IDBdID0gXCJOVUxMX1ZBTFVFXCI7XG59KShOdWxsVmFsdWUgfHwgKE51bGxWYWx1ZSA9IHt9KSk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTdHJ1Y3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2dvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2ZpZWxkcycsXG4gICAgICAgICAgICAgICAga2luZDogJ21hcCcsXG4gICAgICAgICAgICAgICAgSzogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICAgICAgVjogeyBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFZhbHVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGBTdHJ1Y3RgIHRvIEpTT04gb2JqZWN0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7fTtcbiAgICAgICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UuZmllbGRzKSkge1xuICAgICAgICAgICAganNvbltrXSA9IFZhbHVlLnRvSnNvbih2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGBTdHJ1Y3RgIGZyb20gSlNPTiBvYmplY3QuXG4gICAgICovXG4gICAgaW50ZXJuYWxKc29uUmVhZChqc29uLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCFpc0pzb25PYmplY3QoanNvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcignVW5hYmxlIHRvIHBhcnNlIG1lc3NhZ2UgJyArXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSArXG4gICAgICAgICAgICAgICAgJyBmcm9tIEpTT04gJyArXG4gICAgICAgICAgICAgICAgdHlwZW9mSnNvblZhbHVlKGpzb24pICtcbiAgICAgICAgICAgICAgICAnLicpO1xuICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIGZvciAobGV0IFtrLCB2XSBvZiBnbG9iYWxUaGlzLk9iamVjdC5lbnRyaWVzKGpzb24pKSB7XG4gICAgICAgICAgICB0YXJnZXQuZmllbGRzW2tdID0gVmFsdWUuZnJvbUpzb24odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5maWVsZHMgPSB7fTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogbWFwPHN0cmluZywgZ29vZ2xlLnByb3RvYnVmLlZhbHVlPiBmaWVsZHMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5hcnlSZWFkTWFwMShtZXNzYWdlLmZpZWxkcywgcmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYmluYXJ5UmVhZE1hcDEobWFwLCByZWFkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGxlbiA9IHJlYWRlci51aW50MzIoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbiwga2V5LCB2YWw7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IFZhbHVlLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCd1bmtub3duIG1hcCBlbnRyeSBmaWVsZCBmb3IgZmllbGQgZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5maWVsZHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXBba2V5ID8/ICcnXSA9IHZhbCA/PyBWYWx1ZS5jcmVhdGUoKTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogbWFwPHN0cmluZywgZ29vZ2xlLnByb3RvYnVmLlZhbHVlPiBmaWVsZHMgPSAxOyAqL1xuICAgICAgICBmb3IgKGxldCBrIG9mIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMobWVzc2FnZS5maWVsZHMpKSB7XG4gICAgICAgICAgICB3cml0ZXJcbiAgICAgICAgICAgICAgICAudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZClcbiAgICAgICAgICAgICAgICAuZm9yaygpXG4gICAgICAgICAgICAgICAgLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgICAgICAgICAgLnN0cmluZyhrKTtcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCk7XG4gICAgICAgICAgICBWYWx1ZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZmllbGRzW2tdLCB3cml0ZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgd3JpdGVyLmpvaW4oKS5qb2luKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RcbiAqL1xuY29uc3QgU3RydWN0ID0gbmV3IFN0cnVjdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWYWx1ZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignZ29vZ2xlLnByb3RvYnVmLlZhbHVlJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdudWxsX3ZhbHVlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbJ2dvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUnLCBOdWxsVmFsdWVdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnbnVtYmVyX3ZhbHVlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2tpbmQnLFxuICAgICAgICAgICAgICAgIFQ6IDEgLypTY2FsYXJUeXBlLkRPVUJMRSovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3RyaW5nX3ZhbHVlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2tpbmQnLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYm9vbF92YWx1ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJ1Y3RfdmFsdWUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2tpbmQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFN0cnVjdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2xpc3RfdmFsdWUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2tpbmQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IExpc3RWYWx1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYFZhbHVlYCB0byBKU09OIHZhbHVlLlxuICAgICAqL1xuICAgIGludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5raW5kLm9uZW9mS2luZCkge1xuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xWYWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2Uua2luZC5ib29sVmFsdWU7XG4gICAgICAgICAgICBjYXNlICdudWxsVmFsdWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyVmFsdWUnOlxuICAgICAgICAgICAgICAgIGxldCBudW1iZXJWYWx1ZSA9IG1lc3NhZ2Uua2luZC5udW1iZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG51bWJlclZhbHVlID09ICdudW1iZXInICYmICFOdW1iZXIuaXNGaW5pdGUobnVtYmVyVmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJWYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZ1ZhbHVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5raW5kLnN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgY2FzZSAnbGlzdFZhbHVlJzpcbiAgICAgICAgICAgICAgICBsZXQgbGlzdFZhbHVlRmllbGQgPSB0aGlzLmZpZWxkcy5maW5kKChmKSA9PiBmLm5vID09PSA2KTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdFZhbHVlRmllbGQ/LmtpbmQgIT09ICdtZXNzYWdlJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFZhbHVlRmllbGQuVCgpLnRvSnNvbihtZXNzYWdlLmtpbmQubGlzdFZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cnVjdFZhbHVlJzpcbiAgICAgICAgICAgICAgICBsZXQgc3RydWN0VmFsdWVGaWVsZCA9IHRoaXMuZmllbGRzLmZpbmQoKGYpID0+IGYubm8gPT09IDUpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3RWYWx1ZUZpZWxkPy5raW5kICE9PSAnbWVzc2FnZScpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdFZhbHVlRmllbGQuVCgpLnRvSnNvbihtZXNzYWdlLmtpbmQuc3RydWN0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBgVmFsdWVgIGZyb20gSlNPTiB2YWx1ZS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25SZWFkKGpzb24sIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmtpbmQgPSB7IG9uZW9mS2luZDogJ251bWJlclZhbHVlJywgbnVtYmVyVmFsdWU6IGpzb24gfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmtpbmQgPSB7IG9uZW9mS2luZDogJ3N0cmluZ1ZhbHVlJywgc3RyaW5nVmFsdWU6IGpzb24gfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0geyBvbmVvZktpbmQ6ICdib29sVmFsdWUnLCBib29sVmFsdWU6IGpzb24gfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdudWxsVmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFZhbHVlOiBOdWxsVmFsdWUuTlVMTF9WQUxVRSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnbGlzdFZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RWYWx1ZTogTGlzdFZhbHVlLmZyb21Kc29uKGpzb24pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdzdHJ1Y3RWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3RWYWx1ZTogU3RydWN0LmZyb21Kc29uKGpzb24pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcgZnJvbSBKU09OICcgK1xuICAgICAgICAgICAgICAgICAgICB0eXBlb2ZKc29uVmFsdWUoanNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2Uua2luZCA9IHsgb25lb2ZLaW5kOiB1bmRlZmluZWQgfTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZSBudWxsX3ZhbHVlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ251bGxWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsVmFsdWU6IHJlYWRlci5pbnQzMigpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGRvdWJsZSBudW1iZXJfdmFsdWUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5raW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnbnVtYmVyVmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyVmFsdWU6IHJlYWRlci5kb3VibGUoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc3RyaW5nX3ZhbHVlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ3N0cmluZ1ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiByZWFkZXIuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBib29sX3ZhbHVlICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2Jvb2xWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sVmFsdWU6IHJlYWRlci5ib29sKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBzdHJ1Y3RfdmFsdWUgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5raW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnc3RydWN0VmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0VmFsdWU6IFN0cnVjdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uua2luZC5zdHJ1Y3RWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZSBsaXN0X3ZhbHVlICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2xpc3RWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0VmFsdWU6IExpc3RWYWx1ZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uua2luZC5saXN0VmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlIG51bGxfdmFsdWUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ251bGxWYWx1ZScpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5raW5kLm51bGxWYWx1ZSk7XG4gICAgICAgIC8qIGRvdWJsZSBudW1iZXJfdmFsdWUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ251bWJlclZhbHVlJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuQml0NjQpLmRvdWJsZShtZXNzYWdlLmtpbmQubnVtYmVyVmFsdWUpO1xuICAgICAgICAvKiBzdHJpbmcgc3RyaW5nX3ZhbHVlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQgPT09ICdzdHJpbmdWYWx1ZScpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uua2luZC5zdHJpbmdWYWx1ZSk7XG4gICAgICAgIC8qIGJvb2wgYm9vbF92YWx1ZSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSAnYm9vbFZhbHVlJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2Uua2luZC5ib29sVmFsdWUpO1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuU3RydWN0IHN0cnVjdF92YWx1ZSA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSAnc3RydWN0VmFsdWUnKVxuICAgICAgICAgICAgU3RydWN0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5raW5kLnN0cnVjdFZhbHVlLCB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUgbGlzdF92YWx1ZSA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSAnbGlzdFZhbHVlJylcbiAgICAgICAgICAgIExpc3RWYWx1ZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uua2luZC5saXN0VmFsdWUsIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZVxuICovXG5jb25zdCBWYWx1ZSA9IG5ldyBWYWx1ZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBMaXN0VmFsdWUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2dvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3ZhbHVlcycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVmFsdWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGBMaXN0VmFsdWVgIHRvIEpTT04gYXJyYXkuXG4gICAgICovXG4gICAgaW50ZXJuYWxKc29uV3JpdGUobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS52YWx1ZXMubWFwKCh2KSA9PiBWYWx1ZS50b0pzb24odikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYExpc3RWYWx1ZWAgZnJvbSBKU09OIGFycmF5LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvblJlYWQoanNvbiwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KGpzb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVOYW1lICtcbiAgICAgICAgICAgICAgICAnIGZyb20gSlNPTiAnICtcbiAgICAgICAgICAgICAgICB0eXBlb2ZKc29uVmFsdWUoanNvbikpO1xuICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBqc29uLm1hcCgodikgPT4gVmFsdWUuZnJvbUpzb24odikpO1xuICAgICAgICB0YXJnZXQudmFsdWVzLnB1c2goLi4udmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIHZhbHVlcyAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcy5wdXNoKFZhbHVlLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiByZXBlYXRlZCBnb29nbGUucHJvdG9idWYuVmFsdWUgdmFsdWVzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFZhbHVlLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS52YWx1ZXNbaV0sIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWVcbiAqL1xuY29uc3QgTGlzdFZhbHVlID0gbmV3IExpc3RWYWx1ZSRUeXBlKCk7XG5cbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFRpbWVzdGFtcCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdzZWNvbmRzJywga2luZDogJ3NjYWxhcicsIFQ6IDMgLypTY2FsYXJUeXBlLklOVDY0Ki8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICduYW5vcycsIGtpbmQ6ICdzY2FsYXInLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUaW1lc3RhbXBgIGZvciB0aGUgY3VycmVudCB0aW1lLlxuICAgICAqL1xuICAgIG5vdygpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgY29uc3QgbXMgPSBEYXRlLm5vdygpO1xuICAgICAgICBtc2cuc2Vjb25kcyA9IFBiTG9uZy5mcm9tKE1hdGguZmxvb3IobXMgLyAxMDAwKSkudG9TdHJpbmcoKTtcbiAgICAgICAgbXNnLm5hbm9zID0gKG1zICUgMTAwMCkgKiAxMDAwMDAwO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBUaW1lc3RhbXBgIHRvIGEgSmF2YVNjcmlwdCBEYXRlLlxuICAgICAqL1xuICAgIHRvRGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShQYkxvbmcuZnJvbShtZXNzYWdlLnNlY29uZHMpLnRvTnVtYmVyKCkgKiAxMDAwICtcbiAgICAgICAgICAgIE1hdGguY2VpbChtZXNzYWdlLm5hbm9zIC8gMTAwMDAwMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgRGF0ZSB0byBhIGBUaW1lc3RhbXBgLlxuICAgICAqL1xuICAgIGZyb21EYXRlKGRhdGUpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgbXNnLnNlY29uZHMgPSBQYkxvbmcuZnJvbShNYXRoLmZsb29yKG1zIC8gMTAwMCkpLnRvU3RyaW5nKCk7XG4gICAgICAgIG1zZy5uYW5vcyA9IChtcyAlIDEwMDApICogMTAwMDAwMDtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW4gSlNPTiBmb3JtYXQsIHRoZSBgVGltZXN0YW1wYCB0eXBlIGlzIGVuY29kZWQgYXMgYSBzdHJpbmdcbiAgICAgKiBpbiB0aGUgUkZDIDMzMzkgZm9ybWF0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG1zID0gUGJMb25nLmZyb20obWVzc2FnZS5zZWNvbmRzKS50b051bWJlcigpICogMTAwMDtcbiAgICAgICAgaWYgKG1zIDwgRGF0ZS5wYXJzZSgnMDAwMS0wMS0wMVQwMDowMDowMFonKSB8fFxuICAgICAgICAgICAgbXMgPiBEYXRlLnBhcnNlKCc5OTk5LTEyLTMxVDIzOjU5OjU5WicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZW5jb2RlIFRpbWVzdGFtcCB0byBKU09OLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLicpO1xuICAgICAgICBpZiAobWVzc2FnZS5uYW5vcyA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBlbmNvZGUgaW52YWxpZCBUaW1lc3RhbXAgdG8gSlNPTi4gTmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmUuJyk7XG4gICAgICAgIGxldCB6ID0gJ1onO1xuICAgICAgICBpZiAobWVzc2FnZS5uYW5vcyA+IDApIHtcbiAgICAgICAgICAgIGxldCBuYW5vc1N0ciA9IChtZXNzYWdlLm5hbm9zICsgMTAwMDAwMDAwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDMpID09PSAnMDAwMDAwJylcbiAgICAgICAgICAgICAgICB6ID0gJy4nICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDMpICsgJ1onO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDYpID09PSAnMDAwJylcbiAgICAgICAgICAgICAgICB6ID0gJy4nICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDYpICsgJ1onO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHogPSAnLicgKyBuYW5vc1N0ciArICdaJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnLjAwMFonLCB6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW4gSlNPTiBmb3JtYXQsIHRoZSBgVGltZXN0YW1wYCB0eXBlIGlzIGVuY29kZWQgYXMgYSBzdHJpbmdcbiAgICAgKiBpbiB0aGUgUkZDIDMzMzkgZm9ybWF0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvblJlYWQoanNvbiwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBUaW1lc3RhbXAgZnJvbSBKU09OICcgKyB0eXBlb2ZKc29uVmFsdWUoanNvbikgKyAnLicpO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IGpzb24ubWF0Y2goL14oWzAtOV17NH0pLShbMC05XXsyfSktKFswLTldezJ9KVQoWzAtOV17Mn0pOihbMC05XXsyfSk6KFswLTldezJ9KSg/Olp8XFwuKFswLTldezMsOX0pWnwoWystXVswLTldWzAtOV06WzAtOV1bMC05XSkpJC8pO1xuICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBUaW1lc3RhbXAgZnJvbSBKU09OLiBJbnZhbGlkIGZvcm1hdC4nKTtcbiAgICAgICAgbGV0IG1zID0gRGF0ZS5wYXJzZShtYXRjaGVzWzFdICtcbiAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICBtYXRjaGVzWzJdICtcbiAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICBtYXRjaGVzWzNdICtcbiAgICAgICAgICAgICdUJyArXG4gICAgICAgICAgICBtYXRjaGVzWzRdICtcbiAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICBtYXRjaGVzWzVdICtcbiAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICBtYXRjaGVzWzZdICtcbiAgICAgICAgICAgIChtYXRjaGVzWzhdID8gbWF0Y2hlc1s4XSA6ICdaJykpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG1zKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIFRpbWVzdGFtcCBmcm9tIEpTT04uIEludmFsaWQgdmFsdWUuJyk7XG4gICAgICAgIGlmIChtcyA8IERhdGUucGFyc2UoJzAwMDEtMDEtMDFUMDA6MDA6MDBaJykgfHxcbiAgICAgICAgICAgIG1zID4gRGF0ZS5wYXJzZSgnOTk5OS0xMi0zMVQyMzo1OTo1OVonKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCdVbmFibGUgdG8gcGFyc2UgVGltZXN0YW1wIGZyb20gSlNPTi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS4nKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICB0YXJnZXQuc2Vjb25kcyA9IFBiTG9uZy5mcm9tKG1zIC8gMTAwMCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGFyZ2V0Lm5hbm9zID0gMDtcbiAgICAgICAgaWYgKG1hdGNoZXNbN10pXG4gICAgICAgICAgICB0YXJnZXQubmFub3MgPVxuICAgICAgICAgICAgICAgIHBhcnNlSW50KCcxJyArIG1hdGNoZXNbN10gKyAnMCcucmVwZWF0KDkgLSBtYXRjaGVzWzddLmxlbmd0aCkpIC1cbiAgICAgICAgICAgICAgICAgICAgMTAwMDAwMDAwMDtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZWNvbmRzID0gJzAnO1xuICAgICAgICBtZXNzYWdlLm5hbm9zID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50NjQgc2Vjb25kcyAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlY29uZHMgPSByZWFkZXIuaW50NjQoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIG5hbm9zICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFub3MgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogaW50NjQgc2Vjb25kcyA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlY29uZHMgIT09ICcwJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQ2NChtZXNzYWdlLnNlY29uZHMpO1xuICAgICAgICAvKiBpbnQzMiBuYW5vcyA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbm9zICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UubmFub3MpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFxuICovXG5jb25zdCBUaW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wJFR5cGUoKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZVxuICovXG52YXIgUGVlclR5cGU7XG4oZnVuY3Rpb24gKFBlZXJUeXBlKSB7XG4gICAgLyoqXG4gICAgICogdG9kbyBmaXggbWUgKG1hcmNlbG8pXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogUEVFUl9UWVBFX1BVQkxJU0hFUl9VTlNQRUNJRklFRCA9IDA7XG4gICAgICovXG4gICAgUGVlclR5cGVbUGVlclR5cGVbXCJQVUJMSVNIRVJfVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiUFVCTElTSEVSX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBFRVJfVFlQRV9TVUJTQ1JJQkVSID0gMTtcbiAgICAgKi9cbiAgICBQZWVyVHlwZVtQZWVyVHlwZVtcIlNVQlNDUklCRVJcIl0gPSAxXSA9IFwiU1VCU0NSSUJFUlwiO1xufSkoUGVlclR5cGUgfHwgKFBlZXJUeXBlID0ge30pKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHlcbiAqL1xudmFyIENvbm5lY3Rpb25RdWFsaXR5O1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uUXVhbGl0eSkge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBDT05ORUNUSU9OX1FVQUxJVFlfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogQ09OTkVDVElPTl9RVUFMSVRZX1BPT1IgPSAxO1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiUE9PUlwiXSA9IDFdID0gXCJQT09SXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IENPTk5FQ1RJT05fUVVBTElUWV9HT09EID0gMjtcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIkdPT0RcIl0gPSAyXSA9IFwiR09PRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBDT05ORUNUSU9OX1FVQUxJVFlfRVhDRUxMRU5UID0gMztcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIkVYQ0VMTEVOVFwiXSA9IDNdID0gXCJFWENFTExFTlRcIjtcbn0pKENvbm5lY3Rpb25RdWFsaXR5IHx8IChDb25uZWN0aW9uUXVhbGl0eSA9IHt9KSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eVxuICovXG52YXIgVmlkZW9RdWFsaXR5O1xuKGZ1bmN0aW9uIChWaWRlb1F1YWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVklERU9fUVVBTElUWV9MT1dfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJMT1dfVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiTE9XX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFZJREVPX1FVQUxJVFlfTUlEID0gMTtcbiAgICAgKi9cbiAgICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTUlEXCJdID0gMV0gPSBcIk1JRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBWSURFT19RVUFMSVRZX0hJR0ggPSAyO1xuICAgICAqL1xuICAgIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJISUdIXCJdID0gMl0gPSBcIkhJR0hcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVklERU9fUVVBTElUWV9PRkYgPSAzO1xuICAgICAqL1xuICAgIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJPRkZcIl0gPSAzXSA9IFwiT0ZGXCI7XG59KShWaWRlb1F1YWxpdHkgfHwgKFZpZGVvUXVhbGl0eSA9IHt9KSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZVxuICovXG52YXIgVHJhY2tUeXBlO1xuKGZ1bmN0aW9uIChUcmFja1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVFlQRV9VTlNQRUNJRklFRCA9IDA7XG4gICAgICovXG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIlVOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1RZUEVfQVVESU8gPSAxO1xuICAgICAqL1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJBVURJT1wiXSA9IDFdID0gXCJBVURJT1wiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX1ZJREVPID0gMjtcbiAgICAgKi9cbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiVklERU9cIl0gPSAyXSA9IFwiVklERU9cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVFlQRV9TQ1JFRU5fU0hBUkUgPSAzO1xuICAgICAqL1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJTQ1JFRU5fU0hBUkVcIl0gPSAzXSA9IFwiU0NSRUVOX1NIQVJFXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFX0FVRElPID0gNDtcbiAgICAgKi9cbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiU0NSRUVOX1NIQVJFX0FVRElPXCJdID0gNF0gPSBcIlNDUkVFTl9TSEFSRV9BVURJT1wiO1xufSkoVHJhY2tUeXBlIHx8IChUcmFja1R5cGUgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvckNvZGVcbiAqL1xudmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVTlNQRUNJRklFRFwiXSA9IDBdID0gXCJVTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BVQkxJU0hfVFJBQ0tfTk9UX0ZPVU5EID0gMTAwO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQVUJMSVNIX1RSQUNLX05PVF9GT1VORFwiXSA9IDEwMF0gPSBcIlBVQkxJU0hfVFJBQ0tfTk9UX0ZPVU5EXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUFVCTElTSF9UUkFDS1NfTUlTTUFUQ0ggPSAxMDE7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBVQkxJU0hfVFJBQ0tTX01JU01BVENIXCJdID0gMTAxXSA9IFwiUFVCTElTSF9UUkFDS1NfTUlTTUFUQ0hcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QVUJMSVNIX1RSQUNLX09VVF9PRl9PUkRFUiA9IDEwMjtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUFVCTElTSF9UUkFDS19PVVRfT0ZfT1JERVJcIl0gPSAxMDJdID0gXCJQVUJMSVNIX1RSQUNLX09VVF9PRl9PUkRFUlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BVQkxJU0hfVFJBQ0tfVklERU9fTEFZRVJfTk9UX0ZPVU5EID0gMTAzO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQVUJMSVNIX1RSQUNLX1ZJREVPX0xBWUVSX05PVF9GT1VORFwiXSA9IDEwM10gPSBcIlBVQkxJU0hfVFJBQ0tfVklERU9fTEFZRVJfTk9UX0ZPVU5EXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfTElWRV9FTkRFRCA9IDEwNDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTElWRV9FTkRFRFwiXSA9IDEwNF0gPSBcIkxJVkVfRU5ERURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QQVJUSUNJUEFOVF9OT1RfRk9VTkQgPSAyMDA7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBBUlRJQ0lQQU5UX05PVF9GT1VORFwiXSA9IDIwMF0gPSBcIlBBUlRJQ0lQQU5UX05PVF9GT1VORFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BBUlRJQ0lQQU5UX01JR1JBVElOR19PVVQgPSAyMDE7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBBUlRJQ0lQQU5UX01JR1JBVElOR19PVVRcIl0gPSAyMDFdID0gXCJQQVJUSUNJUEFOVF9NSUdSQVRJTkdfT1VUXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTUlHUkFUSU9OX0ZBSUxFRCA9IDIwMjtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUEFSVElDSVBBTlRfTUlHUkFUSU9OX0ZBSUxFRFwiXSA9IDIwMl0gPSBcIlBBUlRJQ0lQQU5UX01JR1JBVElPTl9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QQVJUSUNJUEFOVF9NSUdSQVRJTkcgPSAyMDM7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBBUlRJQ0lQQU5UX01JR1JBVElOR1wiXSA9IDIwM10gPSBcIlBBUlRJQ0lQQU5UX01JR1JBVElOR1wiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BBUlRJQ0lQQU5UX1JFQ09OTkVDVF9GQUlMRUQgPSAyMDQ7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBBUlRJQ0lQQU5UX1JFQ09OTkVDVF9GQUlMRURcIl0gPSAyMDRdID0gXCJQQVJUSUNJUEFOVF9SRUNPTk5FQ1RfRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTUVESUFfVFJBTlNQT1JUX0ZBSUxVUkUgPSAyMDU7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBBUlRJQ0lQQU5UX01FRElBX1RSQU5TUE9SVF9GQUlMVVJFXCJdID0gMjA1XSA9IFwiUEFSVElDSVBBTlRfTUVESUFfVFJBTlNQT1JUX0ZBSUxVUkVcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9DQUxMX05PVF9GT1VORCA9IDMwMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ0FMTF9OT1RfRk9VTkRcIl0gPSAzMDBdID0gXCJDQUxMX05PVF9GT1VORFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1JFUVVFU1RfVkFMSURBVElPTl9GQUlMRUQgPSA0MDA7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlJFUVVFU1RfVkFMSURBVElPTl9GQUlMRURcIl0gPSA0MDBdID0gXCJSRVFVRVNUX1ZBTElEQVRJT05fRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfVU5BVVRIRU5USUNBVEVEID0gNDAxO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSA0MDFdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QRVJNSVNTSU9OX0RFTklFRCA9IDQwMztcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUEVSTUlTU0lPTl9ERU5JRURcIl0gPSA0MDNdID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1RPT19NQU5ZX1JFUVVFU1RTID0gNDI5O1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJUT09fTUFOWV9SRVFVRVNUU1wiXSA9IDQyOV0gPSBcIlRPT19NQU5ZX1JFUVVFU1RTXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfSU5URVJOQUxfU0VSVkVSX0VSUk9SID0gNTAwO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIl0gPSA1MDBdID0gXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9TRlVfU0hVVFRJTkdfRE9XTiA9IDYwMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiU0ZVX1NIVVRUSU5HX0RPV05cIl0gPSA2MDBdID0gXCJTRlVfU0hVVFRJTkdfRE9XTlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1NGVV9GVUxMID0gNzAwO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJTRlVfRlVMTFwiXSA9IDcwMF0gPSBcIlNGVV9GVUxMXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNka1R5cGVcbiAqL1xudmFyIFNka1R5cGU7XG4oZnVuY3Rpb24gKFNka1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFNka1R5cGVbU2RrVHlwZVtcIlVOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX1JFQUNUID0gMTtcbiAgICAgKi9cbiAgICBTZGtUeXBlW1Nka1R5cGVbXCJSRUFDVFwiXSA9IDFdID0gXCJSRUFDVFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9BTkdVTEFSID0gMjtcbiAgICAgKi9cbiAgICBTZGtUeXBlW1Nka1R5cGVbXCJBTkdVTEFSXCJdID0gMl0gPSBcIkFOR1VMQVJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfQU5EUk9JRCA9IDM7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiQU5EUk9JRFwiXSA9IDNdID0gXCJBTkRST0lEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX0lPUyA9IDQ7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiSU9TXCJdID0gNF0gPSBcIklPU1wiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9GTFVUVEVSID0gNTtcbiAgICAgKi9cbiAgICBTZGtUeXBlW1Nka1R5cGVbXCJGTFVUVEVSXCJdID0gNV0gPSBcIkZMVVRURVJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfUkVBQ1RfTkFUSVZFID0gNjtcbiAgICAgKi9cbiAgICBTZGtUeXBlW1Nka1R5cGVbXCJSRUFDVF9OQVRJVkVcIl0gPSA2XSA9IFwiUkVBQ1RfTkFUSVZFXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX1VOSVRZID0gNztcbiAgICAgKi9cbiAgICBTZGtUeXBlW1Nka1R5cGVbXCJVTklUWVwiXSA9IDddID0gXCJVTklUWVwiO1xufSkoU2RrVHlwZSB8fCAoU2RrVHlwZSA9IHt9KSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVW5wdWJsaXNoUmVhc29uXG4gKi9cbnZhciBUcmFja1VucHVibGlzaFJlYXNvbjtcbihmdW5jdGlvbiAoVHJhY2tVbnB1Ymxpc2hSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlIHdoaWNoIGlzIHVzZWQgd2hlbiB0aGUgc3BlY2lmaWMgcmVhc29uXG4gICAgICogZm9yIG11dGluZyB0aGUgdHJhY2sgaXMgbm90IGtub3duLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1VOUFVCTElTSF9SRUFTT05fVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFRyYWNrVW5wdWJsaXNoUmVhc29uW1RyYWNrVW5wdWJsaXNoUmVhc29uW1wiVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHVzZXIgbXV0aW5nIHRoZWlyIHRyYWNrcy5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19VTlBVQkxJU0hfUkVBU09OX1VTRVJfTVVURUQgPSAxO1xuICAgICAqL1xuICAgIFRyYWNrVW5wdWJsaXNoUmVhc29uW1RyYWNrVW5wdWJsaXNoUmVhc29uW1wiVVNFUl9NVVRFRFwiXSA9IDFdID0gXCJVU0VSX01VVEVEXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBtdXRpbmcgdGhlIHRyYWNrIGJlY2F1c2UgdGhlIHBlcm1pc3Npb24gdG9cbiAgICAgKiBwdWJsaXNoIHRoZSB0cmFjayBoYXMgYmVlbiByZXZva2VkLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1VOUFVCTElTSF9SRUFTT05fUEVSTUlTU0lPTl9SRVZPS0VEID0gMjtcbiAgICAgKi9cbiAgICBUcmFja1VucHVibGlzaFJlYXNvbltUcmFja1VucHVibGlzaFJlYXNvbltcIlBFUk1JU1NJT05fUkVWT0tFRFwiXSA9IDJdID0gXCJQRVJNSVNTSU9OX1JFVk9LRURcIjtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIG11dGluZyB0aGUgdHJhY2sgZHVlIHRvIG1vZGVyYXRpb24gYWN0aW9ucy5cbiAgICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHBlcm1pc3Npb24gcmV2b2tlZCBiZWNhdXNlIHRoZVxuICAgICAqIHBhcnRpY2lwYW50IGNhbiB1bm11dGUgdGhlbXNlbHZlcyBoZXJlIHdoZXJlYXMgaW4gY2FzZVxuICAgICAqIG9mIFwicGVybWlzc2lvbiByZXZva2VcIiBpdCBpcyBub3QgcG9zc2libGUgdW50aWwgdGhlXG4gICAgICogY2FsbCBwZXJtaXNzaW9ucyBhcmUgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19VTlBVQkxJU0hfUkVBU09OX01PREVSQVRJT04gPSAzO1xuICAgICAqL1xuICAgIFRyYWNrVW5wdWJsaXNoUmVhc29uW1RyYWNrVW5wdWJsaXNoUmVhc29uW1wiTU9ERVJBVElPTlwiXSA9IDNdID0gXCJNT0RFUkFUSU9OXCI7XG59KShUcmFja1VucHVibGlzaFJlYXNvbiB8fCAoVHJhY2tVbnB1Ymxpc2hSZWFzb24gPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Hb0F3YXlSZWFzb25cbiAqL1xudmFyIEdvQXdheVJlYXNvbjtcbihmdW5jdGlvbiAoR29Bd2F5UmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEdPX0FXQVlfUkVBU09OX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBHb0F3YXlSZWFzb25bR29Bd2F5UmVhc29uW1wiVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogR09fQVdBWV9SRUFTT05fU0hVVFRJTkdfRE9XTiA9IDE7XG4gICAgICovXG4gICAgR29Bd2F5UmVhc29uW0dvQXdheVJlYXNvbltcIlNIVVRUSU5HX0RPV05cIl0gPSAxXSA9IFwiU0hVVFRJTkdfRE9XTlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBHT19BV0FZX1JFQVNPTl9SRUJBTEFOQ0UgPSAyO1xuICAgICAqL1xuICAgIEdvQXdheVJlYXNvbltHb0F3YXlSZWFzb25bXCJSRUJBTEFOQ0VcIl0gPSAyXSA9IFwiUkVCQUxBTkNFXCI7XG59KShHb0F3YXlSZWFzb24gfHwgKEdvQXdheVJlYXNvbiA9IHt9KSk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDYWxsU3RhdGUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGFydGljaXBhbnRzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQYXJ0aWNpcGFudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc3RhcnRlZF9hdCcsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gVGltZXN0YW1wIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BhcnRpY2lwYW50X2NvdW50JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gUGFydGljaXBhbnRDb3VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BpbnMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBpbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50cyA9IFtdO1xuICAgICAgICBtZXNzYWdlLnBpbnMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnRzICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRzLnB1c2goUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBzdGFydGVkX2F0ICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RhcnRlZEF0ID0gVGltZXN0YW1wLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5zdGFydGVkQXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50Q291bnQgcGFydGljaXBhbnRfY291bnQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudENvdW50ID0gUGFydGljaXBhbnRDb3VudC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UucGFydGljaXBhbnRDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluIHBpbnMgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5waW5zLnB1c2goUGluLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudHMgPSAxOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UucGFydGljaXBhbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBhcnRpY2lwYW50c1tpXSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHN0YXJ0ZWRfYXQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zdGFydGVkQXQpXG4gICAgICAgICAgICBUaW1lc3RhbXAuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnN0YXJ0ZWRBdCwgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50IHBhcnRpY2lwYW50X2NvdW50ID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydGljaXBhbnRDb3VudClcbiAgICAgICAgICAgIFBhcnRpY2lwYW50Q291bnQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQsIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluIHBpbnMgPSA0OyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UucGlucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFBpbi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucGluc1tpXSwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbFN0YXRlXG4gKi9cbmNvbnN0IENhbGxTdGF0ZSQxID0gbmV3IENhbGxTdGF0ZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBQYXJ0aWNpcGFudENvdW50JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3RvdGFsJywga2luZDogJ3NjYWxhcicsIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ2Fub255bW91cycsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudG90YWwgPSAwO1xuICAgICAgICBtZXNzYWdlLmFub255bW91cyA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQzMiB0b3RhbCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRvdGFsID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQzMiBhbm9ueW1vdXMgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbm9ueW1vdXMgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHVpbnQzMiB0b3RhbCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnRvdGFsICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLnRvdGFsKTtcbiAgICAgICAgLyogdWludDMyIGFub255bW91cyA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmFub255bW91cyAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5hbm9ueW1vdXMpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudFxuICovXG5jb25zdCBQYXJ0aWNpcGFudENvdW50ID0gbmV3IFBhcnRpY2lwYW50Q291bnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGluJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QaW4nLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QaW5cbiAqL1xuY29uc3QgUGluID0gbmV3IFBpbiRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBQYXJ0aWNpcGFudCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncHVibGlzaGVkX3RyYWNrcycsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICAnVFJBQ0tfVFlQRV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2pvaW5lZF9hdCcsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gVGltZXN0YW1wIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3RyYWNrX2xvb2t1cF9wcmVmaXgnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29ubmVjdGlvbl9xdWFsaXR5JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHknLFxuICAgICAgICAgICAgICAgICAgICBDb25uZWN0aW9uUXVhbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgJ0NPTk5FQ1RJT05fUVVBTElUWV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNywgbmFtZTogJ2lzX3NwZWFraW5nJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA4LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdpc19kb21pbmFudF9zcGVha2VyJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogOSwgbmFtZTogJ2F1ZGlvX2xldmVsJywga2luZDogJ3NjYWxhcicsIFQ6IDIgLypTY2FsYXJUeXBlLkZMT0FUKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDEwLCBuYW1lOiAnbmFtZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMTEsIG5hbWU6ICdpbWFnZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMTIsIG5hbWU6ICdjdXN0b20nLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFN0cnVjdCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncm9sZXMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMiAvKlJlcGVhdFR5cGUuVU5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnVzZXJJZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnB1Ymxpc2hlZFRyYWNrcyA9IFtdO1xuICAgICAgICBtZXNzYWdlLnRyYWNrTG9va3VwUHJlZml4ID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSAwO1xuICAgICAgICBtZXNzYWdlLmlzU3BlYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5pc0RvbWluYW50U3BlYWtlciA9IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLmF1ZGlvTGV2ZWwgPSAwO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSAnJztcbiAgICAgICAgbWVzc2FnZS5pbWFnZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLnJvbGVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSBwdWJsaXNoZWRfdHJhY2tzICovIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IHJlYWRlci5pbnQzMigpICsgcmVhZGVyLnBvczsgcmVhZGVyLnBvcyA8IGU7KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHVibGlzaGVkVHJhY2tzLnB1c2gocmVhZGVyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1Ymxpc2hlZFRyYWNrcy5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGpvaW5lZF9hdCAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmpvaW5lZEF0ID0gVGltZXN0YW1wLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5qb2luZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHRyYWNrX2xvb2t1cF9wcmVmaXggKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja0xvb2t1cFByZWZpeCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db25uZWN0aW9uUXVhbGl0eSBjb25uZWN0aW9uX3F1YWxpdHkgKi8gNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgaXNfc3BlYWtpbmcgKi8gNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc1NwZWFraW5nID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGlzX2RvbWluYW50X3NwZWFrZXIgKi8gODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc0RvbWluYW50U3BlYWtlciA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZmxvYXQgYXVkaW9fbGV2ZWwgKi8gOTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdWRpb0xldmVsID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMTA6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaW1hZ2UgKi8gMTE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW1hZ2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBjdXN0b20gKi8gMTI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3VzdG9tID0gU3RydWN0LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jdXN0b20pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmluZyByb2xlcyAqLyAxMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yb2xlcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB1c2VyX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudXNlcklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS51c2VySWQpO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHB1Ymxpc2hlZF90cmFja3MgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wdWJsaXNoZWRUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnB1Ymxpc2hlZFRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB3cml0ZXIuaW50MzIobWVzc2FnZS5wdWJsaXNoZWRUcmFja3NbaV0pO1xuICAgICAgICAgICAgd3JpdGVyLmpvaW4oKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGpvaW5lZF9hdCA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmpvaW5lZEF0KVxuICAgICAgICAgICAgVGltZXN0YW1wLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5qb2luZWRBdCwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJpbmcgdHJhY2tfbG9va3VwX3ByZWZpeCA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnRyYWNrTG9va3VwUHJlZml4ICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50cmFja0xvb2t1cFByZWZpeCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5IGNvbm5lY3Rpb25fcXVhbGl0eSA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkpO1xuICAgICAgICAvKiBib29sIGlzX3NwZWFraW5nID0gNzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNTcGVha2luZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDcsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmlzU3BlYWtpbmcpO1xuICAgICAgICAvKiBib29sIGlzX2RvbWluYW50X3NwZWFrZXIgPSA4OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pc0RvbWluYW50U3BlYWtlciAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDgsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmlzRG9taW5hbnRTcGVha2VyKTtcbiAgICAgICAgLyogZmxvYXQgYXVkaW9fbGV2ZWwgPSA5OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5hdWRpb0xldmVsICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg5LCBXaXJlVHlwZS5CaXQzMikuZmxvYXQobWVzc2FnZS5hdWRpb0xldmVsKTtcbiAgICAgICAgLyogc3RyaW5nIG5hbWUgPSAxMDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEwLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBzdHJpbmcgaW1hZ2UgPSAxMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW1hZ2UgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pbWFnZSk7XG4gICAgICAgIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgY3VzdG9tID0gMTI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmN1c3RvbSlcbiAgICAgICAgICAgIFN0cnVjdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY3VzdG9tLCB3cml0ZXIudGFnKDEyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJpbmcgcm9sZXMgPSAxMzsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnJvbGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5yb2xlc1tpXSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudFxuICovXG5jb25zdCBQYXJ0aWNpcGFudCA9IG5ldyBQYXJ0aWNpcGFudCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTdHJlYW1RdWFsaXR5JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TdHJlYW1RdWFsaXR5JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd2aWRlb19xdWFsaXR5JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9RdWFsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgVmlkZW9RdWFsaXR5LFxuICAgICAgICAgICAgICAgICAgICAnVklERU9fUVVBTElUWV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudmlkZW9RdWFsaXR5ID0gMDtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9RdWFsaXR5IHZpZGVvX3F1YWxpdHkgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52aWRlb1F1YWxpdHkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9RdWFsaXR5IHZpZGVvX3F1YWxpdHkgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS52aWRlb1F1YWxpdHkgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS52aWRlb1F1YWxpdHkpO1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlN0cmVhbVF1YWxpdHlcbiAqL1xuY29uc3QgU3RyZWFtUXVhbGl0eSA9IG5ldyBTdHJlYW1RdWFsaXR5JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvRGltZW5zaW9uJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvbicsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd3aWR0aCcsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdoZWlnaHQnLCBraW5kOiAnc2NhbGFyJywgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLndpZHRoID0gMDtcbiAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgd2lkdGggKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53aWR0aCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgaGVpZ2h0ICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiB1aW50MzIgd2lkdGggPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS53aWR0aCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS53aWR0aCk7XG4gICAgICAgIC8qIHVpbnQzMiBoZWlnaHQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5oZWlnaHQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uXG4gKi9cbmNvbnN0IFZpZGVvRGltZW5zaW9uID0gbmV3IFZpZGVvRGltZW5zaW9uJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvTGF5ZXIkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvTGF5ZXInLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAncmlkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3ZpZGVvX2RpbWVuc2lvbicsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFZpZGVvRGltZW5zaW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdiaXRyYXRlJywga2luZDogJ3NjYWxhcicsIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyB9LFxuICAgICAgICAgICAgeyBubzogNSwgbmFtZTogJ2ZwcycsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAncXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eScsXG4gICAgICAgICAgICAgICAgICAgIFZpZGVvUXVhbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgJ1ZJREVPX1FVQUxJVFlfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UucmlkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuYml0cmF0ZSA9IDA7XG4gICAgICAgIG1lc3NhZ2UuZnBzID0gMDtcbiAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHJpZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvbiB2aWRlb19kaW1lbnNpb24gKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52aWRlb0RpbWVuc2lvbiA9IFZpZGVvRGltZW5zaW9uLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS52aWRlb0RpbWVuc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIGJpdHJhdGUgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iaXRyYXRlID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQzMiBmcHMgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcHMgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9RdWFsaXR5IHF1YWxpdHkgKi8gNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFsaXR5ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyByaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yaWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnJpZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uIHZpZGVvX2RpbWVuc2lvbiA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnZpZGVvRGltZW5zaW9uKVxuICAgICAgICAgICAgVmlkZW9EaW1lbnNpb24uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnZpZGVvRGltZW5zaW9uLCB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHVpbnQzMiBiaXRyYXRlID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuYml0cmF0ZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5iaXRyYXRlKTtcbiAgICAgICAgLyogdWludDMyIGZwcyA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmZwcyAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5mcHMpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb1F1YWxpdHkgcXVhbGl0eSA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnF1YWxpdHkgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5xdWFsaXR5KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvTGF5ZXJcbiAqL1xuY29uc3QgVmlkZW9MYXllciA9IG5ldyBWaWRlb0xheWVyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENvZGVjJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYycsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGF5bG9hZF90eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ25hbWUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdmbXRwX2xpbmUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2xvY2tfcmF0ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZW5jb2RpbmdfcGFyYW1ldGVycycsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdmZWVkYmFja3MnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMiAvKlJlcGVhdFR5cGUuVU5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuZm10cExpbmUgPSAnJztcbiAgICAgICAgbWVzc2FnZS5jbG9ja1JhdGUgPSAwO1xuICAgICAgICBtZXNzYWdlLmVuY29kaW5nUGFyYW1ldGVycyA9ICcnO1xuICAgICAgICBtZXNzYWdlLmZlZWRiYWNrcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgcGF5bG9hZF90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZFR5cGUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBmbXRwX2xpbmUgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbXRwTGluZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgY2xvY2tfcmF0ZSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsb2NrUmF0ZSA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgZW5jb2RpbmdfcGFyYW1ldGVycyAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVuY29kaW5nUGFyYW1ldGVycyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJpbmcgZmVlZGJhY2tzICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmVlZGJhY2tzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogdWludDMyIHBheWxvYWRfdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBheWxvYWRUeXBlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLnBheWxvYWRUeXBlKTtcbiAgICAgICAgLyogc3RyaW5nIG5hbWUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgLyogc3RyaW5nIGZtdHBfbGluZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmZtdHBMaW5lICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5mbXRwTGluZSk7XG4gICAgICAgIC8qIHVpbnQzMiBjbG9ja19yYXRlID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2xvY2tSYXRlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLmNsb2NrUmF0ZSk7XG4gICAgICAgIC8qIHN0cmluZyBlbmNvZGluZ19wYXJhbWV0ZXJzID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZW5jb2RpbmdQYXJhbWV0ZXJzICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlclxuICAgICAgICAgICAgICAgIC50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKVxuICAgICAgICAgICAgICAgIC5zdHJpbmcobWVzc2FnZS5lbmNvZGluZ1BhcmFtZXRlcnMpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJpbmcgZmVlZGJhY2tzID0gNjsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmZlZWRiYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5mZWVkYmFja3NbaV0pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWNcbiAqL1xuY29uc3QgQ29kZWMgPSBuZXcgQ29kZWMkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xubGV0IElDRVRyaWNrbGUkVHlwZSQxID0gY2xhc3MgSUNFVHJpY2tsZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuSUNFVHJpY2tsZScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGVlcl90eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gWydzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZScsIFBlZXJUeXBlLCAnUEVFUl9UWVBFXyddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnaWNlX2NhbmRpZGF0ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSAwO1xuICAgICAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wZWVyVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBpY2VfY2FuZGlkYXRlICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWNlQ2FuZGlkYXRlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wZWVyVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnBlZXJUeXBlKTtcbiAgICAgICAgLyogc3RyaW5nIGljZV9jYW5kaWRhdGUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pY2VDYW5kaWRhdGUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmljZUNhbmRpZGF0ZSk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59O1xuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGVcbiAqL1xuY29uc3QgSUNFVHJpY2tsZSQxID0gbmV3IElDRVRyaWNrbGUkVHlwZSQxKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUcmFja0luZm8kVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrSW5mbycsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd0cmFja19pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja190eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICAnVFJBQ0tfVFlQRV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdsYXllcnMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFZpZGVvTGF5ZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNiwgbmFtZTogJ21pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogNywgbmFtZTogJ2R0eCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDgsIG5hbWU6ICdzdGVyZW8nLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiA5LCBuYW1lOiAncmVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS50cmFja0lkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5sYXllcnMgPSBbXTtcbiAgICAgICAgbWVzc2FnZS5taWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5kdHggPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5zdGVyZW8gPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5yZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHRyYWNrX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvTGF5ZXIgbGF5ZXJzICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGF5ZXJzLnB1c2goVmlkZW9MYXllci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWlkICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWlkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgZHR4ICovIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZHR4ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIHN0ZXJlbyAqLyA4OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0ZXJlbyA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCByZWQgKi8gOTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHJhY2tfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50cmFja0lkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS50cmFja0lkKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50cmFja1R5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50cmFja1R5cGUpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyIGxheWVycyA9IDU7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5sYXllcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBWaWRlb0xheWVyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5sYXllcnNbaV0sIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyaW5nIG1pZCA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1pZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubWlkKTtcbiAgICAgICAgLyogYm9vbCBkdHggPSA3OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5kdHggIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg3LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5kdHgpO1xuICAgICAgICAvKiBib29sIHN0ZXJlbyA9IDg7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnN0ZXJlbyAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDgsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnN0ZXJlbyk7XG4gICAgICAgIC8qIGJvb2wgcmVkID0gOTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVkICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoOSwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UucmVkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrSW5mb1xuICovXG5jb25zdCBUcmFja0luZm8gPSBuZXcgVHJhY2tJbmZvJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENhbGwkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGwnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndHlwZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2NyZWF0ZWRfYnlfdXNlcl9pZCcsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdob3N0X3VzZXJfaWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6ICdjdXN0b20nLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFN0cnVjdCB9LFxuICAgICAgICAgICAgeyBubzogNiwgbmFtZTogJ2NyZWF0ZWRfYXQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFRpbWVzdGFtcCB9LFxuICAgICAgICAgICAgeyBubzogNywgbmFtZTogJ3VwZGF0ZWRfYXQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFRpbWVzdGFtcCB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5jcmVhdGVkQnlVc2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5ob3N0VXNlcklkID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgY3JlYXRlZF9ieV91c2VyX2lkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRlZEJ5VXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBob3N0X3VzZXJfaWQgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ob3N0VXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgY3VzdG9tICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3VzdG9tID0gU3RydWN0LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jdXN0b20pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgY3JlYXRlZF9hdCAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWRBdCA9IFRpbWVzdGFtcC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY3JlYXRlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHVwZGF0ZWRfYXQgKi8gNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVkQXQgPSBUaW1lc3RhbXAuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnVwZGF0ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBpZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmlkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pZCk7XG4gICAgICAgIC8qIHN0cmluZyBjcmVhdGVkX2J5X3VzZXJfaWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jcmVhdGVkQnlVc2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmNyZWF0ZWRCeVVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBob3N0X3VzZXJfaWQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ob3N0VXNlcklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5ob3N0VXNlcklkKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBjdXN0b20gPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jdXN0b20pXG4gICAgICAgICAgICBTdHJ1Y3QuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmN1c3RvbSwgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGNyZWF0ZWRfYXQgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jcmVhdGVkQXQpXG4gICAgICAgICAgICBUaW1lc3RhbXAuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNyZWF0ZWRBdCwgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHVwZGF0ZWRfYXQgPSA3OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51cGRhdGVkQXQpXG4gICAgICAgICAgICBUaW1lc3RhbXAuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnVwZGF0ZWRBdCwgd3JpdGVyLnRhZyg3LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbFxuICovXG5jb25zdCBDYWxsJDEgPSBuZXcgQ2FsbCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5sZXQgRXJyb3IkVHlwZSQxID0gY2xhc3MgRXJyb3IkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JDb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgRXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICAnRVJST1JfQ09ERV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ21lc3NhZ2UnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdzaG91bGRfcmV0cnknLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmNvZGUgPSAwO1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zaG91bGRSZXRyeSA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvckNvZGUgY29kZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvZGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWVzc2FnZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBzaG91bGRfcmV0cnkgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaG91bGRSZXRyeSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yQ29kZSBjb2RlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmNvZGUpO1xuICAgICAgICAvKiBzdHJpbmcgbWVzc2FnZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICAvKiBib29sIHNob3VsZF9yZXRyeSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNob3VsZFJldHJ5ICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2Uuc2hvdWxkUmV0cnkpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59O1xuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yXG4gKi9cbmNvbnN0IEVycm9yJDIgPSBuZXcgRXJyb3IkVHlwZSQxKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDbGllbnREZXRhaWxzJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DbGllbnREZXRhaWxzJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3NkaycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gU2RrIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnb3MnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IE9TIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiAnYnJvd3NlcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gQnJvd3NlciB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2RldmljZScsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRGV2aWNlIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGsgc2RrICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RrID0gU2RrLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5zZGspO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLk9TIG9zICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3MgPSBPUy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uub3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkJyb3dzZXIgYnJvd3NlciAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJyb3dzZXIgPSBCcm93c2VyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5icm93c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5EZXZpY2UgZGV2aWNlICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGV2aWNlID0gRGV2aWNlLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5kZXZpY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGsgc2RrID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RrKVxuICAgICAgICAgICAgU2RrLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5zZGssIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuT1Mgb3MgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5vcylcbiAgICAgICAgICAgIE9TLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5vcywgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Ccm93c2VyIGJyb3dzZXIgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5icm93c2VyKVxuICAgICAgICAgICAgQnJvd3Nlci5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuYnJvd3Nlciwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5EZXZpY2UgZGV2aWNlID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGV2aWNlKVxuICAgICAgICAgICAgRGV2aWNlLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5kZXZpY2UsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNsaWVudERldGFpbHNcbiAqL1xuY29uc3QgQ2xpZW50RGV0YWlscyA9IG5ldyBDbGllbnREZXRhaWxzJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNkayRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gWydzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtUeXBlJywgU2RrVHlwZSwgJ1NES19UWVBFXyddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdtYWpvcicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogJ21pbm9yJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiAncGF0Y2gnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgIG1lc3NhZ2UubWFqb3IgPSAnJztcbiAgICAgICAgbWVzc2FnZS5taW5vciA9ICcnO1xuICAgICAgICBtZXNzYWdlLnBhdGNoID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNka1R5cGUgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWFqb3IgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tYWpvciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWlub3IgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taW5vciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgcGF0Y2ggKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXRjaCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrVHlwZSB0eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgbWFqb3IgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tYWpvciAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubWFqb3IpO1xuICAgICAgICAvKiBzdHJpbmcgbWlub3IgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5taW5vciAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubWlub3IpO1xuICAgICAgICAvKiBzdHJpbmcgcGF0Y2ggPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wYXRjaCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UucGF0Y2gpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrXG4gKi9cbmNvbnN0IFNkayA9IG5ldyBTZGskVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgT1MkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLk9TJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ25hbWUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICd2ZXJzaW9uJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2FyY2hpdGVjdHVyZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9ICcnO1xuICAgICAgICBtZXNzYWdlLmFyY2hpdGVjdHVyZSA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHZlcnNpb24gKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBhcmNoaXRlY3R1cmUgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hcmNoaXRlY3R1cmUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBuYW1lID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIC8qIHN0cmluZyB2ZXJzaW9uID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudmVyc2lvbik7XG4gICAgICAgIC8qIHN0cmluZyBhcmNoaXRlY3R1cmUgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5hcmNoaXRlY3R1cmUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmFyY2hpdGVjdHVyZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PU1xuICovXG5jb25zdCBPUyA9IG5ldyBPUyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBCcm93c2VyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Ccm93c2VyJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ25hbWUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICd2ZXJzaW9uJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSAnJztcbiAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBuYW1lICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdmVyc2lvbiAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBuYW1lID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIC8qIHN0cmluZyB2ZXJzaW9uID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudmVyc2lvbik7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Ccm93c2VyXG4gKi9cbmNvbnN0IEJyb3dzZXIgPSBuZXcgQnJvd3NlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBEZXZpY2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkRldmljZScsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAndmVyc2lvbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHZlcnNpb24gKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgbmFtZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBzdHJpbmcgdmVyc2lvbiA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRGV2aWNlXG4gKi9cbmNvbnN0IERldmljZSA9IG5ldyBEZXZpY2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ2FsbEdyYW50cyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbEdyYW50cycsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2FuX3B1Ymxpc2hfYXVkaW8nLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nhbl9wdWJsaXNoX3ZpZGVvJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjYW5fc2NyZWVuc2hhcmUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmNhblB1Ymxpc2hBdWRpbyA9IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLmNhblB1Ymxpc2hWaWRlbyA9IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLmNhblNjcmVlbnNoYXJlID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgY2FuX3B1Ymxpc2hfYXVkaW8gKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYW5QdWJsaXNoQXVkaW8gPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgY2FuX3B1Ymxpc2hfdmlkZW8gKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8gPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgY2FuX3NjcmVlbnNoYXJlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FuU2NyZWVuc2hhcmUgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBib29sIGNhbl9wdWJsaXNoX2F1ZGlvID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FuUHVibGlzaEF1ZGlvICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuY2FuUHVibGlzaEF1ZGlvKTtcbiAgICAgICAgLyogYm9vbCBjYW5fcHVibGlzaF92aWRlbyA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhblB1Ymxpc2hWaWRlbyAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmNhblB1Ymxpc2hWaWRlbyk7XG4gICAgICAgIC8qIGJvb2wgY2FuX3NjcmVlbnNoYXJlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FuU2NyZWVuc2hhcmUgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5jYW5TY3JlZW5zaGFyZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsR3JhbnRzXG4gKi9cbmNvbnN0IENhbGxHcmFudHMgPSBuZXcgQ2FsbEdyYW50cyRUeXBlKCk7XG5cbnZhciBtb2RlbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEJyb3dzZXI6IEJyb3dzZXIsXG4gICAgQ2FsbDogQ2FsbCQxLFxuICAgIENhbGxHcmFudHM6IENhbGxHcmFudHMsXG4gICAgQ2FsbFN0YXRlOiBDYWxsU3RhdGUkMSxcbiAgICBDbGllbnREZXRhaWxzOiBDbGllbnREZXRhaWxzLFxuICAgIENvZGVjOiBDb2RlYyxcbiAgICBnZXQgQ29ubmVjdGlvblF1YWxpdHkgKCkgeyByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHk7IH0sXG4gICAgRGV2aWNlOiBEZXZpY2UsXG4gICAgRXJyb3I6IEVycm9yJDIsXG4gICAgZ2V0IEVycm9yQ29kZSAoKSB7IHJldHVybiBFcnJvckNvZGU7IH0sXG4gICAgZ2V0IEdvQXdheVJlYXNvbiAoKSB7IHJldHVybiBHb0F3YXlSZWFzb247IH0sXG4gICAgSUNFVHJpY2tsZTogSUNFVHJpY2tsZSQxLFxuICAgIE9TOiBPUyxcbiAgICBQYXJ0aWNpcGFudDogUGFydGljaXBhbnQsXG4gICAgUGFydGljaXBhbnRDb3VudDogUGFydGljaXBhbnRDb3VudCxcbiAgICBnZXQgUGVlclR5cGUgKCkgeyByZXR1cm4gUGVlclR5cGU7IH0sXG4gICAgUGluOiBQaW4sXG4gICAgU2RrOiBTZGssXG4gICAgZ2V0IFNka1R5cGUgKCkgeyByZXR1cm4gU2RrVHlwZTsgfSxcbiAgICBTdHJlYW1RdWFsaXR5OiBTdHJlYW1RdWFsaXR5LFxuICAgIFRyYWNrSW5mbzogVHJhY2tJbmZvLFxuICAgIGdldCBUcmFja1R5cGUgKCkgeyByZXR1cm4gVHJhY2tUeXBlOyB9LFxuICAgIGdldCBUcmFja1VucHVibGlzaFJlYXNvbiAoKSB7IHJldHVybiBUcmFja1VucHVibGlzaFJlYXNvbjsgfSxcbiAgICBWaWRlb0RpbWVuc2lvbjogVmlkZW9EaW1lbnNpb24sXG4gICAgVmlkZW9MYXllcjogVmlkZW9MYXllcixcbiAgICBnZXQgVmlkZW9RdWFsaXR5ICgpIHsgcmV0dXJuIFZpZGVvUXVhbGl0eTsgfVxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAZ2VuZXJhdGVkIGJ5IHByb3RvYnVmLXRzIDIuOS4zIHdpdGggcGFyYW1ldGVyIGxvbmdfdHlwZV9zdHJpbmcsY2xpZW50X2dlbmVyaWMsc2VydmVyX25vbmUsZXNsaW50X2Rpc2FibGVcbi8vIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBmaWxlIFwidmlkZW8vc2Z1L3NpZ25hbF9ycGMvc2lnbmFsLnByb3RvXCIgKHBhY2thZ2UgXCJzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbFwiLCBzeW50YXggcHJvdG8zKVxuLy8gdHNsaW50OmRpc2FibGVcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNlbmRTdGF0c1JlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1JlcXVlc3QnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzdWJzY3JpYmVyX3N0YXRzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3B1Ymxpc2hlcl9zdGF0cycsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICd3ZWJydGNfdmVyc2lvbicsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNSwgbmFtZTogJ3NkaycsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzZGtfdmVyc2lvbicsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVyU3RhdHMgPSAnJztcbiAgICAgICAgbWVzc2FnZS5wdWJsaXNoZXJTdGF0cyA9ICcnO1xuICAgICAgICBtZXNzYWdlLndlYnJ0Y1ZlcnNpb24gPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZGsgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZGtWZXJzaW9uID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzdWJzY3JpYmVyX3N0YXRzICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3Vic2NyaWJlclN0YXRzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBwdWJsaXNoZXJfc3RhdHMgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wdWJsaXNoZXJTdGF0cyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgd2VicnRjX3ZlcnNpb24gKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53ZWJydGNWZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZGsgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZGsgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNka192ZXJzaW9uICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RrVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmluZyBzdWJzY3JpYmVyX3N0YXRzID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaWJlclN0YXRzICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zdWJzY3JpYmVyU3RhdHMpO1xuICAgICAgICAvKiBzdHJpbmcgcHVibGlzaGVyX3N0YXRzID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucHVibGlzaGVyU3RhdHMgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnB1Ymxpc2hlclN0YXRzKTtcbiAgICAgICAgLyogc3RyaW5nIHdlYnJ0Y192ZXJzaW9uID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uud2VicnRjVmVyc2lvbiAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uud2VicnRjVmVyc2lvbik7XG4gICAgICAgIC8qIHN0cmluZyBzZGsgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZGsgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkayk7XG4gICAgICAgIC8qIHN0cmluZyBzZGtfdmVyc2lvbiA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNka1ZlcnNpb24gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNka1ZlcnNpb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2VuZFN0YXRzUmVxdWVzdFxuICovXG5jb25zdCBTZW5kU3RhdHNSZXF1ZXN0ID0gbmV3IFNlbmRTdGF0c1JlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2VuZFN0YXRzUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1Jlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1Jlc3BvbnNlXG4gKi9cbmNvbnN0IFNlbmRTdGF0c1Jlc3BvbnNlID0gbmV3IFNlbmRTdGF0c1Jlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIElDRVJlc3RhcnRSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VSZXN0YXJ0UmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BlZXJfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUnLCBQZWVyVHlwZSwgJ1BFRVJfVFlQRV8nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBlZXJUeXBlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucGVlclR5cGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlcXVlc3RcbiAqL1xuY29uc3QgSUNFUmVzdGFydFJlcXVlc3QgPSBuZXcgSUNFUmVzdGFydFJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSUNFUmVzdGFydFJlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VSZXN0YXJ0UmVzcG9uc2UnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnZXJyb3InLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IEVycm9yJDIgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBFcnJvciQyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICAgICAgICBFcnJvciQyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5lcnJvciwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlc3BvbnNlXG4gKi9cbmNvbnN0IElDRVJlc3RhcnRSZXNwb25zZSA9IG5ldyBJQ0VSZXN0YXJ0UmVzcG9uc2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbXV0ZV9zdGF0ZXMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFRyYWNrTXV0ZVN0YXRlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UubXV0ZVN0YXRlcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja011dGVTdGF0ZSBtdXRlX3N0YXRlcyAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm11dGVTdGF0ZXMucHVzaChUcmFja011dGVTdGF0ZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrTXV0ZVN0YXRlIG11dGVfc3RhdGVzID0gMzsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLm11dGVTdGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBUcmFja011dGVTdGF0ZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UubXV0ZVN0YXRlc1tpXSwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3RcbiAqL1xuY29uc3QgVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QgPSBuZXcgVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2UnLCBbXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiAnZXJyb3InLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IEVycm9yJDIgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBFcnJvciQyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICAgICAgICBFcnJvciQyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5lcnJvciwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlXG4gKi9cbmNvbnN0IFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSA9IG5ldyBVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVHJhY2tNdXRlU3RhdGUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrTXV0ZVN0YXRlJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja190eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICAnVFJBQ0tfVFlQRV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ211dGVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS50cmFja1R5cGUgPSAwO1xuICAgICAgICBtZXNzYWdlLm11dGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0cmFja190eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBtdXRlZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm11dGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50cmFja1R5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50cmFja1R5cGUpO1xuICAgICAgICAvKiBib29sIG11dGVkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubXV0ZWQgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5tdXRlZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja011dGVTdGF0ZVxuICovXG5jb25zdCBUcmFja011dGVTdGF0ZSA9IG5ldyBUcmFja011dGVTdGF0ZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBBdWRpb011dGVDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5BdWRpb011dGVDaGFuZ2VkJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ211dGVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIG11dGVkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXV0ZWQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBib29sIG11dGVkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubXV0ZWQgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5tdXRlZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5BdWRpb011dGVDaGFuZ2VkXG4gKi9cbm5ldyBBdWRpb011dGVDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvTXV0ZUNoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlZpZGVvTXV0ZUNoYW5nZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnbXV0ZWQnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLm11dGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgbXV0ZWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tdXRlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIGJvb2wgbXV0ZWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tdXRlZCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLm11dGVkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlZpZGVvTXV0ZUNoYW5nZWRcbiAqL1xubmV3IFZpZGVvTXV0ZUNoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0JywgW1xuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS50cmFja3MgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzIHRyYWNrcyAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrcy5wdXNoKFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyB0cmFja3MgPSAzOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UudHJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS50cmFja3NbaV0sIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0XG4gKi9cbmNvbnN0IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0ID0gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZVxuICovXG5jb25zdCBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2UgPSBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3RyYWNrX3R5cGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUnLFxuICAgICAgICAgICAgICAgICAgICBUcmFja1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICdUUkFDS19UWVBFXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiAnZGltZW5zaW9uJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBWaWRlb0RpbWVuc2lvbiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS50cmFja1R5cGUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uIGRpbWVuc2lvbiAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbWVuc2lvbiA9IFZpZGVvRGltZW5zaW9uLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5kaW1lbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0cmFja190eXBlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tUeXBlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudHJhY2tUeXBlKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb24gZGltZW5zaW9uID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGltZW5zaW9uKVxuICAgICAgICAgICAgVmlkZW9EaW1lbnNpb24uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmRpbWVuc2lvbiwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzXG4gKi9cbmNvbnN0IFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyA9IG5ldyBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2VuZEFuc3dlclJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXF1ZXN0JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwZWVyX3R5cGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlJywgUGVlclR5cGUsICdQRUVSX1RZUEVfJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3NkcCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSAwO1xuICAgICAgICBtZXNzYWdlLnNkcCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wZWVyVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHAgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBlZXJUeXBlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucGVlclR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgc2RwID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXF1ZXN0XG4gKi9cbmNvbnN0IFNlbmRBbnN3ZXJSZXF1ZXN0ID0gbmV3IFNlbmRBbnN3ZXJSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNlbmRBbnN3ZXJSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2VuZEFuc3dlclJlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXNwb25zZVxuICovXG5jb25zdCBTZW5kQW5zd2VyUmVzcG9uc2UgPSBuZXcgU2VuZEFuc3dlclJlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIElDRVRyaWNrbGVSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFVHJpY2tsZVJlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVRyaWNrbGVSZXNwb25zZVxuICovXG5jb25zdCBJQ0VUcmlja2xlUmVzcG9uc2UgPSBuZXcgSUNFVHJpY2tsZVJlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNldFB1Ymxpc2hlclJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNldFB1Ymxpc2hlclJlcXVlc3QnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2RwJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja3MnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFRyYWNrSW5mbyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnNkcCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnRyYWNrcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrSW5mbyB0cmFja3MgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja3MucHVzaChUcmFja0luZm8uaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZHAgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm8gdHJhY2tzID0gMzsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFRyYWNrSW5mby5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UudHJhY2tzW2ldLCB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXF1ZXN0XG4gKi9cbmNvbnN0IFNldFB1Ymxpc2hlclJlcXVlc3QgPSBuZXcgU2V0UHVibGlzaGVyUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZXRQdWJsaXNoZXJSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2V0UHVibGlzaGVyUmVzcG9uc2UnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2RwJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogJ2ljZV9yZXN0YXJ0Jywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnNkcCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLmljZVJlc3RhcnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkcCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGljZV9yZXN0YXJ0ICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWNlUmVzdGFydCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHNkcCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkcCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RwKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIGJvb2wgaWNlX3Jlc3RhcnQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pY2VSZXN0YXJ0ICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuaWNlUmVzdGFydCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IpXG4gICAgICAgICAgICBFcnJvciQyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5lcnJvciwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2V0UHVibGlzaGVyUmVzcG9uc2VcbiAqL1xuY29uc3QgU2V0UHVibGlzaGVyUmVzcG9uc2UgPSBuZXcgU2V0UHVibGlzaGVyUmVzcG9uc2UkVHlwZSgpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIFNlcnZpY2VUeXBlIGZvciBwcm90b2J1ZiBzZXJ2aWNlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNpZ25hbFNlcnZlclxuICovXG5jb25zdCBTaWduYWxTZXJ2ZXIgPSBuZXcgU2VydmljZVR5cGUoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNpZ25hbFNlcnZlcicsIFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICdTZXRQdWJsaXNoZXInLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgSTogU2V0UHVibGlzaGVyUmVxdWVzdCxcbiAgICAgICAgTzogU2V0UHVibGlzaGVyUmVzcG9uc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdTZW5kQW5zd2VyJyxcbiAgICAgICAgb3B0aW9uczoge30sXG4gICAgICAgIEk6IFNlbmRBbnN3ZXJSZXF1ZXN0LFxuICAgICAgICBPOiBTZW5kQW5zd2VyUmVzcG9uc2UsXG4gICAgfSxcbiAgICB7IG5hbWU6ICdJY2VUcmlja2xlJywgb3B0aW9uczoge30sIEk6IElDRVRyaWNrbGUkMSwgTzogSUNFVHJpY2tsZVJlc3BvbnNlIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnVXBkYXRlU3Vic2NyaXB0aW9ucycsXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICBJOiBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCxcbiAgICAgICAgTzogVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnVXBkYXRlTXV0ZVN0YXRlcycsXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICBJOiBVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCxcbiAgICAgICAgTzogVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnSWNlUmVzdGFydCcsXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICBJOiBJQ0VSZXN0YXJ0UmVxdWVzdCxcbiAgICAgICAgTzogSUNFUmVzdGFydFJlc3BvbnNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnU2VuZFN0YXRzJyxcbiAgICAgICAgb3B0aW9uczoge30sXG4gICAgICAgIEk6IFNlbmRTdGF0c1JlcXVlc3QsXG4gICAgICAgIE86IFNlbmRTdGF0c1Jlc3BvbnNlLFxuICAgIH0sXG5dKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nLlByaW9yaXR5XG4gKi9cbnZhciBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eTtcbihmdW5jdGlvbiAoVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHkpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogUFJJT1JJVFlfSElHSF9VTlNQRUNJRklFRCA9IDA7XG4gICAgICovXG4gICAgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbXCJISUdIX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkhJR0hfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogUFJJT1JJVFlfTE9XID0gMTtcbiAgICAgKi9cbiAgICBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eVtWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eVtcIkxPV1wiXSA9IDFdID0gXCJMT1dcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogUFJJT1JJVFlfTUVESVVNID0gMjtcbiAgICAgKi9cbiAgICBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eVtWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eVtcIk1FRElVTVwiXSA9IDJdID0gXCJNRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogUFJJT1JJVFlfVkVSWV9MT1cgPSAzO1xuICAgICAqL1xuICAgIFZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5W1ZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5W1wiVkVSWV9MT1dcIl0gPSAzXSA9IFwiVkVSWV9MT1dcIjtcbn0pKFZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5IHx8IChWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSA9IHt9KSk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZnVFdmVudCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TZnVFdmVudCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3Vic2NyaWJlcl9vZmZlcicsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBTdWJzY3JpYmVyT2ZmZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwdWJsaXNoZXJfYW5zd2VyJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFB1Ymxpc2hlckFuc3dlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25fcXVhbGl0eV9jaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2F1ZGlvX2xldmVsX2NoYW5nZWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gQXVkaW9MZXZlbENoYW5nZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdpY2VfdHJpY2tsZScsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBJQ0VUcmlja2xlJDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjaGFuZ2VfcHVibGlzaF9xdWFsaXR5JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IENoYW5nZVB1Ymxpc2hRdWFsaXR5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMTAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BhcnRpY2lwYW50X2pvaW5lZCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQYXJ0aWNpcGFudEpvaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDExLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9sZWZ0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBhcnRpY2lwYW50TGVmdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdkb21pbmFudF9zcGVha2VyX2NoYW5nZWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gRG9taW5hbnRTcGVha2VyQ2hhbmdlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdqb2luX3Jlc3BvbnNlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEpvaW5SZXNwb25zZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDE0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdoZWFsdGhfY2hlY2tfcmVzcG9uc2UnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gSGVhbHRoQ2hlY2tSZXNwb25zZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDE2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja19wdWJsaXNoZWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVHJhY2tQdWJsaXNoZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tfdW5wdWJsaXNoZWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVHJhY2tVbnB1Ymxpc2hlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDE4LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBFcnJvciQxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMTksXG4gICAgICAgICAgICAgICAgbmFtZTogJ2NhbGxfZ3JhbnRzX3VwZGF0ZWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gQ2FsbEdyYW50c1VwZGF0ZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyMCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZ29fYXdheScsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBHb0F3YXksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaWNlX3Jlc3RhcnQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gSUNFUmVzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwaW5zX3VwZGF0ZWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gUGluc0NoYW5nZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7IG9uZW9mS2luZDogdW5kZWZpbmVkIH07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuU3Vic2NyaWJlck9mZmVyIHN1YnNjcmliZXJfb2ZmZXIgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdzdWJzY3JpYmVyT2ZmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlck9mZmVyOiBTdWJzY3JpYmVyT2ZmZXIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5zdWJzY3JpYmVyT2ZmZXIpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUHVibGlzaGVyQW5zd2VyIHB1Ymxpc2hlcl9hbnN3ZXIgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdwdWJsaXNoZXJBbnN3ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVyQW5zd2VyOiBQdWJsaXNoZXJBbnN3ZXIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5wdWJsaXNoZXJBbnN3ZXIpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIGNvbm5lY3Rpb25fcXVhbGl0eV9jaGFuZ2VkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZDogQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWxDaGFuZ2VkIGF1ZGlvX2xldmVsX2NoYW5nZWQgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdhdWRpb0xldmVsQ2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0xldmVsQ2hhbmdlZDogQXVkaW9MZXZlbENoYW5nZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5hdWRpb0xldmVsQ2hhbmdlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuSUNFVHJpY2tsZSBpY2VfdHJpY2tsZSAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2ljZVRyaWNrbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNlVHJpY2tsZTogSUNFVHJpY2tsZSQxLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuaWNlVHJpY2tsZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DaGFuZ2VQdWJsaXNoUXVhbGl0eSBjaGFuZ2VfcHVibGlzaF9xdWFsaXR5ICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnY2hhbmdlUHVibGlzaFF1YWxpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlUHVibGlzaFF1YWxpdHk6IENoYW5nZVB1Ymxpc2hRdWFsaXR5LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuY2hhbmdlUHVibGlzaFF1YWxpdHkpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRKb2luZWQgcGFydGljaXBhbnRfam9pbmVkICovIDEwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ3BhcnRpY2lwYW50Sm9pbmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50Sm9pbmVkOiBQYXJ0aWNpcGFudEpvaW5lZC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnBhcnRpY2lwYW50Sm9pbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdCBwYXJ0aWNpcGFudF9sZWZ0ICovIDExOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ3BhcnRpY2lwYW50TGVmdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudExlZnQ6IFBhcnRpY2lwYW50TGVmdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnBhcnRpY2lwYW50TGVmdCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Eb21pbmFudFNwZWFrZXJDaGFuZ2VkIGRvbWluYW50X3NwZWFrZXJfY2hhbmdlZCAqLyAxMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdkb21pbmFudFNwZWFrZXJDaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWluYW50U3BlYWtlckNoYW5nZWQ6IERvbWluYW50U3BlYWtlckNoYW5nZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5kb21pbmFudFNwZWFrZXJDaGFuZ2VkKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXNwb25zZSBqb2luX3Jlc3BvbnNlICovIDEzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2pvaW5SZXNwb25zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmpvaW5SZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1Jlc3BvbnNlIGhlYWx0aF9jaGVja19yZXNwb25zZSAqLyAxNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdoZWFsdGhDaGVja1Jlc3BvbnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWx0aENoZWNrUmVzcG9uc2U6IEhlYWx0aENoZWNrUmVzcG9uc2UuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5oZWFsdGhDaGVja1Jlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrUHVibGlzaGVkIHRyYWNrX3B1Ymxpc2hlZCAqLyAxNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICd0cmFja1B1Ymxpc2hlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja1B1Ymxpc2hlZDogVHJhY2tQdWJsaXNoZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC50cmFja1B1Ymxpc2hlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1VucHVibGlzaGVkIHRyYWNrX3VucHVibGlzaGVkICovIDE3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ3RyYWNrVW5wdWJsaXNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tVbnB1Ymxpc2hlZDogVHJhY2tVbnB1Ymxpc2hlZC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnRyYWNrVW5wdWJsaXNoZWQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRXJyb3IgZXJyb3IgKi8gMTg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IEVycm9yJDEuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5lcnJvciksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DYWxsR3JhbnRzVXBkYXRlZCBjYWxsX2dyYW50c191cGRhdGVkICovIDE5OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2NhbGxHcmFudHNVcGRhdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxHcmFudHNVcGRhdGVkOiBDYWxsR3JhbnRzVXBkYXRlZC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmNhbGxHcmFudHNVcGRhdGVkKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkdvQXdheSBnb19hd2F5ICovIDIwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2dvQXdheScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb0F3YXk6IEdvQXdheS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmdvQXdheSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5JQ0VSZXN0YXJ0IGljZV9yZXN0YXJ0ICovIDIxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2ljZVJlc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNlUmVzdGFydDogSUNFUmVzdGFydC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmljZVJlc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGluc0NoYW5nZWQgcGluc191cGRhdGVkICovIDIyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ3BpbnNVcGRhdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbnNVcGRhdGVkOiBQaW5zQ2hhbmdlZC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnBpbnNVcGRhdGVkKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TdWJzY3JpYmVyT2ZmZXIgc3Vic2NyaWJlcl9vZmZlciA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdzdWJzY3JpYmVyT2ZmZXInKVxuICAgICAgICAgICAgU3Vic2NyaWJlck9mZmVyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuc3Vic2NyaWJlck9mZmVyLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUHVibGlzaGVyQW5zd2VyIHB1Ymxpc2hlcl9hbnN3ZXIgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAncHVibGlzaGVyQW5zd2VyJylcbiAgICAgICAgICAgIFB1Ymxpc2hlckFuc3dlci5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnB1Ymxpc2hlckFuc3dlciwgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCBjb25uZWN0aW9uX3F1YWxpdHlfY2hhbmdlZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQnKVxuICAgICAgICAgICAgQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbENoYW5nZWQgYXVkaW9fbGV2ZWxfY2hhbmdlZCA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdhdWRpb0xldmVsQ2hhbmdlZCcpXG4gICAgICAgICAgICBBdWRpb0xldmVsQ2hhbmdlZC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmF1ZGlvTGV2ZWxDaGFuZ2VkLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUgaWNlX3RyaWNrbGUgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnaWNlVHJpY2tsZScpXG4gICAgICAgICAgICBJQ0VUcmlja2xlJDEuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5pY2VUcmlja2xlLCB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2hhbmdlUHVibGlzaFF1YWxpdHkgY2hhbmdlX3B1Ymxpc2hfcXVhbGl0eSA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdjaGFuZ2VQdWJsaXNoUXVhbGl0eScpXG4gICAgICAgICAgICBDaGFuZ2VQdWJsaXNoUXVhbGl0eS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmNoYW5nZVB1Ymxpc2hRdWFsaXR5LCB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRKb2luZWQgcGFydGljaXBhbnRfam9pbmVkID0gMTA7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdwYXJ0aWNpcGFudEpvaW5lZCcpXG4gICAgICAgICAgICBQYXJ0aWNpcGFudEpvaW5lZC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnBhcnRpY2lwYW50Sm9pbmVkLCB3cml0ZXIudGFnKDEwLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdCBwYXJ0aWNpcGFudF9sZWZ0ID0gMTE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdwYXJ0aWNpcGFudExlZnQnKVxuICAgICAgICAgICAgUGFydGljaXBhbnRMZWZ0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQucGFydGljaXBhbnRMZWZ0LCB3cml0ZXIudGFnKDExLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkRvbWluYW50U3BlYWtlckNoYW5nZWQgZG9taW5hbnRfc3BlYWtlcl9jaGFuZ2VkID0gMTI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdkb21pbmFudFNwZWFrZXJDaGFuZ2VkJylcbiAgICAgICAgICAgIERvbWluYW50U3BlYWtlckNoYW5nZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5kb21pbmFudFNwZWFrZXJDaGFuZ2VkLCB3cml0ZXIudGFnKDEyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXNwb25zZSBqb2luX3Jlc3BvbnNlID0gMTM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdqb2luUmVzcG9uc2UnKVxuICAgICAgICAgICAgSm9pblJlc3BvbnNlLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuam9pblJlc3BvbnNlLCB3cml0ZXIudGFnKDEzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVzcG9uc2UgaGVhbHRoX2NoZWNrX3Jlc3BvbnNlID0gMTQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdoZWFsdGhDaGVja1Jlc3BvbnNlJylcbiAgICAgICAgICAgIEhlYWx0aENoZWNrUmVzcG9uc2UuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5oZWFsdGhDaGVja1Jlc3BvbnNlLCB3cml0ZXIudGFnKDE0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrUHVibGlzaGVkIHRyYWNrX3B1Ymxpc2hlZCA9IDE2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAndHJhY2tQdWJsaXNoZWQnKVxuICAgICAgICAgICAgVHJhY2tQdWJsaXNoZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC50cmFja1B1Ymxpc2hlZCwgd3JpdGVyLnRhZygxNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1VucHVibGlzaGVkIHRyYWNrX3VucHVibGlzaGVkID0gMTc7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICd0cmFja1VucHVibGlzaGVkJylcbiAgICAgICAgICAgIFRyYWNrVW5wdWJsaXNoZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC50cmFja1VucHVibGlzaGVkLCB3cml0ZXIudGFnKDE3LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkVycm9yIGVycm9yID0gMTg7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdlcnJvcicpXG4gICAgICAgICAgICBFcnJvciQxLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuZXJyb3IsIHdyaXRlci50YWcoMTgsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2FsbEdyYW50c1VwZGF0ZWQgY2FsbF9ncmFudHNfdXBkYXRlZCA9IDE5OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnY2FsbEdyYW50c1VwZGF0ZWQnKVxuICAgICAgICAgICAgQ2FsbEdyYW50c1VwZGF0ZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5jYWxsR3JhbnRzVXBkYXRlZCwgd3JpdGVyLnRhZygxOSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Hb0F3YXkgZ29fYXdheSA9IDIwOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnZ29Bd2F5JylcbiAgICAgICAgICAgIEdvQXdheS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmdvQXdheSwgd3JpdGVyLnRhZygyMCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5JQ0VSZXN0YXJ0IGljZV9yZXN0YXJ0ID0gMjE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmV2ZW50UGF5bG9hZC5vbmVvZktpbmQgPT09ICdpY2VSZXN0YXJ0JylcbiAgICAgICAgICAgIElDRVJlc3RhcnQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5pY2VSZXN0YXJ0LCB3cml0ZXIudGFnKDIxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkIHBpbnNfdXBkYXRlZCA9IDIyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAncGluc1VwZGF0ZWQnKVxuICAgICAgICAgICAgUGluc0NoYW5nZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5waW5zVXBkYXRlZCwgd3JpdGVyLnRhZygyMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuU2Z1RXZlbnRcbiAqL1xuY29uc3QgU2Z1RXZlbnQgPSBuZXcgU2Z1RXZlbnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGluc0NoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuUGluc0NoYW5nZWQnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BpbnMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBpbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBpbnMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluIHBpbnMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5waW5zLnB1c2goUGluLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QaW4gcGlucyA9IDE7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5waW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgUGluLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5waW5zW2ldLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkXG4gKi9cbmNvbnN0IFBpbnNDaGFuZ2VkID0gbmV3IFBpbnNDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEVycm9yJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkVycm9yJywgW1xuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRXJyb3JcbiAqL1xuY29uc3QgRXJyb3IkMSA9IG5ldyBFcnJvciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VUcmlja2xlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LklDRVRyaWNrbGUnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BlZXJfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUnLCBQZWVyVHlwZSwgJ1BFRVJfVFlQRV8nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2ljZV9jYW5kaWRhdGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSAwO1xuICAgICAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wZWVyVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBpY2VfY2FuZGlkYXRlICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWNlQ2FuZGlkYXRlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wZWVyVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnBlZXJUeXBlKTtcbiAgICAgICAgLyogc3RyaW5nIGljZV9jYW5kaWRhdGUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pY2VDYW5kaWRhdGUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmljZUNhbmRpZGF0ZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LklDRVRyaWNrbGVcbiAqL1xuY29uc3QgSUNFVHJpY2tsZSA9IG5ldyBJQ0VUcmlja2xlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIElDRVJlc3RhcnQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGVlcl90eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gWydzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZScsIFBlZXJUeXBlLCAnUEVFUl9UWVBFXyddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wZWVyVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wZWVyVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnBlZXJUeXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydFxuICovXG5jb25zdCBJQ0VSZXN0YXJ0ID0gbmV3IElDRVJlc3RhcnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2Z1UmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TZnVSZXF1ZXN0JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdqb2luX3JlcXVlc3QnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ3JlcXVlc3RQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBKb2luUmVxdWVzdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2hlYWx0aF9jaGVja19yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdyZXF1ZXN0UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gSGVhbHRoQ2hlY2tSZXF1ZXN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UucmVxdWVzdFBheWxvYWQgPSB7IG9uZW9mS2luZDogdW5kZWZpbmVkIH07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSm9pblJlcXVlc3Qgam9pbl9yZXF1ZXN0ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdqb2luUmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luUmVxdWVzdDogSm9pblJlcXVlc3QuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnJlcXVlc3RQYXlsb2FkLmpvaW5SZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVxdWVzdCBoZWFsdGhfY2hlY2tfcmVxdWVzdCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnaGVhbHRoQ2hlY2tSZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWx0aENoZWNrUmVxdWVzdDogSGVhbHRoQ2hlY2tSZXF1ZXN0LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5oZWFsdGhDaGVja1JlcXVlc3QpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXF1ZXN0IGpvaW5fcmVxdWVzdCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnJlcXVlc3RQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2pvaW5SZXF1ZXN0JylcbiAgICAgICAgICAgIEpvaW5SZXF1ZXN0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5qb2luUmVxdWVzdCwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVxdWVzdCBoZWFsdGhfY2hlY2tfcmVxdWVzdCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnJlcXVlc3RQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2hlYWx0aENoZWNrUmVxdWVzdCcpXG4gICAgICAgICAgICBIZWFsdGhDaGVja1JlcXVlc3QuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnJlcXVlc3RQYXlsb2FkLmhlYWx0aENoZWNrUmVxdWVzdCwgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TZnVSZXF1ZXN0XG4gKi9cbmNvbnN0IFNmdVJlcXVlc3QgPSBuZXcgU2Z1UmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBIZWFsdGhDaGVja1JlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXF1ZXN0JywgW10pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1JlcXVlc3RcbiAqL1xuY29uc3QgSGVhbHRoQ2hlY2tSZXF1ZXN0ID0gbmV3IEhlYWx0aENoZWNrUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBIZWFsdGhDaGVja1Jlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVzcG9uc2UnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BhcnRpY2lwYW50X2NvdW50JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gUGFydGljaXBhbnRDb3VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50IHBhcnRpY2lwYW50X2NvdW50ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRDb3VudCA9IFBhcnRpY2lwYW50Q291bnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50IHBhcnRpY2lwYW50X2NvdW50ID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydGljaXBhbnRDb3VudClcbiAgICAgICAgICAgIFBhcnRpY2lwYW50Q291bnQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQsIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXNwb25zZVxuICovXG5jb25zdCBIZWFsdGhDaGVja1Jlc3BvbnNlID0gbmV3IEhlYWx0aENoZWNrUmVzcG9uc2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVHJhY2tQdWJsaXNoZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tQdWJsaXNoZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdwYXJ0aWNpcGFudCcsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gUGFydGljaXBhbnQgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0eXBlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQgPSBQYXJ0aWNpcGFudC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UucGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0eXBlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50KVxuICAgICAgICAgICAgUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBhcnRpY2lwYW50LCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrUHVibGlzaGVkXG4gKi9cbmNvbnN0IFRyYWNrUHVibGlzaGVkID0gbmV3IFRyYWNrUHVibGlzaGVkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFRyYWNrVW5wdWJsaXNoZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICAnVFJBQ0tfVFlQRV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjYXVzZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVW5wdWJsaXNoUmVhc29uJyxcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tVbnB1Ymxpc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICdUUkFDS19VTlBVQkxJU0hfUkVBU09OXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA1LCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnVzZXJJZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICBtZXNzYWdlLmNhdXNlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHR5cGUgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tVbnB1Ymxpc2hSZWFzb24gY2F1c2UgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYXVzZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQgPSBQYXJ0aWNpcGFudC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UucGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0eXBlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1VucHVibGlzaFJlYXNvbiBjYXVzZSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhdXNlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UuY2F1c2UpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50KVxuICAgICAgICAgICAgUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBhcnRpY2lwYW50LCB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrVW5wdWJsaXNoZWRcbiAqL1xuY29uc3QgVHJhY2tVbnB1Ymxpc2hlZCA9IG5ldyBUcmFja1VucHVibGlzaGVkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEpvaW5SZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXF1ZXN0JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3Rva2VuJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzdWJzY3JpYmVyX3NkcCcsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjbGllbnRfZGV0YWlscycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IENsaWVudERldGFpbHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNSwgbmFtZTogJ21pZ3JhdGlvbicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gTWlncmF0aW9uIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Zhc3RfcmVjb25uZWN0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS50b2tlbiA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnN1YnNjcmliZXJTZHAgPSAnJztcbiAgICAgICAgbWVzc2FnZS5mYXN0UmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0b2tlbiAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRva2VuID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzdWJzY3JpYmVyX3NkcCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmliZXJTZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2xpZW50RGV0YWlscyBjbGllbnRfZGV0YWlscyAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsaWVudERldGFpbHMgPSBDbGllbnREZXRhaWxzLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jbGllbnREZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50Lk1pZ3JhdGlvbiBtaWdyYXRpb24gKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taWdyYXRpb24gPSBNaWdyYXRpb24uaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLm1pZ3JhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBmYXN0X3JlY29ubmVjdCAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZhc3RSZWNvbm5lY3QgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdG9rZW4gPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50b2tlbiAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudG9rZW4pO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgLyogc3RyaW5nIHN1YnNjcmliZXJfc2RwID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3Vic2NyaWJlclNkcCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc3Vic2NyaWJlclNkcCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNsaWVudERldGFpbHMgY2xpZW50X2RldGFpbHMgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jbGllbnREZXRhaWxzKVxuICAgICAgICAgICAgQ2xpZW50RGV0YWlscy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY2xpZW50RGV0YWlscywgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50Lk1pZ3JhdGlvbiBtaWdyYXRpb24gPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5taWdyYXRpb24pXG4gICAgICAgICAgICBNaWdyYXRpb24uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLm1pZ3JhdGlvbiwgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBib29sIGZhc3RfcmVjb25uZWN0ID0gNjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZmFzdFJlY29ubmVjdCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmZhc3RSZWNvbm5lY3QpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVxdWVzdFxuICovXG5jb25zdCBKb2luUmVxdWVzdCA9IG5ldyBKb2luUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBNaWdyYXRpb24kVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuTWlncmF0aW9uJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdmcm9tX3NmdV9pZCcsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhbm5vdW5jZWRfdHJhY2tzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBUcmFja0luZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzdWJzY3JpcHRpb25zJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5mcm9tU2Z1SWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5hbm5vdW5jZWRUcmFja3MgPSBbXTtcbiAgICAgICAgbWVzc2FnZS5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBmcm9tX3NmdV9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZyb21TZnVJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm8gYW5ub3VuY2VkX3RyYWNrcyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFubm91bmNlZFRyYWNrcy5wdXNoKFRyYWNrSW5mby5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja1N1YnNjcmlwdGlvbkRldGFpbHMgc3Vic2NyaXB0aW9ucyAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1YnNjcmlwdGlvbnMucHVzaChUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBmcm9tX3NmdV9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmZyb21TZnVJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuZnJvbVNmdUlkKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvIGFubm91bmNlZF90cmFja3MgPSAyOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuYW5ub3VuY2VkVHJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVHJhY2tJbmZvLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5hbm5vdW5jZWRUcmFja3NbaV0sIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzIHN1YnNjcmlwdGlvbnMgPSAzOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2Uuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uuc3Vic2NyaXB0aW9uc1tpXSwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5NaWdyYXRpb25cbiAqL1xuY29uc3QgTWlncmF0aW9uID0gbmV3IE1pZ3JhdGlvbiRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBKb2luUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuSm9pblJlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ2NhbGxfc3RhdGUnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENhbGxTdGF0ZSQxIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAncmVjb25uZWN0ZWQnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnJlY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZSBjYWxsX3N0YXRlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FsbFN0YXRlID0gQ2FsbFN0YXRlJDEuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmNhbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCByZWNvbm5lY3RlZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY29ubmVjdGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbFN0YXRlIGNhbGxfc3RhdGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jYWxsU3RhdGUpXG4gICAgICAgICAgICBDYWxsU3RhdGUkMS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY2FsbFN0YXRlLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIGJvb2wgcmVjb25uZWN0ZWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZWNvbm5lY3RlZCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnJlY29ubmVjdGVkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSm9pblJlc3BvbnNlXG4gKi9cbmNvbnN0IEpvaW5SZXNwb25zZSA9IG5ldyBKb2luUmVzcG9uc2UkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnRKb2luZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRKb2luZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnY2FsbF9jaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdwYXJ0aWNpcGFudCcsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gUGFydGljaXBhbnQgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuY2FsbENpZCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgY2FsbF9jaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYWxsQ2lkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnQgPSBQYXJ0aWNpcGFudC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UucGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgY2FsbF9jaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jYWxsQ2lkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5jYWxsQ2lkKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudClcbiAgICAgICAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudCwgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QYXJ0aWNpcGFudEpvaW5lZFxuICovXG5jb25zdCBQYXJ0aWNpcGFudEpvaW5lZCA9IG5ldyBQYXJ0aWNpcGFudEpvaW5lZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBQYXJ0aWNpcGFudExlZnQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRMZWZ0JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ2NhbGxfY2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmNhbGxDaWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGNhbGxfY2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FsbENpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50ID0gUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIGNhbGxfY2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FsbENpZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuY2FsbENpZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydGljaXBhbnQpXG4gICAgICAgICAgICBQYXJ0aWNpcGFudC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucGFydGljaXBhbnQsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRMZWZ0XG4gKi9cbmNvbnN0IFBhcnRpY2lwYW50TGVmdCA9IG5ldyBQYXJ0aWNpcGFudExlZnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU3Vic2NyaWJlck9mZmVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlN1YnNjcmliZXJPZmZlcicsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdpY2VfcmVzdGFydCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZHAnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuaWNlUmVzdGFydCA9IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLnNkcCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGljZV9yZXN0YXJ0ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWNlUmVzdGFydCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkcCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogYm9vbCBpY2VfcmVzdGFydCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmljZVJlc3RhcnQgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5pY2VSZXN0YXJ0KTtcbiAgICAgICAgLyogc3RyaW5nIHNkcCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkcCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RwKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuU3Vic2NyaWJlck9mZmVyXG4gKi9cbmNvbnN0IFN1YnNjcmliZXJPZmZlciA9IG5ldyBTdWJzY3JpYmVyT2ZmZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUHVibGlzaGVyQW5zd2VyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlB1Ymxpc2hlckFuc3dlcicsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdzZHAnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2Uuc2RwID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHAgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZHAgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlB1Ymxpc2hlckFuc3dlclxuICovXG5jb25zdCBQdWJsaXNoZXJBbnN3ZXIgPSBuZXcgUHVibGlzaGVyQW5zd2VyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25fcXVhbGl0eV91cGRhdGVzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBDb25uZWN0aW9uUXVhbGl0eUluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUluZm8gY29ubmVjdGlvbl9xdWFsaXR5X3VwZGF0ZXMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMucHVzaChDb25uZWN0aW9uUXVhbGl0eUluZm8uaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlJbmZvIGNvbm5lY3Rpb25fcXVhbGl0eV91cGRhdGVzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIENvbm5lY3Rpb25RdWFsaXR5SW5mby5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHlVcGRhdGVzW2ldLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFxuICovXG5jb25zdCBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgPSBuZXcgQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENvbm5lY3Rpb25RdWFsaXR5SW5mbyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUluZm8nLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29ubmVjdGlvbl9xdWFsaXR5JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHknLFxuICAgICAgICAgICAgICAgICAgICBDb25uZWN0aW9uUXVhbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgJ0NPTk5FQ1RJT05fUVVBTElUWV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5IGNvbm5lY3Rpb25fcXVhbGl0eSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB1c2VyX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudXNlcklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS51c2VySWQpO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHkgY29ubmVjdGlvbl9xdWFsaXR5ID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5SW5mb1xuICovXG5jb25zdCBDb25uZWN0aW9uUXVhbGl0eUluZm8gPSBuZXcgQ29ubmVjdGlvblF1YWxpdHlJbmZvJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIERvbWluYW50U3BlYWtlckNoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuRG9taW5hbnRTcGVha2VyQ2hhbmdlZCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyB1c2VyX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudXNlcklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS51c2VySWQpO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRG9taW5hbnRTcGVha2VyQ2hhbmdlZFxuICovXG5jb25zdCBEb21pbmFudFNwZWFrZXJDaGFuZ2VkID0gbmV3IERvbWluYW50U3BlYWtlckNoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9MZXZlbCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiAnbGV2ZWwnLCBraW5kOiAnc2NhbGFyJywgVDogMiAvKlNjYWxhclR5cGUuRkxPQVQqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2lzX3NwZWFraW5nJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5sZXZlbCA9IDA7XG4gICAgICAgIG1lc3NhZ2UuaXNTcGVha2luZyA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBmbG9hdCBsZXZlbCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxldmVsID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBpc19zcGVha2luZyAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlzU3BlYWtpbmcgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIGZsb2F0IGxldmVsID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubGV2ZWwgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkJpdDMyKS5mbG9hdChtZXNzYWdlLmxldmVsKTtcbiAgICAgICAgLyogYm9vbCBpc19zcGVha2luZyA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmlzU3BlYWtpbmcgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5pc1NwZWFraW5nKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbFxuICovXG5jb25zdCBBdWRpb0xldmVsID0gbmV3IEF1ZGlvTGV2ZWwkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9MZXZlbENoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbENoYW5nZWQnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2F1ZGlvX2xldmVscycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gQXVkaW9MZXZlbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmF1ZGlvTGV2ZWxzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbCBhdWRpb19sZXZlbHMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdWRpb0xldmVscy5wdXNoKEF1ZGlvTGV2ZWwuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbCBhdWRpb19sZXZlbHMgPSAxOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuYXVkaW9MZXZlbHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBBdWRpb0xldmVsLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5hdWRpb0xldmVsc1tpXSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsQ2hhbmdlZFxuICovXG5jb25zdCBBdWRpb0xldmVsQ2hhbmdlZCA9IG5ldyBBdWRpb0xldmVsQ2hhbmdlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBBdWRpb01lZGlhUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb01lZGlhUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2hhbm5lbF9jb3VudCcsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmNoYW5uZWxDb3VudCA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIGNoYW5uZWxfY291bnQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFubmVsQ291bnQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogaW50MzIgY2hhbm5lbF9jb3VudCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNoYW5uZWxDb3VudCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmNoYW5uZWxDb3VudCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTWVkaWFSZXF1ZXN0XG4gKi9cbmNvbnN0IEF1ZGlvTWVkaWFSZXF1ZXN0ID0gbmV3IEF1ZGlvTWVkaWFSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEF1ZGlvU2VuZGVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvU2VuZGVyJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdtZWRpYV9yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gQXVkaW9NZWRpYVJlcXVlc3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ2NvZGVjJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBDb2RlYyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb01lZGlhUmVxdWVzdCBtZWRpYV9yZXF1ZXN0ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVkaWFSZXF1ZXN0ID0gQXVkaW9NZWRpYVJlcXVlc3QuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLm1lZGlhUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2RlYyA9IENvZGVjLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jb2RlYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9NZWRpYVJlcXVlc3QgbWVkaWFfcmVxdWVzdCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1lZGlhUmVxdWVzdClcbiAgICAgICAgICAgIEF1ZGlvTWVkaWFSZXF1ZXN0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5tZWRpYVJlcXVlc3QsIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jb2RlYylcbiAgICAgICAgICAgIENvZGVjLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jb2RlYywgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb1NlbmRlclxuICovXG5jb25zdCBBdWRpb1NlbmRlciA9IG5ldyBBdWRpb1NlbmRlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb01lZGlhUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb01lZGlhUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaWRlYWxfaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdpZGVhbF93aWR0aCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2lkZWFsX2ZyYW1lX3JhdGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5pZGVhbEhlaWdodCA9IDA7XG4gICAgICAgIG1lc3NhZ2UuaWRlYWxXaWR0aCA9IDA7XG4gICAgICAgIG1lc3NhZ2UuaWRlYWxGcmFtZVJhdGUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBpZGVhbF9oZWlnaHQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVhbEhlaWdodCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIGlkZWFsX3dpZHRoICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlYWxXaWR0aCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIGlkZWFsX2ZyYW1lX3JhdGUgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZGVhbEZyYW1lUmF0ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBpbnQzMiBpZGVhbF9oZWlnaHQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pZGVhbEhlaWdodCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmlkZWFsSGVpZ2h0KTtcbiAgICAgICAgLyogaW50MzIgaWRlYWxfd2lkdGggPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pZGVhbFdpZHRoICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UuaWRlYWxXaWR0aCk7XG4gICAgICAgIC8qIGludDMyIGlkZWFsX2ZyYW1lX3JhdGUgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pZGVhbEZyYW1lUmF0ZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmlkZWFsRnJhbWVSYXRlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9NZWRpYVJlcXVlc3RcbiAqL1xuY29uc3QgVmlkZW9NZWRpYVJlcXVlc3QgPSBuZXcgVmlkZW9NZWRpYVJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVmlkZW9MYXllclNldHRpbmckVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnbmFtZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ2FjdGl2ZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdtYXhfYml0cmF0ZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NjYWxlX3Jlc29sdXRpb25fZG93bl9ieScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogMiAvKlNjYWxhclR5cGUuRkxPQVQqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3ByaW9yaXR5JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZy5Qcmlvcml0eScsXG4gICAgICAgICAgICAgICAgICAgIFZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAnUFJJT1JJVFlfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDYsIG5hbWU6ICdjb2RlYycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gQ29kZWMgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbWF4X2ZyYW1lcmF0ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLm1heEJpdHJhdGUgPSAwO1xuICAgICAgICBtZXNzYWdlLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IDA7XG4gICAgICAgIG1lc3NhZ2UucHJpb3JpdHkgPSAwO1xuICAgICAgICBtZXNzYWdlLm1heEZyYW1lcmF0ZSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBuYW1lICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGFjdGl2ZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFjdGl2ZSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgbWF4X2JpdHJhdGUgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tYXhCaXRyYXRlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZmxvYXQgc2NhbGVfcmVzb2x1dGlvbl9kb3duX2J5ICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZy5Qcmlvcml0eSBwcmlvcml0eSAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByaW9yaXR5ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgKi8gNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2RlYyA9IENvZGVjLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jb2RlYyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIG1heF9mcmFtZXJhdGUgKi8gNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tYXhGcmFtZXJhdGUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBuYW1lID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIC8qIGJvb2wgYWN0aXZlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWN0aXZlICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuYWN0aXZlKTtcbiAgICAgICAgLyogaW50MzIgbWF4X2JpdHJhdGUgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tYXhCaXRyYXRlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UubWF4Qml0cmF0ZSk7XG4gICAgICAgIC8qIGZsb2F0IHNjYWxlX3Jlc29sdXRpb25fZG93bl9ieSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNjYWxlUmVzb2x1dGlvbkRvd25CeSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuQml0MzIpLmZsb2F0KG1lc3NhZ2Uuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZy5Qcmlvcml0eSBwcmlvcml0eSA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnByaW9yaXR5ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucHJpb3JpdHkpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYyBjb2RlYyA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNvZGVjKVxuICAgICAgICAgICAgQ29kZWMuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNvZGVjLCB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHVpbnQzMiBtYXhfZnJhbWVyYXRlID0gNzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWF4RnJhbWVyYXRlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg3LCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLm1heEZyYW1lcmF0ZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nXG4gKi9cbmNvbnN0IFZpZGVvTGF5ZXJTZXR0aW5nID0gbmV3IFZpZGVvTGF5ZXJTZXR0aW5nJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvU2VuZGVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvU2VuZGVyJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdtZWRpYV9yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVmlkZW9NZWRpYVJlcXVlc3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ2NvZGVjJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBDb2RlYyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdsYXllcnMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFZpZGVvTGF5ZXJTZXR0aW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubGF5ZXJzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9NZWRpYVJlcXVlc3QgbWVkaWFfcmVxdWVzdCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lZGlhUmVxdWVzdCA9IFZpZGVvTWVkaWFSZXF1ZXN0LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5tZWRpYVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29kZWMgPSBDb2RlYy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY29kZWMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcgbGF5ZXJzICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGF5ZXJzLnB1c2goVmlkZW9MYXllclNldHRpbmcuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9NZWRpYVJlcXVlc3QgbWVkaWFfcmVxdWVzdCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1lZGlhUmVxdWVzdClcbiAgICAgICAgICAgIFZpZGVvTWVkaWFSZXF1ZXN0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5tZWRpYVJlcXVlc3QsIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jb2RlYylcbiAgICAgICAgICAgIENvZGVjLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jb2RlYywgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nIGxheWVycyA9IDM7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5sYXllcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBWaWRlb0xheWVyU2V0dGluZy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UubGF5ZXJzW2ldLCB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvU2VuZGVyXG4gKi9cbmNvbnN0IFZpZGVvU2VuZGVyID0gbmV3IFZpZGVvU2VuZGVyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENoYW5nZVB1Ymxpc2hRdWFsaXR5JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNoYW5nZVB1Ymxpc2hRdWFsaXR5JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhdWRpb19zZW5kZXJzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBBdWRpb1NlbmRlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3ZpZGVvX3NlbmRlcnMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFZpZGVvU2VuZGVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuYXVkaW9TZW5kZXJzID0gW107XG4gICAgICAgIG1lc3NhZ2UudmlkZW9TZW5kZXJzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9TZW5kZXIgYXVkaW9fc2VuZGVycyAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF1ZGlvU2VuZGVycy5wdXNoKEF1ZGlvU2VuZGVyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9TZW5kZXIgdmlkZW9fc2VuZGVycyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZpZGVvU2VuZGVycy5wdXNoKFZpZGVvU2VuZGVyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvU2VuZGVyIGF1ZGlvX3NlbmRlcnMgPSAxOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuYXVkaW9TZW5kZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgQXVkaW9TZW5kZXIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmF1ZGlvU2VuZGVyc1tpXSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvU2VuZGVyIHZpZGVvX3NlbmRlcnMgPSAyOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UudmlkZW9TZW5kZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVmlkZW9TZW5kZXIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnZpZGVvU2VuZGVyc1tpXSwgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DaGFuZ2VQdWJsaXNoUXVhbGl0eVxuICovXG5jb25zdCBDaGFuZ2VQdWJsaXNoUXVhbGl0eSA9IG5ldyBDaGFuZ2VQdWJsaXNoUXVhbGl0eSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDYWxsR3JhbnRzVXBkYXRlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DYWxsR3JhbnRzVXBkYXRlZCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdjdXJyZW50X2dyYW50cycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gQ2FsbEdyYW50cyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ21lc3NhZ2UnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsR3JhbnRzIGN1cnJlbnRfZ3JhbnRzICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3VycmVudEdyYW50cyA9IENhbGxHcmFudHMuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmN1cnJlbnRHcmFudHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBtZXNzYWdlICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbEdyYW50cyBjdXJyZW50X2dyYW50cyA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmN1cnJlbnRHcmFudHMpXG4gICAgICAgICAgICBDYWxsR3JhbnRzLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jdXJyZW50R3JhbnRzLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmluZyBtZXNzYWdlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNhbGxHcmFudHNVcGRhdGVkXG4gKi9cbmNvbnN0IENhbGxHcmFudHNVcGRhdGVkID0gbmV3IENhbGxHcmFudHNVcGRhdGVkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEdvQXdheSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Hb0F3YXknLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3JlYXNvbicsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkdvQXdheVJlYXNvbicsXG4gICAgICAgICAgICAgICAgICAgIEdvQXdheVJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgJ0dPX0FXQVlfUkVBU09OXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnJlYXNvbiA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkdvQXdheVJlYXNvbiByZWFzb24gKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWFzb24gPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuR29Bd2F5UmVhc29uIHJlYXNvbiA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnJlYXNvbiAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnJlYXNvbik7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkdvQXdheVxuICovXG5jb25zdCBHb0F3YXkgPSBuZXcgR29Bd2F5JFR5cGUoKTtcblxudmFyIGV2ZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgQXVkaW9MZXZlbDogQXVkaW9MZXZlbCxcbiAgICBBdWRpb0xldmVsQ2hhbmdlZDogQXVkaW9MZXZlbENoYW5nZWQsXG4gICAgQXVkaW9NZWRpYVJlcXVlc3Q6IEF1ZGlvTWVkaWFSZXF1ZXN0LFxuICAgIEF1ZGlvU2VuZGVyOiBBdWRpb1NlbmRlcixcbiAgICBDYWxsR3JhbnRzVXBkYXRlZDogQ2FsbEdyYW50c1VwZGF0ZWQsXG4gICAgQ2hhbmdlUHVibGlzaFF1YWxpdHk6IENoYW5nZVB1Ymxpc2hRdWFsaXR5LFxuICAgIENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZDogQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLFxuICAgIENvbm5lY3Rpb25RdWFsaXR5SW5mbzogQ29ubmVjdGlvblF1YWxpdHlJbmZvLFxuICAgIERvbWluYW50U3BlYWtlckNoYW5nZWQ6IERvbWluYW50U3BlYWtlckNoYW5nZWQsXG4gICAgRXJyb3I6IEVycm9yJDEsXG4gICAgR29Bd2F5OiBHb0F3YXksXG4gICAgSGVhbHRoQ2hlY2tSZXF1ZXN0OiBIZWFsdGhDaGVja1JlcXVlc3QsXG4gICAgSGVhbHRoQ2hlY2tSZXNwb25zZTogSGVhbHRoQ2hlY2tSZXNwb25zZSxcbiAgICBJQ0VSZXN0YXJ0OiBJQ0VSZXN0YXJ0LFxuICAgIElDRVRyaWNrbGU6IElDRVRyaWNrbGUsXG4gICAgSm9pblJlcXVlc3Q6IEpvaW5SZXF1ZXN0LFxuICAgIEpvaW5SZXNwb25zZTogSm9pblJlc3BvbnNlLFxuICAgIE1pZ3JhdGlvbjogTWlncmF0aW9uLFxuICAgIFBhcnRpY2lwYW50Sm9pbmVkOiBQYXJ0aWNpcGFudEpvaW5lZCxcbiAgICBQYXJ0aWNpcGFudExlZnQ6IFBhcnRpY2lwYW50TGVmdCxcbiAgICBQaW5zQ2hhbmdlZDogUGluc0NoYW5nZWQsXG4gICAgUHVibGlzaGVyQW5zd2VyOiBQdWJsaXNoZXJBbnN3ZXIsXG4gICAgU2Z1RXZlbnQ6IFNmdUV2ZW50LFxuICAgIFNmdVJlcXVlc3Q6IFNmdVJlcXVlc3QsXG4gICAgU3Vic2NyaWJlck9mZmVyOiBTdWJzY3JpYmVyT2ZmZXIsXG4gICAgVHJhY2tQdWJsaXNoZWQ6IFRyYWNrUHVibGlzaGVkLFxuICAgIFRyYWNrVW5wdWJsaXNoZWQ6IFRyYWNrVW5wdWJsaXNoZWQsXG4gICAgVmlkZW9MYXllclNldHRpbmc6IFZpZGVvTGF5ZXJTZXR0aW5nLFxuICAgIGdldCBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSAoKSB7IHJldHVybiBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eTsgfSxcbiAgICBWaWRlb01lZGlhUmVxdWVzdDogVmlkZW9NZWRpYVJlcXVlc3QsXG4gICAgVmlkZW9TZW5kZXI6IFZpZGVvU2VuZGVyXG59KTtcblxudmFyIFZpc2liaWxpdHlTdGF0ZTtcbihmdW5jdGlvbiAoVmlzaWJpbGl0eVN0YXRlKSB7XG4gICAgVmlzaWJpbGl0eVN0YXRlW1wiVU5LTk9XTlwiXSA9IFwiVU5LTk9XTlwiO1xuICAgIFZpc2liaWxpdHlTdGF0ZVtcIlZJU0lCTEVcIl0gPSBcIlZJU0lCTEVcIjtcbiAgICBWaXNpYmlsaXR5U3RhdGVbXCJJTlZJU0lCTEVcIl0gPSBcIklOVklTSUJMRVwiO1xufSkoVmlzaWJpbGl0eVN0YXRlIHx8IChWaXNpYmlsaXR5U3RhdGUgPSB7fSkpO1xudmFyIERlYm91bmNlVHlwZTtcbihmdW5jdGlvbiAoRGVib3VuY2VUeXBlKSB7XG4gICAgRGVib3VuY2VUeXBlW0RlYm91bmNlVHlwZVtcIklNTUVESUFURVwiXSA9IDIwXSA9IFwiSU1NRURJQVRFXCI7XG4gICAgRGVib3VuY2VUeXBlW0RlYm91bmNlVHlwZVtcIkZBU1RcIl0gPSAxMDBdID0gXCJGQVNUXCI7XG4gICAgRGVib3VuY2VUeXBlW0RlYm91bmNlVHlwZVtcIk1FRElVTVwiXSA9IDYwMF0gPSBcIk1FRElVTVwiO1xuICAgIERlYm91bmNlVHlwZVtEZWJvdW5jZVR5cGVbXCJTTE9XXCJdID0gMTIwMF0gPSBcIlNMT1dcIjtcbn0pKERlYm91bmNlVHlwZSB8fCAoRGVib3VuY2VUeXBlID0ge30pKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgc2VydmljZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TaWduYWxTZXJ2ZXJcbiAqL1xuY2xhc3MgU2lnbmFsU2VydmVyQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihfdHJhbnNwb3J0KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IF90cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMudHlwZU5hbWUgPSBTaWduYWxTZXJ2ZXIudHlwZU5hbWU7XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IFNpZ25hbFNlcnZlci5tZXRob2RzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBTaWduYWxTZXJ2ZXIub3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0UHVibGlzaGVyIHNlbmRzIHRoZSBXZWJSVEMgb2ZmZXIgZm9yIHRoZSBwZWVyIGNvbm5lY3Rpb24gdXNlZCB0byBwdWJsaXNoIEEvVlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogU2V0UHVibGlzaGVyKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNldFB1Ymxpc2hlclJlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNldFB1Ymxpc2hlclJlc3BvbnNlKTtcbiAgICAgKi9cbiAgICBzZXRQdWJsaXNoZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzBdLCBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQoJ3VuYXJ5JywgdGhpcy5fdHJhbnNwb3J0LCBtZXRob2QsIG9wdCwgaW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhbnN3ZXIgaXMgc2VudCBieSB0aGUgY2xpZW50IHRvIHRoZSBTRlUgYWZ0ZXIgcmVjZWl2aW5nIGEgc3Vic2NyaWJlcl9vZmZlci5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFNlbmRBbnN3ZXIoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2VuZEFuc3dlclJlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXNwb25zZSk7XG4gICAgICovXG4gICAgc2VuZEFuc3dlcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbMV0sIG9wdCA9IHRoaXMuX3RyYW5zcG9ydC5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdGFja0ludGVyY2VwdCgndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRJQ0VDYW5kaWRhdGUgc2VuZHMgYW4gSUNFIGNhbmRpZGF0ZSB0byB0aGUgY2xpZW50XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgcnBjOiBJY2VUcmlja2xlKHN0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVRyaWNrbGVSZXNwb25zZSk7XG4gICAgICovXG4gICAgaWNlVHJpY2tsZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbMl0sIG9wdCA9IHRoaXMuX3RyYW5zcG9ydC5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdGFja0ludGVyY2VwdCgndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZVN1YnNjcmliZXJzIGlzIHVzZWQgdG8gbm90aWZ5IHRoZSBTRlUgYWJvdXQgdGhlIGxpc3Qgb2YgdmlkZW8gc3Vic2NyaXB0aW9uc1xuICAgICAqIFRPRE86IHN5bmMgc3Vic2NyaXB0aW9ucyBiYXNlZCBvbiB0aGlzICsgdXBkYXRlIHRyYWNrcyB1c2luZyB0aGUgZGltZW5zaW9uIGluZm8gc2VudCBieSB0aGUgdXNlclxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogVXBkYXRlU3Vic2NyaXB0aW9ucyhzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlKTtcbiAgICAgKi9cbiAgICB1cGRhdGVTdWJzY3JpcHRpb25zKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMubWV0aG9kc1szXSwgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHN0YWNrSW50ZXJjZXB0KCd1bmFyeScsIHRoaXMuX3RyYW5zcG9ydCwgbWV0aG9kLCBvcHQsIGlucHV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogVXBkYXRlTXV0ZVN0YXRlcyhzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlKTtcbiAgICAgKi9cbiAgICB1cGRhdGVNdXRlU3RhdGVzKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMubWV0aG9kc1s0XSwgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHN0YWNrSW50ZXJjZXB0KCd1bmFyeScsIHRoaXMuX3RyYW5zcG9ydCwgbWV0aG9kLCBvcHQsIGlucHV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogSWNlUmVzdGFydChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VSZXN0YXJ0UmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlc3BvbnNlKTtcbiAgICAgKi9cbiAgICBpY2VSZXN0YXJ0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMubWV0aG9kc1s1XSwgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHN0YWNrSW50ZXJjZXB0KCd1bmFyeScsIHRoaXMuX3RyYW5zcG9ydCwgbWV0aG9kLCBvcHQsIGlucHV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogU2VuZFN0YXRzKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRTdGF0c1Jlc3BvbnNlKTtcbiAgICAgKi9cbiAgICBzZW5kU3RhdHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzZdLCBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQoJ3VuYXJ5JywgdGhpcy5fdHJhbnNwb3J0LCBtZXRob2QsIG9wdCwgaW5wdXQpO1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgYmFzZVVybDogJycsXG4gICAgc2VuZEpzb246IHRydWUsXG4gICAgdGltZW91dDogNSAqIDEwMDAsIC8vIG1zLlxuICAgIGpzb25PcHRpb25zOiB7XG4gICAgICAgIGlnbm9yZVVua25vd25GaWVsZHM6IHRydWUsXG4gICAgfSxcbn07XG5jb25zdCB3aXRoSGVhZGVycyA9IChoZWFkZXJzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJjZXB0VW5hcnkobmV4dCwgbWV0aG9kLCBpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucy5tZXRhID0geyAuLi5vcHRpb25zLm1ldGEsIC4uLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KG1ldGhvZCwgaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBDcmVhdGVzIG5ldyBTaWduYWxTZXJ2ZXJDbGllbnQgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIHR3aXJwIG9wdGlvbnMuXG4gKi9cbmNvbnN0IGNyZWF0ZVNpZ25hbENsaWVudCA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFR3aXJwRmV0Y2hUcmFuc3BvcnQoe1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFNlcnZlckNsaWVudCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB3ZSBhcmUgdXNpbmcgUmVhY3QgTmF0aXZlXG4gKi9cbmNvbnN0IGlzUmVhY3ROYXRpdmUgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5wcm9kdWN0Py50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnO1xufTtcblxuLy8gbG9nIGxldmVscywgc29ydGVkIGJ5IHZlcmJvc2l0eVxuY29uc3QgbG9nTGV2ZWxzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgdHJhY2U6IDAsXG4gICAgZGVidWc6IDEsXG4gICAgaW5mbzogMixcbiAgICB3YXJuOiAzLFxuICAgIGVycm9yOiA0LFxufSk7XG5sZXQgbG9nZ2VyJDQ7XG5sZXQgbGV2ZWwgPSAnaW5mbyc7XG5jb25zdCBsb2dUb0NvbnNvbGUgPSAobG9nTGV2ZWwsIG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgbG9nTWV0aG9kO1xuICAgIHN3aXRjaCAobG9nTGV2ZWwpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgbG9nTWV0aG9kID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFdBUk46ICR7bWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIGxvZ01ldGhvZCA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ01ldGhvZCA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbmZvJzpcbiAgICAgICAgICAgIGxvZ01ldGhvZCA9IGNvbnNvbGUuaW5mbztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0cmFjZSc6XG4gICAgICAgICAgICBsb2dNZXRob2QgPSBjb25zb2xlLnRyYWNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2dNZXRob2QgPSBjb25zb2xlLmxvZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsb2dNZXRob2QobWVzc2FnZSwgLi4uYXJncyk7XG59O1xuY29uc3Qgc2V0TG9nZ2VyID0gKGwsIGx2bCkgPT4ge1xuICAgIGxvZ2dlciQ0ID0gbDtcbiAgICBpZiAobHZsKSB7XG4gICAgICAgIHNldExvZ0xldmVsKGx2bCk7XG4gICAgfVxufTtcbmNvbnN0IHNldExvZ0xldmVsID0gKGwpID0+IHtcbiAgICBsZXZlbCA9IGw7XG59O1xuY29uc3QgZ2V0TG9nZ2VyID0gKHdpdGhUYWdzKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyTWV0aG9kID0gbG9nZ2VyJDQgfHwgbG9nVG9Db25zb2xlO1xuICAgIGNvbnN0IHRhZ3MgPSAod2l0aFRhZ3MgfHwgW10pLmpvaW4oJzonKTtcbiAgICBjb25zdCByZXN1bHQgPSAobG9nTGV2ZWwsIG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGxvZ0xldmVsc1tsb2dMZXZlbF0gPj0gbG9nTGV2ZWxzW2xldmVsXSkge1xuICAgICAgICAgICAgbG9nZ2VyTWV0aG9kKGxvZ0xldmVsLCBgWyR7dGFnc31dOiAke21lc3NhZ2V9YCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBnZXRQcmVmZXJyZWRDb2RlY3MgPSAoa2luZCwgcHJlZmVycmVkQ29kZWMsIGNvZGVjVG9SZW1vdmUpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoWydjb2RlY3MnXSk7XG4gICAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xuICAgICAgICBsb2dnZXI/Lignd2FybicsICdSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYXAgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKGtpbmQpO1xuICAgIGlmICghY2FwKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWF0Y2hlZCA9IFtdO1xuICAgIGNvbnN0IHBhcnRpYWxNYXRjaGVkID0gW107XG4gICAgY29uc3QgdW5tYXRjaGVkID0gW107XG4gICAgY2FwLmNvZGVjcy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb2dnZXI/LignZGVidWcnLCBgRm91bmQgc3VwcG9ydGVkIGNvZGVjOiAke2NvZGVjfWApO1xuICAgICAgICBjb25zdCBzaG91bGRSZW1vdmVDb2RlYyA9IGNvZGVjVG9SZW1vdmUgJiYgY29kZWMgPT09IGAke2tpbmR9LyR7Y29kZWNUb1JlbW92ZS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVDb2RlYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWF0Y2hlc0NvZGVjID0gY29kZWMgPT09IGAke2tpbmR9LyR7cHJlZmVycmVkQ29kZWMudG9Mb3dlckNhc2UoKX1gO1xuICAgICAgICBpZiAoIW1hdGNoZXNDb2RlYykge1xuICAgICAgICAgICAgdW5tYXRjaGVkLnB1c2goYyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIGgyNjQgY29kZWNzIHRoYXQgaGF2ZSBzZHBGbXRwTGluZSBhdmFpbGFibGUsIHVzZSBvbmx5IGlmIHRoZVxuICAgICAgICAvLyBwcm9maWxlLWxldmVsLWlkIGlzIDQyZTAxZiBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gICAgICAgIGlmIChjb2RlYyA9PT0gJ2gyNjQnKSB7XG4gICAgICAgICAgICBpZiAoYy5zZHBGbXRwTGluZSAmJiBjLnNkcEZtdHBMaW5lLmluY2x1ZGVzKCdwcm9maWxlLWxldmVsLWlkPTQyZTAxZicpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbE1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVkLnB1c2goYyk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLm1hdGNoZWQsIC4uLnBhcnRpYWxNYXRjaGVkLCAuLi51bm1hdGNoZWRdO1xuICAgIGxvZ2dlcj8uKCdpbmZvJywgYFByZWZmZXJlZCBjb2RlY3M6IGAsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBnZXRHZW5lcmljU2RwID0gYXN5bmMgKGRpcmVjdGlvbikgPT4ge1xuICAgIGNvbnN0IHRlbXBQYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbigpO1xuICAgIHRlbXBQYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nLCB7IGRpcmVjdGlvbiB9KTtcbiAgICB0ZW1wUGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywgeyBkaXJlY3Rpb24gfSk7XG4gICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0ZW1wUGMuY3JlYXRlT2ZmZXIoKTtcbiAgICBsZXQgc2RwID0gb2ZmZXIuc2RwID8/ICcnO1xuICAgIHRlbXBQYy5nZXRUcmFuc2NlaXZlcnMoKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIHQuc3RvcCgpO1xuICAgIH0pO1xuICAgIHRlbXBQYy5jbG9zZSgpO1xuICAgIHJldHVybiBzZHA7XG59O1xuXG5jb25zdCBzZnVFdmVudEtpbmRzID0ge1xuICAgIHN1YnNjcmliZXJPZmZlcjogdW5kZWZpbmVkLFxuICAgIHB1Ymxpc2hlckFuc3dlcjogdW5kZWZpbmVkLFxuICAgIGNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZDogdW5kZWZpbmVkLFxuICAgIGF1ZGlvTGV2ZWxDaGFuZ2VkOiB1bmRlZmluZWQsXG4gICAgaWNlVHJpY2tsZTogdW5kZWZpbmVkLFxuICAgIGNoYW5nZVB1Ymxpc2hRdWFsaXR5OiB1bmRlZmluZWQsXG4gICAgcGFydGljaXBhbnRKb2luZWQ6IHVuZGVmaW5lZCxcbiAgICBwYXJ0aWNpcGFudExlZnQ6IHVuZGVmaW5lZCxcbiAgICBkb21pbmFudFNwZWFrZXJDaGFuZ2VkOiB1bmRlZmluZWQsXG4gICAgam9pblJlc3BvbnNlOiB1bmRlZmluZWQsXG4gICAgaGVhbHRoQ2hlY2tSZXNwb25zZTogdW5kZWZpbmVkLFxuICAgIHRyYWNrUHVibGlzaGVkOiB1bmRlZmluZWQsXG4gICAgdHJhY2tVbnB1Ymxpc2hlZDogdW5kZWZpbmVkLFxuICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgY2FsbEdyYW50c1VwZGF0ZWQ6IHVuZGVmaW5lZCxcbiAgICBnb0F3YXk6IHVuZGVmaW5lZCxcbiAgICBpY2VSZXN0YXJ0OiB1bmRlZmluZWQsXG4gICAgcGluc1VwZGF0ZWQ6IHVuZGVmaW5lZCxcbn07XG5jb25zdCBpc1NmdUV2ZW50ID0gKGV2ZW50TmFtZSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2Z1RXZlbnRLaW5kcywgZXZlbnROYW1lKTtcbn07XG5jbGFzcyBEaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydEaXNwYXRjaGVyJ10pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzID0ge307XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRLaW5kID0gbWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kO1xuICAgICAgICAgICAgaWYgKCFldmVudEtpbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2UuZXZlbnRQYXlsb2FkW2V2ZW50S2luZF07XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgRGlzcGF0Y2hpbmcgJHtldmVudEtpbmR9YCwgcGF5bG9hZCk7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLnN1YnNjcmliZXJzW2V2ZW50S2luZF07XG4gICAgICAgICAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsICdMaXN0ZW5lciBmYWlsZWQgd2l0aCBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbiA9IChldmVudE5hbWUsIGZuKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoKF9hID0gdGhpcy5zdWJzY3JpYmVycylbZXZlbnROYW1lXSA/PyAoX2FbZXZlbnROYW1lXSA9IFtdKSkucHVzaChmbik7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vZmYgPSAoZXZlbnROYW1lLCBmbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyc1tldmVudE5hbWVdID0gKHRoaXMuc3Vic2NyaWJlcnNbZXZlbnROYW1lXSB8fCBbXSkuZmlsdGVyKChmKSA9PiBmICE9PSBmbik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2ZmQWxsID0gKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGJ1ZmZlciBmb3IgSUNFIENhbmRpZGF0ZXMuIFVzZWQgZm9yIElDRSBUcmlja2xlOlxuICogLSBodHRwczovL2Jsb2dnZWVrLm1lL3dlYnJ0Y2dsb3NzYXJ5L3RyaWNrbGUtaWNlL1xuICovXG5jbGFzcyBJY2VUcmlja2xlQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyQ2FuZGlkYXRlcyA9IG5ldyBSZXBsYXlTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucHVibGlzaGVyQ2FuZGlkYXRlcyA9IG5ldyBSZXBsYXlTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnc2Z1LWNsaWVudCddKTtcbiAgICAgICAgdGhpcy5wdXNoID0gKGljZVRyaWNrbGUpID0+IHtcbiAgICAgICAgICAgIGlmIChpY2VUcmlja2xlLnBlZXJUeXBlID09PSBQZWVyVHlwZS5TVUJTQ1JJQkVSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyQ2FuZGlkYXRlcy5uZXh0KGljZVRyaWNrbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaWNlVHJpY2tsZS5wZWVyVHlwZSA9PT0gUGVlclR5cGUuUFVCTElTSEVSX1VOU1BFQ0lGSUVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXJDYW5kaWRhdGVzLm5leHQoaWNlVHJpY2tsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBJQ0VUcmlja2xlLCBVbmtub3duIHBlZXIgdHlwZWAsIGljZVRyaWNrbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkge1xuICAgIGlmICghY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQpIHtcbiAgICAgICAgLy8gcmVhY3QtbmF0aXZlLXdlYnJ0YyBkb2Vzbid0IGluY2x1ZGUgdXNlcm5hbWVGcmFnbWVudCBpbiB0aGUgY2FuZGlkYXRlXG4gICAgICAgIGNvbnN0IHNwbGl0dGVkQ2FuZGlkYXRlID0gY2FuZGlkYXRlLmNhbmRpZGF0ZS5zcGxpdCgnICcpO1xuICAgICAgICBjb25zdCB1ZnJhZ0luZGV4ID0gc3BsaXR0ZWRDYW5kaWRhdGUuZmluZEluZGV4KChzKSA9PiBzID09PSAndWZyYWcnKSArIDE7XG4gICAgICAgIGNvbnN0IHVzZXJuYW1lRnJhZ21lbnQgPSBzcGxpdHRlZENhbmRpZGF0ZVt1ZnJhZ0luZGV4XTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHsgLi4uY2FuZGlkYXRlLCB1c2VybmFtZUZyYWdtZW50IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNhbmRpZGF0ZS50b0pTT04oKSk7XG4gICAgfVxufVxuXG5sZXQgc2RrSW5mbztcbmxldCBvc0luZm87XG5sZXQgZGV2aWNlSW5mbztcbmxldCB3ZWJSdGNJbmZvO1xuY29uc3Qgc2V0U2RrSW5mbyA9IChpbmZvKSA9PiB7XG4gICAgc2RrSW5mbyA9IGluZm87XG59O1xuY29uc3QgZ2V0U2RrSW5mbyA9ICgpID0+IHtcbiAgICByZXR1cm4gc2RrSW5mbztcbn07XG5jb25zdCBzZXRPU0luZm8gPSAoaW5mbykgPT4ge1xuICAgIG9zSW5mbyA9IGluZm87XG59O1xuY29uc3QgZ2V0T1NJbmZvID0gKCkgPT4ge1xuICAgIHJldHVybiBvc0luZm87XG59O1xuY29uc3Qgc2V0RGV2aWNlSW5mbyA9IChpbmZvKSA9PiB7XG4gICAgZGV2aWNlSW5mbyA9IGluZm87XG59O1xuY29uc3QgZ2V0RGV2aWNlSW5mbyA9ICgpID0+IHtcbiAgICByZXR1cm4gZGV2aWNlSW5mbztcbn07XG5jb25zdCBnZXRXZWJSVENJbmZvID0gKCkgPT4ge1xuICAgIHJldHVybiB3ZWJSdGNJbmZvO1xufTtcbmNvbnN0IHNldFdlYlJUQ0luZm8gPSAoaW5mbykgPT4ge1xuICAgIHdlYlJ0Y0luZm8gPSBpbmZvO1xufTtcbmNvbnN0IGdldENsaWVudERldGFpbHMgPSAoKSA9PiB7XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAvLyBTaW5jZSBSTiBkb2Vzbid0IHN1cHBvcnQgd2ViLCBzaGFyaW5nIGJyb3dzZXIgaW5mbyBpcyBub3QgcmVxdWlyZWRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNkazogZ2V0U2RrSW5mbygpLFxuICAgICAgICAgICAgb3M6IGdldE9TSW5mbygpLFxuICAgICAgICAgICAgZGV2aWNlOiBnZXREZXZpY2VJbmZvKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5ldyBVQVBhcnNlcihuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBjb25zdCB7IGJyb3dzZXIsIG9zLCBkZXZpY2UsIGNwdSB9ID0gdXNlckFnZW50LmdldFJlc3VsdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNkazogZ2V0U2RrSW5mbygpLFxuICAgICAgICBicm93c2VyOiB7XG4gICAgICAgICAgICBuYW1lOiBicm93c2VyLm5hbWUgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHZlcnNpb246IGJyb3dzZXIudmVyc2lvbiB8fCAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgb3M6IHtcbiAgICAgICAgICAgIG5hbWU6IG9zLm5hbWUgfHwgJycsXG4gICAgICAgICAgICB2ZXJzaW9uOiBvcy52ZXJzaW9uIHx8ICcnLFxuICAgICAgICAgICAgYXJjaGl0ZWN0dXJlOiBjcHUuYXJjaGl0ZWN0dXJlIHx8ICcnLFxuICAgICAgICB9LFxuICAgICAgICBkZXZpY2U6IHtcbiAgICAgICAgICAgIG5hbWU6IFtkZXZpY2UudmVuZG9yLCBkZXZpY2UubW9kZWwsIGRldmljZS50eXBlXVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgICAgICAuam9pbignICcpLFxuICAgICAgICAgICAgdmVyc2lvbjogJycsXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IERFRkFVTFRfQklUUkFURSA9IDEyNTAwMDA7XG5jb25zdCBkZWZhdWx0VGFyZ2V0UmVzb2x1dGlvbiA9IHtcbiAgICBiaXRyYXRlOiBERUZBVUxUX0JJVFJBVEUsXG4gICAgd2lkdGg6IDEyODAsXG4gICAgaGVpZ2h0OiA3MjAsXG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBtb3N0IG9wdGltYWwgdmlkZW8gbGF5ZXJzIGZvciBzaW11bGNhc3RpbmdcbiAqIGZvciB0aGUgZ2l2ZW4gdHJhY2suXG4gKlxuICogQHBhcmFtIHZpZGVvVHJhY2sgdGhlIHZpZGVvIHRyYWNrIHRvIGZpbmQgb3B0aW1hbCBsYXllcnMgZm9yLlxuICogQHBhcmFtIHRhcmdldFJlc29sdXRpb24gdGhlIGV4cGVjdGVkIHRhcmdldCByZXNvbHV0aW9uLlxuICovXG5jb25zdCBmaW5kT3B0aW1hbFZpZGVvTGF5ZXJzID0gKHZpZGVvVHJhY2ssIHRhcmdldFJlc29sdXRpb24gPSBkZWZhdWx0VGFyZ2V0UmVzb2x1dGlvbikgPT4ge1xuICAgIGNvbnN0IG9wdGltYWxWaWRlb0xheWVycyA9IFtdO1xuICAgIGNvbnN0IHNldHRpbmdzID0gdmlkZW9UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IHsgd2lkdGg6IHcgPSAwLCBoZWlnaHQ6IGggPSAwIH0gPSBzZXR0aW5ncztcbiAgICBjb25zdCBpc1JOSW9zID0gaXNSZWFjdE5hdGl2ZSgpICYmIGdldE9TSW5mbygpPy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpb3MnO1xuICAgIGNvbnN0IG1heEJpdHJhdGUgPSBnZXRDb21wdXRlZE1heEJpdHJhdGUodGFyZ2V0UmVzb2x1dGlvbiwgdywgaCk7XG4gICAgbGV0IGRvd25zY2FsZUZhY3RvciA9IDE7XG4gICAgWydmJywgJ2gnLCAncSddLmZvckVhY2goKHJpZCkgPT4ge1xuICAgICAgICAvLyBSZXZlcnNpbmcgdGhlIG9yZGVyIFtmLCBoLCBxXSB0byBbcSwgaCwgZl0gYXMgQ2hyb21lIHVzZXMgZW5jb2RpbmcgaW5kZXhcbiAgICAgICAgLy8gd2hlbiBkZWNpZGluZyB3aGljaCBsYXllciB0byBkaXNhYmxlIHdoZW4gQ1BVIG9yIGJhbmR3aWR0aCBpcyBjb25zdHJhaW5lZC5cbiAgICAgICAgLy8gRW5jb2RpbmdzIHNob3VsZCBiZSBvcmRlcmVkIGluIGluY3JlYXNpbmcgc3BhdGlhbCByZXNvbHV0aW9uIG9yZGVyLlxuICAgICAgICBvcHRpbWFsVmlkZW9MYXllcnMudW5zaGlmdCh7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICByaWQsXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZCh3IC8gZG93bnNjYWxlRmFjdG9yKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChoIC8gZG93bnNjYWxlRmFjdG9yKSxcbiAgICAgICAgICAgIG1heEJpdHJhdGU6IE1hdGgucm91bmQobWF4Qml0cmF0ZSAvIGRvd25zY2FsZUZhY3RvciksXG4gICAgICAgICAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IGRvd25zY2FsZUZhY3RvcixcbiAgICAgICAgICAgIC8vIFNpbXVsY2FzdCBvbiBpT1MgUmVhY3QtTmF0aXZlIHJlcXVpcmVzIGFsbCBlbmNvZGluZ3MgdG8gc2hhcmUgdGhlIHNhbWUgZnJhbWVyYXRlXG4gICAgICAgICAgICBtYXhGcmFtZXJhdGU6IHtcbiAgICAgICAgICAgICAgICBmOiAzMCxcbiAgICAgICAgICAgICAgICBoOiBpc1JOSW9zID8gMzAgOiAyNSxcbiAgICAgICAgICAgICAgICBxOiBpc1JOSW9zID8gMzAgOiAyMCxcbiAgICAgICAgICAgIH1bcmlkXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRvd25zY2FsZUZhY3RvciAqPSAyO1xuICAgIH0pO1xuICAgIC8vIGZvciBzaW1wbGljaXR5LCB3ZSBzdGFydCB3aXRoIGFsbCBsYXllcnMgZW5hYmxlZCwgdGhlbiB0aGlzIGZ1bmN0aW9uXG4gICAgLy8gd2lsbCBjbGVhci9yZWFzc2lnbiB0aGUgbGF5ZXJzIHRoYXQgYXJlIG5vdCBuZWVkZWRcbiAgICByZXR1cm4gd2l0aFNpbXVsY2FzdENvbnN0cmFpbnRzKHNldHRpbmdzLCBvcHRpbWFsVmlkZW9MYXllcnMpO1xufTtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIG1heGltdW0gYml0cmF0ZSBmb3IgYSBnaXZlbiByZXNvbHV0aW9uLlxuICogSWYgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBpcyBsb3dlciB0aGFuIHRoZSB0YXJnZXQgcmVzb2x1dGlvbixcbiAqIHdlIHdhbnQgdG8gcHJvcG9ydGlvbmFsbHkgcmVkdWNlIHRoZSB0YXJnZXQgYml0cmF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHJlc29sdXRpb24gaXMgaGlnaGVyIHRoYW4gdGhlIHRhcmdldCByZXNvbHV0aW9uLFxuICogd2Ugd2FudCB0byB1c2UgdGhlIHRhcmdldCBiaXRyYXRlLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRSZXNvbHV0aW9uIHRoZSB0YXJnZXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSBjdXJyZW50V2lkdGggdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIHRyYWNrLlxuICogQHBhcmFtIGN1cnJlbnRIZWlnaHQgdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSB0cmFjay5cbiAqL1xuY29uc3QgZ2V0Q29tcHV0ZWRNYXhCaXRyYXRlID0gKHRhcmdldFJlc29sdXRpb24sIGN1cnJlbnRXaWR0aCwgY3VycmVudEhlaWdodCkgPT4ge1xuICAgIC8vIGlmIHRoZSBjdXJyZW50IHJlc29sdXRpb24gaXMgbG93ZXIgdGhhbiB0aGUgdGFyZ2V0IHJlc29sdXRpb24sXG4gICAgLy8gd2Ugd2FudCB0byBwcm9wb3J0aW9uYWxseSByZWR1Y2UgdGhlIHRhcmdldCBiaXRyYXRlXG4gICAgY29uc3QgeyB3aWR0aDogdGFyZ2V0V2lkdGgsIGhlaWdodDogdGFyZ2V0SGVpZ2h0IH0gPSB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIGlmIChjdXJyZW50V2lkdGggPCB0YXJnZXRXaWR0aCB8fCBjdXJyZW50SGVpZ2h0IDwgdGFyZ2V0SGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQaXhlbHMgPSBjdXJyZW50V2lkdGggKiBjdXJyZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCB0YXJnZXRQaXhlbHMgPSB0YXJnZXRXaWR0aCAqIHRhcmdldEhlaWdodDtcbiAgICAgICAgY29uc3QgcmVkdWN0aW9uRmFjdG9yID0gY3VycmVudFBpeGVscyAvIHRhcmdldFBpeGVscztcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGFyZ2V0UmVzb2x1dGlvbi5iaXRyYXRlICogcmVkdWN0aW9uRmFjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFJlc29sdXRpb24uYml0cmF0ZTtcbn07XG4vKipcbiAqIEJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IHNpbXVsY2FzdCBjb25zdHJhaW50cyBmb3IgZGlmZmVyZW50IHZpZGVvIHJlc29sdXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgdmlkZW8gbGF5ZXJzIGFjY29yZGluZyB0byB0aGVcbiAqIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2Ygc2ltdWxjYXN0IGNvbnN0cmFpbnRzIGluIHRoZSBDaHJvbWl1bSBiYXNlZCBicm93c2Vycy5cbiAqXG4gKiBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vZXh0ZXJuYWwvd2VicnRjLysvcmVmcy9oZWFkcy9tYWluL21lZGlhL2VuZ2luZS9zaW11bGNhc3QuY2MjOTBcbiAqL1xuY29uc3Qgd2l0aFNpbXVsY2FzdENvbnN0cmFpbnRzID0gKHNldHRpbmdzLCBvcHRpbWFsVmlkZW9MYXllcnMpID0+IHtcbiAgICBsZXQgbGF5ZXJzO1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heChzZXR0aW5ncy53aWR0aCB8fCAwLCBzZXR0aW5ncy5oZWlnaHQgfHwgMCk7XG4gICAgaWYgKHNpemUgPD0gMzIwKSB7XG4gICAgICAgIC8vIHByb3ZpZGUgb25seSBvbmUgbGF5ZXIgMzIweDI0MCAocSksIHRoZSBvbmUgd2l0aCB0aGUgaGlnaGVzdCBxdWFsaXR5XG4gICAgICAgIGxheWVycyA9IG9wdGltYWxWaWRlb0xheWVycy5maWx0ZXIoKGxheWVyKSA9PiBsYXllci5yaWQgPT09ICdmJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpemUgPD0gNjQwKSB7XG4gICAgICAgIC8vIHByb3ZpZGUgdHdvIGxheWVycywgMTYweDEyMCAocSkgYW5kIDY0MHg0ODAgKGgpXG4gICAgICAgIGxheWVycyA9IG9wdGltYWxWaWRlb0xheWVycy5maWx0ZXIoKGxheWVyKSA9PiBsYXllci5yaWQgIT09ICdoJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBwcm92aWRlIHRocmVlIGxheWVycyBmb3Igc2l6ZXMgPiA2NDB4NDgwXG4gICAgICAgIGxheWVycyA9IG9wdGltYWxWaWRlb0xheWVycztcbiAgICB9XG4gICAgY29uc3QgcmlkTWFwcGluZyA9IFsncScsICdoJywgJ2YnXTtcbiAgICByZXR1cm4gbGF5ZXJzLm1hcCgobGF5ZXIsIGluZGV4KSA9PiAoe1xuICAgICAgICAuLi5sYXllcixcbiAgICAgICAgcmlkOiByaWRNYXBwaW5nW2luZGV4XSwgLy8gcmVhc3NpZ24gcmlkXG4gICAgfSkpO1xufTtcbmNvbnN0IGZpbmRPcHRpbWFsU2NyZWVuU2hhcmluZ0xheWVycyA9ICh2aWRlb1RyYWNrLCBwcmVmZXJlbmNlcykgPT4ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gdmlkZW9UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHJpZDogJ3EnLCAvLyBzaW5nbGUgdHJhY2ssIHN0YXJ0IGZyb20gJ3EnXG4gICAgICAgICAgICB3aWR0aDogc2V0dGluZ3Mud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogc2V0dGluZ3MuaGVpZ2h0IHx8IDAsXG4gICAgICAgICAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IDEsXG4gICAgICAgICAgICBtYXhCaXRyYXRlOiBwcmVmZXJlbmNlcz8ubWF4Qml0cmF0ZSA/PyAzMDAwMDAwLFxuICAgICAgICAgICAgbWF4RnJhbWVyYXRlOiBwcmVmZXJlbmNlcz8ubWF4RnJhbWVyYXRlID8/IDMwLFxuICAgICAgICB9LFxuICAgIF07XG59O1xuXG5jb25zdCB0cmFja1R5cGVUb1BhcnRpY2lwYW50U3RyZWFtS2V5ID0gKHRyYWNrVHlwZSkgPT4ge1xuICAgIHN3aXRjaCAodHJhY2tUeXBlKSB7XG4gICAgICAgIGNhc2UgVHJhY2tUeXBlLlNDUkVFTl9TSEFSRTpcbiAgICAgICAgICAgIHJldHVybiAnc2NyZWVuU2hhcmVTdHJlYW0nO1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICAgICAgICByZXR1cm4gJ3NjcmVlblNoYXJlQXVkaW9TdHJlYW0nO1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5WSURFTzpcbiAgICAgICAgICAgIHJldHVybiAndmlkZW9TdHJlYW0nO1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5BVURJTzpcbiAgICAgICAgICAgIHJldHVybiAnYXVkaW9TdHJlYW0nO1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhY2sgdHlwZSBpcyB1bnNwZWNpZmllZCcpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZVRyYWNrVHlwZUNoZWNrID0gdHJhY2tUeXBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRyYWNrIHR5cGU6ICR7ZXhoYXVzdGl2ZVRyYWNrVHlwZUNoZWNrfWApO1xuICAgIH1cbn07XG5jb25zdCBtdXRlVHlwZVRvVHJhY2tUeXBlID0gKG11dGVUeXBlKSA9PiB7XG4gICAgc3dpdGNoIChtdXRlVHlwZSkge1xuICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkFVRElPO1xuICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xuICAgICAgICBjYXNlICdzY3JlZW5zaGFyZSc6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlNDUkVFTl9TSEFSRTtcbiAgICAgICAgY2FzZSAnc2NyZWVuc2hhcmVfYXVkaW8nOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlTXV0ZVR5cGVDaGVjayA9IG11dGVUeXBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG11dGUgdHlwZTogJHtleGhhdXN0aXZlTXV0ZVR5cGVDaGVja31gKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgdXBkYXRlIGlzIGEgZnVuY3Rpb24gcGF0Y2guXG4gKlxuICogQHBhcmFtIHVwZGF0ZSB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb25QYXRjaCA9ICh1cGRhdGUpID0+IHR5cGVvZiB1cGRhdGUgPT09ICdmdW5jdGlvbic7XG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICogbm90IGVtaXR0ZWQgYSB2YWx1ZSB5ZXQuXG4gKlxuICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAqL1xuY29uc3QgZ2V0Q3VycmVudFZhbHVlID0gKG9ic2VydmFibGUkKSA9PiB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBlcnIgPSB1bmRlZmluZWQ7XG4gICAgY29tYmluZUxhdGVzdChbb2JzZXJ2YWJsZSRdKVxuICAgICAgICAuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKFt2XSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKGUpID0+IHtcbiAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgIH0sXG4gICAgfSlcbiAgICAgICAgLnVuc3Vic2NyaWJlKCk7XG4gICAgaWYgKGVycilcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBTdWJqZWN0LlxuICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gKiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byB1cGRhdGUuXG4gKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gKiBAcmV0dXJuIHRoZSB1cGRhdGVkIHZhbHVlLlxuICovXG5jb25zdCBzZXRDdXJyZW50VmFsdWUgPSAoc3ViamVjdCwgdXBkYXRlKSA9PiB7XG4gICAgY29uc3QgbmV4dCA9IGlzRnVuY3Rpb25QYXRjaCh1cGRhdGUpXG4gICAgICAgID8gdXBkYXRlKGdldEN1cnJlbnRWYWx1ZShzdWJqZWN0KSlcbiAgICAgICAgOiB1cGRhdGU7XG4gICAgc3ViamVjdC5uZXh0KG5leHQpO1xuICAgIHJldHVybiBuZXh0O1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIHN1YnNjcmlwdGlvbiBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlLlxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlIHRoZSBvYnNlcnZhYmxlIHRvIHN1YnNjcmliZSB0by5cbiAqIEBwYXJhbSBoYW5kbGVyIHRoZSBoYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICovXG5jb25zdCBjcmVhdGVTdWJzY3JpcHRpb24gPSAob2JzZXJ2YWJsZSwgaGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG59O1xuXG52YXIgcnhVdGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY3JlYXRlU3Vic2NyaXB0aW9uOiBjcmVhdGVTdWJzY3JpcHRpb24sXG4gICAgZ2V0Q3VycmVudFZhbHVlOiBnZXRDdXJyZW50VmFsdWUsXG4gICAgc2V0Q3VycmVudFZhbHVlOiBzZXRDdXJyZW50VmFsdWVcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29tYmluZWQge0BsaW5rIENvbXBhcmF0b3I8VD59IHdoaWNoIHNvcnRzIGl0ZW1zIGJ5IHRoZSBnaXZlbiBjb21wYXJhdG9ycy5cbiAqIFRoZSBjb21wYXJhdG9ycyBhcmUgYXBwbGllZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZ2l2ZW4gKGxlZnQgLT4gcmlnaHQpLlxuICpcbiAqIEBwYXJhbSBjb21wYXJhdG9ycyB0aGUgY29tcGFyYXRvcnMgdG8gdXNlIGZvciBzb3J0aW5nLlxuICogQHJldHVybnMgYSBjb21iaW5lZCB7QGxpbmsgQ29tcGFyYXRvcjxUPn0uXG4gKi9cbmNvbnN0IGNvbWJpbmVDb21wYXJhdG9ycyA9ICguLi5jb21wYXJhdG9ycykgPT4ge1xuICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbXBhcmF0b3Igb2YgY29tcGFyYXRvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmF0b3IoYSwgYik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29tcGFyYXRvciB3aGljaCBzb3J0cyBpdGVtcyBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBieVZhbHVlID0gKGEsIGIpID0+IGEgPCBiID8gLSAxIDogYSA+IGIgPyAxIDogMDtcbiAqIGNvbnN0IGJ5VmFsdWVEZXNjID0gZGVzY2VuZGluZyhieVZhbHVlKTtcbiAqXG4gKiBAcGFyYW0gY29tcGFyYXRvciB0aGUgY29tcGFyYXRvciB0byB3cmFwLlxuICovXG5jb25zdCBkZXNjZW5kaW5nID0gKGNvbXBhcmF0b3IpID0+IHtcbiAgICByZXR1cm4gKGEsIGIpID0+IGNvbXBhcmF0b3IoYiwgYSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbXBhcmF0b3Igd2hpY2ggY29uZGl0aW9uYWxseSBhcHBsaWVzIHRoZSBnaXZlbiBjb21wYXJhdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzaG91bGRTb3J0QnlWYWx1ZSA9IChhLCBiKSA9PiBhICUgMiA9PT0gMDsgLy8gcmV0dXJuIGZhbHNlIHRvIHR1cm4gaXQgb2ZmXG4gKiBjb25zdCBieVZhbHVlID0gKGEsIGIpID0+IGEgPCBiID8gLSAxIDogYSA+IGIgPyAxIDogMDtcbiAqIGNvbnN0IGNvbXBhcmF0b3IgPSBjb25kaXRpb25hbChzaG91bGRTb3J0QnlWYWx1ZSkoYnlWYWx1ZSk7XG4gKlxuICogQHBhcmFtIHByZWRpY2F0ZSB0aGUgcHJlZGljYXRlIHRvIHVzZSBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0byBhcHBseSB0aGUgY29tcGFyYXRvci5cbiAqL1xuY29uc3QgY29uZGl0aW9uYWwgPSAocHJlZGljYXRlKSA9PiB7XG4gICAgcmV0dXJuIChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGUoYSwgYikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiKTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbi8qKlxuICogQSBuby1vcCBjb21wYXJhdG9yIHdoaWNoIGFsd2F5cyByZXR1cm5zIDAuXG4gKi9cbmNvbnN0IG5vb3BDb21wYXJhdG9yID0gKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiAwO1xufTtcblxuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgdGhlIGRvbWluYW50IHNwZWFrZXIgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmNvbnN0IGRvbWluYW50U3BlYWtlciA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEuaXNEb21pbmFudFNwZWFrZXIgJiYgIWIuaXNEb21pbmFudFNwZWFrZXIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWEuaXNEb21pbmFudFNwZWFrZXIgJiYgYi5pc0RvbWluYW50U3BlYWtlcilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgc3BlYWtpbmcgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmNvbnN0IHNwZWFraW5nID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5pc1NwZWFraW5nICYmICFiLmlzU3BlYWtpbmcpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWEuaXNTcGVha2luZyAmJiBiLmlzU3BlYWtpbmcpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSBzY3JlZW4gc2hhcmluZyBzdGF0dXMuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuY29uc3Qgc2NyZWVuU2hhcmluZyA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGhhc1NjcmVlblNoYXJlKGEpICYmICFoYXNTY3JlZW5TaGFyZShiKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmICghaGFzU2NyZWVuU2hhcmUoYSkgJiYgaGFzU2NyZWVuU2hhcmUoYikpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSB2aWRlbyBzdGF0dXMuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuY29uc3QgcHVibGlzaGluZ1ZpZGVvID0gKGEsIGIpID0+IHtcbiAgICBpZiAoaGFzVmlkZW8oYSkgJiYgIWhhc1ZpZGVvKGIpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKCFoYXNWaWRlbyhhKSAmJiBoYXNWaWRlbyhiKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IGF1ZGlvIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3QgcGFydGljaXBhbnQuXG4gKiBAcGFyYW0gYiB0aGUgc2Vjb25kIHBhcnRpY2lwYW50LlxuICovXG5jb25zdCBwdWJsaXNoaW5nQXVkaW8gPSAoYSwgYikgPT4ge1xuICAgIGlmIChoYXNBdWRpbyhhKSAmJiAhaGFzQXVkaW8oYikpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWhhc0F1ZGlvKGEpICYmIGhhc0F1ZGlvKGIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn07XG4vKipcbiAqIEEgY29tcGFyYXRvciB3aGljaCBwcmlvcml0aXplcyBwYXJ0aWNpcGFudHMgd2hvIGFyZSBwaW5uZWQuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuY29uc3QgcGlubmVkID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5waW4gJiYgYi5waW4pIHtcbiAgICAgICAgaWYgKCFhLnBpbi5pc0xvY2FsUGluICYmIGIucGluLmlzTG9jYWxQaW4pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhLnBpbi5pc0xvY2FsUGluICYmICFiLnBpbi5pc0xvY2FsUGluKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhLnBpbi5waW5uZWRBdCA+IGIucGluLnBpbm5lZEF0KVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS5waW4ucGlubmVkQXQgPCBiLnBpbi5waW5uZWRBdClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYS5waW4gJiYgIWIucGluKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKCFhLnBpbiAmJiBiLnBpbilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3IgY3JlYXRvciB3aGljaCB3aWxsIHNldCB1cCBhIGNvbXBhcmF0b3Igd2hpY2ggcHJpb3JpdGl6ZXNcbiAqIHBhcnRpY2lwYW50cyB3aG8gaGF2ZSBhIHNwZWNpZmljIHJlYWN0aW9uLlxuICpcbiAqIEBwYXJhbSB0eXBlIHRoZSByZWFjdGlvbiB0eXBlLlxuICovXG5jb25zdCByZWFjdGlvblR5cGUgPSAodHlwZSkgPT4ge1xuICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS5yZWFjdGlvbj8udHlwZSA9PT0gdHlwZSAmJiBiLnJlYWN0aW9uPy50eXBlICE9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS5yZWFjdGlvbj8udHlwZSAhPT0gdHlwZSAmJiBiLnJlYWN0aW9uPy50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3IgY3JlYXRvciB3aGljaCB3aWxsIHNldCB1cCBhIGNvbXBhcmF0b3Igd2hpY2ggcHJpb3JpdGl6ZXNcbiAqIHBhcnRpY2lwYW50cyB3aG8gaGF2ZSBhIHNwZWNpZmljIHJvbGUuXG4gKlxuICogQHBhcmFtIHJvbGVzIHRoZSByb2xlcyB0byBwcmlvcml0aXplLlxuICovXG5jb25zdCByb2xlID0gKC4uLnJvbGVzKSA9PiAoYSwgYikgPT4ge1xuICAgIGlmIChoYXNBbnlSb2xlKGEsIHJvbGVzKSAmJiAhaGFzQW55Um9sZShiLCByb2xlcykpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWhhc0FueVJvbGUoYSwgcm9sZXMpICYmIGhhc0FueVJvbGUoYiwgcm9sZXMpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn07XG4vKipcbiAqIEEgY29tcGFyYXRvciB3aGljaCBzb3J0cyBwYXJ0aWNpcGFudHMgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3QgcGFydGljaXBhbnQuXG4gKiBAcGFyYW0gYiB0aGUgc2Vjb25kIHBhcnRpY2lwYW50LlxuICovXG5jb25zdCBuYW1lID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5uYW1lIDwgYi5uYW1lKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGEubmFtZSA+IGIubmFtZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3QgaGFzQW55Um9sZSA9IChwLCByb2xlcykgPT4gKHAucm9sZXMgfHwgW10pLnNvbWUoKHIpID0+IHJvbGVzLmluY2x1ZGVzKHIpKTtcbmNvbnN0IGhhc1NjcmVlblNoYXJlID0gKHApID0+IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpO1xuY29uc3QgaGFzVmlkZW8gPSAocCkgPT4gcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlZJREVPKTtcbmNvbnN0IGhhc0F1ZGlvID0gKHApID0+IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5BVURJTyk7XG5cbi8vIGEgY29tcGFyYXRvciBkZWNvcmF0b3Igd2hpY2ggYXBwbGllcyB0aGUgZGVjb3JhdGVkIGNvbXBhcmF0b3Igb25seSBpZiB0aGVcbi8vIHBhcnRpY2lwYW50IGlzIGludmlzaWJsZS5cbi8vIFRoaXMgZW5zdXJlcyBzdGFibGUgc29ydGluZyB3aGVuIGFsbCBwYXJ0aWNpcGFudHMgYXJlIHZpc2libGUuXG5jb25zdCBpZkludmlzaWJsZUJ5ID0gY29uZGl0aW9uYWwoKGEsIGIpID0+IGEudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUgfHxcbiAgICBiLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFKTtcbi8qKlxuICogQSBjb21wYXJhdG9yIHRoYXQgYXBwbGllcyB0aGUgZGVjb3JhdGVkIGNvbXBhcmF0b3Igd2hlbiBhIHBhcnRpY2lwYW50IGlzXG4gKiBlaXRoZXIgaW52aXNpYmxlIG9yIGl0cyB2aXNpYmlsaXR5IHN0YXRlIGlzbid0IGtub3duLlxuICogRm9yIHZpc2libGUgcGFydGljaXBhbnRzLCBpdCBlbnN1cmVzIHN0YWJsZSBzb3J0aW5nLlxuICovXG5jb25zdCBpZkludmlzaWJsZU9yVW5rbm93bkJ5ID0gY29uZGl0aW9uYWwoKGEsIGIpID0+IGEudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUgfHxcbiAgICBhLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTiB8fFxuICAgIGIudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUgfHxcbiAgICBiLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHNvcnRpbmcgcHJlc2V0LlxuICovXG5jb25zdCBkZWZhdWx0U29ydFByZXNldCA9IGNvbWJpbmVDb21wYXJhdG9ycyhwaW5uZWQsIHNjcmVlblNoYXJpbmcsIGlmSW52aXNpYmxlQnkoY29tYmluZUNvbXBhcmF0b3JzKGRvbWluYW50U3BlYWtlciwgc3BlYWtpbmcsIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSwgcHVibGlzaGluZ1ZpZGVvLCBwdWJsaXNoaW5nQXVkaW8pKSk7XG4vKipcbiAqIFRoZSBzb3J0aW5nIHByZXNldCBmb3Igc3BlYWtlciBsYXlvdXQuXG4gKi9cbmNvbnN0IHNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0ID0gY29tYmluZUNvbXBhcmF0b3JzKHBpbm5lZCwgc2NyZWVuU2hhcmluZywgZG9taW5hbnRTcGVha2VyLCBpZkludmlzaWJsZUJ5KGNvbWJpbmVDb21wYXJhdG9ycyhzcGVha2luZywgcmVhY3Rpb25UeXBlKCdyYWlzZWQtaGFuZCcpLCBwdWJsaXNoaW5nVmlkZW8sIHB1Ymxpc2hpbmdBdWRpbykpKTtcbi8qKlxuICogVGhlIHNvcnRpbmcgcHJlc2V0IGZvciBsYXlvdXRzIHRoYXQgZG9uJ3QgcmVuZGVyIGFsbCBwYXJ0aWNpcGFudHMgYnV0XG4gKiBpbnN0ZWFkLCByZW5kZXIgdGhlbSBpbiBwYWdlcy5cbiAqL1xuY29uc3QgcGFnaW5hdGVkTGF5b3V0U29ydFByZXNldCA9IGNvbWJpbmVDb21wYXJhdG9ycyhwaW5uZWQsIGlmSW52aXNpYmxlT3JVbmtub3duQnkoY29tYmluZUNvbXBhcmF0b3JzKGRvbWluYW50U3BlYWtlciwgc3BlYWtpbmcsIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSwgcHVibGlzaGluZ1ZpZGVvLCBwdWJsaXNoaW5nQXVkaW8pKSk7XG4vKipcbiAqIFRoZSBzb3J0aW5nIHByZXNldCBmb3IgbGl2ZXN0cmVhbXMgYW5kIGF1ZGlvIHJvb21zLlxuICovXG5jb25zdCBsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0ID0gY29tYmluZUNvbXBhcmF0b3JzKGlmSW52aXNpYmxlQnkoY29tYmluZUNvbXBhcmF0b3JzKGRvbWluYW50U3BlYWtlciwgc3BlYWtpbmcsIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSwgcHVibGlzaGluZ1ZpZGVvLCBwdWJsaXNoaW5nQXVkaW8pKSwgcm9sZSgnYWRtaW4nLCAnaG9zdCcsICdzcGVha2VyJykpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKi9cbnZhciBDYWxsaW5nU3RhdGU7XG4oZnVuY3Rpb24gKENhbGxpbmdTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGlzIGluIGFuIHVua25vd24gc3RhdGUuXG4gICAgICovXG4gICAgQ2FsbGluZ1N0YXRlW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGlzIGluIGFuIGlkbGUgc3RhdGUuXG4gICAgICovXG4gICAgQ2FsbGluZ1N0YXRlW1wiSURMRVwiXSA9IFwiaWRsZVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGlzIGluIHRoZSBwcm9jZXNzIG9mIHJpbmdpbmcuXG4gICAgICogKFVzZXIgaGFzbid0IGFjY2VwdGVkIG5vciByZWplY3RlZCB0aGUgY2FsbCB5ZXQuKVxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIlJJTkdJTkdcIl0gPSBcInJpbmdpbmdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBpbiB0aGUgcHJvY2VzcyBvZiBqb2luaW5nLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIkpPSU5JTkdcIl0gPSBcImpvaW5pbmdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIkpPSU5FRFwiXSA9IFwiam9pbmVkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaGFzIGJlZW4gbGVmdC5cbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJMRUZUXCJdID0gXCJsZWZ0XCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgcmVjb25uZWN0aW5nLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIlJFQ09OTkVDVElOR1wiXSA9IFwicmVjb25uZWN0aW5nXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgbWlncmF0aW5nIGZyb20gb25lIG5vZGUgdG8gYW5vdGhlci5cbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJNSUdSQVRJTkdcIl0gPSBcIm1pZ3JhdGluZ1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGhhcyBmYWlsZWQgdG8gcmVjb25uZWN0LlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIlJFQ09OTkVDVElOR19GQUlMRURcIl0gPSBcInJlY29ubmVjdGluZy1mYWlsZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBpbiBvZmZsaW5lIG1vZGUuXG4gICAgICovXG4gICAgQ2FsbGluZ1N0YXRlW1wiT0ZGTElORVwiXSA9IFwib2ZmbGluZVwiO1xufSkoQ2FsbGluZ1N0YXRlIHx8IChDYWxsaW5nU3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGVncmVzcyBvYmplY3QgLSB3aGVuIG5vIGVncmVzcyBkYXRhIGlzIGF2YWlsYWJsZS5cbiAqL1xuY29uc3QgZGVmYXVsdEVncmVzcyA9IHtcbiAgICBicm9hZGNhc3Rpbmc6IGZhbHNlLFxuICAgIGhsczogeyBwbGF5bGlzdF91cmw6ICcnIH0sXG4gICAgcnRtcHM6IFtdLFxufTtcbi8qKlxuICogSG9sZHMgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKiBAcmVhY3QgWW91IGRvbid0IGhhdmUgdG8gdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIGFzIHdlIGFyZSBleHBvc2luZyB0aGUgc3RhdGUgdGhyb3VnaCBIb29rcy5cbiAqL1xuY2xhc3MgQ2FsbFN0YXRlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBDYWxsU3RhdGUgY2xhc3MuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iYWNrc3RhZ2VTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0cnVlKTtcbiAgICAgICAgdGhpcy5ibG9ja2VkVXNlcklkc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICAgICAgdGhpcy5jcmVhdGVkQXRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChuZXcgRGF0ZSgpKTtcbiAgICAgICAgdGhpcy5lbmRlZEF0U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5zdGFydHNBdFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMudXBkYXRlZEF0U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QobmV3IERhdGUoKSk7XG4gICAgICAgIHRoaXMuY3JlYXRlZEJ5U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5jdXN0b21TdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh7fSk7XG4gICAgICAgIHRoaXMuZWdyZXNzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5pbmdyZXNzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmdTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnRyYW5zY3JpYmluZ1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5lbmRlZEJ5U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy50aHVtYm5haWxzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5tZW1iZXJzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICB0aGlzLm93bkNhcGFiaWxpdGllc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICAgICAgdGhpcy5jYWxsaW5nU3RhdGVTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChDYWxsaW5nU3RhdGUuVU5LTk9XTik7XG4gICAgICAgIHRoaXMuc3RhcnRlZEF0U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNpcGFudENvdW50U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoMCk7XG4gICAgICAgIHRoaXMuYW5vbnltb3VzUGFydGljaXBhbnRDb3VudFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KDApO1xuICAgICAgICB0aGlzLnBhcnRpY2lwYW50c1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICAgICAgdGhpcy5jYWxsU3RhdHNSZXBvcnRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGNvbXBhcmF0b3JzIHRoYXQgYXJlIHVzZWQgdG8gc29ydCB0aGUgcGFydGljaXBhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0UGFydGljaXBhbnRzQnkgPSBkZWZhdWx0U29ydFByZXNldDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGxpc3Qgb2YgY3JpdGVyaWEgdGhhdCBhcmUgdXNlZCB0byBzb3J0IHRoZSBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqIFRvIGRpc2FibGUgc29ydGluZywgeW91IGNhbiBwYXNzIGBub29wQ29tcGFyYXRvcigpYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvbXBhcmF0b3IgdGhlIGNvbXBhcmF0b3IgdG8gdXNlIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U29ydFBhcnRpY2lwYW50c0J5ID0gKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ydFBhcnRpY2lwYW50c0J5ID0gY29tcGFyYXRvcjtcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgcmUtc29ydGluZyBvZiBwYXJ0aWNpcGFudHNcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRzU3ViamVjdCwgKHBzKSA9PiBwcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGFuIG9ic2VydmFibGUsIG9yIHVuZGVmaW5lZCBpZiB0aGUgb2JzZXJ2YWJsZSBoYXNcbiAgICAgICAgICogbm90IGVtaXR0ZWQgYSB2YWx1ZSB5ZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYnNlcnZhYmxlJCB0aGUgb2JzZXJ2YWJsZSB0byBnZXQgdGhlIHZhbHVlIGZyb20uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRWYWx1ZSA9IGdldEN1cnJlbnRWYWx1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBTdWJqZWN0LlxuICAgICAgICAgKiBBbiBgdXBkYXRlYCBjYW4gZWl0aGVyIGJlIGEgbmV3IHZhbHVlIG9yIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXNcbiAgICAgICAgICogdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byB1cGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB1cGRhdGUgdGhlIHVwZGF0ZSB0byBhcHBseSB0byB0aGUgc3ViamVjdC5cbiAgICAgICAgICogQHJldHVybiB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlID0gc2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcGFydGljaXBhbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENvdW50ID0gKGNvdW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5wYXJ0aWNpcGFudENvdW50U3ViamVjdCwgY291bnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdGltZSB0aGUgY2FsbCBzZXNzaW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRlZEF0IHRoZSB0aW1lIHRoZSBjYWxsIHNlc3Npb24gYWN0dWFsbHkgc3RhcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U3RhcnRlZEF0ID0gKHN0YXJ0ZWRBdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhcnRlZEF0U3ViamVjdCwgc3RhcnRlZEF0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50ID0gKGNvdW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5hbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50U3ViamVjdCwgY291bnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbGlzdCBvZiBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJ0aWNpcGFudHMgdGhlIGxpc3Qgb2YgcGFydGljaXBhbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudHMgPSAocGFydGljaXBhbnRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5wYXJ0aWNpcGFudHNTdWJqZWN0LCBwYXJ0aWNpcGFudHMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgY2FsbGluZyBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgbmV3IGNhbGxpbmcgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENhbGxpbmdTdGF0ZSA9IChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbGluZ1N0YXRlU3ViamVjdCwgc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgY2FsbCBzdGF0cyByZXBvcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gcmVwb3J0IHRoZSByZXBvcnQgdG8gc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDYWxsU3RhdHNSZXBvcnQgPSAocmVwb3J0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jYWxsU3RhdHNSZXBvcnRTdWJqZWN0LCByZXBvcnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbWVtYmVycyBvZiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIG1lbWJlcnMgdGhlIG1lbWJlcnMgdG8gc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRNZW1iZXJzID0gKG1lbWJlcnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMubWVtYmVyc1N1YmplY3QsIG1lbWJlcnMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3duIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSBjYXBhYmlsaXRpZXMgdGhlIGNhcGFiaWxpdGllcyB0byBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldE93bkNhcGFiaWxpdGllcyA9IChjYXBhYmlsaXRpZXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm93bkNhcGFiaWxpdGllc1N1YmplY3QsIGNhcGFiaWxpdGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIHRyeSB0byBmaW5kIHRoZSBwYXJ0aWNpcGFudCB3aXRoIHRoZSBnaXZlbiBzZXNzaW9uSWQgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbklkIG9mIHRoZSBwYXJ0aWNpcGFudCB0byBmaW5kLlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgcGFydGljaXBhbnQgd2l0aCB0aGUgZ2l2ZW4gc2Vzc2lvbklkIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbmRQYXJ0aWNpcGFudEJ5U2Vzc2lvbklkID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydGljaXBhbnRzLmZpbmQoKHApID0+IHAuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBsb29rdXAgdGFibGUgb2YgcGFydGljaXBhbnRzIGluZGV4ZWQgYnkgdGhlaXIgc2Vzc2lvbiBJRC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGFydGljaXBhbnRMb29rdXBCeVNlc3Npb25JZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5yZWR1Y2UoKGxvb2t1cFRhYmxlLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlW3BhcnRpY2lwYW50LnNlc3Npb25JZF0gPSBwYXJ0aWNpcGFudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9va3VwVGFibGU7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGEgcGFydGljaXBhbnQgaW4gdGhlIGN1cnJlbnQgY2FsbCBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBgc2Vzc2lvbklkYC5cbiAgICAgICAgICogSWYgdGhlIHBhcnRpY2lwYW50IGNhbid0IGJlIGZvdW5kLCB0aGlzIG9wZXJhdGlvbiBpcyBuby1vcC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gSUQgb2YgdGhlIHBhcnRpY2lwYW50IHRvIHVwZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHBhdGNoIHRoZSBwYXRjaCB0byBhcHBseSB0byB0aGUgcGFydGljaXBhbnQuXG4gICAgICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIHBhcnRpY2lwYW50IG9yIGB1bmRlZmluZWRgIGlmIHRoZSBwYXJ0aWNpcGFudCBjb3VsZG4ndCBiZSBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlUGFydGljaXBhbnQgPSAoc2Vzc2lvbklkLCBwYXRjaCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmZpbmRQYXJ0aWNpcGFudEJ5U2Vzc2lvbklkKHNlc3Npb25JZCk7XG4gICAgICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgUGFydGljaXBhbnQgd2l0aCBzZXNzaW9uSWQgJHtzZXNzaW9uSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRoZVBhdGNoID0gdHlwZW9mIHBhdGNoID09PSAnZnVuY3Rpb24nID8gcGF0Y2gocGFydGljaXBhbnQpIDogcGF0Y2g7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUGFydGljaXBhbnQgPSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgT0w6IHRoaXMgaXMgbm90IGEgZGVlcCBtZXJnZSwgd2UgbWlnaHQgd2FudCB0byByZXZpc2l0IHRoaXNcbiAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICAuLi50aGVQYXRjaCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLm1hcCgocCkgPT4gcC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCA/IHVwZGF0ZWRQYXJ0aWNpcGFudCA6IHApKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYSBwYXJ0aWNpcGFudCBpbiB0aGUgY3VycmVudCBjYWxsIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIGBzZXNzaW9uSWRgLlxuICAgICAgICAgKiBJZiBhIHBhcnRpY2lwYW50IHdpdGggbWF0Y2hpbmcgYHNlc3Npb25JZGAgY2FuJ3QgYmUgZm91bmQsIHRoZSBwcm92aWRlZFxuICAgICAgICAgKiBgcGFydGljaXBhbnRgIGlzIGFkZGVkIHRvIHRoZSBsaXN0IG9mIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBJRCBvZiB0aGUgcGFydGljaXBhbnQgdG8gdXBkYXRlLlxuICAgICAgICAgKiBAcGFyYW0gcGFydGljaXBhbnQgdGhlIHBhcnRpY2lwYW50IHRvIHVwZGF0ZSBvciBhZGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZU9yQWRkUGFydGljaXBhbnQgPSAoc2Vzc2lvbklkLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbmRQYXJ0aWNpcGFudEJ5U2Vzc2lvbklkKHNlc3Npb25JZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gW1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudHMsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsIHdob3NlIHNlc3Npb24gSUQgaXMgaW4gdGhlIGdpdmVuIGBzZXNzaW9uSWRzYC5cbiAgICAgICAgICogSWYgbm8gcGF0Y2hlcyBhcmUgcHJvdmlkZWQsIHRoaXMgb3BlcmF0aW9uIGlzIG5vLW9wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhdGNoIHRoZSBwYXRjaCB0byBhcHBseSB0byB0aGUgcGFydGljaXBhbnRzLlxuICAgICAgICAgKiBAcmV0dXJucyBhbGwgcGFydGljaXBhbnRzLCB3aXRoIGFsbCBwYXRjaCBhcHBsaWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVQYXJ0aWNpcGFudHMgPSAocGF0Y2gpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXRjaCkubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhlUGF0Y2ggPSBwYXRjaFtwLnNlc3Npb25JZF07XG4gICAgICAgICAgICAgICAgaWYgKHRoZVBhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhlUGF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgY2FsbCBzdGF0ZSB3aXRoIHRoZSBkYXRhIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudCB0aGUgdmlkZW8gZXZlbnQgdGhhdCBvdXIgYmFja2VuZCBzZW50IHVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVGcm9tRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcGFydGljaXBhbnQgcGlubmVkIHN0YXRlIHdpdGggc2VydmVyIHNpZGUgcGlubmluZyBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGlucyB0aGUgbGF0ZXN0IHBpbnMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRTZXJ2ZXJTaWRlUGlucyA9IChwaW5zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwaW5zTG9va3VwID0gcGlucy5yZWR1Y2UoKGxvb2t1cCwgcGluKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9va3VwW3Bpbi5zZXNzaW9uSWRdID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5tYXAoKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU2lkZVBpbm5lZEF0ID0gcGluc0xvb2t1cFtwYXJ0aWNpcGFudC5zZXNzaW9uSWRdO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJ0aWNpcGFudCBpcyBuZXdseSBwaW5uZWRcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyU2lkZVBpbm5lZEF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTG9jYWxQaW46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpbm5lZEF0OiBzZXJ2ZXJTaWRlUGlubmVkQXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFydGljaXBhbnQgaXMgbm8gbG9uZ2VyIHBpbm5lZCBzZXJ2ZXIgc2lkZVxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHBpblxuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudC5waW4gJiYgIXBhcnRpY2lwYW50LnBpbi5pc0xvY2FsUGluKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBubyBjaGFuZ2VzIHRvIGJlIGFwcGxpZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjYWxsIHN0YXRlIHdpdGggdGhlIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlID0gKGNhbGwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuYmFja3N0YWdlU3ViamVjdCwgY2FsbC5iYWNrc3RhZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5ibG9ja2VkVXNlcklkc1N1YmplY3QsIGNhbGwuYmxvY2tlZF91c2VyX2lkcyk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmNyZWF0ZWRBdFN1YmplY3QsIG5ldyBEYXRlKGNhbGwuY3JlYXRlZF9hdCkpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy51cGRhdGVkQXRTdWJqZWN0LCBuZXcgRGF0ZShjYWxsLnVwZGF0ZWRfYXQpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhcnRzQXRTdWJqZWN0LCBjYWxsLnN0YXJ0c19hdCA/IG5ldyBEYXRlKGNhbGwuc3RhcnRzX2F0KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmVuZGVkQXRTdWJqZWN0LCBjYWxsLmVuZGVkX2F0ID8gbmV3IERhdGUoY2FsbC5lbmRlZF9hdCkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jcmVhdGVkQnlTdWJqZWN0LCBjYWxsLmNyZWF0ZWRfYnkpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jdXN0b21TdWJqZWN0LCBjYWxsLmN1c3RvbSk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmVncmVzc1N1YmplY3QsIGNhbGwuZWdyZXNzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuaW5ncmVzc1N1YmplY3QsIGNhbGwuaW5ncmVzcyk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnJlY29yZGluZ1N1YmplY3QsIGNhbGwucmVjb3JkaW5nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc2Vzc2lvblN1YmplY3QsIGNhbGwuc2Vzc2lvbik7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNldHRpbmdzU3ViamVjdCwgY2FsbC5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnRyYW5zY3JpYmluZ1N1YmplY3QsIGNhbGwudHJhbnNjcmliaW5nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMudGh1bWJuYWlsc1N1YmplY3QsIGNhbGwudGh1bWJuYWlscyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbU1lbWJlclJlbW92ZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMubWVtYmVyc1N1YmplY3QsIChtZW1iZXJzKSA9PiBtZW1iZXJzLmZpbHRlcigobSkgPT4gZXZlbnQubWVtYmVycy5pbmRleE9mKG0udXNlcl9pZCkgPT09IC0xKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbU1lbWJlckFkZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm1lbWJlcnNTdWJqZWN0LCAobWVtYmVycykgPT4gW1xuICAgICAgICAgICAgICAgIC4uLm1lbWJlcnMsXG4gICAgICAgICAgICAgICAgLi4uZXZlbnQubWVtYmVycyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdG9wcGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lZ3Jlc3NTdWJqZWN0LCAoZWdyZXNzID0gZGVmYXVsdEVncmVzcykgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5lZ3Jlc3MsXG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tSExTQnJvYWRjYXN0aW5nRmFpbGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lZ3Jlc3NTdWJqZWN0LCAoZWdyZXNzID0gZGVmYXVsdEVncmVzcykgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5lZ3Jlc3MsXG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tSExTQnJvYWRjYXN0U3RhcnRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lZ3Jlc3NTdWJqZWN0LCAoZWdyZXNzID0gZGVmYXVsdEVncmVzcykgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5lZ3Jlc3MsXG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhsczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5lZ3Jlc3MuaGxzLFxuICAgICAgICAgICAgICAgICAgICBwbGF5bGlzdF91cmw6IGV2ZW50Lmhsc19wbGF5bGlzdF91cmwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50TGVmdCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZXNzaW9uU3ViamVjdCwgKHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgUmVjZWl2ZWQgY2FsbC5zZXNzaW9uX3BhcnRpY2lwYW50X2xlZnQgZXZlbnQgYnV0IG5vIHNlc3Npb24gaXMgYXZhaWxhYmxlLmAsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFydGljaXBhbnRzLCBwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZSB9ID0gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZXIsIHVzZXJfc2Vzc2lvbl9pZCB9ID0gZXZlbnQucGFydGljaXBhbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc2Vzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRzOiBwYXJ0aWNpcGFudHMuZmlsdGVyKChwKSA9PiBwLnVzZXJfc2Vzc2lvbl9pZCAhPT0gdXNlcl9zZXNzaW9uX2lkKSxcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3VzZXIucm9sZV06IE1hdGgubWF4KDAsIChwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZVt1c2VyLnJvbGVdIHx8IDApIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRKb2luZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc2Vzc2lvblN1YmplY3QsIChzZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYFJlY2VpdmVkIGNhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9qb2luZWQgZXZlbnQgYnV0IG5vIHNlc3Npb24gaXMgYXZhaWxhYmxlLmAsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFydGljaXBhbnRzLCBwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZSB9ID0gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZXIsIHVzZXJfc2Vzc2lvbl9pZCB9ID0gZXZlbnQucGFydGljaXBhbnQ7XG4gICAgICAgICAgICAgICAgLy8gSXQgY291bGQgaGFwcGVuIHRoYXQgdGhlIGJhY2tlbmQgZGVsaXZlcnMgdGhlIHNhbWUgcGFydGljaXBhbnQgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gT25jZSB3aXRoIHRoZSBjYWxsLnNlc3Npb25fc3RhcnRlZCBldmVudCBhbmQgb25jZSBhZ2FpbiB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9qb2luZWQgZXZlbnQuIEluIHRoaXMgY2FzZSxcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgdXBkYXRlIHRoZSBleGlzdGluZyBwYXJ0aWNpcGFudCBhbmQgcHJldmVudCBkdXBsaWNhdGluZyBpdC5cbiAgICAgICAgICAgICAgICBsZXQgc2hvdWxkSW5zZXJ0UGFydGljaXBhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQYXJ0aWNpcGFudHMgPSBwYXJ0aWNpcGFudHMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnVzZXJfc2Vzc2lvbl9pZCA9PT0gdXNlcl9zZXNzaW9uX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRJbnNlcnRQYXJ0aWNpcGFudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnBhcnRpY2lwYW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRJbnNlcnRQYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IGFycmF5LCB3ZSBjYW4gc2FmZWx5IHB1c2ggdGhlIG5ldyBwYXJ0aWNpcGFudFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUGFydGljaXBhbnRzLnB1c2goZXZlbnQucGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgdXBkYXRpbmcgYW4gZXhpc3RpbmcgcGFydGljaXBhbnQsIHdlIGRvbid0IHdhbnQgdG8gaW5jcmVtZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcnRpY2lwYW50X2J5X3JvbGUgY291bnQuXG4gICAgICAgICAgICAgICAgY29uc3QgaW5jcmVtZW50ID0gc2hvdWxkSW5zZXJ0UGFydGljaXBhbnQgPyAxIDogMDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudHM6IHVwZGF0ZWRQYXJ0aWNpcGFudHMsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt1c2VyLnJvbGVdOiAocGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGVbdXNlci5yb2xlXSB8fCAwKSArIGluY3JlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTWVtYmVycyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5tZW1iZXJzU3ViamVjdCwgKG1lbWJlcnMpID0+IG1lbWJlcnMubWFwKChtZW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZW1iZXJVcGRhdGUgPSBldmVudC5tZW1iZXJzLmZpbmQoKG0pID0+IG0udXNlcl9pZCA9PT0gbWVtYmVyLnVzZXJfaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXJVcGRhdGUgPyBtZW1iZXJVcGRhdGUgOiBtZW1iZXI7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlUGFydGljaXBhbnRSZWFjdGlvbiA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VyLCBjdXN0b20sIHR5cGUsIGVtb2ppX2NvZGUgfSA9IGV2ZW50LnJlYWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWNpcGFudHMubWFwKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdGhlIHJlYWN0aW9uIGlzIG5vdCBmb3IgdGhpcyBwYXJ0aWNpcGFudFxuICAgICAgICAgICAgICAgICAgICBpZiAocC51c2VySWQgIT09IHVzZXIuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwYXJ0aWNpcGFudCB3aXRoIHRoZSBuZXcgcmVhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1vamlfY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5ibG9ja1VzZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuYmxvY2tlZFVzZXJJZHNTdWJqZWN0LCAoY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZmlsdGVyKChpZCkgPT4gaWQgIT09IGV2ZW50LnVzZXIuaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmxvY2tVc2VyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmJsb2NrZWRVc2VySWRzU3ViamVjdCwgKGN1cnJlbnQpID0+IFtcbiAgICAgICAgICAgICAgICAuLi4oY3VycmVudCB8fCBbXSksXG4gICAgICAgICAgICAgICAgZXZlbnQudXNlci5pZCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZU93bkNhcGFiaWxpdGllcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnVzZXIuaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudD8udXNlcklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5vd25DYXBhYmlsaXRpZXNTdWJqZWN0LCBldmVudC5vd25fY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydDYWxsU3RhdGUnXSk7XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRzJCA9IHRoaXMucGFydGljaXBhbnRzU3ViamVjdC5hc09ic2VydmFibGUoKS5waXBlKFxuICAgICAgICAvLyBtYWludGFpbiBzdGFibGUtc29ydCBieSBtdXRhdGluZyB0aGUgcGFydGljaXBhbnRzIHN0b3JlZFxuICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgc3ViamVjdFxuICAgICAgICBtYXAkMSgocHMpID0+IHBzLnNvcnQodGhpcy5zb3J0UGFydGljaXBhbnRzQnkpKSwgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCQgPSB0aGlzLnBhcnRpY2lwYW50cyQucGlwZShtYXAkMSgocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuZmluZCgocCkgPT4gcC5pc0xvY2FsUGFydGljaXBhbnQpKSwgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzJCA9IHRoaXMucGFydGljaXBhbnRzJC5waXBlKG1hcCQxKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5maWx0ZXIoKHApID0+ICFwLmlzTG9jYWxQYXJ0aWNpcGFudCkpLCBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5waW5uZWRQYXJ0aWNpcGFudHMkID0gdGhpcy5wYXJ0aWNpcGFudHMkLnBpcGUobWFwJDEoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbHRlcigocCkgPT4gISFwLnBpbikpLCBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5kb21pbmFudFNwZWFrZXIkID0gdGhpcy5wYXJ0aWNpcGFudHMkLnBpcGUobWFwJDEoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbmQoKHApID0+IHAuaXNEb21pbmFudFNwZWFrZXIpKSwgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMuaGFzT25nb2luZ1NjcmVlblNoYXJlJCA9IHRoaXMucGFydGljaXBhbnRzJC5waXBlKG1hcCQxKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5zb21lKChwKSA9PiBwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhUcmFja1R5cGUuU0NSRUVOX1NIQVJFKSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLCBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5zdGFydGVkQXQkID0gdGhpcy5zdGFydGVkQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLnBhcnRpY2lwYW50Q291bnQkID0gdGhpcy5wYXJ0aWNpcGFudENvdW50U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5hbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50JCA9XG4gICAgICAgICAgICB0aGlzLmFub255bW91c1BhcnRpY2lwYW50Q291bnRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmNhbGxTdGF0c1JlcG9ydCQgPSB0aGlzLmNhbGxTdGF0c1JlcG9ydFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMubWVtYmVycyQgPSB0aGlzLm1lbWJlcnNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLm93bkNhcGFiaWxpdGllcyQgPSB0aGlzLm93bkNhcGFiaWxpdGllc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuY2FsbGluZ1N0YXRlJCA9IHRoaXMuY2FsbGluZ1N0YXRlU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5iYWNrc3RhZ2UkID0gdGhpcy5iYWNrc3RhZ2VTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmJsb2NrZWRVc2VySWRzJCA9IHRoaXMuYmxvY2tlZFVzZXJJZHNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCQgPSB0aGlzLmNyZWF0ZWRBdFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuZW5kZWRBdCQgPSB0aGlzLmVuZGVkQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLnN0YXJ0c0F0JCA9IHRoaXMuc3RhcnRzQXRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZWRBdCQgPSB0aGlzLnVwZGF0ZWRBdFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlZEJ5JCA9IHRoaXMuY3JlYXRlZEJ5U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5jdXN0b20kID0gdGhpcy5jdXN0b21TdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmVncmVzcyQgPSB0aGlzLmVncmVzc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuaW5ncmVzcyQgPSB0aGlzLmluZ3Jlc3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLnJlY29yZGluZyQgPSB0aGlzLnJlY29yZGluZ1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiQgPSB0aGlzLnNlc3Npb25TdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLnNldHRpbmdzJCA9IHRoaXMuc2V0dGluZ3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLnRyYW5zY3JpYmluZyQgPSB0aGlzLnRyYW5zY3JpYmluZ1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuZW5kZWRCeSQgPSB0aGlzLmVuZGVkQnlTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLnRodW1ibmFpbHMkID0gdGhpcy50aHVtYm5haWxzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0ge1xuICAgICAgICAgICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBub3QgdXBkYXRpbmcgdGhlIGNhbGwgc3RhdGU6XG4gICAgICAgICAgICAnY2FsbC5jbG9zZWRfY2FwdGlvbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjYWxsLnBlcm1pc3Npb25fcmVxdWVzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjYWxsLnJlY29yZGluZ19mYWlsZWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC5yZWNvcmRpbmdfcmVhZHknOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC50cmFuc2NyaXB0aW9uX3N0YXJ0ZWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC50cmFuc2NyaXB0aW9uX3N0b3BwZWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC50cmFuc2NyaXB0aW9uX3JlYWR5JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NhbGwudHJhbnNjcmlwdGlvbl9mYWlsZWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC51c2VyX211dGVkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nvbm5lY3Rpb24uZXJyb3InOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY29ubmVjdGlvbi5vayc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdoZWFsdGguY2hlY2snOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdXN0b206IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGV2ZW50cyB0aGF0IHVwZGF0ZSBjYWxsIHN0YXRlOlxuICAgICAgICAgICAgJ2NhbGwuYWNjZXB0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAgICAgICAnY2FsbC5ibG9ja2VkX3VzZXInOiB0aGlzLmJsb2NrVXNlcixcbiAgICAgICAgICAgICdjYWxsLmNyZWF0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAgICAgICAnY2FsbC5lbmRlZCc6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lbmRlZEJ5U3ViamVjdCwgZS51c2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY2FsbC5obHNfYnJvYWRjYXN0aW5nX2ZhaWxlZCc6IHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdGluZ0ZhaWxlZCxcbiAgICAgICAgICAgICdjYWxsLmhsc19icm9hZGNhc3Rpbmdfc3RhcnRlZCc6IHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdFN0YXJ0ZWQsXG4gICAgICAgICAgICAnY2FsbC5obHNfYnJvYWRjYXN0aW5nX3N0b3BwZWQnOiB0aGlzLnVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdG9wcGVkLFxuICAgICAgICAgICAgJ2NhbGwubGl2ZV9zdGFydGVkJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwubWVtYmVyX2FkZGVkJzogdGhpcy51cGRhdGVGcm9tTWVtYmVyQWRkZWQsXG4gICAgICAgICAgICAnY2FsbC5tZW1iZXJfcmVtb3ZlZCc6IHRoaXMudXBkYXRlRnJvbU1lbWJlclJlbW92ZWQsXG4gICAgICAgICAgICAnY2FsbC5tZW1iZXJfdXBkYXRlZF9wZXJtaXNzaW9uJzogdGhpcy51cGRhdGVNZW1iZXJzLFxuICAgICAgICAgICAgJ2NhbGwubWVtYmVyX3VwZGF0ZWQnOiB0aGlzLnVwZGF0ZU1lbWJlcnMsXG4gICAgICAgICAgICAnY2FsbC5ub3RpZmljYXRpb24nOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWVtYmVycyhlLm1lbWJlcnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdjYWxsLnBlcm1pc3Npb25zX3VwZGF0ZWQnOiB0aGlzLnVwZGF0ZU93bkNhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICdjYWxsLnJlYWN0aW9uX25ldyc6IHRoaXMudXBkYXRlUGFydGljaXBhbnRSZWFjdGlvbixcbiAgICAgICAgICAgICdjYWxsLnJlY29yZGluZ19zdGFydGVkJzogKCkgPT4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5yZWNvcmRpbmdTdWJqZWN0LCB0cnVlKSxcbiAgICAgICAgICAgICdjYWxsLnJlY29yZGluZ19zdG9wcGVkJzogKCkgPT4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5yZWNvcmRpbmdTdWJqZWN0LCBmYWxzZSksXG4gICAgICAgICAgICAnY2FsbC5yZWplY3RlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICAgICAgICdjYWxsLnJpbmcnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAgICAgICAnY2FsbC5zZXNzaW9uX2VuZGVkJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9qb2luZWQnOiB0aGlzLnVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRKb2luZWQsXG4gICAgICAgICAgICAnY2FsbC5zZXNzaW9uX3BhcnRpY2lwYW50X2xlZnQnOiB0aGlzLnVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRMZWZ0LFxuICAgICAgICAgICAgJ2NhbGwuc2Vzc2lvbl9zdGFydGVkJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwudW5ibG9ja2VkX3VzZXInOiB0aGlzLnVuYmxvY2tVc2VyLFxuICAgICAgICAgICAgJ2NhbGwudXBkYXRlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlci1zaWRlIGNvdW50ZWQgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyBjb25uZWN0ZWQgdG8gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKiBUaGlzIG51bWJlciBpbmNsdWRlcyB0aGUgYW5vbnltb3VzIHBhcnRpY2lwYW50cyBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGdldCBwYXJ0aWNpcGFudENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5wYXJ0aWNpcGFudENvdW50JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIHRoZSBjYWxsIHNlc3Npb24gYWN0dWFsbHkgc3RhcnRlZC5cbiAgICAgKiBVc2VmdWwgZm9yIGRpc3BsYXlpbmcgdGhlIGNhbGwgZHVyYXRpb24uXG4gICAgICovXG4gICAgZ2V0IHN0YXJ0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhcnRlZEF0JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXItc2lkZSBjb3VudGVkIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGNvbm5lY3RlZCB0byB0aGUgY3VycmVudCBjYWxsLlxuICAgICAqIFRoaXMgbnVtYmVyIGluY2x1ZGVzIHRoZSBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGFzIHdlbGwuXG4gICAgICovXG4gICAgZ2V0IGFub255bW91c1BhcnRpY2lwYW50Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmFub255bW91c1BhcnRpY2lwYW50Q291bnQkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICovXG4gICAgZ2V0IHBhcnRpY2lwYW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBwYXJ0aWNpcGFudCBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAqL1xuICAgIGdldCBsb2NhbFBhcnRpY2lwYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5sb2NhbFBhcnRpY2lwYW50JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHJlbW90ZSBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgcmVtb3RlUGFydGljaXBhbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRvbWluYW50IHNwZWFrZXIgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgZG9taW5hbnRTcGVha2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5kb21pbmFudFNwZWFrZXIkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgcGlubmVkIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAqL1xuICAgIGdldCBwaW5uZWRQYXJ0aWNpcGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnBpbm5lZFBhcnRpY2lwYW50cyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWxsIGlmIHRoZXJlIGlzIGFuIG9uZ29pbmcgc2NyZWVuIHNoYXJlIGluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgaGFzT25nb2luZ1NjcmVlblNoYXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5oYXNPbmdvaW5nU2NyZWVuU2hhcmUkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxpbmcgc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGNhbGxpbmdTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbGluZ1N0YXRlJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIHN0YXRzIHJlcG9ydC5cbiAgICAgKi9cbiAgICBnZXQgY2FsbFN0YXRzUmVwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5jYWxsU3RhdHNSZXBvcnQkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lbWJlcnMgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgbWVtYmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMubWVtYmVycyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBjdXJyZW50IHVzZXIgZm9yIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICovXG4gICAgZ2V0IG93bkNhcGFiaWxpdGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMub3duQ2FwYWJpbGl0aWVzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrc3RhZ2Ugc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGJhY2tzdGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuYmFja3N0YWdlJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgbGlzdCBvZiBibG9ja2VkIHVzZXIgSURzLlxuICAgICAqL1xuICAgIGdldCBibG9ja2VkVXNlcklkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuYmxvY2tlZFVzZXJJZHMkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB0aW1lIHdoZW4gdGhpcyBjYWxsIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZ2V0IGNyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY3JlYXRlZEF0JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgdGltZSB3aGVuIHRoaXMgY2FsbCBoYXMgYmVlbiBlbmRlZC5cbiAgICAgKi9cbiAgICBnZXQgZW5kZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZW5kZWRBdCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRpbWUgd2hlbiB0aGlzIGNhbGwgaGFzIGJlZW4gc2NoZWR1bGVkIHRvIHN0YXJ0LlxuICAgICAqL1xuICAgIGdldCBzdGFydHNBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhcnRzQXQkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB0aW1lIHdoZW4gdGhpcyBjYWxsIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICovXG4gICAgZ2V0IHVwZGF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMudXBkYXRlZEF0JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgZ2V0IGNyZWF0ZWRCeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY3JlYXRlZEJ5JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgY3VzdG9tIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBjdXN0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmN1c3RvbSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIGVncmVzcyBkYXRhIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgZWdyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5lZ3Jlc3MkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSBpbmdyZXNzIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBpbmdyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5pbmdyZXNzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgcmVjb3JkaW5nIHN0YXRlIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgcmVjb3JkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5yZWNvcmRpbmckKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSBzZXNzaW9uIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBzZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5zZXNzaW9uJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgc2V0dGluZ3Mgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBzZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2V0dGluZ3MkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB0cmFuc2NyaWJpbmcgc3RhdGUgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCB0cmFuc2NyaWJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnRyYW5zY3JpYmluZyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHVzZXIgd2hvIGVuZGVkIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgZW5kZWRCeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZW5kZWRCeSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRodW1ibmFpbHMgb2YgdGhpcyBjYWxsLCBpZiBlbmFibGVkIGluIHRoZSBjYWxsIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGdldCB0aHVtYm5haWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy50aHVtYm5haWxzJCk7XG4gICAgfVxufVxuXG5jbGFzcyBTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdG9yZSBrZWVwaW5nIGRhdGEgb2YgYSBzdWNjZXNzZnVsbHkgY29ubmVjdGVkIHVzZXIgb3ZlciBXUyB0byB0aGUgY29vcmRpbmF0b3Igc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0ZWRVc2VyU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiB7QGxpbmsgQ2FsbH0gb2JqZWN0cyBjcmVhdGVkL3RyYWNrZWQgYnkgdGhpcyBjbGllbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbiBvYnNlcnZhYmxlLCBvciB1bmRlZmluZWQgaWYgdGhlIG9ic2VydmFibGUgaGFzXG4gICAgICAgICAqIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSQgdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VmFsdWUgPSBnZXRDdXJyZW50VmFsdWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAgICAgICAgICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gICAgICAgICAqIHRoZSBjdXJyZW50IHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byB1cGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB1cGRhdGUgdGhlIHVwZGF0ZSB0byBhcHBseSB0byB0aGUgc3ViamVjdC5cbiAgICAgICAgICogQHJldHVybiB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlID0gc2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHVzZXIgdGhlIHVzZXIgdG8gc2V0IGFzIGNvbm5lY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q29ubmVjdGVkVXNlciA9ICh1c2VyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jb25uZWN0ZWRVc2VyU3ViamVjdCwgdXNlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICogQHBhcmFtIGNhbGxzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENhbGxzID0gKGNhbGxzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jYWxsc1N1YmplY3QsIGNhbGxzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSB7QGxpbmsgQ2FsbH0gb2JqZWN0IHRvIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gYWRkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWdpc3RlckNhbGwgPSAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxzLmZpbmQoKGMpID0+IGMuY2lkID09PSBjYWxsLmNpZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENhbGxzKChjYWxscykgPT4gWy4uLmNhbGxzLCBjYWxsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEge0BsaW5rIENhbGx9IG9iamVjdCBmcm9tIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gcmVtb3ZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJDYWxsID0gKGNhbGwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldENhbGxzKChjYWxscykgPT4gY2FsbHMuZmlsdGVyKChjKSA9PiBjICE9PSBjYWxsKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kcyBhIHtAbGluayBDYWxsfSBvYmplY3QgaW4gdGhlIGxpc3Qgb2Yge0BsaW5rIENhbGx9IG9iamVjdHMgY3JlYXRlZC90cmFja2VkIGJ5IHRoaXMgY2xpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiBjYWxsIHRvIGZpbmQuXG4gICAgICAgICAqIEBwYXJhbSBpZCB0aGUgaWQgb2YgdGhlIGNhbGwgdG8gZmluZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluZENhbGwgPSAodHlwZSwgaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGxzLmZpbmQoKGMpID0+IGMudHlwZSA9PT0gdHlwZSAmJiBjLmlkID09PSBpZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGVkVXNlclN1YmplY3Quc3Vic2NyaWJlKGFzeW5jICh1c2VyKSA9PiB7XG4gICAgICAgICAgICAvLyBsZWF2ZSBhbGwgY2FsbHMgd2hlbiB0aGUgdXNlciBkaXNjb25uZWN0cy5cbiAgICAgICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ2NsaWVudC1zdGF0ZSddKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy5jYWxscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbC5zdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5MRUZUKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcignaW5mbycsIGBVc2VyIGRpc2Nvbm5lY3RlZCwgbGVhdmluZyBjYWxsOiAke2NhbGwuY2lkfWApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAubGVhdmUoeyByZWFzb246ICdjbGllbnQuZGlzY29ubmVjdFVzZXIoKSBjYWxsZWQnIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsIGBFcnJvciBsZWF2aW5nIGNhbGw6ICR7Y2FsbC5jaWR9YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgdXNlci5cbiAgICAgKi9cbiAgICBnZXQgY29ubmVjdGVkVXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY29ubmVjdGVkVXNlclN1YmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2Yge0BsaW5rIENhbGx9IG9iamVjdHMgY3JlYXRlZC90cmFja2VkIGJ5IHRoaXMgY2xpZW50LlxuICAgICAqL1xuICAgIGdldCBjYWxscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbHNTdWJqZWN0KTtcbiAgICB9XG59XG4vKipcbiAqIEEgcmVhY3RpdmUgc3RvcmUgdGhhdCBleHBvc2VzIHN0YXRlIHZhcmlhYmxlcyBpbiBhIHJlYWN0aXZlIG1hbm5lci5cbiAqIFlvdSBjYW4gc3Vic2NyaWJlIHRvIGNoYW5nZXMgb2YgdGhlIGRpZmZlcmVudCBzdGF0ZSB2YXJpYWJsZXMuXG4gKiBUaGlzIGNlbnRyYWwgc3RvcmUgY29udGFpbnMgYWxsIHRoZSBzdGF0ZSB2YXJpYWJsZXMgcmVsYXRlZCB0byBbYFN0cmVhbVZpZGVvQ2xpZW50YF0oLi9TdHJlYW1WaWRlQ2xpZW50Lm1kKSBhbmQgW2BDYWxsYF0oLi9DYWxsLm1kKS5cbiAqL1xuY2xhc3MgU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRoZSBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBzdGF0ZSB2YXJpYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9ic2VydmFibGUgdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mLlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvLyBjb252ZXJ0IGFuZCBleHBvc2Ugc3ViamVjdHMgYXMgb2JzZXJ2YWJsZXNcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRVc2VyJCA9IHN0b3JlLmNvbm5lY3RlZFVzZXJTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmNhbGxzJCA9IHN0b3JlLmNhbGxzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdXNlciBjb25uZWN0ZWQgb3ZlciBXUyB0byB0aGUgYmFja2VuZC5cbiAgICAgKi9cbiAgICBnZXQgY29ubmVjdGVkVXNlcigpIHtcbiAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRWYWx1ZSh0aGlzLmNvbm5lY3RlZFVzZXIkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBnZXQgY2FsbHMoKSB7XG4gICAgICAgIHJldHVybiBnZXRDdXJyZW50VmFsdWUodGhpcy5jYWxscyQpO1xuICAgIH1cbn1cblxuY29uc3QgZ2V0UnRwTWFwID0gKGxpbmUpID0+IHtcbiAgICAvLyBFeGFtcGxlOiBhPXJ0cG1hcDoxMTAgb3B1cy80ODAwMC8yXG4gICAgY29uc3QgcnRwUmVnZXggPSAvXmE9cnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vO1xuICAgIC8vIFRoZSBmaXJzdCBjYXB0dXJlZCBncm91cCBpcyB0aGUgcGF5bG9hZCB0eXBlIG51bWJlciwgdGhlIHNlY29uZCBjYXB0dXJlZCBncm91cCBpcyB0aGUgZW5jb2RpbmcgbmFtZSwgdGhlIHRoaXJkIGNhcHR1cmVkIGdyb3VwIGlzIHRoZSBjbG9jayByYXRlLCBhbmQgdGhlIGZvdXJ0aCBjYXB0dXJlZCBncm91cCBpcyBhbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzLlxuICAgIGNvbnN0IHJ0cE1hdGNoID0gcnRwUmVnZXguZXhlYyhsaW5lKTtcbiAgICBpZiAocnRwTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdpbmFsOiBydHBNYXRjaFswXSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJ0cE1hdGNoWzFdLFxuICAgICAgICAgICAgY29kZWM6IHJ0cE1hdGNoWzJdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBnZXRGbXRwID0gKGxpbmUpID0+IHtcbiAgICAvLyBFeGFtcGxlOiBhPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxuICAgIGNvbnN0IGZtdHBSZWdleCA9IC9eYT1mbXRwOihcXGQqKSAoLiopLztcbiAgICBjb25zdCBmbXRwTWF0Y2ggPSBmbXRwUmVnZXguZXhlYyhsaW5lKTtcbiAgICAvLyBUaGUgZmlyc3QgY2FwdHVyZWQgZ3JvdXAgaXMgdGhlIHBheWxvYWQgdHlwZSBudW1iZXIsIHRoZSBzZWNvbmQgY2FwdHVyZWQgZ3JvdXAgaXMgYW55IGFkZGl0aW9uYWwgcGFyYW1ldGVycy5cbiAgICBpZiAoZm10cE1hdGNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnaW5hbDogZm10cE1hdGNoWzBdLFxuICAgICAgICAgICAgcGF5bG9hZDogZm10cE1hdGNoWzFdLFxuICAgICAgICAgICAgY29uZmlnOiBmbXRwTWF0Y2hbMl0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogZ2V0cyB0aGUgbWVkaWEgc2VjdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBtZWRpYSB0eXBlLlxuICogVGhlIG1lZGlhIHNlY3Rpb24gY29udGFpbnMgdGhlIG1lZGlhIHR5cGUsIHBvcnQsIGNvZGVjLCBhbmQgcGF5bG9hZCB0eXBlLlxuICogRXhhbXBsZTogbT12aWRlbyA5IFVEUC9UTFMvUlRQL1NBVlBGIDEwMCAxMDEgOTYgOTcgMzUgMzYgMTAyIDEyNSAxMjdcbiAqL1xuY29uc3QgZ2V0TWVkaWEgPSAobGluZSwgbWVkaWFUeXBlKSA9PiB7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGAobT0ke21lZGlhVHlwZX0gXFxcXGQrIFtcXFxcdy9dKykgKFtcXFxcZFxcXFxzXSspYCk7XG4gICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JpZ2luYWw6IG1hdGNoWzBdLFxuICAgICAgICAgICAgbWVkaWFXaXRoUG9ydHM6IG1hdGNoWzFdLFxuICAgICAgICAgICAgY29kZWNPcmRlcjogbWF0Y2hbMl0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGdldE1lZGlhU2VjdGlvbiA9IChzZHAsIG1lZGlhVHlwZSkgPT4ge1xuICAgIGxldCBtZWRpYTtcbiAgICBjb25zdCBydHBNYXAgPSBbXTtcbiAgICBjb25zdCBmbXRwID0gW107XG4gICAgbGV0IGlzVGhlUmVxdWlyZWRNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICBzZHAuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRMaW5lID0gL14oW2Etel0pPSguKikvLnRlc3QobGluZSk7XG4gICAgICAgIGlmICghaXNWYWxpZExpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qXG4gICAgICAgICAgTk9URTogYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM4ODY2LnBkZlxuICAgICAgICAgIEVhY2ggbWVkaWEgZGVzY3JpcHRpb24gc3RhcnRzIHdpdGggYW4gXCJtPVwiIGxpbmUgYW5kIGNvbnRpbnVlcyB0byB0aGUgbmV4dCBtZWRpYSBkZXNjcmlwdGlvbiBvciB0aGUgZW5kIG9mIHRoZSB3aG9sZSBzZXNzaW9uIGRlc2NyaXB0aW9uLCB3aGljaGV2ZXIgY29tZXMgZmlyc3RcbiAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdHlwZSA9IGxpbmVbMF07XG4gICAgICAgIGlmICh0eXBlID09PSAnbScpIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZWRpYSA9IGdldE1lZGlhKGxpbmUsIG1lZGlhVHlwZSk7XG4gICAgICAgICAgICBpc1RoZVJlcXVpcmVkTWVkaWFTZWN0aW9uID0gISFfbWVkaWE7XG4gICAgICAgICAgICBpZiAoX21lZGlhKSB7XG4gICAgICAgICAgICAgICAgbWVkaWEgPSBfbWVkaWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUaGVSZXF1aXJlZE1lZGlhU2VjdGlvbiAmJiB0eXBlID09PSAnYScpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0cE1hcExpbmUgPSBnZXRSdHBNYXAobGluZSk7XG4gICAgICAgICAgICBjb25zdCBmbXRwTGluZSA9IGdldEZtdHAobGluZSk7XG4gICAgICAgICAgICBpZiAocnRwTWFwTGluZSkge1xuICAgICAgICAgICAgICAgIHJ0cE1hcC5wdXNoKHJ0cE1hcExpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm10cExpbmUpIHtcbiAgICAgICAgICAgICAgICBmbXRwLnB1c2goZm10cExpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWRpYSxcbiAgICAgICAgICAgIHJ0cE1hcCxcbiAgICAgICAgICAgIGZtdHAsXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogR2V0cyB0aGUgZm10cCBsaW5lIGNvcnJlc3BvbmRpbmcgdG8gb3B1c1xuICovXG5jb25zdCBnZXRPcHVzRm10cCA9IChzZHApID0+IHtcbiAgICBjb25zdCBzZWN0aW9uID0gZ2V0TWVkaWFTZWN0aW9uKHNkcCwgJ2F1ZGlvJyk7XG4gICAgY29uc3QgcnRwTWFwID0gc2VjdGlvbj8ucnRwTWFwLmZpbmQoKHIpID0+IHIuY29kZWMudG9Mb3dlckNhc2UoKSA9PT0gJ29wdXMnKTtcbiAgICBjb25zdCBjb2RlY0lkID0gcnRwTWFwPy5wYXlsb2FkO1xuICAgIGlmIChjb2RlY0lkKSB7XG4gICAgICAgIHJldHVybiBzZWN0aW9uPy5mbXRwLmZpbmQoKGYpID0+IGYucGF5bG9hZCA9PT0gY29kZWNJZCk7XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBhbiBTRFAgd2l0aCBEVFggZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAqL1xuY29uc3QgdG9nZ2xlRHR4ID0gKHNkcCwgZW5hYmxlKSA9PiB7XG4gICAgY29uc3Qgb3B1c0ZtdHAgPSBnZXRPcHVzRm10cChzZHApO1xuICAgIGlmIChvcHVzRm10cCkge1xuICAgICAgICBjb25zdCBtYXRjaER0eCA9IC91c2VkdHg9KFxcZCkvLmV4ZWMob3B1c0ZtdHAuY29uZmlnKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWREdHhDb25maWcgPSBgdXNlZHR4PSR7ZW5hYmxlID8gJzEnIDogJzAnfWA7XG4gICAgICAgIGlmIChtYXRjaER0eCkge1xuICAgICAgICAgICAgY29uc3QgbmV3Rm10cCA9IG9wdXNGbXRwLm9yaWdpbmFsLnJlcGxhY2UoL3VzZWR0eD0oXFxkKS8sIHJlcXVpcmVkRHR4Q29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiBzZHAucmVwbGFjZShvcHVzRm10cC5vcmlnaW5hbCwgbmV3Rm10cCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdGbXRwID0gYCR7b3B1c0ZtdHAub3JpZ2luYWx9OyR7cmVxdWlyZWREdHhDb25maWd9YDtcbiAgICAgICAgICAgIHJldHVybiBzZHAucmVwbGFjZShvcHVzRm10cC5vcmlnaW5hbCwgbmV3Rm10cCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNkcDtcbn07XG4vKipcbiAqIEVuYWJsZXMgaGlnaC1xdWFsaXR5IGF1ZGlvIHRocm91Z2ggU0RQIG11bmdpbmcgZm9yIHRoZSBnaXZlbiB0cmFja01pZC5cbiAqXG4gKiBAcGFyYW0gc2RwIHRoZSBTRFAgdG8gbXVuZ2UuXG4gKiBAcGFyYW0gdHJhY2tNaWQgdGhlIHRyYWNrTWlkLlxuICogQHBhcmFtIG1heEJpdHJhdGUgdGhlIG1heCBiaXRyYXRlIHRvIHNldC5cbiAqL1xuY29uc3QgZW5hYmxlSGlnaFF1YWxpdHlBdWRpbyA9IChzZHAsIHRyYWNrTWlkLCBtYXhCaXRyYXRlID0gNTEwMDAwKSA9PiB7XG4gICAgbWF4Qml0cmF0ZSA9IE1hdGgubWF4KE1hdGgubWluKG1heEJpdHJhdGUsIDUxMDAwMCksIDk2MDAwKTtcbiAgICBjb25zdCBwYXJzZWRTZHAgPSBTRFAucGFyc2Uoc2RwKTtcbiAgICBjb25zdCBhdWRpb01lZGlhID0gcGFyc2VkU2RwLm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2F1ZGlvJyAmJiBTdHJpbmcobS5taWQpID09PSB0cmFja01pZCk7XG4gICAgaWYgKCFhdWRpb01lZGlhKVxuICAgICAgICByZXR1cm4gc2RwO1xuICAgIGNvbnN0IG9wdXNSdHAgPSBhdWRpb01lZGlhLnJ0cC5maW5kKChyKSA9PiByLmNvZGVjID09PSAnb3B1cycpO1xuICAgIGlmICghb3B1c1J0cClcbiAgICAgICAgcmV0dXJuIHNkcDtcbiAgICBjb25zdCBvcHVzRm10cCA9IGF1ZGlvTWVkaWEuZm10cC5maW5kKChmKSA9PiBmLnBheWxvYWQgPT09IG9wdXNSdHAucGF5bG9hZCk7XG4gICAgaWYgKCFvcHVzRm10cClcbiAgICAgICAgcmV0dXJuIHNkcDtcbiAgICAvLyBlbmFibGUgc3RlcmVvLCBpZiBub3QgYWxyZWFkeSBlbmFibGVkXG4gICAgaWYgKG9wdXNGbXRwLmNvbmZpZy5tYXRjaCgvc3RlcmVvPShcXGQpLykpIHtcbiAgICAgICAgb3B1c0ZtdHAuY29uZmlnID0gb3B1c0ZtdHAuY29uZmlnLnJlcGxhY2UoL3N0ZXJlbz0oXFxkKS8sICdzdGVyZW89MScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B1c0ZtdHAuY29uZmlnID0gYCR7b3B1c0ZtdHAuY29uZmlnfTtzdGVyZW89MWA7XG4gICAgfVxuICAgIC8vIHNldCBtYXhhdmVyYWdlYml0cmF0ZSwgdG8gdGhlIGdpdmVuIHZhbHVlXG4gICAgaWYgKG9wdXNGbXRwLmNvbmZpZy5tYXRjaCgvbWF4YXZlcmFnZWJpdHJhdGU9KFxcZCopLykpIHtcbiAgICAgICAgb3B1c0ZtdHAuY29uZmlnID0gb3B1c0ZtdHAuY29uZmlnLnJlcGxhY2UoL21heGF2ZXJhZ2ViaXRyYXRlPShcXGQqKS8sIGBtYXhhdmVyYWdlYml0cmF0ZT0ke21heEJpdHJhdGV9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHVzRm10cC5jb25maWcgPSBgJHtvcHVzRm10cC5jb25maWd9O21heGF2ZXJhZ2ViaXRyYXRlPSR7bWF4Qml0cmF0ZX1gO1xuICAgIH1cbiAgICByZXR1cm4gU0RQLndyaXRlKHBhcnNlZFNkcCk7XG59O1xuXG5jb25zdCBsb2dnZXIkMyA9IGdldExvZ2dlcihbJ1B1Ymxpc2hlciddKTtcbi8qKlxuICogVGhlIGBQdWJsaXNoZXJgIGlzIHJlc3BvbnNpYmxlIGZvciBwdWJsaXNoaW5nL3VucHVibGlzaGluZyBtZWRpYSBzdHJlYW1zIHRvL2Zyb20gdGhlIFNGVVxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFB1Ymxpc2hlciB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnBjLmdldENvbmZpZ3VyYXRpb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgUHVibGlzaGVyYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlLlxuICAgICAqIEBwYXJhbSBzZnVDbGllbnQgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgY2FsbCBzdGF0ZSB0byB1c2UuXG4gICAgICogQHBhcmFtIGRpc3BhdGNoZXIgdGhlIGRpc3BhdGNoZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBpc0R0eEVuYWJsZWQgd2hldGhlciBEVFggaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0gaXNSZWRFbmFibGVkIHdoZXRoZXIgUkVEIGlzIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIGljZVJlc3RhcnREZWxheSB0aGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlc3RhcnRpbmcgSUNFIG9uY2UgY29ubmVjdGlvbiBnb2VzIHRvIGBkaXNjb25uZWN0ZWRgIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY29ubmVjdGlvbkNvbmZpZywgc2Z1Q2xpZW50LCBkaXNwYXRjaGVyLCBzdGF0ZSwgaXNEdHhFbmFibGVkLCBpc1JlZEVuYWJsZWQsIGljZVJlc3RhcnREZWxheSA9IDI1MDAsIH0pIHtcbiAgICAgICAgdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5ID0ge1xuICAgICAgICAgICAgW1RyYWNrVHlwZS5BVURJT106IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuVklERU9dOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV06IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1RyYWNrVHlwZS5VTlNQRUNJRklFRF06IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wdWJsaXNoT3B0aW9uc1BlclRyYWNrVHlwZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG1haW50YWluaW5nIHRoZSBvcmRlciBob3cgdHJhbnNjZWl2ZXJzIHdlcmUgYWRkZWQgdG8gdGhlIHBlZXIgY29ubmVjdGlvbi5cbiAgICAgICAgICogVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBzb21lIGJyb3dzZXJzIChGaXJlZm94KSBkb24ndCByZWxpYWJseSByZXBvcnRcbiAgICAgICAgICogdHJhY2tJZCBhbmQgYG1pZGAgcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNjZWl2ZXJJbml0T3JkZXIgPSBbXTtcbiAgICAgICAgdGhpcy50cmFja0tpbmRNYXBwaW5nID0ge1xuICAgICAgICAgICAgW1RyYWNrVHlwZS5BVURJT106ICdhdWRpbycsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlZJREVPXTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuU0NSRUVOX1NIQVJFXTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPXTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuVU5TUEVDSUZJRURdOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhY2tMYXllcnNDYWNoZSA9IHtcbiAgICAgICAgICAgIFtUcmFja1R5cGUuQVVESU9dOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlZJREVPXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVdOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJT106IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuVU5TUEVDSUZJRURdOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNJY2VSZXN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24gPSAoY29ubmVjdGlvbkNvbmZpZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbiA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCB0aGlzLm9uSWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ25lZ290aWF0aW9ubmVlZGVkJywgdGhpcy5vbk5lZ290aWF0aW9uTmVlZGVkKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZWVycm9yJywgdGhpcy5vbkljZUNhbmRpZGF0ZUVycm9yKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLm9uSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignc2lnbmFsaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLm9uU2lnbmFsaW5nU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHBjO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBwdWJsaXNoZXIgUGVlckNvbm5lY3Rpb24gYW5kIGNsZWFucyB1cCB0aGUgcmVzb3VyY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9ICh7IHN0b3BUcmFja3MgPSB0cnVlIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BUcmFja3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BQdWJsaXNoaW5nKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5KS5mb3JFYWNoKCh0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnRyYWNrTGF5ZXJzQ2FjaGUpLmZvckVhY2goKHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tMYXllcnNDYWNoZVt0cmFja1R5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWNlUmVzdGFydFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZU9uSWNlUmVzdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5wYy5yZW1vdmVFdmVudExpc3RlbmVyKCduZWdvdGlhdGlvbm5lZWRlZCcsIHRoaXMub25OZWdvdGlhdGlvbk5lZWRlZCk7XG4gICAgICAgICAgICB0aGlzLnBjLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gdHJhY2sgb2YgdGhlIGdpdmVuIG1lZGlhIHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc2VjdXRpdmUgY2FsbHMgdG8gdGhpcyBtZXRob2Qgd2lsbCByZXBsYWNlIHRoZSBzdHJlYW0uXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWVkaWFTdHJlYW0gdGhlIG1lZGlhIHN0cmVhbSB0byBwdWJsaXNoLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2sgdGhlIHRyYWNrIHRvIHB1Ymxpc2guXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHRyYWNrIHR5cGUgdG8gcHVibGlzaC5cbiAgICAgICAgICogQHBhcmFtIG9wdHMgdGhlIG9wdGlvbmFsIHB1Ymxpc2ggb3B0aW9ucyB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnB1Ymxpc2hTdHJlYW0gPSBhc3luYyAobWVkaWFTdHJlYW0sIHRyYWNrLCB0cmFja1R5cGUsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHB1Ymxpc2ggYSB0cmFjayB0aGF0IGhhcyBlbmRlZCBhbHJlYWR5LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYW5zY2VpdmVyID0gdGhpcy5wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0ID09PSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSAmJlxuICAgICAgICAgICAgICAgIHQuc2VuZGVyLnRyYWNrICYmXG4gICAgICAgICAgICAgICAgdC5zZW5kZXIudHJhY2s/LmtpbmQgPT09IHRoaXMudHJhY2tLaW5kTWFwcGluZ1t0cmFja1R5cGVdKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gZXZlbnQgaGFuZGxlciB3aGljaCBsaXN0ZW5zIGZvciB0aGUgJ2VuZGVkJyBldmVudCBvbiB0aGUgdHJhY2suXG4gICAgICAgICAgICAgKiBPbmNlIHRoZSB0cmFjayBoYXMgZW5kZWQsIGl0IHdpbGwgbm90aWZ5IHRoZSBTRlUgYW5kIHVwZGF0ZSB0aGUgc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVRyYWNrRW5kZWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2luZm8nLCBgVHJhY2sgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gaGFzIGVuZGVkLCBub3RpZnlpbmcgdGhlIFNGVWApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubm90aWZ5VHJhY2tNdXRlU3RhdGVDaGFuZ2VkKG1lZGlhU3RyZWFtLCB0cmFja1R5cGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGNsZWFuLXVwLCB0aGlzIGV2ZW50IGxpc3RlbmVyIG5lZWRzIHRvIHJ1biBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRSZXNvbHV0aW9uID0gc2V0dGluZ3M/LnZpZGVvLnRhcmdldF9yZXNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvRW5jb2RpbmdzID0gdHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU9cbiAgICAgICAgICAgICAgICAgICAgPyBmaW5kT3B0aW1hbFZpZGVvTGF5ZXJzKHRyYWNrLCB0YXJnZXRSZXNvbHV0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlNDUkVFTl9TSEFSRVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBmaW5kT3B0aW1hbFNjcmVlblNoYXJpbmdMYXllcnModHJhY2ssIG9wdHMuc2NyZWVuU2hhcmVTZXR0aW5ncylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBwcmVmZXJyZWRDb2RlYyA9IG9wdHMucHJlZmVycmVkQ29kZWM7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVmZXJyZWRDb2RlYyAmJiB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvc05hbWUgPSBnZXRPU0luZm8oKT8ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9zTmFtZSA9PT0gJ2lwYWRvcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpcGFkcyBpdCB3YXMgbm90aWNlZCB0aGF0IGlmIHZwOCBjb2RlYyBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgYnl0ZXMgc2VudCBpcyAwIGluIHRoZSBvdXRib3VuZC1ydHBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBhcmUgZm9yY2luZyBoMjY0IGNvZGVjIGZvciBpcGFkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZENvZGVjID0gJ0gyNjQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3NOYW1lID09PSAnYW5kcm9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWRDb2RlYyA9ICdWUDgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjUHJlZmVyZW5jZXMgPSB0aGlzLmdldENvZGVjUHJlZmVyZW5jZXModHJhY2tUeXBlLCBwcmVmZXJyZWRDb2RlYyk7XG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuIGZvciAnZW5kZWQnIGV2ZW50IG9uIHRoZSB0cmFjayBhcyBpdCBtaWdodCBiZSBlbmRlZCBhYnJ1cHRseVxuICAgICAgICAgICAgICAgIC8vIGJ5IGFuIGV4dGVybmFsIGZhY3RvciBhcyBwZXJtaXNzaW9uIHJldm9rZXMsIGRldmljZSBkaXNjb25uZWN0ZWQsIGV0Yy5cbiAgICAgICAgICAgICAgICAvLyBrZWVwIGluIG1pbmQgdGhhdCBgdHJhY2suc3RvcCgpYCBkb2Vzbid0IHRyaWdnZXIgdGhpcyBldmVudC5cbiAgICAgICAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgICAgIGlmICghdHJhY2suZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIgPSB0aGlzLnBjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtczogdHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8gfHwgdHJhY2tUeXBlID09PSBUcmFja1R5cGUuU0NSRUVOX1NIQVJFXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFttZWRpYVN0cmVhbV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzZW5kRW5jb2RpbmdzOiB2aWRlb0VuY29kaW5ncyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgQWRkZWQgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gdHJhbnNjZWl2ZXJgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY2VpdmVySW5pdE9yZGVyLnB1c2godHJhY2tUeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSA9IHRyYW5zY2VpdmVyO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaE9wdGlvbnNQZXJUcmFja1R5cGUuc2V0KHRyYWNrVHlwZSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgaWYgKCdzZXRDb2RlY1ByZWZlcmVuY2VzJyBpbiB0cmFuc2NlaXZlciAmJiBjb2RlY1ByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdpbmZvJywgYFNldHRpbmcgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gY29kZWMgcHJlZmVyZW5jZXNgLCBjb2RlY1ByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2V0Q29kZWNQcmVmZXJlbmNlcyhjb2RlY1ByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1RyYWNrID0gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrO1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN0b3AgdGhlIHRyYWNrIGlmIHdlIGFyZSByZS1wdWJsaXNoaW5nIHRoZSBzYW1lIHRyYWNrXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVHJhY2sgJiYgcHJldmlvdXNUcmFjayAhPT0gdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUcmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFjay5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubm90aWZ5VHJhY2tNdXRlU3RhdGVDaGFuZ2VkKG1lZGlhU3RyZWFtLCB0cmFja1R5cGUsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIHRyYWNrIHR5cGUgdG8gdGhlIFNGVSwgaWYgaXQgaXMgY3VycmVudGx5IGJlaW5nIHB1Ymxpc2hlZC5cbiAgICAgICAgICogVW5kZXJseWluZyB0cmFjayB3aWxsIGJlIHN0b3BwZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgcHVibGlzaGVyLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSB0cmFjayB0eXBlIHRvIHVucHVibGlzaC5cbiAgICAgICAgICogQHBhcmFtIHN0b3BUcmFjayBzcGVjaWZpZXMgd2hldGhlciB0cmFjayBzaG91bGQgYmUgc3RvcHBlZCBvciBqdXN0IGRpc2FibGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVucHVibGlzaFN0cmVhbSA9IGFzeW5jICh0cmFja1R5cGUsIHN0b3BUcmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLnBjXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQgPT09IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVt0cmFja1R5cGVdICYmIHQuc2VuZGVyLnRyYWNrKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjayAmJlxuICAgICAgICAgICAgICAgIChzdG9wVHJhY2tcbiAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2xpdmUnXG4gICAgICAgICAgICAgICAgICAgIDogdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmVuYWJsZWQpKSB7XG4gICAgICAgICAgICAgICAgc3RvcFRyYWNrXG4gICAgICAgICAgICAgICAgICAgID8gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLnN0b3AoKVxuICAgICAgICAgICAgICAgICAgICA6ICh0cmFuc2NlaXZlci5zZW5kZXIudHJhY2suZW5hYmxlZCA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIG5vdGlmeSBTRlUgaWYgdW5wdWJsaXNoaW5nIGluIHJlc3BvbnNlIHRvIHJlbW90ZSBzb2Z0IG11dGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5sb2NhbFBhcnRpY2lwYW50Py5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXModHJhY2tUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeVRyYWNrTXV0ZVN0YXRlQ2hhbmdlZCh1bmRlZmluZWQsIHRyYWNrVHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB0cmFjayB0eXBlIGlzIGN1cnJlbnRseSBiZWluZyBwdWJsaXNoZWQgdG8gdGhlIFNGVS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUgdHJhY2sgdHlwZSB0byBjaGVjay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNQdWJsaXNoaW5nID0gKHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUgPSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXTtcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlckZvclRyYWNrVHlwZSAmJiB0cmFuc2NlaXZlckZvclRyYWNrVHlwZS5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0cmFuc2NlaXZlckZvclRyYWNrVHlwZS5zZW5kZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuICghIXNlbmRlci50cmFjayAmJlxuICAgICAgICAgICAgICAgICAgICBzZW5kZXIudHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2xpdmUnICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlci50cmFjay5lbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdHJhY2sgdHlwZSBpcyBjdXJyZW50bHkgbGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSB0cmFjayB0eXBlIHRvIGNoZWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0xpdmUgPSAodHJhY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlckZvclRyYWNrVHlwZSA9IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVt0cmFja1R5cGVdO1xuICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlICYmIHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlLnNlbmRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRlciA9IHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlLnNlbmRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFzZW5kZXIudHJhY2sgJiYgc2VuZGVyLnRyYWNrLnJlYWR5U3RhdGUgPT09ICdsaXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub3RpZnlUcmFja011dGVTdGF0ZUNoYW5nZWQgPSBhc3luYyAobWVkaWFTdHJlYW0sIHRyYWNrVHlwZSwgaXNNdXRlZCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZnVDbGllbnQudXBkYXRlTXV0ZVN0YXRlKHRyYWNrVHlwZSwgaXNNdXRlZCk7XG4gICAgICAgICAgICBjb25zdCBhdWRpb09yVmlkZW9PclNjcmVlblNoYXJlU3RyZWFtID0gdHJhY2tUeXBlVG9QYXJ0aWNpcGFudFN0cmVhbUtleSh0cmFja1R5cGUpO1xuICAgICAgICAgICAgaWYgKGlzTXV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHRoaXMuc2Z1Q2xpZW50LnNlc3Npb25JZCwgKHApID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlZFRyYWNrczogcC5wdWJsaXNoZWRUcmFja3MuZmlsdGVyKCh0KSA9PiB0ICE9PSB0cmFja1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBbYXVkaW9PclZpZGVvT3JTY3JlZW5TaGFyZVN0cmVhbV06IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHRoaXMuc2Z1Q2xpZW50LnNlc3Npb25JZCwgKHApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlZFRyYWNrczogcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXModHJhY2tUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcC5wdWJsaXNoZWRUcmFja3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFsuLi5wLnB1Ymxpc2hlZFRyYWNrcywgdHJhY2tUeXBlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdWRpb09yVmlkZW9PclNjcmVlblNoYXJlU3RyZWFtXTogbWVkaWFTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyBwdWJsaXNoaW5nIGFsbCB0cmFja3MgYW5kIHN0b3AgYWxsIHRyYWNrcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcFB1Ymxpc2hpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnU3RvcHBpbmcgcHVibGlzaGluZyBhbGwgdHJhY2tzJyk7XG4gICAgICAgICAgICB0aGlzLnBjLmdldFNlbmRlcnMoKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgcy50cmFjaz8uc3RvcCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBjLnNpZ25hbGluZ1N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBjLnJlbW92ZVRyYWNrKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZGVvUHVibGlzaFF1YWxpdHkgPSBhc3luYyAoZW5hYmxlZExheWVycykgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDMoJ2luZm8nLCAnVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgcmVxdWVzdGVkIGxheWVycyBieSBTRlU6JywgZW5hYmxlZExheWVycyk7XG4gICAgICAgICAgICBjb25zdCB2aWRlb1NlbmRlciA9IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVtUcmFja1R5cGUuVklERU9dPy5zZW5kZXI7XG4gICAgICAgICAgICBpZiAoIXZpZGVvU2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCAnVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgbm8gdmlkZW8gc2VuZGVyIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHZpZGVvU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZW5jb2RpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCd3YXJuJywgJ1VwZGF0ZSBwdWJsaXNoIHF1YWxpdHksIE5vIHN1aXRhYmxlIHZpZGVvIGVuY29kaW5nIHF1YWxpdHkgZm91bmQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGVuYWJsZWRSaWRzID0gZW5hYmxlZExheWVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGx5KSA9PiBseS5hY3RpdmUpXG4gICAgICAgICAgICAgICAgLm1hcCgobHkpID0+IGx5Lm5hbWUpO1xuICAgICAgICAgICAgcGFyYW1zLmVuY29kaW5ncy5mb3JFYWNoKChlbmMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBmbGlwICdhY3RpdmUnIGZsYWcgb25seSB3aGVuIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEVuYWJsZSA9IGVuYWJsZWRSaWRzLmluY2x1ZGVzKGVuYy5yaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRFbmFibGUgIT09IGVuYy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jLmFjdGl2ZSA9IHNob3VsZEVuYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRFbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheWVyID0gZW5hYmxlZExheWVycy5maW5kKCh2bHMpID0+IHZscy5uYW1lID09PSBlbmMucmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5zY2FsZVJlc29sdXRpb25Eb3duQnkgPj0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLnNjYWxlUmVzb2x1dGlvbkRvd25CeSAhPT0gZW5jLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsICdbZHluYXNjYWxlXTogc2V0dGluZyBzY2FsZVJlc29sdXRpb25Eb3duQnkgZnJvbSBzZXJ2ZXInLCAnbGF5ZXInLCBsYXllci5uYW1lLCAnc2NhbGUtcmVzb2x1dGlvbi1kb3duLWJ5JywgbGF5ZXIuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmMuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gbGF5ZXIuc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLm1heEJpdHJhdGUgPiAwICYmIGxheWVyLm1heEJpdHJhdGUgIT09IGVuYy5tYXhCaXRyYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgJ1tkeW5hc2NhbGVdIHNldHRpbmcgbWF4LWJpdHJhdGUgZnJvbSB0aGUgc2VydmVyJywgJ2xheWVyJywgbGF5ZXIubmFtZSwgJ21heC1iaXRyYXRlJywgbGF5ZXIubWF4Qml0cmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jLm1heEJpdHJhdGUgPSBsYXllci5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLm1heEZyYW1lcmF0ZSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5tYXhGcmFtZXJhdGUgIT09IGVuYy5tYXhGcmFtZXJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnW2R5bmFzY2FsZV06IHNldHRpbmcgbWF4RnJhbWVyYXRlIGZyb20gc2VydmVyJywgJ2xheWVyJywgbGF5ZXIubmFtZSwgJ21heC1mcmFtZXJhdGUnLCBsYXllci5tYXhGcmFtZXJhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYy5tYXhGcmFtZXJhdGUgPSBsYXllci5tYXhGcmFtZXJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUxheWVycyA9IHBhcmFtcy5lbmNvZGluZ3MuZmlsdGVyKChlKSA9PiBlLmFjdGl2ZSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHZpZGVvU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnaW5mbycsIGBVcGRhdGUgcHVibGlzaCBxdWFsaXR5LCBlbmFibGVkIHJpZHM6IGAsIGFjdGl2ZUxheWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnaW5mbycsIGBVcGRhdGUgcHVibGlzaCBxdWFsaXR5LCBubyBjaGFuZ2U6IGAsIGFjdGl2ZUxheWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpYCBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHNlbGVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFN0YXRzID0gKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYy5nZXRTdGF0cyhzZWxlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29kZWNQcmVmZXJlbmNlcyA9ICh0cmFja1R5cGUsIHByZWZlcnJlZENvZGVjKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJlZmVycmVkQ29kZWNzKCd2aWRlbycsIHByZWZlcnJlZENvZGVjIHx8ICd2cDgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5BVURJTykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBdWRpb0NvZGVjID0gdGhpcy5pc1JlZEVuYWJsZWQgPyAncmVkJyA6ICdvcHVzJztcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlY1RvUmVtb3ZlID0gIXRoaXMuaXNSZWRFbmFibGVkID8gJ3JlZCcgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByZWZlcnJlZENvZGVjcygnYXVkaW8nLCBwcmVmZXJyZWRDb2RlYyA/PyBkZWZhdWx0QXVkaW9Db2RlYywgY29kZWNUb1JlbW92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25JY2VDYW5kaWRhdGUgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjYW5kaWRhdGUgfSA9IGU7XG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsICdudWxsIGljZSBjYW5kaWRhdGUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNmdUNsaWVudC5pY2VUcmlja2xlKHtcbiAgICAgICAgICAgICAgICBpY2VDYW5kaWRhdGU6IGdldEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpLFxuICAgICAgICAgICAgICAgIHBlZXJUeXBlOiBQZWVyVHlwZS5QVUJMSVNIRVJfVU5TUEVDSUZJRUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBTRlUgY2xpZW50IHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U2Z1Q2xpZW50ID0gKHNmdUNsaWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIG1pZ3JhdGlvbiBvZiB0aGlzIHB1Ymxpc2hlciBpbnN0YW5jZSB0byBhIG5ldyBTRlUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluaXRpYXRlcyBhIG5ldyBgaWNlUmVzdGFydGAgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlIHdpdGggdGhlIG5ldyBTRlUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZnVDbGllbnQgdGhlIG5ldyBTRlUgY2xpZW50IHRvIG1pZ3JhdGUgdG8uXG4gICAgICAgICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBuZXcgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWlncmF0ZVRvID0gYXN5bmMgKHNmdUNsaWVudCwgY29ubmVjdGlvbkNvbmZpZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgICAgICB0aGlzLnBjLnNldENvbmZpZ3VyYXRpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbiA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZXN0YXJ0SWNlID0gdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJlc3RhcnRJY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWdvdGlhdGUgb25seSBpZiB0aGVyZSBhcmUgdHJhY2tzIHRvIHB1Ymxpc2hcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5lZ290aWF0ZSh7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXN0YXJ0cyB0aGUgSUNFIGNvbm5lY3Rpb24gYW5kIHJlbmVnb3RpYXRlcyB3aXRoIHRoZSBTRlUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3RhcnRJY2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnUmVzdGFydGluZyBJQ0UgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsaW5nU3RhdGUgPSB0aGlzLnBjLnNpZ25hbGluZ1N0YXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJY2VSZXN0YXJ0aW5nIHx8IHNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnSUNFIHJlc3RhcnQgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubmVnb3RpYXRlKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbk5lZ290aWF0aW9uTmVlZGVkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYXRlcyBhIG5ldyBvZmZlci9hbnN3ZXIgZXhjaGFuZ2Ugd2l0aCB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBTRlUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25hbCBvZmZlciBvcHRpb25zIHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmVnb3RpYXRlID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNJY2VSZXN0YXJ0aW5nID0gb3B0aW9ucz8uaWNlUmVzdGFydCA/PyBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5wYy5jcmVhdGVPZmZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGxldCBzZHAgPSB0aGlzLm11bmdlQ29kZWNzKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBpZiAoc2RwICYmIHRoaXMuaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJT107XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyICYmIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWQgPSB0cmFuc2NlaXZlci5taWQgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFjdE1pZChzZHAsIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjaywgVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTyk7XG4gICAgICAgICAgICAgICAgICAgIHNkcCA9IGVuYWJsZUhpZ2hRdWFsaXR5QXVkaW8oc2RwLCBtaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB0aGUgbXVuZ2VkIFNEUCBiYWNrIHRvIHRoZSBvZmZlclxuICAgICAgICAgICAgb2ZmZXIuc2RwID0gc2RwO1xuICAgICAgICAgICAgY29uc3QgdHJhY2tJbmZvcyA9IHRoaXMuZ2V0Q3VycmVudFRyYWNrSW5mb3Mob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGlmICh0cmFja0luZm9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaW5pdGlhdGUgbmVnb3RpYXRpb24gd2l0aG91dCBhbm5vdW5jaW5nIGFueSB0cmFja3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnNmdUNsaWVudC5zZXRQdWJsaXNoZXIoe1xuICAgICAgICAgICAgICAgIHNkcDogb2ZmZXIuc2RwIHx8ICcnLFxuICAgICAgICAgICAgICAgIHRyYWNrczogdHJhY2tJbmZvcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Fuc3dlcicsXG4gICAgICAgICAgICAgICAgICAgIHNkcDogcmVzcG9uc2Uuc2RwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZXJyb3InLCBgc2V0UmVtb3RlRGVzY3JpcHRpb24gZXJyb3JgLCB7XG4gICAgICAgICAgICAgICAgICAgIHNkcDogcmVzcG9uc2Uuc2RwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNJY2VSZXN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNmdUNsaWVudC5pY2VUcmlja2xlQnVmZmVyLnB1Ymxpc2hlckNhbmRpZGF0ZXMuc3Vic2NyaWJlKGFzeW5jIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY2VDYW5kaWRhdGUgPSBKU09OLnBhcnNlKGNhbmRpZGF0ZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnd2FybicsIGBJQ0UgY2FuZGlkYXRlIGVycm9yYCwgW2UsIGNhbmRpZGF0ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm11bmdlQ29kZWNzID0gKHNkcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNkcCkge1xuICAgICAgICAgICAgICAgIHNkcCA9IHRvZ2dsZUR0eChzZHAsIHRoaXMuaXNEdHhFbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZHA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXh0cmFjdE1pZCA9IChzZHAsIHRyYWNrLCB0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGlmICghc2RwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCAnTm8gU0RQIGZvdW5kLiBSZXR1cm5pbmcgZW1wdHkgbWlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYE5vICdtaWQnIGZvdW5kIGZvciB0cmFjay4gVHJ5aW5nIHRvIGZpbmQgaXQgZnJvbSB0aGUgT2ZmZXIgU0RQYCk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZHAgPSBTRFAucGFyc2Uoc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhID0gcGFyc2VkU2RwLm1lZGlhLmZpbmQoKG0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG0udHlwZSA9PT0gdHJhY2sua2luZCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBgbXNpZGAgaXMgbm90IHByZXNlbnQsIHdlIGFzc3VtZSB0aGF0IHRoZSB0cmFjayBpcyB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgIChtLm1zaWQ/LmluY2x1ZGVzKHRyYWNrLmlkKSA/PyB0cnVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVkaWE/Lm1pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgTm8gbWlkIGZvdW5kIGluIFNEUCBmb3IgdHJhY2sgdHlwZSAke3RyYWNrLmtpbmR9IGFuZCBpZCAke3RyYWNrLmlkfS4gQXR0ZW1wdGluZyB0byBmaW5kIGEgaGV1cmlzdGljIG1pZGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhldXJpc3RpY01pZCA9IHRoaXMudHJhbnNjZWl2ZXJJbml0T3JkZXIuaW5kZXhPZih0cmFja1R5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChoZXVyaXN0aWNNaWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaGV1cmlzdGljTWlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgJ05vIGhldXJpc3RpYyBtaWQgZm91bmQuIFJldHVybmluZyBlbXB0eSBtaWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKG1lZGlhLm1pZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFRyYWNrSW5mb3MgPSAoc2RwKSA9PiB7XG4gICAgICAgICAgICBzZHAgPSBzZHAgfHwgdGhpcy5wYy5sb2NhbERlc2NyaXB0aW9uPy5zZHA7XG4gICAgICAgICAgICBjb25zdCB7IHNldHRpbmdzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHNldHRpbmdzPy52aWRlby50YXJnZXRfcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBjXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodCkgPT4gdC5kaXJlY3Rpb24gPT09ICdzZW5kb25seScgJiYgdC5zZW5kZXIudHJhY2spXG4gICAgICAgICAgICAgICAgLm1hcCgodHJhbnNjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja1R5cGUgPSBOdW1iZXIoT2JqZWN0LmtleXModGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5KS5maW5kKChrZXkpID0+IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVtrZXldID09PSB0cmFuc2NlaXZlcikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrO1xuICAgICAgICAgICAgICAgIGxldCBvcHRpbWFsTGF5ZXJzO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjay5yZWFkeVN0YXRlID09PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVibGlzaE9wdHMgPSB0aGlzLnB1Ymxpc2hPcHRpb25zUGVyVHJhY2tUeXBlLmdldCh0cmFja1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpbWFsTGF5ZXJzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmaW5kT3B0aW1hbFZpZGVvTGF5ZXJzKHRyYWNrLCB0YXJnZXRSZXNvbHV0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJhY2tUeXBlID09PSBUcmFja1R5cGUuU0NSRUVOX1NIQVJFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmluZE9wdGltYWxTY3JlZW5TaGFyaW5nTGF5ZXJzKHRyYWNrLCBwdWJsaXNoT3B0cz8uc2NyZWVuU2hhcmVTZXR0aW5ncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja0xheWVyc0NhY2hlW3RyYWNrVHlwZV0gPSBvcHRpbWFsTGF5ZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgcmVwb3J0IHRoZSBsYXN0IGtub3duIG9wdGltYWwgbGF5ZXJzIGZvciBlbmRlZCB0cmFja3NcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1hbExheWVycyA9IHRoaXMudHJhY2tMYXllcnNDYWNoZVt0cmFja1R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgVHJhY2sgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gaXMgZW5kZWQuIEFubm91bmNpbmcgbGFzdCBrbm93biBvcHRpbWFsIGxheWVyc2AsIG9wdGltYWxMYXllcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcnMgPSBvcHRpbWFsTGF5ZXJzLm1hcCgob3B0aW1hbExheWVyKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICByaWQ6IG9wdGltYWxMYXllci5yaWQgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIGJpdHJhdGU6IG9wdGltYWxMYXllci5tYXhCaXRyYXRlIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIGZwczogb3B0aW1hbExheWVyLm1heEZyYW1lcmF0ZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiB0aGlzLnJpZFRvVmlkZW9RdWFsaXR5KG9wdGltYWxMYXllci5yaWQgfHwgJycpLFxuICAgICAgICAgICAgICAgICAgICB2aWRlb0RpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG9wdGltYWxMYXllci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW1hbExheWVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdWRpb1RyYWNrID0gW1xuICAgICAgICAgICAgICAgICAgICBUcmFja1R5cGUuQVVESU8sXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8sXG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyh0cmFja1R5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU3RlcmVvID0gaXNBdWRpb1RyYWNrICYmIHRyYWNrU2V0dGluZ3MuY2hhbm5lbENvdW50ID09PSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrLmlkLFxuICAgICAgICAgICAgICAgICAgICBsYXllcnM6IGxheWVycyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICBtaWQ6IHRyYW5zY2VpdmVyLm1pZCA/PyB0aGlzLmV4dHJhY3RNaWQoc2RwLCB0cmFjaywgdHJhY2tUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcmVvOiBpc1N0ZXJlbyxcbiAgICAgICAgICAgICAgICAgICAgZHR4OiBpc0F1ZGlvVHJhY2sgJiYgdGhpcy5pc0R0eEVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlZDogaXNBdWRpb1RyYWNrICYmIHRoaXMuaXNSZWRFbmFibGVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUNhbmRpZGF0ZUVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGUgaW5zdGFuY2VvZiBSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQgJiZcbiAgICAgICAgICAgICAgICBgJHtlLmVycm9yQ29kZX06ICR7ZS5lcnJvclRleHR9YDtcbiAgICAgICAgICAgIGNvbnN0IGljZVN0YXRlID0gdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBsb2dMZXZlbCA9IGljZVN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBpY2VTdGF0ZSA9PT0gJ2NoZWNraW5nJyA/ICdkZWJ1ZycgOiAnd2Fybic7XG4gICAgICAgICAgICBsb2dnZXIkMyhsb2dMZXZlbCwgYElDRSBDYW5kaWRhdGUgZXJyb3JgLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsIGBJQ0UgQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkIHRvYCwgc3RhdGUpO1xuICAgICAgICAgICAgY29uc3QgaGFzTmV0d29ya0Nvbm5lY3Rpb24gPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLk9GRkxJTkU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCBgQXR0ZW1wdGluZyB0byByZXN0YXJ0IElDRWApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEljZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdlcnJvcicsIGBJQ0UgcmVzdGFydCBlcnJvcmAsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmIGhhc05ldHdvcmtDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBpbiBgZGlzY29ubmVjdGVkYCBzdGF0ZSwgdGhlIGJyb3dzZXIgbWF5IHJlY292ZXIgYXV0b21hdGljYWxseSxcbiAgICAgICAgICAgICAgICAvLyBoZW5jZSwgd2UgZGVsYXkgdGhlIElDRSByZXN0YXJ0XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCBgU2NoZWR1bGluZyBJQ0UgcmVzdGFydCBpbiAke3RoaXMuaWNlUmVzdGFydERlbGF5fSBtcy5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmljZVJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzdGF0ZSBpcyBzdGlsbCBgZGlzY29ubmVjdGVkYCBvciBgZmFpbGVkYFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyB0aGUgY29ubmVjdGlvbiBtYXkgaGF2ZSByZWNvdmVyZWQgKG9yIGZhaWxlZCkgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0SWNlKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnZXJyb3InLCBgSUNFIHJlc3RhcnQgZXJyb3JgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYFNjaGVkdWxlZCBJQ0UgcmVzdGFydDogY29ubmVjdGlvbiByZWNvdmVyZWQsIGNhbmNlbGVkLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5pY2VSZXN0YXJ0RGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgSUNFIEdhdGhlcmluZyBTdGF0ZWAsIHRoaXMucGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2lnbmFsaW5nU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgU2lnbmFsaW5nIHN0YXRlIGNoYW5nZWRgLCB0aGlzLnBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yaWRUb1ZpZGVvUXVhbGl0eSA9IChyaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByaWQgPT09ICdxJ1xuICAgICAgICAgICAgICAgID8gVmlkZW9RdWFsaXR5LkxPV19VTlNQRUNJRklFRFxuICAgICAgICAgICAgICAgIDogcmlkID09PSAnaCdcbiAgICAgICAgICAgICAgICAgICAgPyBWaWRlb1F1YWxpdHkuTUlEXG4gICAgICAgICAgICAgICAgICAgIDogVmlkZW9RdWFsaXR5LkhJR0g7IC8vIGRlZmF1bHQgdG8gSElHSFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBjID0gdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5pc0R0eEVuYWJsZWQgPSBpc0R0eEVuYWJsZWQ7XG4gICAgICAgIHRoaXMuaXNSZWRFbmFibGVkID0gaXNSZWRFbmFibGVkO1xuICAgICAgICB0aGlzLmljZVJlc3RhcnREZWxheSA9IGljZVJlc3RhcnREZWxheTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZU9uSWNlUmVzdGFydCA9IGRpc3BhdGNoZXIub24oJ2ljZVJlc3RhcnQnLCBhc3luYyAoaWNlUmVzdGFydCkgPT4ge1xuICAgICAgICAgICAgaWYgKGljZVJlc3RhcnQucGVlclR5cGUgIT09IFBlZXJUeXBlLlBVQkxJU0hFUl9VTlNQRUNJRklFRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRJY2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBsb2dnZXIkMiA9IGdldExvZ2dlcihbJ1N1YnNjcmliZXInXSk7XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIGBSVENQZWVyQ29ubmVjdGlvbmAgdGhhdCBoYW5kbGVzIHRoZSBpbmNvbWluZ1xuICogbWVkaWEgc3RyZWFtcyBmcm9tIHRoZSBTRlUuXG4gKi9cbmNsYXNzIFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3Rpb25Db25maWd1cmF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wYy5nZXRDb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbkNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgYFN1YnNjcmliZXJgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNmdUNsaWVudCB0aGUgU0ZVIGNsaWVudCB0byB1c2UuXG4gICAgICogQHBhcmFtIGRpc3BhdGNoZXIgdGhlIGRpc3BhdGNoZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgb2YgdGhlIGNhbGwuXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWcgdGhlIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAgICogQHBhcmFtIGljZVJlc3RhcnREZWxheSB0aGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlc3RhcnRpbmcgSUNFIHdoZW4gY29ubmVjdGlvbiBnb2VzIHRvIGBkaXNjb25uZWN0ZWRgIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgc2Z1Q2xpZW50LCBkaXNwYXRjaGVyLCBzdGF0ZSwgY29ubmVjdGlvbkNvbmZpZywgaWNlUmVzdGFydERlbGF5ID0gMjUwMCwgfSkge1xuICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBgUlRDUGVlckNvbm5lY3Rpb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbiA9IChjb25uZWN0aW9uQ29uZmlnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Db25maWd1cmF0aW9uID0gY29ubmVjdGlvbkNvbmZpZztcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIHRoaXMub25JY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLmhhbmRsZU9uVHJhY2spO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlZXJyb3InLCB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3IpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMub25JY2VHYXRoZXJpbmdTdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gcGM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIGBSVENQZWVyQ29ubmVjdGlvbmAgYW5kIHVuc3Vic2NyaWJlcyBmcm9tIHRoZSBkaXNwYXRjaGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmljZVJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlck9uU3Vic2NyaWJlck9mZmVyKCk7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJPbkljZVJlc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMucGMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgYFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKClgIG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0gc2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0U3RhdHMgPSAoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBTRlUgY2xpZW50IHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U2Z1Q2xpZW50ID0gKHNmdUNsaWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaWdyYXRlcyB0aGUgc3Vic2NyaWJlciB0byBhIG5ldyBTRlUgY2xpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBuZXcgU0ZVIGNsaWVudCB0byBtaWdyYXRlIHRvLlxuICAgICAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkNvbmZpZyB0aGUgbmV3IGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pZ3JhdGVUbyA9IChzZnVDbGllbnQsIGNvbm5lY3Rpb25Db25maWcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2Z1Q2xpZW50KHNmdUNsaWVudCk7XG4gICAgICAgICAgICAvLyB3aGVuIG1pZ3JhdGluZywgd2Ugd2FudCB0byBrZWVwIHRoZSBwcmV2aW91cyBzdWJzY3JpYmVyIG9wZW5cbiAgICAgICAgICAgIC8vIHVudGlsIHRoZSBuZXcgb25lIGlzIGNvbm5lY3RlZFxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQQyA9IHRoaXMucGM7XG4gICAgICAgICAgICAvLyB3ZSBrZWVwIGEgcmVjb3JkIG9mIHByZXZpb3VzbHkgYXZhaWxhYmxlIHZpZGVvIHRyYWNrc1xuICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gbW9uaXRvciB3aGVuIHRoZXkgYmVjb21lIGF2YWlsYWJsZSBvbiB0aGUgbmV3XG4gICAgICAgICAgICAvLyBzdWJzY3JpYmVyIGFuZCBjbG9zZSB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICAgICAgY29uc3QgdHJhY2tJZHNUb01pZ3JhdGUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBwcmV2aW91c1BDLmdldFJlY2VpdmVycygpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoci50cmFjay5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSWRzVG9NaWdyYXRlLmFkZChyLnRyYWNrLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCB1cCBhIG5ldyBzdWJzY3JpYmVyIHBlZXIgY29ubmVjdGlvbiwgY29uZmlndXJlZCB0byBjb25uZWN0XG4gICAgICAgICAgICAvLyB0byB0aGUgbmV3IFNGVSBub2RlXG4gICAgICAgICAgICBjb25zdCBwYyA9IHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBsZXQgbWlncmF0aW9uVGltZW91dElkO1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cE1pZ3JhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1BDLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1pZ3JhdGlvblRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2hlbiBtaWdyYXRpbmcsIHdlIHdhbnQgdG8ga2VlcCB0cmFjayBvZiB0aGUgdmlkZW8gdHJhY2tzXG4gICAgICAgICAgICAvLyB0aGF0IGFyZSBtaWdyYXRpbmcgdG8gdGhlIG5ldyBzdWJzY3JpYmVyLlxuICAgICAgICAgICAgLy8gT25jZSBhbGwgb2YgdGhlbSBhcmUgYXZhaWxhYmxlLCB3ZSBjYW4gY2xvc2UgdGhlIHByZXZpb3VzIHN1YnNjcmliZXIuXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVUcmFja01pZ3JhdGlvbiA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgYFtNaWdyYXRpb25dOiBNaWdyYXRlZCB0cmFjazogJHtlLnRyYWNrLmlkfSwgJHtlLnRyYWNrLmtpbmR9YCk7XG4gICAgICAgICAgICAgICAgdHJhY2tJZHNUb01pZ3JhdGUuZGVsZXRlKGUudHJhY2suaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja0lkc1RvTWlncmF0ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsIGBbTWlncmF0aW9uXTogTWlncmF0aW9uIGNvbXBsZXRlYCk7XG4gICAgICAgICAgICAgICAgICAgIHBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgaGFuZGxlVHJhY2tNaWdyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwTWlncmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdoZW4gbWlncmF0aW5nLCB3ZSB3YW50IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNvbm5lY3Rpb24gc3RhdGVcbiAgICAgICAgICAgIC8vIG9mIHRoZSBuZXcgc3Vic2NyaWJlci5cbiAgICAgICAgICAgIC8vIE9uY2UgaXQgaXMgY29ubmVjdGVkLCB3ZSBnaXZlIGl0IGEgMi1zZWNvbmQgZ3JhY2UgcGVyaW9kIHRvIHJlY2VpdmVcbiAgICAgICAgICAgIC8vIGFsbCB0aGUgdmlkZW8gdHJhY2tzIHRoYXQgYXJlIG1pZ3JhdGluZyBmcm9tIHRoZSBwcmV2aW91cyBzdWJzY3JpYmVyLlxuICAgICAgICAgICAgLy8gQWZ0ZXIgdGhpcyB0aHJlc2hvbGQsIHdlIGFicnVwdGx5IGNsb3NlIHRoZSBwcmV2aW91cyBzdWJzY3JpYmVyLlxuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYy5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pZ3JhdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCBoYW5kbGVUcmFja01pZ3JhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwTWlncmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgICAgICAgICBwYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBoYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIGhhbmRsZVRyYWNrTWlncmF0aW9uKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBQZWVyQ29ubmVjdGlvbiBpbnN0YW5jZVxuICAgICAgICAgICAgdGhpcy5wYyA9IHBjO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdGFydHMgdGhlIElDRSBjb25uZWN0aW9uIGFuZCByZW5lZ290aWF0ZXMgd2l0aCB0aGUgU0ZVLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXN0YXJ0SWNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgJ1Jlc3RhcnRpbmcgSUNFIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBjLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1yZW1vdGUtb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgJ0lDRSByZXN0YXJ0IGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0lzSWNlUmVzdGFydGluZyA9IHRoaXMuaXNJY2VSZXN0YXJ0aW5nO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZnVDbGllbnQuaWNlUmVzdGFydCh7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJUeXBlOiBQZWVyVHlwZS5TVUJTQ1JJQkVSLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSwgYXMgb3VyIGludGVudCBmb3IgcmVzdGFydGluZyBJQ0UgZmFpbGVkXG4gICAgICAgICAgICAgICAgdGhpcy5pc0ljZVJlc3RhcnRpbmcgPSBwcmV2aW91c0lzSWNlUmVzdGFydGluZztcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZU9uVHJhY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3ByaW1hcnlTdHJlYW1dID0gZS5zdHJlYW1zO1xuICAgICAgICAgICAgLy8gZXhhbXBsZTogYGUzZjZhYWY4LWIwM2QtNDkxMS1iZTM2LTgzZjQ3ZDM3YTc2YTpUUkFDS19UWVBFX1ZJREVPYFxuICAgICAgICAgICAgY29uc3QgW3RyYWNrSWQsIHRyYWNrVHlwZV0gPSBwcmltYXJ5U3RyZWFtLmlkLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudFRvVXBkYXRlID0gdGhpcy5zdGF0ZS5wYXJ0aWNpcGFudHMuZmluZCgocCkgPT4gcC50cmFja0xvb2t1cFByZWZpeCA9PT0gdHJhY2tJZCk7XG4gICAgICAgICAgICBsb2dnZXIkMignZGVidWcnLCBgW29uVHJhY2tdOiBHb3QgcmVtb3RlICR7dHJhY2tUeXBlfSB0cmFjayBmb3IgdXNlcklkOiAke3BhcnRpY2lwYW50VG9VcGRhdGU/LnVzZXJJZH1gLCBlLnRyYWNrLmlkLCBlLnRyYWNrKTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnRUb1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdlcnJvcicsIGBbb25UcmFja106IFJlY2VpdmVkIHRyYWNrIGZvciB1bmtub3duIHBhcnRpY2lwYW50OiAke3RyYWNrSWR9YCwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS50cmFjay5hZGRFdmVudExpc3RlbmVyKCdtdXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdpbmZvJywgYFtvblRyYWNrXTogVHJhY2sgbXV0ZWQ6ICR7cGFydGljaXBhbnRUb1VwZGF0ZS51c2VySWR9ICR7dHJhY2tUeXBlfToke3RyYWNrSWR9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUudHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdpbmZvJywgYFtvblRyYWNrXTogVHJhY2sgdW5tdXRlZDogJHtwYXJ0aWNpcGFudFRvVXBkYXRlLnVzZXJJZH0gJHt0cmFja1R5cGV9OiR7dHJhY2tJZH1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZS50cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMignaW5mbycsIGBbb25UcmFja106IFRyYWNrIGVuZGVkOiAke3BhcnRpY2lwYW50VG9VcGRhdGUudXNlcklkfSAke3RyYWNrVHlwZX06JHt0cmFja0lkfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW1LaW5kUHJvcCA9IHtcbiAgICAgICAgICAgICAgICBUUkFDS19UWVBFX0FVRElPOiAnYXVkaW9TdHJlYW0nLFxuICAgICAgICAgICAgICAgIFRSQUNLX1RZUEVfVklERU86ICd2aWRlb1N0cmVhbScsXG4gICAgICAgICAgICAgICAgVFJBQ0tfVFlQRV9TQ1JFRU5fU0hBUkU6ICdzY3JlZW5TaGFyZVN0cmVhbScsXG4gICAgICAgICAgICAgICAgVFJBQ0tfVFlQRV9TQ1JFRU5fU0hBUkVfQVVESU86ICdzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtJyxcbiAgICAgICAgICAgIH1bdHJhY2tUeXBlXTtcbiAgICAgICAgICAgIGlmICghc3RyZWFtS2luZFByb3ApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMignZXJyb3InLCBgVW5rbm93biB0cmFjayB0eXBlOiAke3RyYWNrVHlwZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1N0cmVhbSA9IHBhcnRpY2lwYW50VG9VcGRhdGVbc3RyZWFtS2luZFByb3BdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2luZm8nLCBgW29uVHJhY2tdOiBDbGVhbmluZyB1cCBwcmV2aW91cyByZW1vdGUgJHtlLnRyYWNrLmtpbmR9IHRyYWNrcyBmb3IgdXNlcklkOiAke3BhcnRpY2lwYW50VG9VcGRhdGUudXNlcklkfWApO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzU3RyZWFtLnJlbW92ZVRyYWNrKHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChwYXJ0aWNpcGFudFRvVXBkYXRlLnNlc3Npb25JZCwge1xuICAgICAgICAgICAgICAgIFtzdHJlYW1LaW5kUHJvcF06IHByaW1hcnlTdHJlYW0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUNhbmRpZGF0ZSA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNhbmRpZGF0ZSB9ID0gZTtcbiAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgJ251bGwgaWNlIGNhbmRpZGF0ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LmljZVRyaWNrbGUoe1xuICAgICAgICAgICAgICAgIGljZUNhbmRpZGF0ZTogZ2V0SWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSksXG4gICAgICAgICAgICAgICAgcGVlclR5cGU6IFBlZXJUeXBlLlNVQlNDUklCRVIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uZWdvdGlhdGUgPSBhc3luYyAoc3Vic2NyaWJlck9mZmVyKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMignaW5mbycsIGBSZWNlaXZlZCBzdWJzY3JpYmVyT2ZmZXJgLCBzdWJzY3JpYmVyT2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29mZmVyJyxcbiAgICAgICAgICAgICAgICBzZHA6IHN1YnNjcmliZXJPZmZlci5zZHAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Z1Q2xpZW50LmljZVRyaWNrbGVCdWZmZXIuc3Vic2NyaWJlckNhbmRpZGF0ZXMuc3Vic2NyaWJlKGFzeW5jIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY2VDYW5kaWRhdGUgPSBKU09OLnBhcnNlKGNhbmRpZGF0ZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMignd2FybicsIGBJQ0UgY2FuZGlkYXRlIGVycm9yYCwgW2UsIGNhbmRpZGF0ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZnVDbGllbnQuc2VuZEFuc3dlcih7XG4gICAgICAgICAgICAgICAgcGVlclR5cGU6IFBlZXJUeXBlLlNVQlNDUklCRVIsXG4gICAgICAgICAgICAgICAgc2RwOiBhbnN3ZXIuc2RwIHx8ICcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsIGBJQ0UgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkYCwgc3RhdGUpO1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZyB3aGVuIElDRSBpcyByZXN0YXJ0aW5nXG4gICAgICAgICAgICBpZiAodGhpcy5pc0ljZVJlc3RhcnRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaGFzTmV0d29ya0Nvbm5lY3Rpb24gPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLk9GRkxJTkU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ3dhcm4nLCBgQXR0ZW1wdGluZyB0byByZXN0YXJ0IElDRWApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEljZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdlcnJvcicsIGBJQ0UgcmVzdGFydCBmYWlsZWRgLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiBoYXNOZXR3b3JrQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gaW4gYGRpc2Nvbm5lY3RlZGAgc3RhdGUsIHRoZSBicm93c2VyIG1heSByZWNvdmVyIGF1dG9tYXRpY2FsbHksXG4gICAgICAgICAgICAgICAgLy8gaGVuY2UsIHdlIGRlbGF5IHRoZSBJQ0UgcmVzdGFydFxuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCd3YXJuJywgYFNjaGVkdWxpbmcgSUNFIHJlc3RhcnQgaW4gJHt0aGlzLmljZVJlc3RhcnREZWxheX0gbXMuYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pY2VSZXN0YXJ0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgc3RhdGUgaXMgc3RpbGwgYGRpc2Nvbm5lY3RlZGAgb3IgYGZhaWxlZGBcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbm5lY3Rpb24gbWF5IGhhdmUgcmVjb3ZlcmVkIChvciBmYWlsZWQpIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEljZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2Vycm9yJywgYElDRSByZXN0YXJ0IGZhaWxlZGAsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMignZGVidWcnLCBgU2NoZWR1bGVkIElDRSByZXN0YXJ0OiBjb25uZWN0aW9uIHJlY292ZXJlZCwgY2FuY2VsZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgYElDRSBnYXRoZXJpbmcgc3RhdGUgY2hhbmdlZGAsIHRoaXMucGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZSBpbnN0YW5jZW9mIFJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCAmJlxuICAgICAgICAgICAgICAgIGAke2UuZXJyb3JDb2RlfTogJHtlLmVycm9yVGV4dH1gO1xuICAgICAgICAgICAgY29uc3QgaWNlU3RhdGUgPSB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ0xldmVsID0gaWNlU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IGljZVN0YXRlID09PSAnY2hlY2tpbmcnID8gJ2RlYnVnJyA6ICd3YXJuJztcbiAgICAgICAgICAgIGxvZ2dlciQyKGxvZ0xldmVsLCBgSUNFIENhbmRpZGF0ZSBlcnJvcmAsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2Z1Q2xpZW50ID0gc2Z1Q2xpZW50O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuaWNlUmVzdGFydERlbGF5ID0gaWNlUmVzdGFydERlbGF5O1xuICAgICAgICB0aGlzLnBjID0gdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyT25TdWJzY3JpYmVyT2ZmZXIgPSBkaXNwYXRjaGVyLm9uKCdzdWJzY3JpYmVyT2ZmZXInLCBhc3luYyAoc3Vic2NyaWJlck9mZmVyKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm5lZ290aWF0ZShzdWJzY3JpYmVyT2ZmZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyT25JY2VSZXN0YXJ0ID0gZGlzcGF0Y2hlci5vbignaWNlUmVzdGFydCcsIGFzeW5jIChpY2VSZXN0YXJ0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWNlUmVzdGFydC5wZWVyVHlwZSAhPT0gUGVlclR5cGUuU1VCU0NSSUJFUilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRJY2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBjcmVhdGVXZWJTb2NrZXRTaWduYWxDaGFubmVsID0gKG9wdHMpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoWydzZnUtY2xpZW50J10pO1xuICAgIGNvbnN0IHsgZW5kcG9pbnQsIG9uTWVzc2FnZSB9ID0gb3B0cztcbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoZW5kcG9pbnQpO1xuICAgIHdzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInOyAvLyBkbyB3ZSBuZWVkIHRoaXM/XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICBsb2dnZXIoJ2Vycm9yJywgJ1NpZ25hbGluZyBXUyBjaGFubmVsIGVycm9yJywgZSk7XG4gICAgfSk7XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoZSkgPT4ge1xuICAgICAgICBsb2dnZXIoJ2luZm8nLCAnU2lnbmFsaW5nIFdTIGNoYW5uZWwgaXMgY2xvc2VkJywgZSk7XG4gICAgfSk7XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIChlKSA9PiB7XG4gICAgICAgIGxvZ2dlcignaW5mbycsICdTaWduYWxpbmcgV1MgY2hhbm5lbCBpcyBvcGVuJywgZSk7XG4gICAgfSk7XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgICA/IFNmdUV2ZW50LmZyb21CaW5hcnkobmV3IFVpbnQ4QXJyYXkoZS5kYXRhKSlcbiAgICAgICAgICAgICAgICA6IFNmdUV2ZW50LmZyb21Kc29uU3RyaW5nKGUuZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIG9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIoJ2Vycm9yJywgJ0ZhaWxlZCB0byBkZWNvZGUgYSBtZXNzYWdlLiBDaGVjayB3aGV0aGVyIHRoZSBQcm90byBtb2RlbHMgbWF0Y2guJywgeyBldmVudDogZSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB3cztcbn07XG5cbmNvbnN0IHNsZWVwID0gKG0pID0+IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIG0pKTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKTtcbn1cbi8qKlxuICogQSBtYXAgb2Yga25vd24gZXJyb3IgY29kZXMuXG4gKi9cbmNvbnN0IEtub3duQ29kZXMgPSB7XG4gICAgVE9LRU5fRVhQSVJFRDogNDAsXG4gICAgV1NfQ0xPU0VEX1NVQ0NFU1M6IDEwMDAsXG4gICAgV1NfQ0xPU0VEX0FCUlVQVExZOiAxMDA2LFxuICAgIFdTX1BPTElDWV9WSU9MQVRJT046IDEwMDgsXG59O1xuLyoqXG4gKiByZXRyeUludGVydmFsIC0gQSByZXRyeSBpbnRlcnZhbCB3aGljaCBpbmNyZWFzZXMgYWNjIHRvIG51bWJlciBvZiBmYWlsdXJlc1xuICpcbiAqIEByZXR1cm4ge251bWJlcn0gRHVyYXRpb24gdG8gd2FpdCBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZnVuY3Rpb24gcmV0cnlJbnRlcnZhbChudW1iZXJPZkZhaWx1cmVzKSB7XG4gICAgLy8gdHJ5IHRvIHJlY29ubmVjdCBpbiAwLjI1LTUgc2Vjb25kcyAocmFuZG9tIHRvIHNwcmVhZCBvdXQgdGhlIGxvYWQgZnJvbSBmYWlsdXJlcylcbiAgICBjb25zdCBtYXggPSBNYXRoLm1pbig1MDAgKyBudW1iZXJPZkZhaWx1cmVzICogMjAwMCwgNTAwMCk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oTWF0aC5tYXgoMjUwLCAobnVtYmVyT2ZGYWlsdXJlcyAtIDEpICogMjAwMCksIDUwMDApO1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbik7XG59XG5mdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVVVUlEdjQoKTtcbn1cbmZ1bmN0aW9uIGhleChieXRlcykge1xuICAgIGxldCBzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzICs9IGJ5dGVzW2ldLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUR2NCgpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldFJhbmRvbUJ5dGVzKDE2KTtcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDsgLy8gdmVyc2lvblxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHhiZikgfCAweDgwOyAvLyB2YXJpYW50XG4gICAgcmV0dXJuIChoZXgoYnl0ZXMuc3ViYXJyYXkoMCwgNCkpICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgaGV4KGJ5dGVzLnN1YmFycmF5KDQsIDYpKSArXG4gICAgICAgICctJyArXG4gICAgICAgIGhleChieXRlcy5zdWJhcnJheSg2LCA4KSkgK1xuICAgICAgICAnLScgK1xuICAgICAgICBoZXgoYnl0ZXMuc3ViYXJyYXkoOCwgMTApKSArXG4gICAgICAgICctJyArXG4gICAgICAgIGhleChieXRlcy5zdWJhcnJheSgxMCwgMTYpKSk7XG59XG5mdW5jdGlvbiBnZXRSYW5kb21WYWx1ZXNXaXRoTWF0aFJhbmRvbShieXRlcykge1xuICAgIGNvbnN0IG1heCA9IE1hdGgucG93KDIsICg4ICogYnl0ZXMuYnl0ZUxlbmd0aCkgLyBieXRlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBNYXRoLnJhbmRvbSgpICogbWF4O1xuICAgIH1cbn1cbmNvbnN0IGdldFJhbmRvbVZhbHVlcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjcnlwdG8/LmdldFJhbmRvbVZhbHVlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzV2l0aE1hdGhSYW5kb207XG4gICAgfVxufSkoKTtcbmZ1bmN0aW9uIGdldFJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBnZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRFcnJvclRvSnNvbihlcnIpIHtcbiAgICBjb25zdCBqc29uT2JqID0ge307XG4gICAgaWYgKCFlcnIpXG4gICAgICAgIHJldHVybiBqc29uT2JqO1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBqc29uT2JqW2tleV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVyciwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjogJ2ZhaWxlZCB0byBzZXJpYWxpemUgdGhlIGVycm9yJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25PYmo7XG59XG4vKipcbiAqIGlzT25saW5lIHNhZmVseSByZXR1cm4gdGhlIG5hdmlnYXRvci5vbmxpbmUgdmFsdWUgZm9yIGJyb3dzZXIgZW52XG4gKiBpZiBuYXZpZ2F0b3IgaXMgbm90IGluIGdsb2JhbCBvYmplY3QsIGl0IGFsd2F5cyByZXR1cm4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc09ubGluZShsb2dnZXIpIHtcbiAgICBjb25zdCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG5hdmlnYXRvclxuICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3JcbiAgICAgICAgICAgID8gd2luZG93Lm5hdmlnYXRvclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuYXYpIHtcbiAgICAgICAgbG9nZ2VyKCd3YXJuJywgJ2lzT25saW5lIGZhaWxlZCB0byBhY2Nlc3Mgd2luZG93Lm5hdmlnYXRvciBhbmQgYXNzdW1lIGJyb3dzZXIgaXMgb25saW5lJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBSTiBuYXZpZ2F0b3IgaGFzIHVuZGVmaW5lZCBmb3Igb25MaW5lXG4gICAgaWYgKHR5cGVvZiBuYXYub25MaW5lICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBuYXYub25MaW5lO1xufVxuLyoqXG4gKiBsaXN0ZW5Gb3JDb25uZWN0aW9uQ2hhbmdlcyAtIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZmlyZWQgb24gYnJvd3NlciBnb2luZyBvbmxpbmUgb3Igb2ZmbGluZVxuICovXG5mdW5jdGlvbiBhZGRDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnMoY2IpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBjYik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBjYik7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKGNiKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgY2IpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgY2IpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgY2xpZW50IHVzZWQgZm9yIGV4Y2hhbmdpbmcgaW5mb3JtYXRpb24gd2l0aCB0aGUgU0ZVLlxuICovXG5jbGFzcyBTdHJlYW1TZnVDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU0ZVIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBldmVudCBkaXNwYXRjaGVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gc2Z1U2VydmVyIHRoZSBTRlUgc2VydmVyIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIHRva2VuIHRoZSBKV1QgdG9rZW4gdG8gdXNlIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBgc2Vzc2lvbklkYCBvZiB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBwYXJ0aWNpcGFudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGRpc3BhdGNoZXIsIHNmdVNlcnZlciwgdG9rZW4sIHNlc3Npb25JZCwgfSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBidWZmZXIgZm9yIElDRSBDYW5kaWRhdGVzIHRoYXQgYXJlIHJlY2VpdmVkIGJlZm9yZVxuICAgICAgICAgKiB0aGUgUGVlckNvbm5lY3Rpb25zIGFyZSByZWFkeSB0byBoYW5kbGUgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWNlVHJpY2tsZUJ1ZmZlciA9IG5ldyBJY2VUcmlja2xlQnVmZmVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IG1pZ3JhdGluZyBhd2F5XG4gICAgICAgICAqIGZyb20gdGhpcyBTRlUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzTWlncmF0aW5nQXdheSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGUgY2xpZW50IGNvbm5lY3Rpb24gaXMgYnJva2VuIGZvciB0aGUgY3VycmVudFxuICAgICAgICAgKiBjbGllbnQgYW5kIHRoYXQgYSBmYXN0LXJlY29ubmVjdCB3aXRoIGEgbmV3IGNsaWVudCBzaG91bGQgYmUgYXR0ZW1wdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0Zhc3RSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxJbk1zID0gMTAgKiAxMDAwO1xuICAgICAgICB0aGlzLnVuaGVhbHRoeVRpbWVvdXRJbk1zID0gdGhpcy5waW5nSW50ZXJ2YWxJbk1zICsgNSAqIDEwMDA7XG4gICAgICAgIHRoaXMuY2xvc2UgPSAoY29kZSwgcmVhc29uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgQ2xvc2luZyBTRlUgV1MgY29ubmVjdGlvbjogJHtjb2RlfSAtICR7cmVhc29ufWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsV3MucmVhZHlTdGF0ZSAhPT0gdGhpcy5zaWduYWxXcy5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbFdzLmNsb3NlKGNvZGUsIGBqcy1jbGllbnQ6ICR7cmVhc29ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZUljZVRyaWNrbGUoKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb25zID0gYXN5bmMgKHN1YnNjcmlwdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeWFibGUoKCkgPT4gdGhpcy5ycGMudXBkYXRlU3Vic2NyaXB0aW9ucyh7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB0cmFja3M6IHN1YnNjcmlwdGlvbnMsXG4gICAgICAgICAgICB9KSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFB1Ymxpc2hlciA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlKCgpID0+IHRoaXMucnBjLnNldFB1Ymxpc2hlcih7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgfSksIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kQW5zd2VyID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeWFibGUoKCkgPT4gdGhpcy5ycGMuc2VuZEFuc3dlcih7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgfSksIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pY2VUcmlja2xlID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeWFibGUoKCkgPT4gdGhpcy5ycGMuaWNlVHJpY2tsZSh7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgfSksIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pY2VSZXN0YXJ0ID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeWFibGUoKCkgPT4gdGhpcy5ycGMuaWNlUmVzdGFydCh7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgfSksIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVNdXRlU3RhdGUgPSBhc3luYyAodHJhY2tUeXBlLCBtdXRlZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTXV0ZVN0YXRlcyh7XG4gICAgICAgICAgICAgICAgbXV0ZVN0YXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRlZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTXV0ZVN0YXRlcyA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlKCgpID0+IHRoaXMucnBjLnVwZGF0ZU11dGVTdGF0ZXMoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZFN0YXRzID0gYXN5bmMgKHN0YXRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlKCgpID0+IHRoaXMucnBjLnNlbmRTdGF0cyh7XG4gICAgICAgICAgICAgICAgLi4uc3RhdHMsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuam9pbiA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBqb2luUmVxdWVzdCA9IEpvaW5SZXF1ZXN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLnRva2VuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFNmdVJlcXVlc3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdqb2luUmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgIGpvaW5SZXF1ZXN0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZCA9IGFzeW5jIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduYWxSZWFkeS50aGVuKChzaWduYWwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsLnJlYWR5U3RhdGUgIT09IHNpZ25hbC5PUEVOKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYFNlbmRpbmcgbWVzc2FnZSB0bzogJHt0aGlzLmVkZ2VOYW1lfWAsIFNmdVJlcXVlc3QudG9Kc29uKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICBzaWduYWwuc2VuZChTZnVSZXF1ZXN0LnRvQmluYXJ5KG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmtlZXBBbGl2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLmtlZXBBbGl2ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd0cmFjZScsICdTZW5kaW5nIGhlYWx0aENoZWNrUmVxdWVzdCB0byBTRlUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gU2Z1UmVxdWVzdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnaGVhbHRoQ2hlY2tSZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWx0aENoZWNrUmVxdWVzdDoge30sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kKG1lc3NhZ2UpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsICdFcnJvciBzZW5kaW5nIGhlYWx0aENoZWNrUmVxdWVzdCB0byBTRlUnLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMucGluZ0ludGVydmFsSW5Ncyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RNZXNzYWdlVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RNZXNzYWdlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RNZXNzYWdlVGltZXN0YW1wLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RNZXNzYWdlID4gdGhpcy51bmhlYWx0aHlUaW1lb3V0SW5Ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZShTdHJlYW1TZnVDbGllbnQuRVJST1JfQ09OTkVDVElPTl9VTkhFQUxUSFksIGBTRlUgY29ubmVjdGlvbiB1bmhlYWx0aHkuIERpZG4ndCByZWNlaXZlIGFueSBtZXNzYWdlIGZvciAke3RoaXMudW5oZWFsdGh5VGltZW91dEluTXN9bXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMudW5oZWFsdGh5VGltZW91dEluTXMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZCB8fCBnZW5lcmF0ZVVVSUR2NCgpO1xuICAgICAgICB0aGlzLnNmdVNlcnZlciA9IHNmdVNlcnZlcjtcbiAgICAgICAgdGhpcy5lZGdlTmFtZSA9IHNmdVNlcnZlci5lZGdlX25hbWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydzZnUtY2xpZW50J10pO1xuICAgICAgICBjb25zdCBsb2dJbnRlcmNlcHRvciA9IHtcbiAgICAgICAgICAgIGludGVyY2VwdFVuYXJ5OiAobmV4dCwgbWV0aG9kLCBpbnB1dCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd0cmFjZScsIGBDYWxsaW5nIFNGVSBSUEMgbWV0aG9kICR7bWV0aG9kLm5hbWV9YCwge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChtZXRob2QsIGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnBjID0gY3JlYXRlU2lnbmFsQ2xpZW50KHtcbiAgICAgICAgICAgIGJhc2VVcmw6IHNmdVNlcnZlci51cmwsXG4gICAgICAgICAgICBpbnRlcmNlcHRvcnM6IFtcbiAgICAgICAgICAgICAgICB3aXRoSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGxvZ0ludGVyY2VwdG9yLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoZSBJQ0VUcmlja2xlIGtpbmQgb2YgZXZlbnRzLlxuICAgICAgICAvLyBUaGVzZSBldmVudHMgbWlnaHQgYmUgdHJpZ2dlcmVkIGJ5IHRoZSBTRlUgYmVmb3JlIHRoZSBpbml0aWFsIFJUQ1xuICAgICAgICAvLyBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLiBJbiB0aGF0IGNhc2UsIHRob3NlIGV2ZW50cyAoSUNFIGNhbmRpZGF0ZXMpXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgYnVmZmVyZWQgYW5kIGxhdGVyIGFkZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBQZWVyQ29ubmVjdGlvblxuICAgICAgICAvLyBvbmNlIHRoZSByZW1vdGVEZXNjcmlwdGlvbiBpcyBrbm93biBhbmQgc2V0LlxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlSWNlVHJpY2tsZSA9IGRpc3BhdGNoZXIub24oJ2ljZVRyaWNrbGUnLCAoaWNlVHJpY2tsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pY2VUcmlja2xlQnVmZmVyLnB1c2goaWNlVHJpY2tsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpZ25hbFdzID0gY3JlYXRlV2ViU29ja2V0U2lnbmFsQ2hhbm5lbCh7XG4gICAgICAgICAgICBlbmRwb2ludDogc2Z1U2VydmVyLndzX2VuZHBvaW50LFxuICAgICAgICAgICAgb25NZXNzYWdlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2VUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2soKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLmRpc3BhdGNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lnbmFsUmVhZHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb25PcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsV3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIG9uT3Blbik7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwQWxpdmUoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuc2lnbmFsV3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsV3MuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIG9uT3Blbik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIG5vcm1hbCBjbG9zdXJlIGNvZGUuIFVzZWQgZm9yIGNvbnRyb2xsZWQgc2h1dGRvd25zLlxuICovXG5TdHJlYW1TZnVDbGllbnQuTk9STUFMX0NMT1NVUkUgPSAxMDAwO1xuLyoqXG4gKiBUaGUgZXJyb3IgY29kZSB1c2VkIHdoZW4gdGhlIFNGVSBjb25uZWN0aW9uIGlzIHVuaGVhbHRoeS5cbiAqIFVzdWFsbHksIHRoaXMgbWVhbnMgdGhhdCBubyBtZXNzYWdlIGhhcyBiZWVuIHJlY2VpdmVkIGZyb20gdGhlIFNGVSBmb3JcbiAqIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZSAoYGNvbm5lY3Rpb25DaGVja1RpbWVvdXRgKS5cbiAqL1xuU3RyZWFtU2Z1Q2xpZW50LkVSUk9SX0NPTk5FQ1RJT05fVU5IRUFMVEhZID0gNDAwMTtcbi8qKlxuICogVGhlIGVycm9yIGNvZGUgdXNlZCB3aGVuIHRoZSBTRlUgY29ubmVjdGlvbiBpcyBicm9rZW4uXG4gKiBVc3VhbGx5LCB0aGlzIG1lYW5zIHRoYXQgdGhlIFdTIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkIHVuZXhwZWN0ZWRseS5cbiAqIFRoaXMgZXJyb3IgY29kZSBpcyB1c2VkIHRvIGFubm91bmNlIGEgZmFzdC1yZWNvbm5lY3QuXG4gKi9cblN0cmVhbVNmdUNsaWVudC5FUlJPUl9DT05ORUNUSU9OX0JST0tFTiA9IDQwMDI7IC8vIHVzZWQgaW4gZmFzdC1yZWNvbm5lY3RzXG5jb25zdCBNQVhfUkVUUklFUyA9IDU7XG4vKipcbiAqIENyZWF0ZXMgYSBjbG9zdXJlIHdoaWNoIHdyYXBzIHRoZSBnaXZlbiBSUEMgY2FsbCBhbmQgcmV0cmllcyBpbnZva2luZ1xuICogdGhlIFJQQyB1bnRpbCBpdCBzdWNjZWVkcyBvciB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyBpcyByZWFjaGVkLlxuICpcbiAqIEJldHdlZW4gZWFjaCByZXRyeSwgdGhlcmUgd291bGQgYmUgYSByYW5kb20gZGVsYXkgaW4gb3JkZXIgdG8gYXZvaWRcbiAqIHJlcXVlc3QgYnVyc3RzIHRvd2FyZHMgdGhlIFNGVS5cbiAqXG4gKiBAcGFyYW0gcnBjIHRoZSBjbG9zdXJlIGFyb3VuZCB0aGUgUlBDIGNhbGwgdG8gZXhlY3V0ZS5cbiAqIEBwYXJhbSBsb2dnZXIgYSBsb2dnZXIgaW5zdGFuY2UgdG8gdXNlLlxuICogQHBhcmFtIDxJPiB0aGUgdHlwZSBvZiB0aGUgcmVxdWVzdCBvYmplY3QuXG4gKiBAcGFyYW0gPE8+IHRoZSB0eXBlIG9mIHRoZSByZXNwb25zZSBvYmplY3QuXG4gKi9cbmNvbnN0IHJldHJ5YWJsZSA9IGFzeW5jIChycGMsIGxvZ2dlcikgPT4ge1xuICAgIGxldCByZXRyeUF0dGVtcHQgPSAwO1xuICAgIGxldCBycGNDYWxsUmVzdWx0O1xuICAgIGRvIHtcbiAgICAgICAgLy8gZG9uJ3QgZGVsYXkgdGhlIGZpcnN0IGludm9jYXRpb25cbiAgICAgICAgaWYgKHJldHJ5QXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwocmV0cnlBdHRlbXB0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcnBjQ2FsbFJlc3VsdCA9IGF3YWl0IHJwYygpO1xuICAgICAgICBsb2dnZXIoJ3RyYWNlJywgYFNGVSBSUEMgcmVzcG9uc2UgcmVjZWl2ZWQgZm9yICR7cnBjQ2FsbFJlc3VsdC5tZXRob2QubmFtZX1gLCBycGNDYWxsUmVzdWx0KTtcbiAgICAgICAgLy8gaWYgdGhlIFJQQyBjYWxsIGZhaWxlZCwgbG9nIHRoZSBlcnJvciBhbmQgcmV0cnlcbiAgICAgICAgaWYgKHJwY0NhbGxSZXN1bHQucmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlcignZXJyb3InLCBgU0ZVIFJQQyBFcnJvciAoJHtycGNDYWxsUmVzdWx0Lm1ldGhvZC5uYW1lfSk6YCwgcnBjQ2FsbFJlc3VsdC5yZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0cnlBdHRlbXB0Kys7XG4gICAgfSB3aGlsZSAocnBjQ2FsbFJlc3VsdC5yZXNwb25zZS5lcnJvcj8uc2hvdWxkUmV0cnkgJiZcbiAgICAgICAgcmV0cnlBdHRlbXB0IDwgTUFYX1JFVFJJRVMpO1xuICAgIGlmIChycGNDYWxsUmVzdWx0LnJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgIHRocm93IHJwY0NhbGxSZXN1bHQucmVzcG9uc2UuZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBycGNDYWxsUmVzdWx0O1xufTtcblxuLyoqXG4gKiBFdmVudCBoYW5kbGVyIHRoYXQgd2F0Y2hlZCB0aGUgZGVsaXZlcnkgb2YgYGNhbGwuYWNjZXB0ZWRgLlxuICogT25jZSB0aGUgZXZlbnQgaXMgcmVjZWl2ZWQsIHRoZSBjYWxsIGlzIGpvaW5lZC5cbiAqL1xuY29uc3Qgd2F0Y2hDYWxsQWNjZXB0ZWQgPSAoY2FsbCkgPT4ge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBvbkNhbGxBY2NlcHRlZChldmVudCkge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGRpc2NhcmQgdGhlIGV2ZW50IGlmIGl0J3MgZnJvbSB0aGUgY3VycmVudCB1c2VyXG4gICAgICAgIGlmIChldmVudC51c2VyLmlkID09PSBjYWxsLmN1cnJlbnRVc2VySWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNhbGw7XG4gICAgICAgIGlmIChldmVudC5jYWxsLmNyZWF0ZWRfYnkuaWQgPT09IGNhbGwuY3VycmVudFVzZXJJZCAmJlxuICAgICAgICAgICAgc3RhdGUuY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuUklOR0lORykge1xuICAgICAgICAgICAgYXdhaXQgY2FsbC5qb2luKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8qKlxuICogRXZlbnQgaGFuZGxlciB0aGF0IHdhdGNoZXMgZGVsaXZlcnkgb2YgYGNhbGwucmVqZWN0ZWRgIFdlYnNvY2tldCBldmVudC5cbiAqIE9uY2UgdGhlIGV2ZW50IGlzIHJlY2VpdmVkLCB0aGUgY2FsbCBpcyBsZWZ0LlxuICovXG5jb25zdCB3YXRjaENhbGxSZWplY3RlZCA9IChjYWxsKSA9PiB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIG9uQ2FsbFJlamVjdGVkKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZGlzY2FyZCB0aGUgZXZlbnQgaWYgaXQncyBmcm9tIHRoZSBjdXJyZW50IHVzZXJcbiAgICAgICAgaWYgKGV2ZW50LnVzZXIuaWQgPT09IGNhbGwuY3VycmVudFVzZXJJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBjYWxsOiBldmVudENhbGwgfSA9IGV2ZW50O1xuICAgICAgICBjb25zdCB7IHNlc3Npb246IGNhbGxTZXNzaW9uIH0gPSBldmVudENhbGw7XG4gICAgICAgIGlmICghY2FsbFNlc3Npb24pIHtcbiAgICAgICAgICAgIGNhbGwubG9nZ2VyKCd3YXJuJywgJ05vIGNhbGwgc2Vzc2lvbiBwcm92aWRlZC4gSWdub3JpbmcgY2FsbC5yZWplY3RlZCBldmVudC4nLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVqZWN0ZWRCeSA9IGNhbGxTZXNzaW9uLnJlamVjdGVkX2J5O1xuICAgICAgICBjb25zdCB7IG1lbWJlcnMsIGNhbGxpbmdTdGF0ZSB9ID0gY2FsbC5zdGF0ZTtcbiAgICAgICAgaWYgKGNhbGxpbmdTdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLlJJTkdJTkcpIHtcbiAgICAgICAgICAgIGNhbGwubG9nZ2VyKCdpbmZvJywgJ0NhbGwgaXMgbm90IGluIHJpbmdpbmcgbW9kZSAoaXQgaXMgZWl0aGVyIGFjY2VwdGVkIG9yIHJlamVjdGVkIGFscmVhZHkpLiBJZ25vcmluZyBjYWxsLnJlamVjdGVkIGV2ZW50LicsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbC5pc0NyZWF0ZWRCeU1lKSB7XG4gICAgICAgICAgICBjb25zdCBldmVyeW9uZUVsc2VSZWplY3RlZCA9IG1lbWJlcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChtKSA9PiBtLnVzZXJfaWQgIT09IGNhbGwuY3VycmVudFVzZXJJZClcbiAgICAgICAgICAgICAgICAuZXZlcnkoKG0pID0+IHJlamVjdGVkQnlbbS51c2VyX2lkXSk7XG4gICAgICAgICAgICBpZiAoZXZlcnlvbmVFbHNlUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsLmxvZ2dlcignaW5mbycsICdldmVyeW9uZSByZWplY3RlZCwgbGVhdmluZyB0aGUgY2FsbCcpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubGVhdmUoeyByZWFzb246ICdyaW5nOiBldmVyeW9uZSByZWplY3RlZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVqZWN0ZWRCeVtldmVudENhbGwuY3JlYXRlZF9ieS5pZF0pIHtcbiAgICAgICAgICAgICAgICBjYWxsLmxvZ2dlcignaW5mbycsICdjYWxsIGNyZWF0b3IgcmVqZWN0ZWQsIGxlYXZpbmcgY2FsbCcpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubGVhdmUoeyByZWFzb246ICdyaW5nOiBjcmVhdG9yIHJlamVjdGVkJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBFdmVudCBoYW5kbGVyIHRoYXQgd2F0Y2hlcyB0aGUgZGVsaXZlcnkgb2YgYGNhbGwuZW5kZWRgIFdlYnNvY2tldCBldmVudC5cbiAqL1xuY29uc3Qgd2F0Y2hDYWxsRW5kZWQgPSAoY2FsbCkgPT4ge1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBvbkNhbGxFbmRlZCgpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsaW5nU3RhdGUgfSA9IGNhbGwuc3RhdGU7XG4gICAgICAgIGlmIChjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HIHx8XG4gICAgICAgICAgICBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lORUQgfHxcbiAgICAgICAgICAgIGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5JTkcpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGwubGVhdmUoeyByZWFzb246ICdjYWxsLmVuZGVkIGV2ZW50IHJlY2VpdmVkJyB9KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgdGhhdCB3YXRjaGVzIGZvciBgY2FsbEdyYW50c1VwZGF0ZWRgIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGNhbGwgc3RhdGUgdG8gdXBkYXRlLlxuICovXG5jb25zdCB3YXRjaENhbGxHcmFudHNVcGRhdGVkID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uQ2FsbEdyYW50c1VwZGF0ZWQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50R3JhbnRzIH0gPSBldmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnRHcmFudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FuUHVibGlzaEF1ZGlvLCBjYW5QdWJsaXNoVmlkZW8sIGNhblNjcmVlbnNoYXJlIH0gPSBjdXJyZW50R3JhbnRzO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0ge1xuICAgICAgICAgICAgICAgIFtPd25DYXBhYmlsaXR5LlNFTkRfQVVESU9dOiBjYW5QdWJsaXNoQXVkaW8sXG4gICAgICAgICAgICAgICAgW093bkNhcGFiaWxpdHkuU0VORF9WSURFT106IGNhblB1Ymxpc2hWaWRlbyxcbiAgICAgICAgICAgICAgICBbT3duQ2FwYWJpbGl0eS5TQ1JFRU5TSEFSRV06IGNhblNjcmVlbnNoYXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDYXBhYmlsaXRpZXMgPSBzdGF0ZS5vd25DYXBhYmlsaXRpZXMuZmlsdGVyKChjYXBhYmlsaXR5KSA9PiB1cGRhdGVbY2FwYWJpbGl0eV0gIT09IGZhbHNlKTtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHVwZGF0ZSkuZm9yRWFjaCgoW2NhcGFiaWxpdHksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhbmV4dENhcGFiaWxpdGllcy5pbmNsdWRlcyhjYXBhYmlsaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2FwYWJpbGl0aWVzLnB1c2goY2FwYWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMobmV4dENhcGFiaWxpdGllcyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgbG9nZ2VyJDEgPSBnZXRMb2dnZXIoWydldmVudHMnXSk7XG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgY2hhbmdlUHVibGlzaFF1YWxpdHlgIGV2ZW50LlxuICovXG5jb25zdCB3YXRjaENoYW5nZVB1Ymxpc2hRdWFsaXR5ID0gKGRpc3BhdGNoZXIsIGNhbGwpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci5vbignY2hhbmdlUHVibGlzaFF1YWxpdHknLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHZpZGVvU2VuZGVycyB9ID0gZTtcbiAgICAgICAgdmlkZW9TZW5kZXJzLmZvckVhY2goKHZpZGVvU2VuZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGxheWVycyB9ID0gdmlkZW9TZW5kZXI7XG4gICAgICAgICAgICBjYWxsLnVwZGF0ZVB1Ymxpc2hRdWFsaXR5KGxheWVycy5maWx0ZXIoKGwpID0+IGwuYWN0aXZlKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmNvbnN0IHdhdGNoQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gKGRpc3BhdGNoZXIsIHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCcsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvblF1YWxpdHlVcGRhdGVzIH0gPSBlO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RhdGUudXBkYXRlUGFydGljaXBhbnRzKGNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcy5yZWR1Y2UoKHBhdGNoZXMsIHVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZXNzaW9uSWQsIGNvbm5lY3Rpb25RdWFsaXR5IH0gPSB1cGRhdGU7XG4gICAgICAgICAgICBwYXRjaGVzW3Nlc3Npb25JZF0gPSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblF1YWxpdHksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgcGFydGljaXBhbnRzIGluIHRoZSBjYWxsIGJ5IHBlZWtpbmcgYXQgdGhlXG4gKiBoZWFsdGggY2hlY2sgZXZlbnRzIHRoYXQgb3VyIFNGVSBzZW5kcy5cbiAqL1xuY29uc3Qgd2F0Y2hQYXJ0aWNpcGFudENvdW50Q2hhbmdlZCA9IChkaXNwYXRjaGVyLCBzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBkaXNwYXRjaGVyLm9uKCdoZWFsdGhDaGVja1Jlc3BvbnNlJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBwYXJ0aWNpcGFudENvdW50IH0gPSBlO1xuICAgICAgICBpZiAocGFydGljaXBhbnRDb3VudCkge1xuICAgICAgICAgICAgc3RhdGUuc2V0UGFydGljaXBhbnRDb3VudChwYXJ0aWNpcGFudENvdW50LnRvdGFsKTtcbiAgICAgICAgICAgIHN0YXRlLnNldEFub255bW91c1BhcnRpY2lwYW50Q291bnQocGFydGljaXBhbnRDb3VudC5hbm9ueW1vdXMpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3Qgd2F0Y2hMaXZlRW5kZWQgPSAoZGlzcGF0Y2hlciwgY2FsbCkgPT4ge1xuICAgIHJldHVybiBkaXNwYXRjaGVyLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLmVycm9yICYmIGUuZXJyb3IuY29kZSAhPT0gRXJyb3JDb2RlLkxJVkVfRU5ERUQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2FsbC5wZXJtaXNzaW9uc0NvbnRleHQuaGFzUGVybWlzc2lvbihPd25DYXBhYmlsaXR5LkpPSU5fQkFDS1NUQUdFKSkge1xuICAgICAgICAgICAgY2FsbC5sZWF2ZSh7IHJlYXNvbjogJ2xpdmUgZW5kZWQnIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMSgnZXJyb3InLCAnRmFpbGVkIHRvIGxlYXZlIGNhbGwgYWZ0ZXIgbGl2ZSBlbmRlZCcsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICogV2F0Y2hlcyBhbmQgbG9ncyB0aGUgZXJyb3JzIHJlcG9ydGVkIGJ5IHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIFNGVS5cbiAqL1xuY29uc3Qgd2F0Y2hTZnVFcnJvclJlcG9ydHMgPSAoZGlzcGF0Y2hlcikgPT4ge1xuICAgIHJldHVybiBkaXNwYXRjaGVyLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIGlmICghZS5lcnJvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gZTtcbiAgICAgICAgbG9nZ2VyJDEoJ2Vycm9yJywgJ1NGVSByZXBvcnRlZCBlcnJvcicsIHtcbiAgICAgICAgICAgIGNvZGU6IEVycm9yQ29kZVtlcnJvci5jb2RlXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzaG91bGRSZXRyeTogZXJyb3Iuc2hvdWxkUmV0cnksXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogV2F0Y2hlcyBmb3IgYHBpbnNVcGRhdGVkYCBldmVudHMgYW5kIHVwZGF0ZXMgdGhlIHBpbm5lZCBzdGF0ZSBvZiBwYXJ0aWNpcGFudHNcbiAqIGluIHRoZSBjYWxsLlxuICovXG5jb25zdCB3YXRjaFBpbnNVcGRhdGVkID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uUGluc1VwZGF0ZWQoZSkge1xuICAgICAgICBjb25zdCB7IHBpbnMgfSA9IGU7XG4gICAgICAgIHN0YXRlLnNldFNlcnZlclNpZGVQaW5zKHBpbnMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEFuIGV2ZW50IGhhbmRsZXIgdGhhdCBoYW5kbGVzIHNvZnQgbXV0ZXMuXG4gKlxuICogQHBhcmFtIGNhbGwgdGhlIGNhbGwuXG4gKi9cbmNvbnN0IGhhbmRsZVJlbW90ZVNvZnRNdXRlID0gKGNhbGwpID0+IHtcbiAgICByZXR1cm4gY2FsbC5vbigndHJhY2tVbnB1Ymxpc2hlZCcsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGNhdXNlLCB0eXBlLCBzZXNzaW9uSWQgfSA9IGV2ZW50O1xuICAgICAgICBjb25zdCB7IGxvY2FsUGFydGljaXBhbnQgfSA9IGNhbGwuc3RhdGU7XG4gICAgICAgIGlmIChjYXVzZSA9PT0gVHJhY2tVbnB1Ymxpc2hSZWFzb24uTU9ERVJBVElPTiAmJlxuICAgICAgICAgICAgc2Vzc2lvbklkID09PSBsb2NhbFBhcnRpY2lwYW50Py5zZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IGNhbGwubG9nZ2VyO1xuICAgICAgICAgICAgbG9nZ2VyKCdpbmZvJywgYExvY2FsIHBhcnRpY2lwYW50J3MgJHtUcmFja1R5cGVbdHlwZV19IHRyYWNrIGlzIG11dGVkIHJlbW90ZWx5YCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBUcmFja1R5cGUuVklERU8pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FsbC5jYW1lcmEuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBUcmFja1R5cGUuQVVESU8pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FsbC5taWNyb3Bob25lLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcignd2FybicsICdVbnN1cHBvcnRlZCB0cmFjayB0eXBlIHRvIHNvZnQgbXV0ZScsIFRyYWNrVHlwZVt0eXBlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuc3RvcFB1Ymxpc2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gc3RvcCBwdWJsaXNoaW5nJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgcGFydGljaXBhbnRKb2luZWRgIGV2ZW50LlxuICovXG5jb25zdCB3YXRjaFBhcnRpY2lwYW50Sm9pbmVkID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uUGFydGljaXBhbnRKb2luZWQoZSkge1xuICAgICAgICBjb25zdCB7IHBhcnRpY2lwYW50IH0gPSBlO1xuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBgc3RhdGUudXBkYXRlT3JBZGRQYXJ0aWNpcGFudGAgYWN0cyBhcyBhIHNhZmVndWFyZCBhZ2FpbnN0XG4gICAgICAgIC8vIHBvdGVudGlhbCBkdXBsaWNhdGUgZXZlbnRzIGZyb20gdGhlIFNGVS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWx0aG91Z2ggdGhlIFNGVSBzaG91bGQgbm90IHNlbmQgZHVwbGljYXRlIGV2ZW50cywgd2UgaGF2ZSBzZWVuXG4gICAgICAgIC8vIHNvbWUgcmFjZSBjb25kaXRpb25zIGluIHRoZSBwYXN0IGR1cmluZyB0aGUgYGpvaW4tZmxvd2Agd2hlcmVcbiAgICAgICAgLy8gdGhlIFNGVSB3b3VsZCBzZW5kIHBhcnRpY2lwYW50IGluZm8gYXMgcGFydCBvZiB0aGUgYGpvaW5gXG4gICAgICAgIC8vIHJlc3BvbnNlIGFuZCB0aGVuIGZvbGxvdyB1cCB3aXRoIGEgYHBhcnRpY2lwYW50Sm9pbmVkYCBldmVudCBmb3JcbiAgICAgICAgLy8gYWxyZWFkeSBhbm5vdW5jZWQgcGFydGljaXBhbnRzLlxuICAgICAgICBzdGF0ZS51cGRhdGVPckFkZFBhcnRpY2lwYW50KHBhcnRpY2lwYW50LnNlc3Npb25JZCwgT2JqZWN0LmFzc2lnbihwYXJ0aWNpcGFudCwge1xuICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGU6IHtcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbiAgICAgICAgICAgICAgICBzY3JlZW5TaGFyZVRyYWNrOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9O1xufTtcbi8qKlxuICogQW4gZXZlbnQgcmVzcG9uZGVyIHdoaWNoIGhhbmRsZXMgdGhlIGBwYXJ0aWNpcGFudExlZnRgIGV2ZW50LlxuICovXG5jb25zdCB3YXRjaFBhcnRpY2lwYW50TGVmdCA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBvblBhcnRpY2lwYW50TGVmdChlKSB7XG4gICAgICAgIGNvbnN0IHsgcGFydGljaXBhbnQgfSA9IGU7XG4gICAgICAgIGlmICghcGFydGljaXBhbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0YXRlLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuZmlsdGVyKChwKSA9PiBwLnNlc3Npb25JZCAhPT0gcGFydGljaXBhbnQuc2Vzc2lvbklkKSk7XG4gICAgfTtcbn07XG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgdHJhY2tQdWJsaXNoZWRgIGV2ZW50LlxuICogVGhlIFNGVSB3aWxsIHNlbmQgdGhpcyBldmVudCB3aGVuIGEgcGFydGljaXBhbnQgcHVibGlzaGVzIGEgdHJhY2suXG4gKi9cbmNvbnN0IHdhdGNoVHJhY2tQdWJsaXNoZWQgPSAoc3RhdGUpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25UcmFja1B1Ymxpc2hlZChlKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgc2Vzc2lvbklkLCBwYXJ0aWNpcGFudCB9ID0gZTtcbiAgICAgICAgLy8gQW4gb3B0aW1pemF0aW9uIGZvciBsYXJnZSBjYWxscy5cbiAgICAgICAgLy8gQWZ0ZXIgYSBjZXJ0YWluIHRocmVzaG9sZCwgdGhlIFNGVSB3b3VsZCBzdG9wIGVtaXR0aW5nIGBwYXJ0aWNpcGFudEpvaW5lZGBcbiAgICAgICAgLy8gZXZlbnRzLCBhbmQgaW5zdGVhZCwgaXQgd291bGQgb25seSBwcm92aWRlIHRoZSBwYXJ0aWNpcGFudCdzIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIG9uY2UgdGhleSBzdGFydCBwdWJsaXNoaW5nIGEgdHJhY2suXG4gICAgICAgIGlmIChwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgc3RhdGUudXBkYXRlT3JBZGRQYXJ0aWNpcGFudChzZXNzaW9uSWQsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwgKHApID0+ICh7XG4gICAgICAgICAgICAgICAgcHVibGlzaGVkVHJhY2tzOiBbLi4ucC5wdWJsaXNoZWRUcmFja3MsIHR5cGVdLmZpbHRlcih1bmlxdWUpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgdHJhY2tVbnB1Ymxpc2hlZGAgZXZlbnQuXG4gKiBUaGUgU0ZVIHdpbGwgc2VuZCB0aGlzIGV2ZW50IHdoZW4gYSBwYXJ0aWNpcGFudCB1bnB1Ymxpc2hlcyBhIHRyYWNrLlxuICovXG5jb25zdCB3YXRjaFRyYWNrVW5wdWJsaXNoZWQgPSAoc3RhdGUpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25UcmFja1VucHVibGlzaGVkKGUpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBzZXNzaW9uSWQsIHBhcnRpY2lwYW50IH0gPSBlO1xuICAgICAgICAvLyBBbiBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGNhbGxzLiBTZWUgYHdhdGNoVHJhY2tQdWJsaXNoZWRgLlxuICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHN0YXRlLnVwZGF0ZU9yQWRkUGFydGljaXBhbnQoc2Vzc2lvbklkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIChwKSA9PiAoe1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hlZFRyYWNrczogcC5wdWJsaXNoZWRUcmFja3MuZmlsdGVyKCh0KSA9PiB0ICE9PSB0eXBlKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuY29uc3QgdW5pcXVlID0gKHYsIGksIGFycikgPT4gYXJyLmluZGV4T2YodikgPT09IGk7XG5cbi8qKlxuICogV2F0Y2hlcyBmb3IgYGRvbWluYW50U3BlYWtlckNoYW5nZWRgIGV2ZW50cy5cbiAqL1xuY29uc3Qgd2F0Y2hEb21pbmFudFNwZWFrZXJDaGFuZ2VkID0gKGRpc3BhdGNoZXIsIHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2RvbWluYW50U3BlYWtlckNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlc3Npb25JZCB9ID0gZTtcbiAgICAgICAgaWYgKHNlc3Npb25JZCA9PT0gc3RhdGUuZG9taW5hbnRTcGVha2VyPy5zZXNzaW9uSWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0YXRlLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMubWFwKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgLy8gbWFyayB0aGUgbmV3IGRvbWluYW50IHNwZWFrZXJcbiAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgICAgICBpc0RvbWluYW50U3BlYWtlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5tYXJrIHRoZSBvbGQgZG9taW5hbnQgc3BlYWtlclxuICAgICAgICAgICAgaWYgKHBhcnRpY2lwYW50LmlzRG9taW5hbnRTcGVha2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgICAgIGlzRG9taW5hbnRTcGVha2VyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50OyAvLyBubyBjaGFuZ2VcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcbi8qKlxuICogV2F0Y2hlcyBmb3IgYGF1ZGlvTGV2ZWxDaGFuZ2VkYCBldmVudHMuXG4gKi9cbmNvbnN0IHdhdGNoQXVkaW9MZXZlbENoYW5nZWQgPSAoZGlzcGF0Y2hlciwgc3RhdGUpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci5vbignYXVkaW9MZXZlbENoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGF1ZGlvTGV2ZWxzIH0gPSBlO1xuICAgICAgICBzdGF0ZS51cGRhdGVQYXJ0aWNpcGFudHMoYXVkaW9MZXZlbHMucmVkdWNlKChwYXRjaGVzLCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICBwYXRjaGVzW2N1cnJlbnQuc2Vzc2lvbklkXSA9IHtcbiAgICAgICAgICAgICAgICBhdWRpb0xldmVsOiBjdXJyZW50LmxldmVsLFxuICAgICAgICAgICAgICAgIGlzU3BlYWtpbmc6IGN1cnJlbnQuaXNTcGVha2luZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcGF0Y2hlcztcbiAgICAgICAgfSwge30pKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIHRoZSBkZWZhdWx0IGV2ZW50IGhhbmRsZXJzIGZvciBhIGNhbGwgZHVyaW5nIGl0cyBsaWZlY3ljbGUuXG4gKlxuICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgZm9yLlxuICogQHBhcmFtIHN0YXRlIHRoZSBjYWxsIHN0YXRlLlxuICogQHBhcmFtIGRpc3BhdGNoZXIgdGhlIGRpc3BhdGNoZXIuXG4gKi9cbmNvbnN0IHJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IChjYWxsLCBzdGF0ZSwgZGlzcGF0Y2hlcikgPT4ge1xuICAgIGNvbnN0IGV2ZW50SGFuZGxlcnMgPSBbXG4gICAgICAgIGNhbGwub24oJ2NhbGwuZW5kZWQnLCB3YXRjaENhbGxFbmRlZChjYWxsKSksXG4gICAgICAgIHdhdGNoTGl2ZUVuZGVkKGRpc3BhdGNoZXIsIGNhbGwpLFxuICAgICAgICB3YXRjaFNmdUVycm9yUmVwb3J0cyhkaXNwYXRjaGVyKSxcbiAgICAgICAgd2F0Y2hDaGFuZ2VQdWJsaXNoUXVhbGl0eShkaXNwYXRjaGVyLCBjYWxsKSxcbiAgICAgICAgd2F0Y2hDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQoZGlzcGF0Y2hlciwgc3RhdGUpLFxuICAgICAgICB3YXRjaFBhcnRpY2lwYW50Q291bnRDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICAgICAgY2FsbC5vbigncGFydGljaXBhbnRKb2luZWQnLCB3YXRjaFBhcnRpY2lwYW50Sm9pbmVkKHN0YXRlKSksXG4gICAgICAgIGNhbGwub24oJ3BhcnRpY2lwYW50TGVmdCcsIHdhdGNoUGFydGljaXBhbnRMZWZ0KHN0YXRlKSksXG4gICAgICAgIGNhbGwub24oJ3RyYWNrUHVibGlzaGVkJywgd2F0Y2hUcmFja1B1Ymxpc2hlZChzdGF0ZSkpLFxuICAgICAgICBjYWxsLm9uKCd0cmFja1VucHVibGlzaGVkJywgd2F0Y2hUcmFja1VucHVibGlzaGVkKHN0YXRlKSksXG4gICAgICAgIHdhdGNoQXVkaW9MZXZlbENoYW5nZWQoZGlzcGF0Y2hlciwgc3RhdGUpLFxuICAgICAgICB3YXRjaERvbWluYW50U3BlYWtlckNoYW5nZWQoZGlzcGF0Y2hlciwgc3RhdGUpLFxuICAgICAgICBjYWxsLm9uKCdjYWxsR3JhbnRzVXBkYXRlZCcsIHdhdGNoQ2FsbEdyYW50c1VwZGF0ZWQoc3RhdGUpKSxcbiAgICAgICAgY2FsbC5vbigncGluc1VwZGF0ZWQnLCB3YXRjaFBpbnNVcGRhdGVkKHN0YXRlKSksXG4gICAgICAgIGhhbmRsZVJlbW90ZVNvZnRNdXRlKGNhbGwpLFxuICAgIF07XG4gICAgaWYgKGNhbGwucmluZ2luZykge1xuICAgICAgICAvLyB0aGVzZSBldmVudHMgYXJlIG9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgY2FsbCBpcyByaW5naW5nXG4gICAgICAgIGV2ZW50SGFuZGxlcnMucHVzaChyZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyhjYWxsKSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaCgodW5zdWJzY3JpYmUpID0+IHVuc3Vic2NyaWJlKCkpO1xuICAgIH07XG59O1xuLyoqXG4gKiBSZWdpc3RlcnMgZXZlbnQgaGFuZGxlcnMgZm9yIGEgY2FsbCB0aGF0IGlzIG9mIHJpbmdpbmcgdHlwZS5cbiAqXG4gKiBAcGFyYW0gY2FsbCB0aGUgY2FsbCB0byByZWdpc3RlciBldmVudCBoYW5kbGVycyBmb3IuXG4gKi9cbmNvbnN0IHJlZ2lzdGVyUmluZ2luZ0NhbGxFdmVudEhhbmRsZXJzID0gKGNhbGwpID0+IHtcbiAgICBjb25zdCBjb29yZGluYXRvclJpbmdFdmVudHMgPSB7XG4gICAgICAgICdjYWxsLmFjY2VwdGVkJzogd2F0Y2hDYWxsQWNjZXB0ZWQoY2FsbCksXG4gICAgICAgICdjYWxsLnJlamVjdGVkJzogd2F0Y2hDYWxsUmVqZWN0ZWQoY2FsbCksXG4gICAgfTtcbiAgICBjb25zdCBldmVudEhhbmRsZXJzID0gT2JqZWN0LmtleXMoY29vcmRpbmF0b3JSaW5nRXZlbnRzKS5tYXAoKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FsbC5vbihldmVudE5hbWUsIGNvb3JkaW5hdG9yUmluZ0V2ZW50c1tldmVudE5hbWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBldmVudEhhbmRsZXJzLmZvckVhY2goKHVuc3Vic2NyaWJlKSA9PiB1bnN1YnNjcmliZSgpKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDb2xsZWN0cyBhbGwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIGpvaW4gYSBjYWxsLCB0YWxrcyB0byB0aGUgY29vcmRpbmF0b3JcbiAqIGFuZCByZXR1cm5zIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gam9pbiB0aGUgY2FsbC5cbiAqXG4gKiBAcGFyYW0gaHR0cENsaWVudCB0aGUgaHR0cCBjbGllbnQgdG8gdXNlLlxuICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIGNhbGwuXG4gKiBAcGFyYW0gaWQgdGhlIGlkIG9mIHRoZSBjYWxsLlxuICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgZm9yIHRoZSBjYWxsLlxuICovXG5jb25zdCBqb2luID0gYXN5bmMgKGh0dHBDbGllbnQsIHR5cGUsIGlkLCBkYXRhKSA9PiB7XG4gICAgY29uc3QgeyBjYWxsLCBjcmVkZW50aWFscywgbWVtYmVycywgb3duX2NhcGFiaWxpdGllcywgc3RhdHNfb3B0aW9ucyB9ID0gYXdhaXQgZG9Kb2luKGh0dHBDbGllbnQsIHR5cGUsIGlkLCBkYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25uZWN0aW9uQ29uZmlnOiB0b1J0Y0NvbmZpZ3VyYXRpb24oY3JlZGVudGlhbHMuaWNlX3NlcnZlcnMpLFxuICAgICAgICBzZnVTZXJ2ZXI6IGNyZWRlbnRpYWxzLnNlcnZlcixcbiAgICAgICAgdG9rZW46IGNyZWRlbnRpYWxzLnRva2VuLFxuICAgICAgICBtZXRhZGF0YTogY2FsbCxcbiAgICAgICAgbWVtYmVycyxcbiAgICAgICAgb3duQ2FwYWJpbGl0aWVzOiBvd25fY2FwYWJpbGl0aWVzLFxuICAgICAgICBzdGF0c09wdGlvbnM6IHN0YXRzX29wdGlvbnMsXG4gICAgfTtcbn07XG5jb25zdCBkb0pvaW4gPSBhc3luYyAoaHR0cENsaWVudCwgdHlwZSwgaWQsIGRhdGEpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0TG9jYXRpb25IaW50KCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgfTtcbiAgICByZXR1cm4gaHR0cENsaWVudC5wb3N0KGAvY2FsbC8ke3R5cGV9LyR7aWR9L2pvaW5gLCByZXF1ZXN0KTtcbn07XG5jb25zdCB0b1J0Y0NvbmZpZ3VyYXRpb24gPSAoY29uZmlnKSA9PiB7XG4gICAgaWYgKCFjb25maWcgfHwgY29uZmlnLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBydGNDb25maWcgPSB7XG4gICAgICAgIGljZVNlcnZlcnM6IGNvbmZpZy5tYXAoKGljZSkgPT4gKHtcbiAgICAgICAgICAgIHVybHM6IGljZS51cmxzLFxuICAgICAgICAgICAgdXNlcm5hbWU6IGljZS51c2VybmFtZSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWw6IGljZS5wYXNzd29yZCxcbiAgICAgICAgfSkpLFxuICAgIH07XG4gICAgcmV0dXJuIHJ0Y0NvbmZpZztcbn07XG5cbi8qKlxuICogRmxhdHRlbiB0aGUgc3RhdHMgcmVwb3J0IGludG8gYW4gYXJyYXkgb2Ygc3RhdHMgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gcmVwb3J0IHRoZSByZXBvcnQgdG8gZmxhdHRlbi5cbiAqL1xuY29uc3QgZmxhdHRlbiQxID0gKHJlcG9ydCkgPT4ge1xuICAgIGNvbnN0IHN0YXRzID0gW107XG4gICAgcmVwb3J0LmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgc3RhdHMucHVzaChzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdHM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU3RhdHNSZXBvcnRlciBpbnN0YW5jZSB0aGF0IGNvbGxlY3RzIG1ldHJpY3MgYWJvdXQgdGhlIG9uZ29pbmcgY2FsbCBhbmQgcmVwb3J0cyB0aGVtIHRvIHRoZSBzdGF0ZSBzdG9yZVxuICovXG5jb25zdCBjcmVhdGVTdGF0c1JlcG9ydGVyID0gKHsgc3Vic2NyaWJlciwgcHVibGlzaGVyLCBzdGF0ZSwgcG9sbGluZ0ludGVydmFsSW5NcyA9IDIwMDAsIH0pID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoWydzdGF0cyddKTtcbiAgICBjb25zdCBnZXRSYXdTdGF0c0ZvclRyYWNrID0gYXN5bmMgKGtpbmQsIHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGlmIChraW5kID09PSAnc3Vic2NyaWJlcicgJiYgc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIuZ2V0U3RhdHMoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtpbmQgPT09ICdwdWJsaXNoZXInICYmIHB1Ymxpc2hlcikge1xuICAgICAgICAgICAgcmV0dXJuIHB1Ymxpc2hlci5nZXRTdGF0cyhzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIoJ3dhcm4nLCBgQ2FuJ3QgcmV0cmlldmUgUlRDIHN0YXRzIGZvciAke2tpbmR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRTdGF0c0ZvclN0cmVhbSA9IGFzeW5jIChraW5kLCBtZWRpYVN0cmVhbSkgPT4ge1xuICAgICAgICBjb25zdCBwYyA9IGtpbmQgPT09ICdzdWJzY3JpYmVyJyA/IHN1YnNjcmliZXIgOiBwdWJsaXNoZXI7XG4gICAgICAgIGNvbnN0IHN0YXRzRm9yU3RyZWFtID0gW107XG4gICAgICAgIGZvciAobGV0IHRyYWNrIG9mIG1lZGlhU3RyZWFtLmdldFRyYWNrcygpKSB7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBwYy5nZXRTdGF0cyh0cmFjayk7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IHRyYW5zZm9ybShyZXBvcnQsIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdHJhY2tLaW5kOiB0cmFjay5raW5kLFxuICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRzRm9yU3RyZWFtLnB1c2goc3RhdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0c0ZvclN0cmVhbTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXJ0UmVwb3J0aW5nU3RhdHNGb3IgPSAoc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgIHNlc3Npb25JZHNUb1RyYWNrLmFkZChzZXNzaW9uSWQpO1xuICAgICAgICB2b2lkIHJ1bigpO1xuICAgIH07XG4gICAgY29uc3Qgc3RvcFJlcG9ydGluZ1N0YXRzRm9yID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICBzZXNzaW9uSWRzVG9UcmFjay5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICAgICAgdm9pZCBydW4oKTtcbiAgICB9O1xuICAgIGNvbnN0IHNlc3Npb25JZHNUb1RyYWNrID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIHN0YXRzIHJlcG9ydGluZyBsb29wLlxuICAgICAqL1xuICAgIGNvbnN0IHJ1biA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnRTdGF0cyA9IHt9O1xuICAgICAgICBjb25zdCBzZXNzaW9uSWRzID0gbmV3IFNldChzZXNzaW9uSWRzVG9UcmFjayk7XG4gICAgICAgIGlmIChzZXNzaW9uSWRzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0aWNpcGFudCBvZiBzdGF0ZS5wYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25JZHMuaGFzKHBhcnRpY2lwYW50LnNlc3Npb25JZCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSBwYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICAgICAgPyAncHVibGlzaGVyJ1xuICAgICAgICAgICAgICAgICAgICA6ICdzdWJzY3JpYmVyJztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHBhcnRpY2lwYW50LnZpZGVvU3RyZWFtPy5nZXRWaWRlb1RyYWNrcygpIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwYXJ0aWNpcGFudC5hdWRpb1N0cmVhbT8uZ2V0QXVkaW9UcmFja3MoKSB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudFN0YXRzW3BhcnRpY2lwYW50LnNlc3Npb25JZF0gPSBhd2FpdCBnZXRTdGF0c0ZvclN0cmVhbShraW5kLCBtZXJnZWRTdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRTdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkU3RyZWFtLnJlbW92ZVRyYWNrKHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsIGBGYWlsZWQgdG8gY29sbGVjdCBzdGF0cyBmb3IgJHtraW5kfSBpZiAke3BhcnRpY2lwYW50LnVzZXJJZH1gLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3N1YnNjcmliZXJTdGF0cywgcHVibGlzaGVyU3RhdHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgc3Vic2NyaWJlclxuICAgICAgICAgICAgICAgIC5nZXRTdGF0cygpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlcG9ydCkgPT4gdHJhbnNmb3JtKHJlcG9ydCwge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdzdWJzY3JpYmVyJyxcbiAgICAgICAgICAgICAgICB0cmFja0tpbmQ6ICd2aWRlbycsXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAudGhlbihhZ2dyZWdhdGUpLFxuICAgICAgICAgICAgcHVibGlzaGVyXG4gICAgICAgICAgICAgICAgLmdldFN0YXRzKClcbiAgICAgICAgICAgICAgICAudGhlbigocmVwb3J0KSA9PiB0cmFuc2Zvcm0ocmVwb3J0LCB7XG4gICAgICAgICAgICAgICAga2luZDogJ3B1Ymxpc2hlcicsXG4gICAgICAgICAgICAgICAgdHJhY2tLaW5kOiAndmlkZW8nLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oYWdncmVnYXRlKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IFtzdWJzY3JpYmVyUmF3U3RhdHMsIHB1Ymxpc2hlclJhd1N0YXRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGdldFJhd1N0YXRzRm9yVHJhY2soJ3N1YnNjcmliZXInKSxcbiAgICAgICAgICAgIGdldFJhd1N0YXRzRm9yVHJhY2soJ3B1Ymxpc2hlcicpLFxuICAgICAgICBdKTtcbiAgICAgICAgc3RhdGUuc2V0Q2FsbFN0YXRzUmVwb3J0KHtcbiAgICAgICAgICAgIGRhdGFjZW50ZXI6IHB1Ymxpc2hlci5zZnVDbGllbnQuZWRnZU5hbWUsXG4gICAgICAgICAgICBwdWJsaXNoZXJTdGF0cyxcbiAgICAgICAgICAgIHN1YnNjcmliZXJTdGF0cyxcbiAgICAgICAgICAgIHN1YnNjcmliZXJSYXdTdGF0cyxcbiAgICAgICAgICAgIHB1Ymxpc2hlclJhd1N0YXRzLFxuICAgICAgICAgICAgcGFydGljaXBhbnRzOiBwYXJ0aWNpcGFudFN0YXRzLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgaWYgKHBvbGxpbmdJbnRlcnZhbEluTXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IGxvb3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBydW4oKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlcignZGVidWcnLCAnRmFpbGVkIHRvIGNvbGxlY3Qgc3RhdHMnLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChsb29wLCBwb2xsaW5nSW50ZXJ2YWxJbk1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgdm9pZCBsb29wKCk7XG4gICAgfVxuICAgIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRSYXdTdGF0c0ZvclRyYWNrLFxuICAgICAgICBnZXRTdGF0c0ZvclN0cmVhbSxcbiAgICAgICAgc3RhcnRSZXBvcnRpbmdTdGF0c0ZvcixcbiAgICAgICAgc3RvcFJlcG9ydGluZ1N0YXRzRm9yLFxuICAgICAgICBzdG9wLFxuICAgIH07XG59O1xuLyoqXG4gKiBUcmFuc2Zvcm1zIHJhdyBSVEMgc3RhdHMgaW50byBhIHNsaW1tZXIgYW5kIHVuaWZvcm0gYWNyb3NzIGJyb3dzZXJzIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcmVwb3J0IHRoZSByZXBvcnQgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIG9wdHMgdGhlIHRyYW5zZm9ybSBvcHRpb25zLlxuICovXG5jb25zdCB0cmFuc2Zvcm0gPSAocmVwb3J0LCBvcHRzKSA9PiB7XG4gICAgY29uc3QgeyB0cmFja0tpbmQsIGtpbmQgfSA9IG9wdHM7XG4gICAgY29uc3QgZGlyZWN0aW9uID0ga2luZCA9PT0gJ3N1YnNjcmliZXInID8gJ2luYm91bmQtcnRwJyA6ICdvdXRib3VuZC1ydHAnO1xuICAgIGNvbnN0IHN0YXRzID0gZmxhdHRlbiQxKHJlcG9ydCk7XG4gICAgY29uc3Qgc3RyZWFtcyA9IHN0YXRzXG4gICAgICAgIC5maWx0ZXIoKHN0YXQpID0+IHN0YXQudHlwZSA9PT0gZGlyZWN0aW9uICYmXG4gICAgICAgIHN0YXQua2luZCA9PT0gdHJhY2tLaW5kKVxuICAgICAgICAubWFwKChzdGF0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJ0Y1N0cmVhbVN0YXRzID0gc3RhdDtcbiAgICAgICAgY29uc3QgY29kZWMgPSBzdGF0cy5maW5kKChzKSA9PiBzLnR5cGUgPT09ICdjb2RlYycgJiYgcy5pZCA9PT0gcnRjU3RyZWFtU3RhdHMuY29kZWNJZCk7IC8vIEZJWE1FIE9MOiBpbmNvcnJlY3QgdHlwZSFcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gc3RhdHMuZmluZCgocykgPT4gcy50eXBlID09PSAndHJhbnNwb3J0JyAmJiBzLmlkID09PSBydGNTdHJlYW1TdGF0cy50cmFuc3BvcnRJZCk7XG4gICAgICAgIGxldCByb3VuZFRyaXBUaW1lO1xuICAgICAgICBpZiAodHJhbnNwb3J0ICYmIHRyYW5zcG9ydC5kdGxzU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5kaWRhdGVQYWlyID0gc3RhdHMuZmluZCgocykgPT4gcy50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInICYmXG4gICAgICAgICAgICAgICAgcy5pZCA9PT0gdHJhbnNwb3J0LnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKTtcbiAgICAgICAgICAgIHJvdW5kVHJpcFRpbWUgPSBjYW5kaWRhdGVQYWlyPy5jdXJyZW50Um91bmRUcmlwVGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnl0ZXNTZW50OiBydGNTdHJlYW1TdGF0cy5ieXRlc1NlbnQsXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiBydGNTdHJlYW1TdGF0cy5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgICAgY29kZWM6IGNvZGVjPy5taW1lVHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnRSb3VuZFRyaXBUaW1lOiByb3VuZFRyaXBUaW1lLFxuICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHJ0Y1N0cmVhbVN0YXRzLmZyYW1lSGVpZ2h0LFxuICAgICAgICAgICAgZnJhbWVXaWR0aDogcnRjU3RyZWFtU3RhdHMuZnJhbWVXaWR0aCxcbiAgICAgICAgICAgIGZyYW1lc1BlclNlY29uZDogcnRjU3RyZWFtU3RhdHMuZnJhbWVzUGVyU2Vjb25kLFxuICAgICAgICAgICAgaml0dGVyOiBydGNTdHJlYW1TdGF0cy5qaXR0ZXIsXG4gICAgICAgICAgICBraW5kOiBydGNTdHJlYW1TdGF0cy5raW5kLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogYXZhaWxhYmxlIGluIENocm9tZSBvbmx5LCBUUyBkb2Vzbid0IHJlY29nbml6ZSB0aGlzXG4gICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjogcnRjU3RyZWFtU3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZWFzb24sXG4gICAgICAgICAgICByaWQ6IHJ0Y1N0cmVhbVN0YXRzLnJpZCxcbiAgICAgICAgICAgIHNzcmM6IHJ0Y1N0cmVhbVN0YXRzLnNzcmMsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmF3U3RhdHM6IHJlcG9ydCxcbiAgICAgICAgc3RyZWFtcyxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH07XG59O1xuLyoqXG4gKiBBZ2dyZWdhdGVzIGdlbmVyaWMgc3RhdHMuXG4gKlxuICogQHBhcmFtIHN0YXRzIHRoZSBzdGF0cyB0byBhZ2dyZWdhdGUuXG4gKi9cbmNvbnN0IGFnZ3JlZ2F0ZSA9IChzdGF0cykgPT4ge1xuICAgIGNvbnN0IGFnZ3JlZ2F0ZWRTdGF0cyA9IHtcbiAgICAgICAgcmF3UmVwb3J0OiBzdGF0cyxcbiAgICAgICAgdG90YWxCeXRlc1NlbnQ6IDAsXG4gICAgICAgIHRvdGFsQnl0ZXNSZWNlaXZlZDogMCxcbiAgICAgICAgYXZlcmFnZUppdHRlckluTXM6IDAsXG4gICAgICAgIGF2ZXJhZ2VSb3VuZFRyaXBUaW1lSW5NczogMCxcbiAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zOiAnbm9uZScsXG4gICAgICAgIGhpZ2hlc3RGcmFtZVdpZHRoOiAwLFxuICAgICAgICBoaWdoZXN0RnJhbWVIZWlnaHQ6IDAsXG4gICAgICAgIGhpZ2hlc3RGcmFtZXNQZXJTZWNvbmQ6IDAsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9O1xuICAgIGxldCBtYXhBcmVhID0gLTE7XG4gICAgY29uc3QgYXJlYSA9ICh3LCBoKSA9PiB3ICogaDtcbiAgICBjb25zdCBxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc3RyZWFtcyA9IHN0YXRzLnN0cmVhbXM7XG4gICAgY29uc3QgcmVwb3J0ID0gc3RyZWFtcy5yZWR1Y2UoKGFjYywgc3RyZWFtKSA9PiB7XG4gICAgICAgIGFjYy50b3RhbEJ5dGVzU2VudCArPSBzdHJlYW0uYnl0ZXNTZW50IHx8IDA7XG4gICAgICAgIGFjYy50b3RhbEJ5dGVzUmVjZWl2ZWQgKz0gc3RyZWFtLmJ5dGVzUmVjZWl2ZWQgfHwgMDtcbiAgICAgICAgYWNjLmF2ZXJhZ2VKaXR0ZXJJbk1zICs9IHN0cmVhbS5qaXR0ZXIgfHwgMDtcbiAgICAgICAgYWNjLmF2ZXJhZ2VSb3VuZFRyaXBUaW1lSW5NcyArPSBzdHJlYW0uY3VycmVudFJvdW5kVHJpcFRpbWUgfHwgMDtcbiAgICAgICAgLy8gbmFpdmUgY2FsY3VsYXRpb24gb2YgdGhlIGhpZ2hlc3QgcmVzb2x1dGlvblxuICAgICAgICBjb25zdCBzdHJlYW1BcmVhID0gYXJlYShzdHJlYW0uZnJhbWVXaWR0aCB8fCAwLCBzdHJlYW0uZnJhbWVIZWlnaHQgfHwgMCk7XG4gICAgICAgIGlmIChzdHJlYW1BcmVhID4gbWF4QXJlYSkge1xuICAgICAgICAgICAgYWNjLmhpZ2hlc3RGcmFtZVdpZHRoID0gc3RyZWFtLmZyYW1lV2lkdGggfHwgMDtcbiAgICAgICAgICAgIGFjYy5oaWdoZXN0RnJhbWVIZWlnaHQgPSBzdHJlYW0uZnJhbWVIZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIGFjYy5oaWdoZXN0RnJhbWVzUGVyU2Vjb25kID0gc3RyZWFtLmZyYW1lc1BlclNlY29uZCB8fCAwO1xuICAgICAgICAgICAgbWF4QXJlYSA9IHN0cmVhbUFyZWE7XG4gICAgICAgIH1cbiAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zLmFkZChzdHJlYW0ucXVhbGl0eUxpbWl0YXRpb25SZWFzb24gfHwgJycpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIGFnZ3JlZ2F0ZWRTdGF0cyk7XG4gICAgaWYgKHN0cmVhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXBvcnQuYXZlcmFnZUppdHRlckluTXMgPSBNYXRoLnJvdW5kKChyZXBvcnQuYXZlcmFnZUppdHRlckluTXMgLyBzdHJlYW1zLmxlbmd0aCkgKiAxMDAwKTtcbiAgICAgICAgcmVwb3J0LmF2ZXJhZ2VSb3VuZFRyaXBUaW1lSW5NcyA9IE1hdGgucm91bmQoKHJlcG9ydC5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgLyBzdHJlYW1zLmxlbmd0aCkgKiAxMDAwKTtcbiAgICB9XG4gICAgY29uc3QgcXVhbGl0eUxpbWl0YXRpb25SZWFzb24gPSBbXG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29ucy5oYXMoJ2NwdScpICYmICdjcHUnLFxuICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMuaGFzKCdiYW5kd2lkdGgnKSAmJiAnYmFuZHdpZHRoJyxcbiAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zLmhhcygnb3RoZXInKSAmJiAnb3RoZXInLFxuICAgIF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICBpZiAocXVhbGl0eUxpbWl0YXRpb25SZWFzb24pIHtcbiAgICAgICAgcmVwb3J0LnF1YWxpdHlMaW1pdGF0aW9uUmVhc29ucyA9IHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uO1xuICAgIH1cbiAgICByZXR1cm4gcmVwb3J0O1xufTtcblxuY2xhc3MgU2Z1U3RhdHNSZXBvcnRlciB7XG4gICAgY29uc3RydWN0b3Ioc2Z1Q2xpZW50LCB7IG9wdGlvbnMsIGNsaWVudERldGFpbHMsIHN1YnNjcmliZXIsIHB1Ymxpc2hlciB9KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnU2Z1U3RhdHNSZXBvcnRlciddKTtcbiAgICAgICAgdGhpcy5ydW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbc3Vic2NyaWJlclN0YXRzLCBwdWJsaXNoZXJTdGF0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLmdldFN0YXRzKCkudGhlbihmbGF0dGVuJDEpLnRoZW4oSlNPTi5zdHJpbmdpZnkpLFxuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyLmdldFN0YXRzKCkudGhlbihmbGF0dGVuJDEpLnRoZW4oSlNPTi5zdHJpbmdpZnkpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNmdUNsaWVudC5zZW5kU3RhdHMoe1xuICAgICAgICAgICAgICAgIHNkazogdGhpcy5zZGtOYW1lLFxuICAgICAgICAgICAgICAgIHNka1ZlcnNpb246IHRoaXMuc2RrVmVyc2lvbixcbiAgICAgICAgICAgICAgICB3ZWJydGNWZXJzaW9uOiB0aGlzLndlYlJUQ1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlclN0YXRzLFxuICAgICAgICAgICAgICAgIHB1Ymxpc2hlclN0YXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlcG9ydGluZ19pbnRlcnZhbF9tcyA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bigpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnRmFpbGVkIHRvIHJlcG9ydCBzdGF0cycsIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMucmVwb3J0aW5nX2ludGVydmFsX21zKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNmdUNsaWVudCA9IHNmdUNsaWVudDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5wdWJsaXNoZXIgPSBwdWJsaXNoZXI7XG4gICAgICAgIGNvbnN0IHdlYlJUQ0luZm8gPSBnZXRXZWJSVENJbmZvKCk7XG4gICAgICAgIGNvbnN0IHsgc2RrLCBicm93c2VyIH0gPSBjbGllbnREZXRhaWxzO1xuICAgICAgICB0aGlzLnNka05hbWUgPVxuICAgICAgICAgICAgc2RrICYmIHNkay50eXBlID09PSBTZGtUeXBlLlJFQUNUXG4gICAgICAgICAgICAgICAgPyAnc3RyZWFtLXJlYWN0J1xuICAgICAgICAgICAgICAgIDogc2RrICYmIHNkay50eXBlID09PSBTZGtUeXBlLlJFQUNUX05BVElWRVxuICAgICAgICAgICAgICAgICAgICA/ICdzdHJlYW0tcmVhY3QtbmF0aXZlJ1xuICAgICAgICAgICAgICAgICAgICA6ICdzdHJlYW0tanMnO1xuICAgICAgICB0aGlzLnNka1ZlcnNpb24gPSBzZGtcbiAgICAgICAgICAgID8gYCR7c2RrLm1ham9yfS4ke3Nkay5taW5vcn0uJHtzZGsucGF0Y2h9YFxuICAgICAgICAgICAgOiAnMC4wLjAtZGV2ZWxvcG1lbnQnO1xuICAgICAgICAvLyBUaGUgV2ViUlRDIHZlcnNpb24gaWYgcGFzc2VkIGZyb20gdGhlIFNESywgaXQgaXMgdGFrZW4gZWxzZSB0aGUgYnJvd3NlciBpbmZvIGlzIHNlbnQuXG4gICAgICAgIHRoaXMud2ViUlRDVmVyc2lvbiA9XG4gICAgICAgICAgICB3ZWJSVENJbmZvPy52ZXJzaW9uIHx8XG4gICAgICAgICAgICAgICAgYCR7YnJvd3Nlcj8ubmFtZSB8fCAnJ30tJHticm93c2VyPy52ZXJzaW9uIHx8ICcnfWAgfHxcbiAgICAgICAgICAgICAgICAnTi9BJztcbiAgICB9XG59XG5cbmNvbnN0IERFRkFVTFRfVEhSRVNIT0xEID0gMC4zNTtcbmNsYXNzIFZpZXdwb3J0VHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50SGFuZGxlck1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgLy8gaW4gUmVhY3QgY2hpbGRyZW4gcmVuZGVyIGJlZm9yZSB2aWV3cG9ydCBpcyBzZXQsIGFkZFxuICAgICAgICAvLyB0aGVtIHRvIHRoZSBxdWV1ZSBhbmQgb2JzZXJ2ZSB0aGVtIG9uY2UgdGhlIG9ic2VydmVyIGlzIHJlYWR5XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWV1ZVNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBzZXQgc2Nyb2xsYWJsZSB2aWV3cG9ydCBhcyByb290IGZvciB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIHJldHVybnNcbiAgICAgICAgICogY2xlYW51cCBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHVwb24gZGlzcG9zaW5nIG9mIHRoZSBET00gZWxlbWVudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlld3BvcnRFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIFVub2JzZXJ2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCA9ICh2aWV3cG9ydEVsZW1lbnQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5lbGVtZW50SGFuZGxlck1hcC5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcj8uKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByb290OiB2aWV3cG9ydEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IG9wdGlvbnM/LnRocmVzaG9sZCA/PyBERUZBVUxUX1RIUkVTSE9MRCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucXVldWVTZXQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVTZXQuZm9yRWFjaCgoW3F1ZXVlRWxlbWVudCwgcXVldWVIYW5kbGVyXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBlbGVtZW50IHdoaWNoIHJlcXVlc3RlZCBvYnNlcnZhdGlvbiBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBhIGNoaWxkIG9mIGEgdmlld3BvcnQgZWxlbWVudCwgc2tpcCBpZiBpc24ndFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudC5jb250YWlucyhxdWV1ZUVsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUocXVldWVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50SGFuZGxlck1hcC5zZXQocXVldWVFbGVtZW50LCBxdWV1ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVTZXQuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHNldCBlbGVtZW50IHRvIG9ic2VydmUgYW5kIGhhbmRsZXIgdG8gYmUgdHJpZ2dlcmVkIHdoZW5ldmVyIEludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgICAgICAqIGRldGVjdHMgYSBwb3NzaWJsZSBjaGFuZ2UgaW4gZWxlbWVudCdzIHZpc2liaWxpdHkgd2l0aGluIHNwZWNpZmllZCB2aWV3cG9ydCwgcmV0dXJuc1xuICAgICAgICAgKiBjbGVhbnVwIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgdXBvbiBkaXNwb3Npbmcgb2YgdGhlIERPTSBlbGVtZW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyXG4gICAgICAgICAqIEByZXR1cm5zIFVub2JzZXJ2ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vYnNlcnZlID0gKGVsZW1lbnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlSXRlbSA9IFtlbGVtZW50LCBoYW5kbGVyXTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50SGFuZGxlck1hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcj8udW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVTZXQuZGVsZXRlKHF1ZXVlSXRlbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZVNldC5hZGQocXVldWVJdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVyLnJvb3QuY29udGFpbnMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRIYW5kbGVyTWFwLnNldChlbGVtZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBTYWZhcmkuXG4gKi9cbmNvbnN0IGlzU2FmYXJpID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJycpO1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBGaXJlZm94LlxuICovXG5jb25zdCBpc0ZpcmVmb3ggPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ/LmluY2x1ZGVzKCdGaXJlZm94Jyk7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIGlzIEdvb2dsZSBDaHJvbWUuXG4gKi9cbmNvbnN0IGlzQ2hyb21lID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50Py5pbmNsdWRlcygnQ2hyb21lJyk7XG59O1xuXG52YXIgYnJvd3NlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGlzQ2hyb21lOiBpc0Nocm9tZSxcbiAgICBpc0ZpcmVmb3g6IGlzRmlyZWZveCxcbiAgICBpc1NhZmFyaTogaXNTYWZhcmlcbn0pO1xuXG5jb25zdCBERUZBVUxUX1ZJRVdQT1JUX1ZJU0lCSUxJVFlfU1RBVEUgPSB7XG4gICAgdmlkZW9UcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgc2NyZWVuU2hhcmVUcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG59O1xuLyoqXG4gKiBBIG1hbmFnZXIgY2xhc3MgdGhhdCBoYW5kbGVzIGR5bmFzY2FsZSByZWxhdGVkIHRhc2tzIGxpa2U6XG4gKlxuICogLSBiaW5kaW5nIHZpZGVvIGVsZW1lbnRzIHRvIHNlc3Npb24gaWRzXG4gKiAtIGJpbmRpbmcgYXVkaW8gZWxlbWVudHMgdG8gc2Vzc2lvbiBpZHNcbiAqIC0gdHJhY2tpbmcgZWxlbWVudCB2aXNpYmlsaXR5XG4gKiAtIHVwZGF0aW5nIHN1YnNjcmlwdGlvbnMgYmFzZWQgb24gdmlld3BvcnQgdmlzaWJpbGl0eVxuICogLSB1cGRhdGluZyBzdWJzY3JpcHRpb25zIGJhc2VkIG9uIHZpZGVvIGVsZW1lbnQgZGltZW5zaW9uc1xuICogLSB1cGRhdGluZyBzdWJzY3JpcHRpb25zIGJhc2VkIG9uIHB1Ymxpc2hlZCB0cmFja3NcbiAqL1xuY2xhc3MgRHluYXNjYWxlTWFuYWdlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEeW5hc2NhbGVNYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gbWFuYWdlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2aWV3cG9ydCB0cmFja2VyIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3cG9ydFRyYWNrZXIgPSBuZXcgVmlld3BvcnRUcmFja2VyKCk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnRHluYXNjYWxlTWFuYWdlciddKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgYmVnaW4gdHJhY2tpbmcgdGhlIGdpdmVuIGVsZW1lbnQgZm9yIHZpc2liaWxpdHkgY2hhbmdlcyB3aXRoaW4gdGhlXG4gICAgICAgICAqIGNvbmZpZ3VyZWQgdmlld3BvcnQgZWxlbWVudCAoYGNhbGwuc2V0Vmlld3BvcnRgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gdHJhY2suXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIGtpbmQgb2YgdmlkZW8uXG4gICAgICAgICAqIEByZXR1cm5zIFVudHJhY2suXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNrRWxlbWVudFZpc2liaWxpdHkgPSAoZWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSB0aGlzLnZpZXdwb3J0VHJhY2tlci5vYnNlcnZlKGVsZW1lbnQsIChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Zpc2liaWxpdHlTdGF0ZSA9IHBhcnRpY2lwYW50LnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID8/XG4gICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX1ZJRVdQT1JUX1ZJU0lCSUxJVFlfU1RBVEU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ic2VydmVyIHRyaWdnZXJzIHdoZW4gdGhlIGVsZW1lbnQgaXMgXCJtb3ZlZFwiIHRvIGJlIGEgZnVsbHNjcmVlbiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgaXQgVklTSUJMRSBpZiB0aGF0IGhhcHBlbnMgdG8gcHJldmVudCBmdWxsc2NyZWVuIHdpdGggcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgPT09IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gVmlzaWJpbGl0eVN0YXRlLlZJU0lCTEVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogVmlzaWJpbGl0eVN0YXRlLklOVklTSUJMRTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wcmV2aW91c1Zpc2liaWxpdHlTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdHJhY2tUeXBlXTogaXNWaXNpYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdmlzaWJpbGl0eSBzdGF0ZSB0byBVTktOT1dOIHVwb24gY2xlYW51cFxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGxheW91dHMgdGhhdCBhcmUgbm90IGFjdGl2ZWx5IG9ic2VydmVkXG4gICAgICAgICAgICAgICAgLy8gY2FuIHN0aWxsIGZ1bmN0aW9uIG5vcm1hbGx5IChydW50aW1lIGxheW91dCBzd2l0Y2hpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwgKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmlzaWJpbGl0eVN0YXRlID0gcGFydGljaXBhbnQudmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfVklFV1BPUlRfVklTSUJJTElUWV9TVEFURTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wcmV2aW91c1Zpc2liaWxpdHlTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdHJhY2tUeXBlXTogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gdHJhY2sgYm91bmQgdmlkZW8gZWxlbWVudHMgZm9yIHZpc2liaWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50IHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRyYWNrZXIuc2V0Vmlld3BvcnQoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBhIERPTSA8dmlkZW8+IGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIHZpZGVvIGVsZW1lbnQgd2lsbCBwbGF5XG4gICAgICAgICAqIHRoZSBjb3JyZWN0IHZpZGVvIHN0cmVhbSBmb3IgdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVuZGVyIHRoZSBob29kLCBpdCB3b3VsZCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHZpZGVvIGVsZW1lbnQgZGltZW5zaW9uc1xuICAgICAgICAgKiBhbmQgdXBkYXRlIHRoZSBzdWJzY3JpcHRpb24gYWNjb3JkaW5nbHkgaW4gb3JkZXIgdG8gb3B0aW1pemUgdGhlIGJhbmR3aWR0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBcInZpZXdwb3J0XCIgaXMgY29uZmlndXJlZCwgdGhlIHZpZGVvIGVsZW1lbnQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAqIHRyYWNrZWQgZm9yIHZpc2liaWxpdHkgYW5kIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZ2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50IHRoZSB2aWRlbyBlbGVtZW50IHRvIGJpbmQgdG8uXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIGtpbmQgb2YgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJpbmRWaWRlb0VsZW1lbnQgPSAodmlkZW9FbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm91bmRQYXJ0aWNpcGFudCA9IHRoaXMuY2FsbC5zdGF0ZS5maW5kUGFydGljaXBhbnRCeVNlc3Npb25JZChzZXNzaW9uSWQpO1xuICAgICAgICAgICAgaWYgKCFib3VuZFBhcnRpY2lwYW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zID0gKGRlYm91bmNlVHlwZSwgZGltZW5zaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbiAmJiAoZGltZW5zaW9uLndpZHRoID09PSAwIHx8IGRpbWVuc2lvbi5oZWlnaHQgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSAweDAgZGltZW5zaW9ucy4gdGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIHZpZGVvIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHZpc2libGUgKGUuZy4sIGhhcyBkaXNwbGF5OiBub25lKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgdHJlYXQgdGhpcyBhcyBcInVuc3Vic2NyaXB0aW9uXCIgYXMgd2UgZG9uJ3Qgd2FudCB0byBrZWVwXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnN1bWluZyBiYW5kd2lkdGggZm9yIGEgdmlkZW8gdGhhdCBpcyBub3QgdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgSWdub3JpbmcgMHgwIGRpbWVuc2lvbmAsIGJvdW5kUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbC51cGRhdGVTdWJzY3JpcHRpb25zUGFydGlhbCh0cmFja1R5cGUsIHsgW3Nlc3Npb25JZF06IHsgZGltZW5zaW9uIH0gfSwgZGVib3VuY2VUeXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCQgPSB0aGlzLmNhbGwuc3RhdGUucGFydGljaXBhbnRzJC5waXBlKG1hcCQxKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5maW5kKChwYXJ0aWNpcGFudCkgPT4gcGFydGljaXBhbnQuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpKSwgdGFrZVdoaWxlKChwYXJ0aWNpcGFudCkgPT4gISFwYXJ0aWNpcGFudCksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTaW5jZSB0aGUgdmlkZW8gZWxlbWVudHMgYXJlIG5vdyBiZWluZyByZW1vdmVkIGZyb20gdGhlIERPTSAoUmVhY3QgU0RLKSB1cG9uXG4gICAgICAgICAgICAgKiB2aXNpYmlsaXR5IGNoYW5nZSwgdGhpcyBzdWJzY3JpcHRpb24gaXMgbm90IGluIHVzZSBhbiBzdGF5cyBoZXJlIG9ubHkgZm9yIHRoZVxuICAgICAgICAgICAgICogcGxhaW4gSlMgaW50ZWdyYXRpb25zIHdoZXJlIGludGVncmF0b3JzIG1pZ2h0IGNob29zZSBub3QgdG8gcmVtb3ZlIHRoZSB2aWRlb1xuICAgICAgICAgICAgICogZWxlbWVudHMgZnJvbSB0aGUgRE9NLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBrZWVwIGNvcHkgZm9yIHJlc2l6ZSBvYnNlcnZlciBoYW5kbGVyXG4gICAgICAgICAgICBsZXQgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGU7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZVN1YnNjcmlwdGlvbiA9IGJvdW5kUGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBwYXJ0aWNpcGFudCRcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUobWFwJDEoKHApID0+IHAudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/Llt0cmFja1R5cGVdKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgobmV4dFZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgaW5pdGlhbCB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlld3BvcnRWaXNpYmlsaXR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Vmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPz8gVmlzaWJpbGl0eVN0YXRlLlVOS05PV047XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID8/IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID09PSBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMoRGVib3VuY2VUeXBlLk1FRElVTSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyhEZWJvdW5jZVR5cGUuTUVESVVNLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmlkZW9FbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBsYXN0RGltZW5zaW9ucztcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gYm91bmRQYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREaW1lbnNpb25zID0gYCR7dmlkZW9FbGVtZW50LmNsaWVudFdpZHRofSwke3ZpZGVvRWxlbWVudC5jbGllbnRIZWlnaHR9YDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBpbml0aWFsIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXN0RGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdERpbWVuc2lvbnMgPSBjdXJyZW50RGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdERpbWVuc2lvbnMgPT09IGN1cnJlbnREaW1lbnNpb25zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA9PT0gVmlzaWJpbGl0eVN0YXRlLklOVklTSUJMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zKERlYm91bmNlVHlwZS5TTE9XLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmlkZW9FbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdERpbWVuc2lvbnMgPSBjdXJyZW50RGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICAvLyBlbGVtZW50IHJlbmRlcnMgYW5kIGdldHMgYm91bmQgLSB0cmFjayBzdWJzY3JpcHRpb24gZ2V0c1xuICAgICAgICAgICAgLy8gdHJpZ2dlcmVkIGZpcnN0IG90aGVyIG9uZXMgZ2V0IHNraXBwZWQgb24gaW5pdGlhbCBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBjb25zdCBwdWJsaXNoZWRUcmFja3NTdWJzY3JpcHRpb24gPSBib3VuZFBhcnRpY2lwYW50LmlzTG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogcGFydGljaXBhbnQkXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCdwdWJsaXNoZWRUcmFja3MnKSwgbWFwJDEoKHApID0+IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snXG4gICAgICAgICAgICAgICAgICAgID8gVHJhY2tUeXBlLlZJREVPXG4gICAgICAgICAgICAgICAgICAgIDogVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChpc1B1Ymxpc2hpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHVibGlzaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhcnRpY2lwYW50IGp1c3Qgc3RhcnRlZCB0byBwdWJsaXNoIGEgdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zKERlYm91bmNlVHlwZS5GQVNULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHZpZGVvRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZpZGVvRWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJ0aWNpcGFudCBqdXN0IHN0b3BwZWQgcHVibGlzaGluZyBhIHRyYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyhEZWJvdW5jZVR5cGUuRkFTVCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBleHBsaWNpdGx5IG1hcmtpbmcgdGhlIGVsZW1lbnQgYXMgbXV0ZWQgd2lsbCBhbGxvdyBhdXRvcGxheSB0byB3b3JrXG4gICAgICAgICAgICAvLyB3aXRob3V0IHByaW9yIHVzZXIgaW50ZXJhY3Rpb246XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9NZWRpYS9BdXRvcGxheV9ndWlkZVxuICAgICAgICAgICAgdmlkZW9FbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbVN1YnNjcmlwdGlvbiA9IHBhcnRpY2lwYW50JFxuICAgICAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snID8gJ3ZpZGVvU3RyZWFtJyA6ICdzY3JlZW5TaGFyZVN0cmVhbScpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0cmFja1R5cGUgPT09ICd2aWRlb1RyYWNrJyA/IHAudmlkZW9TdHJlYW0gOiBwLnNjcmVlblNoYXJlU3RyZWFtO1xuICAgICAgICAgICAgICAgIGlmICh2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID09PSBzb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc291cmNlID8/IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FmYXJpKCkgfHwgaXNGaXJlZm94KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc291cmNlID8/IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQucGxheSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgRmFpbGVkIHRvIHBsYXkgc3RyZWFtYCwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFkZCBleHRyYSBkZWxheSB1bnRpbCB3ZSBhdHRlbXB0IHRvIGZvcmNlLXBsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJ0aWNpcGFudCdzIG1lZGlhIHN0cmVhbSBpbiBGaXJlZm94IGFuZCBTYWZhcmksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyB0aGV5IHNlZW0gdG8gaGF2ZSBzb21lIHRpbWluZyBpc3N1ZXNcbiAgICAgICAgICAgICAgICAgICAgfSwgMjUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyhEZWJvdW5jZVR5cGUuRkFTVCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZVN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBwdWJsaXNoZWRUcmFja3NTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBhIERPTSA8YXVkaW8+IGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGF1ZGlvIGVsZW1lbnQgd2lsbFxuICAgICAgICAgKiBwbGF5IHRoZSBjb3JyZWN0IGF1ZGlvIHN0cmVhbSBmb3IgdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhdWRpb0VsZW1lbnQgdGhlIGF1ZGlvIGVsZW1lbnQgdG8gYmluZCB0by5cbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUga2luZCBvZiBhdWRpby5cbiAgICAgICAgICogQHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgd2lsbCB1bmJpbmQgdGhlIGF1ZGlvIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJpbmRBdWRpb0VsZW1lbnQgPSAoYXVkaW9FbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmNhbGwuc3RhdGUuZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQoc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQgfHwgcGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50JCA9IHRoaXMuY2FsbC5zdGF0ZS5wYXJ0aWNpcGFudHMkLnBpcGUobWFwJDEoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbmQoKHApID0+IHAuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpKSwgdGFrZVdoaWxlKChwKSA9PiAhIXApLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLCBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZU1lZGlhU3RyZWFtU3Vic2NyaXB0aW9uID0gcGFydGljaXBhbnQkXG4gICAgICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbEtleUNoYW5nZWQodHJhY2tUeXBlID09PSAnc2NyZWVuU2hhcmVBdWRpb1RyYWNrJ1xuICAgICAgICAgICAgICAgID8gJ3NjcmVlblNoYXJlQXVkaW9TdHJlYW0nXG4gICAgICAgICAgICAgICAgOiAnYXVkaW9TdHJlYW0nKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdHJhY2tUeXBlID09PSAnc2NyZWVuU2hhcmVBdWRpb1RyYWNrJ1xuICAgICAgICAgICAgICAgICAgICA/IHAuc2NyZWVuU2hhcmVBdWRpb1N0cmVhbVxuICAgICAgICAgICAgICAgICAgICA6IHAuYXVkaW9TdHJlYW07XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5zcmNPYmplY3QgPT09IHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhdWRpb0VsZW1lbnQuc3JjT2JqZWN0ID0gc291cmNlID8/IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb0VsZW1lbnQuc3JjT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0VsZW1lbnQucGxheSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgRmFpbGVkIHRvIHBsYXkgc3RyZWFtYCwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1ZGlvIG91dHB1dCBkZXZpY2Ugc2hhbGwgYmUgc2V0IGFmdGVyIHRoZSBhdWRpbyBlbGVtZW50IGlzIHBsYXllZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB0aGUgYnJvd3NlciB3aWxsIG5vdCBwaWNrIGl0IHVwLCBhbmQgd2lsbCBhbHdheXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYXkgYXVkaW8gdGhyb3VnaCB0aGUgc3lzdGVtJ3MgZGVmYXVsdCBkZXZpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWREZXZpY2UgfSA9IHRoaXMuY2FsbC5zcGVha2VyLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRGV2aWNlICYmICdzZXRTaW5rSWQnIGluIGF1ZGlvRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvRWxlbWVudC5zZXRTaW5rSWQoc2VsZWN0ZWREZXZpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNpbmtJZFN1YnNjcmlwdGlvbiA9ICEoJ3NldFNpbmtJZCcgaW4gYXVkaW9FbGVtZW50KVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogdGhpcy5jYWxsLnNwZWFrZXIuc3RhdGUuc2VsZWN0ZWREZXZpY2UkLnN1YnNjcmliZSgoZGV2aWNlSWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0VsZW1lbnQuc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgdm9sdW1lU3Vic2NyaXB0aW9uID0gY29tYmluZUxhdGVzdChbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsLnNwZWFrZXIuc3RhdGUudm9sdW1lJCxcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudCQucGlwZShkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnYXVkaW9Wb2x1bWUnKSksXG4gICAgICAgICAgICBdKS5zdWJzY3JpYmUoKFt2b2x1bWUsIHBdKSA9PiB7XG4gICAgICAgICAgICAgICAgYXVkaW9FbGVtZW50LnZvbHVtZSA9IHAuYXVkaW9Wb2x1bWUgPz8gdm9sdW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhdWRpb0VsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBzaW5rSWRTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdm9sdW1lU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlTWVkaWFTdHJlYW1TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgfVxufVxuXG4vKipcbiAqIFN0b3JlcyB0aGUgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50IHVzZXIgYW5kIGV4cG9zZXNcbiAqIGEgZmV3IGhlbHBlciBtZXRob2RzIHdoaWNoIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBwZXJtaXNzaW9ucy5cbiAqXG4gKiBUaGlzIGlzIGFuIGludGVybmFsIGNsYXNzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aFxuICogYSB7QGxpbmsgQ2FsbH0gaW5zdGFuY2UuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFBlcm1pc3Npb25zQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGVybWlzc2lvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudCB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGVybWlzc2lvbnMgdGhlIHBlcm1pc3Npb25zIHRvIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0UGVybWlzc2lvbnMgPSAocGVybWlzc2lvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucyB8fCBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHNldHRpbmdzIGZvciB0aGUgYm91bmQgY2FsbC5cbiAgICAgICAgICogQHBhcmFtIHNldHRpbmdzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENhbGxTZXR0aW5ncyA9IChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHVzZXIgaGFzIGEgc3BlY2lmaWMgcGVybWlzc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBlcm1pc3Npb24gdGhlIHBlcm1pc3Npb24gdG8gY2hlY2sgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNQZXJtaXNzaW9uID0gKHBlcm1pc3Npb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zLmluY2x1ZGVzKHBlcm1pc3Npb24pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHVzZXIgY2FuIHJlcXVlc3QgYSBzcGVjaWZpYyBwZXJtaXNzaW9uXG4gICAgICAgICAqIHdpdGhpbiB0aGUgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBlcm1pc3Npb24gdGhlIHBlcm1pc3Npb24gdG8gY2hlY2sgZm9yLlxuICAgICAgICAgKiBAcGFyYW0gc2V0dGluZ3MgdGhlIGNhbGwgc2V0dGluZ3MgdG8gY2hlY2sgYWdhaW5zdCAob3B0aW9uYWwpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5SZXF1ZXN0ID0gKHBlcm1pc3Npb24sIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB7IGF1ZGlvLCB2aWRlbywgc2NyZWVuc2hhcmluZyB9ID0gc2V0dGluZ3M7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIE93bkNhcGFiaWxpdHkuU0VORF9BVURJTzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1ZGlvLmFjY2Vzc19yZXF1ZXN0X2VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNFTkRfVklERU86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby5hY2Nlc3NfcmVxdWVzdF9lbmFibGVkO1xuICAgICAgICAgICAgICAgIGNhc2UgT3duQ2FwYWJpbGl0eS5TQ1JFRU5TSEFSRTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcmVlbnNoYXJpbmcuYWNjZXNzX3JlcXVlc3RfZW5hYmxlZDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjYWxsIHR5cGUuXG4gKi9cbmNsYXNzIENhbGxUeXBlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENhbGxUeXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGNhbGwgdHlwZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgdGhlIGNhbGwgdHlwZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvcHRpb25zID0ge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGRlZmF1bHRTb3J0UHJlc2V0LFxuICAgIH0pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG59XG4vKipcbiAqIEEgcmVnaXN0cnkgb2Yge0BsaW5rIENhbGxUeXBlfXMuXG4gKiBZb3UgY2FuIHJlZ2lzdGVyIGFuZCB1bnJlZ2lzdGVyIGNhbGwgdHlwZXMuXG4gKi9cbmNsYXNzIENhbGxUeXBlc1JlZ2lzdHJ5IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENhbGxUeXBlc1JlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxUeXBlcyB0aGUgaW5pdGlhbCBjYWxsIHR5cGVzIHRvIHJlZ2lzdGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbGxUeXBlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIGEgbmV3IGNhbGwgdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGxUeXBlIHRoZSBjYWxsIHR5cGUgdG8gcmVnaXN0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZ2lzdGVyID0gKGNhbGxUeXBlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUeXBlc1tjYWxsVHlwZS5uYW1lXSA9IGNhbGxUeXBlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlcnMgYSBjYWxsIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBjYWxsIHR5cGUgdG8gdW5yZWdpc3Rlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5yZWdpc3RlciA9IChuYW1lKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsVHlwZXNbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgY2FsbCB0eXBlIGJ5IG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBjYWxsIHR5cGUgdG8gZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXQgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxUeXBlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIobmV3IENhbGxUeXBlKG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGxUeXBlc1tuYW1lXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYWxsVHlwZXMgPSBjYWxsVHlwZXMucmVkdWNlKChhY2MsIGNhbGxUeXBlKSA9PiB7XG4gICAgICAgICAgICBhY2NbY2FsbFR5cGUubmFtZV0gPSBjYWxsVHlwZTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGNhbGwgdHlwZXMgcmVnaXN0cnkuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGluc3RhbmNlIHRvIGR5bmFtaWNhbGx5IHJlZ2lzdGVyIGFuZCB1bnJlZ2lzdGVyIGNhbGwgdHlwZXMuXG4gKi9cbmNvbnN0IENhbGxUeXBlcyA9IG5ldyBDYWxsVHlwZXNSZWdpc3RyeShbXG4gICAgbmV3IENhbGxUeXBlKCdkZWZhdWx0Jywge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGRlZmF1bHRTb3J0UHJlc2V0LFxuICAgIH0pLFxuICAgIG5ldyBDYWxsVHlwZSgnZGV2ZWxvcG1lbnQnLCB7XG4gICAgICAgIHNvcnRQYXJ0aWNpcGFudHNCeTogZGVmYXVsdFNvcnRQcmVzZXQsXG4gICAgfSksXG4gICAgbmV3IENhbGxUeXBlKCdsaXZlc3RyZWFtJywge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGxpdmVzdHJlYW1PckF1ZGlvUm9vbVNvcnRQcmVzZXQsXG4gICAgfSksXG4gICAgbmV3IENhbGxUeXBlKCdhdWRpb19yb29tJywge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGxpdmVzdHJlYW1PckF1ZGlvUm9vbVNvcnRQcmVzZXQsXG4gICAgfSksXG5dKTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgZGV2aWNlc1xuICogdGhhdCBtZWV0IHRoZSBnaXZlbiBjb25zdHJhaW50cy5cbiAqXG4gKiBAcGFyYW0gY29uc3RyYWludHMgdGhlIGNvbnN0cmFpbnRzIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdGhlIGRldmljZXMuXG4gKiBAcGFyYW0ga2luZCB0aGUga2luZCBvZiBkZXZpY2VzIHRvIGVudW1lcmF0ZS5cbiAqL1xuY29uc3QgZ2V0RGV2aWNlcyA9IChjb25zdHJhaW50cywga2luZCkgPT4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICBjb25zdCBlbnVtZXJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICAgICAgLy8gc29tZSBicm93c2VycyByZXBvcnQgZW1wdHkgZGV2aWNlIGxhYmVscyAoRmlyZWZveCkuXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gcmVxdWVzdCBwZXJtaXNzaW9ucyAodmlhIGdldFVzZXJNZWRpYSlcbiAgICAgICAgICAgIC8vIHRvIGJlIGFibGUgdG8gZ2V0IHRoZSBkZXZpY2UgbGFiZWxzXG4gICAgICAgICAgICBjb25zdCBuZWVkc0dldFVzZXJNZWRpYSA9IGRldmljZXMuc29tZSgoZGV2aWNlKSA9PiBkZXZpY2Uua2luZCA9PT0ga2luZCAmJiBkZXZpY2UubGFiZWwgPT09ICcnKTtcbiAgICAgICAgICAgIGlmIChuZWVkc0dldFVzZXJNZWRpYSkge1xuICAgICAgICAgICAgICAgIGxldCBtZWRpYVN0cmVhbTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lZGlhU3RyZWFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZU9mTWVkaWFTdHJlYW0obWVkaWFTdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgICAgICB9O1xuICAgICAgICBlbnVtZXJhdGUoKVxuICAgICAgICAgICAgLnRoZW4oKGRldmljZXMpID0+IHtcbiAgICAgICAgICAgIC8vIG5vdGlmeSBzdWJzY3JpYmVycyBhbmQgY29tcGxldGVcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChkZXZpY2VzKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ2RldmljZXMnXSk7XG4gICAgICAgICAgICBsb2dnZXIoJ2Vycm9yJywgJ0ZhaWxlZCB0byBlbnVtZXJhdGUgZGV2aWNlcycsIGVycm9yKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFtUZWxscyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBvdXRwdXQgY2hhbmdlIG9uICdhdWRpbycgZWxlbWVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3NldFNpbmtJZCkuXG4gKlxuICogICovXG5jb25zdCBjaGVja0lmQXVkaW9PdXRwdXRDaGFuZ2VTdXBwb3J0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICByZXR1cm4gJ3NldFNpbmtJZCcgaW4gZWxlbWVudDtcbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIHVzZWQgdG8gcmVxdWVzdCBhdWRpbyBkZXZpY2VzLlxuICovXG5jb25zdCBhdWRpb0RldmljZUNvbnN0cmFpbnRzID0ge1xuICAgIGF1ZGlvOiB7XG4gICAgICAgIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgICAgICAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcbiAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICB9LFxufTtcbi8qKlxuICogVGhlIGRlZmF1bHQgY29uc3RyYWludHMgdXNlZCB0byByZXF1ZXN0IHZpZGVvIGRldmljZXMuXG4gKi9cbmNvbnN0IHZpZGVvRGV2aWNlQ29uc3RyYWludHMgPSB7XG4gICAgdmlkZW86IHtcbiAgICAgICAgd2lkdGg6IDEyODAsXG4gICAgICAgIGhlaWdodDogNzIwLFxuICAgIH0sXG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbWVtb2l6ZWQgb2JzZXJ2YWJsZSBpbnN0YW5jZVxuICogdGhhdCB3aWxsIGJlIGNyZWF0ZWQgb25seSBvbmNlIGFuZCBzaGFyZWQgYmV0d2VlbiBhbGwgY2FsbGVycy5cbiAqXG4gKiBAcGFyYW0gY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIE9ic2VydmFibGUuXG4gKi9cbmNvbnN0IG1lbW9pemVkT2JzZXJ2YWJsZSA9IChjcmVhdGUpID0+IHtcbiAgICBsZXQgbWVtb2l6ZWQ7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFtZW1vaXplZClcbiAgICAgICAgICAgIG1lbW9pemVkID0gY3JlYXRlKCk7XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xufTtcbmNvbnN0IGdldERldmljZUNoYW5nZU9ic2VydmVyID0gbWVtb2l6ZWRPYnNlcnZhYmxlKCgpID0+IHtcbiAgICAvLyBBdWRpbyBhbmQgdmlkZW8gZGV2aWNlcyBhcmUgcmVxdWVzdGVkIGluIHR3byBzZXBhcmF0ZSByZXF1ZXN0cy5cbiAgICAvLyBUaGF0IHdheSwgdXNlcnMgd2lsbCBiZSBwcmVzZW50ZWQgd2l0aCB0d28gc2VwYXJhdGUgcHJvbXB0c1xuICAgIC8vIC0+IHRoZXkgY2FuIGdpdmUgYWNjZXNzIHRvIGp1c3QgY2FtZXJhLCBvciBqdXN0IG1pY3JvcGhvbmVcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgLy8gJ2FkZEV2ZW50TGlzdGVuZXInIGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgTmF0aXZlXG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBub3RpZnkgPSAoKSA9PiBzdWJzY3JpYmVyLm5leHQoKTtcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCBub3RpZnkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCBub3RpZnkpO1xuICAgICAgICB9O1xuICAgIH0pLnBpcGUoZGVib3VuY2VUaW1lKDUwMCksIGNvbmNhdE1hcCgoKSA9PiBmcm9tKG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpKSksIHNoYXJlUmVwbGF5KDEpKTtcbn0pO1xuY29uc3QgZ2V0QXVkaW9EZXZpY2VzT2JzZXJ2ZXIgPSBtZW1vaXplZE9ic2VydmFibGUoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZShnZXREZXZpY2VzKGF1ZGlvRGV2aWNlQ29uc3RyYWludHMsICdhdWRpb2lucHV0JyksIGdldERldmljZUNoYW5nZU9ic2VydmVyKCkpLnBpcGUoc2hhcmVSZXBsYXkoMSkpO1xufSk7XG5jb25zdCBnZXRBdWRpb091dHB1dERldmljZXNPYnNlcnZlciA9IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlKGdldERldmljZXMoYXVkaW9EZXZpY2VDb25zdHJhaW50cywgJ2F1ZGlvb3V0cHV0JyksIGdldERldmljZUNoYW5nZU9ic2VydmVyKCkpLnBpcGUoc2hhcmVSZXBsYXkoMSkpO1xufSk7XG5jb25zdCBnZXRWaWRlb0RldmljZXNPYnNlcnZlciA9IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlKGdldERldmljZXModmlkZW9EZXZpY2VDb25zdHJhaW50cywgJ3ZpZGVvaW5wdXQnKSwgZ2V0RGV2aWNlQ2hhbmdlT2JzZXJ2ZXIoKSkucGlwZShzaGFyZVJlcGxheSgxKSk7XG59KTtcbi8qKlxuICogUHJvbXB0cyB0aGUgdXNlciBmb3IgYSBwZXJtaXNzaW9uIHRvIHVzZSBhdWRpbyBkZXZpY2VzIChpZiBub3QgYWxyZWFkeSBncmFudGVkKSBhbmQgbGlzdHMgdGhlIGF2YWlsYWJsZSAnYXVkaW9pbnB1dCcgZGV2aWNlcywgaWYgZGV2aWNlcyBhcmUgYWRkZWQvcmVtb3ZlZCB0aGUgbGlzdCBpcyB1cGRhdGVkLlxuICovXG5jb25zdCBnZXRBdWRpb0RldmljZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldEF1ZGlvRGV2aWNlc09ic2VydmVyKCkucGlwZShtYXAkMSgodmFsdWVzKSA9PiB2YWx1ZXMuZmlsdGVyKChkKSA9PiBkLmtpbmQgPT09ICdhdWRpb2lucHV0JykpKTtcbn07XG4vKipcbiAqIFByb21wdHMgdGhlIHVzZXIgZm9yIGEgcGVybWlzc2lvbiB0byB1c2UgdmlkZW8gZGV2aWNlcyAoaWYgbm90IGFscmVhZHkgZ3JhbnRlZCkgYW5kIGxpc3RzIHRoZSBhdmFpbGFibGUgJ3ZpZGVvaW5wdXQnIGRldmljZXMsIGlmIGRldmljZXMgYXJlIGFkZGVkL3JlbW92ZWQgdGhlIGxpc3QgaXMgdXBkYXRlZC5cbiAqL1xuY29uc3QgZ2V0VmlkZW9EZXZpY2VzID0gKCkgPT4ge1xuICAgIHJldHVybiBnZXRWaWRlb0RldmljZXNPYnNlcnZlcigpLnBpcGUobWFwJDEoKHZhbHVlcykgPT4gdmFsdWVzLmZpbHRlcigoZCkgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpKSk7XG59O1xuLyoqXG4gKiBQcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gdXNlIGF1ZGlvIGRldmljZXMgKGlmIG5vdCBhbHJlYWR5IGdyYW50ZWQpIGFuZCBsaXN0cyB0aGUgYXZhaWxhYmxlICdhdWRpb291dHB1dCcgZGV2aWNlcywgaWYgZGV2aWNlcyBhcmUgYWRkZWQvcmVtb3ZlZCB0aGUgbGlzdCBpcyB1cGRhdGVkLiBTZWxlY3RpbmcgJ2F1ZGlvb3V0cHV0JyBkZXZpY2Ugb25seSBtYWtlcyBzZW5zZSBpZiBbdGhlIGJyb3dzZXIgaGFzIHN1cHBvcnQgZm9yIGNoYW5naW5nIGF1ZGlvIG91dHB1dCBvbiAnYXVkaW8nIGVsZW1lbnRzXSgjY2hlY2tpZmF1ZGlvb3V0cHV0Y2hhbmdlc3VwcG9ydGVkKVxuICovXG5jb25zdCBnZXRBdWRpb091dHB1dERldmljZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldEF1ZGlvT3V0cHV0RGV2aWNlc09ic2VydmVyKCkucGlwZShtYXAkMSgodmFsdWVzKSA9PiB2YWx1ZXMuZmlsdGVyKChkKSA9PiBkLmtpbmQgPT09ICdhdWRpb291dHB1dCcpKSk7XG59O1xuY29uc3QgZ2V0U3RyZWFtID0gYXN5bmMgKGNvbnN0cmFpbnRzKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZ2V0TG9nZ2VyKFsnZGV2aWNlcyddKSgnZXJyb3InLCBgRmFpbGVkIGdldCB1c2VyIG1lZGlhYCwge1xuICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICBjb25zdHJhaW50czogY29uc3RyYWludHMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn07XG4vKipcbiAqIFJldHVybnMgYW4gYXVkaW8gbWVkaWEgc3RyZWFtIHRoYXQgZnVsZmlsbHMgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICogSWYgbm8gY29uc3RyYWludHMgYXJlIHByb3ZpZGVkLCBpdCB1c2VzIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBvbmVzLlxuICpcbiAqIEBhbmd1bGFyIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBbYERldmljZU1hbmFnZXJTZXJ2aWNlYF0oLi9EZXZpY2VNYW5hZ2VyU2VydmljZS5tZCkgZm9yIGEgaGlnaGVyIGxldmVsIEFQSSwgdXNlIHRoaXMgbG93LWxldmVsIG1ldGhvZCBvbmx5IGlmIHRoZSBgRGV2aWNlTWFuYWdlclNlcnZpY2VgIGRvZXNuJ3Qgc3VpdCB5b3VyIHJlcXVpcmVtZW50cy5cbiAqIEBwYXJhbSB0cmFja0NvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBzdHJlYW0uXG4gKiBAcmV0dXJucyB0aGUgbmV3IGBNZWRpYVN0cmVhbWAgZnVsZmlsbGluZyB0aGUgZ2l2ZW4gY29uc3RyYWludHMuXG4gKi9cbmNvbnN0IGdldEF1ZGlvU3RyZWFtID0gYXN5bmMgKHRyYWNrQ29uc3RyYWludHMpID0+IHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgIC4uLmF1ZGlvRGV2aWNlQ29uc3RyYWludHMuYXVkaW8sXG4gICAgICAgICAgICAuLi50cmFja0NvbnN0cmFpbnRzLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGdldFN0cmVhbShjb25zdHJhaW50cyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgdmlkZW8gbWVkaWEgc3RyZWFtIHRoYXQgZnVsZmlsbHMgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICogSWYgbm8gY29uc3RyYWludHMgYXJlIHByb3ZpZGVkLCBpdCB1c2VzIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBvbmVzLlxuICpcbiAqIEBhbmd1bGFyIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBbYERldmljZU1hbmFnZXJTZXJ2aWNlYF0oLi9EZXZpY2VNYW5hZ2VyU2VydmljZS5tZCkgZm9yIGEgaGlnaGVyIGxldmVsIEFQSSwgdXNlIHRoaXMgbG93LWxldmVsIG1ldGhvZCBvbmx5IGlmIHRoZSBgRGV2aWNlTWFuYWdlclNlcnZpY2VgIGRvZXNuJ3Qgc3VpdCB5b3VyIHJlcXVpcmVtZW50cy5cbiAqIEBwYXJhbSB0cmFja0NvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBzdHJlYW0uXG4gKiBAcmV0dXJucyBhIG5ldyBgTWVkaWFTdHJlYW1gIGZ1bGZpbGxpbmcgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICovXG5jb25zdCBnZXRWaWRlb1N0cmVhbSA9IGFzeW5jICh0cmFja0NvbnN0cmFpbnRzKSA9PiB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSB7XG4gICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICAuLi52aWRlb0RldmljZUNvbnN0cmFpbnRzLnZpZGVvLFxuICAgICAgICAgICAgLi4udHJhY2tDb25zdHJhaW50cyxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBnZXRTdHJlYW0oY29uc3RyYWludHMpO1xufTtcbi8qKlxuICogUHJvbXB0cyB0aGUgdXNlciBmb3IgYSBwZXJtaXNzaW9uIHRvIHNoYXJlIGEgc2NyZWVuLlxuICogSWYgdGhlIHVzZXIgZ3JhbnRzIHRoZSBwZXJtaXNzaW9uLCBhIHNjcmVlbiBzaGFyaW5nIHN0cmVhbSBpcyByZXR1cm5lZC4gVGhyb3dzIG90aGVyd2lzZS5cbiAqXG4gKiBUaGUgY2FsbGVycyBvZiB0aGlzIEFQSSBhcmUgcmVzcG9uc2libGUgdG8gaGFuZGxlIHRoZSBwb3NzaWJsZSBlcnJvcnMuXG4gKlxuICogQGFuZ3VsYXIgSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIFtgRGV2aWNlTWFuYWdlclNlcnZpY2VgXSguL0RldmljZU1hbmFnZXJTZXJ2aWNlLm1kKSBmb3IgYSBoaWdoZXIgbGV2ZWwgQVBJLCB1c2UgdGhpcyBsb3ctbGV2ZWwgbWV0aG9kIG9ubHkgaWYgdGhlIGBEZXZpY2VNYW5hZ2VyU2VydmljZWAgZG9lc24ndCBzdWl0IHlvdXIgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIGFueSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgW2BnZXREaXNwbGF5TWVkaWFgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldERpc3BsYXlNZWRpYSkgQVBJLlxuICovXG5jb25zdCBnZXRTY3JlZW5TaGFyZVN0cmVhbSA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHtcbiAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaWRlYWw6IDIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlY2hvQ2FuY2VsbGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5vaXNlU3VwcHJlc3Npb246IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBub3QgcHJlc2VudCBpbiB0eXBlcyB5ZXRcbiAgICAgICAgICAgIHN5c3RlbUF1ZGlvOiAnaW5jbHVkZScsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZ2V0TG9nZ2VyKFsnZGV2aWNlcyddKSgnZXJyb3InLCAnRmFpbGVkIHRvIGdldCBzY3JlZW4gc2hhcmUgc3RyZWFtJywgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufTtcbmNvbnN0IGRldmljZUlkcyQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICE9PSAndW5kZWZpbmVkJ1xuICAgID8gbWVtb2l6ZWRPYnNlcnZhYmxlKCgpID0+IG1lcmdlKGZyb20obmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkpLCBnZXREZXZpY2VDaGFuZ2VPYnNlcnZlcigpKS5waXBlKHNoYXJlUmVwbGF5KDEpKSkoKVxuICAgIDogdW5kZWZpbmVkO1xuLyoqXG4gKiBEZWFjdGl2YXRlcyBNZWRpYVN0cmVhbSAoc3RvcHMgYW5kIHJlbW92ZXMgdHJhY2tzKSB0byBiZSBsYXRlciBnYXJiYWdlIGNvbGxlY3RlZFxuICpcbiAqIEBwYXJhbSBzdHJlYW0gTWVkaWFTdHJlYW1cbiAqIEByZXR1cm5zIHZvaWRcbiAqL1xuY29uc3QgZGlzcG9zZU9mTWVkaWFTdHJlYW0gPSAoc3RyZWFtKSA9PiB7XG4gICAgaWYgKCFzdHJlYW0uYWN0aXZlKVxuICAgICAgICByZXR1cm47XG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICB9KTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlbGVhc2UoKSBpcyBwcmVzZW50IGluIHJlYWN0LW5hdGl2ZS13ZWJydGMgYW5kIG11c3QgYmUgY2FsbGVkIHRvIGRpc3Bvc2UgdGhlIHN0cmVhbVxuICAgIGlmICh0eXBlb2Ygc3RyZWFtLnJlbGVhc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBzdHJlYW0ucmVsZWFzZSgpO1xuICAgIH1cbn07XG5cbmNsYXNzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBzdGF0ZSwgdHJhY2tUeXBlKSB7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFja1R5cGUgPSB0cmFja1R5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiB0cnVlLCBzdG9wcyB0aGUgbWVkaWEgc3RyZWFtIHdoZW4gY2FsbCBpcyBsZWZ0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BPbkxlYXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZXMgdGhlIG1hbmFnZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHMpID0+IHMoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFtgJHtUcmFja1R5cGVbdHJhY2tUeXBlXS50b0xvd2VyQ2FzZSgpfSBtYW5hZ2VyYF0pO1xuICAgICAgICBpZiAoZGV2aWNlSWRzJCAmJlxuICAgICAgICAgICAgIWlzUmVhY3ROYXRpdmUoKSAmJlxuICAgICAgICAgICAgKHRoaXMudHJhY2tUeXBlID09PSBUcmFja1R5cGUuQVVESU8gfHwgdGhpcy50cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTykpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdGVkT3JSZXBsYWNlZERldmljZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgYXZhaWxhYmxlIGF1ZGlvL3ZpZGVvIGRldmljZXNcbiAgICAgKlxuICAgICAqIE5vdGU6IEl0IHByb21wdHMgdGhlIHVzZXIgZm9yIGEgcGVybWlzc2lvbiB0byB1c2UgZGV2aWNlcyAoaWYgbm90IGFscmVhZHkgZ3JhbnRlZClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgaWYgYSBkZXZpY2UgaXMgY29ubmVjdGVkIG9yIGRpc2Nvbm5lY3RlZFxuICAgICAqL1xuICAgIGxpc3REZXZpY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREZXZpY2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBzdHJlYW0uXG4gICAgICovXG4gICAgYXN5bmMgZW5hYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lbmFibGVQcm9taXNlID0gdGhpcy51bm11dGVTdHJlYW0oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5hYmxlUHJvbWlzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0U3RhdHVzKCdlbmFibGVkJyk7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBvciBwYXVzZXMgdGhlIHN0cmVhbSBiYXNlZCBvbiBzdGF0ZS5kaXNhYmxlTW9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlU3RvcD1mYWxzZV0gd2hlbiB0cnVlLCBzdG9wcyB0aGUgdHJhY2tzIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlLmRpc2FibGVNb2RlXG4gICAgICovXG4gICAgYXN5bmMgZGlzYWJsZShmb3JjZVN0b3AgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnN0YXRlLnByZXZTdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcbiAgICAgICAgaWYgKCFmb3JjZVN0b3AgJiYgdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdkaXNhYmxlZCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHN0b3BUcmFja3MgPSBmb3JjZVN0b3AgfHwgdGhpcy5zdGF0ZS5kaXNhYmxlTW9kZSA9PT0gJ3N0b3AtdHJhY2tzJztcbiAgICAgICAgdGhpcy5kaXNhYmxlUHJvbWlzZSA9IHRoaXMubXV0ZVN0cmVhbShzdG9wVHJhY2tzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzYWJsZVByb21pc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldFN0YXR1cygnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZVByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgc3RhdHVzIHdhcyBwcmV2aW91c2x5IGVuYWJsZWQsIGl0IHdpbGwgcmUtZW5hYmxlIHRoZSBkZXZpY2UuXG4gICAgICovXG4gICAgYXN5bmMgcmVzdW1lKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wcmV2U3RhdHVzID09PSAnZW5hYmxlZCcgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBjdXJyZW50IGRldmljZSBzdGF0dXMgaXMgZGlzYWJsZWQsIGl0IHdpbGwgZW5hYmxlIHRoZSBkZXZpY2UsXG4gICAgICogZWxzZSBpdCB3aWxsIGRpc2FibGUgaXQuXG4gICAgICovXG4gICAgYXN5bmMgdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZmlsdGVyIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBmaWx0ZXIgd2lsbCBnZXQgdGhlIGV4aXN0aW5nIHN0cmVhbSwgYW5kIGl0IHNob3VsZCByZXR1cm5cbiAgICAgKiBhIG5ldyBzdHJlYW0gd2l0aCB0aGUgYXBwbGllZCBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVyIHRoZSBmaWx0ZXIgdG8gcmVnaXN0ZXIuXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgdW5yZWdpc3RlciB0aGUgZmlsdGVyLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZ2lzdGVyRmlsdGVyKGZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLmFwcGx5U2V0dGluZ3NUb1N0cmVhbSgpO1xuICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gdGhpcy5maWx0ZXJzLmZpbHRlcigoZikgPT4gZiAhPT0gZmlsdGVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgc2V0IHRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIGZvciB0aGUgZGV2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byBzZXQuXG4gICAgICovXG4gICAgc2V0RGVmYXVsdENvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0RGVmYXVsdENvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIGRldmljZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBkZXZpY2UgaWQgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdChkZXZpY2VJZCkge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9nZXRzdHJlYW0uaW8vdmlkZW8vZG9jcy9yZWFjdG5hdGl2ZS9jb3JlL2NhbWVyYS1hbmQtbWljcm9waG9uZS8jc3BlYWtlci1tYW5hZ2VtZW50IGZvciByZWZlcmVuY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldmljZUlkID09PSB0aGlzLnN0YXRlLnNlbGVjdGVkRGV2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXREZXZpY2UoZGV2aWNlSWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmFwcGx5U2V0dGluZ3NUb1N0cmVhbSgpO1xuICAgIH1cbiAgICBhc3luYyBhcHBseVNldHRpbmdzVG9TdHJlYW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm11dGVTdHJlYW0oKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudW5tdXRlU3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHJhY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5tZWRpYVN0cmVhbT8uZ2V0VHJhY2tzKCkgPz8gW107XG4gICAgfVxuICAgIGFzeW5jIG11dGVTdHJlYW0oc3RvcFRyYWNrcyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLm1lZGlhU3RyZWFtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgJHtzdG9wVHJhY2tzID8gJ1N0b3BwaW5nJyA6ICdEaXNhYmxpbmcnfSBzdHJlYW1gKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbC5zdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lORUQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcFB1Ymxpc2hTdHJlYW0oc3RvcFRyYWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXRlTG9jYWxTdHJlYW0oc3RvcFRyYWNrcyk7XG4gICAgICAgIGNvbnN0IGFsbEVuZGVkID0gdGhpcy5nZXRUcmFja3MoKS5ldmVyeSgodCkgPT4gdC5yZWFkeVN0YXRlID09PSAnZW5kZWQnKTtcbiAgICAgICAgaWYgKGFsbEVuZGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5tZWRpYVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVsZWFzZSgpIGlzIHByZXNlbnQgaW4gcmVhY3QtbmF0aXZlLXdlYnJ0Y1xuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLnN0YXRlLm1lZGlhU3RyZWFtLnJlbGVhc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbGxlZCB0byBkaXNwb3NlIHRoZSBzdHJlYW0gaW4gUk5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1lZGlhU3RyZWFtLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0TWVkaWFTdHJlYW0odW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtdXRlVHJhY2tzKCkge1xuICAgICAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2suZW5hYmxlZClcbiAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bm11dGVUcmFja3MoKSB7XG4gICAgICAgIHRoaXMuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICghdHJhY2suZW5hYmxlZClcbiAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3BUcmFja3MoKSB7XG4gICAgICAgIHRoaXMuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFjay5yZWFkeVN0YXRlID09PSAnbGl2ZScpXG4gICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXV0ZUxvY2FsU3RyZWFtKHN0b3BUcmFja3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLm1lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3BUcmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFRyYWNrcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tdXRlVHJhY2tzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdW5tdXRlU3RyZWFtKCkge1xuICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCAnU3RhcnRpbmcgc3RyZWFtJyk7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1lZGlhU3RyZWFtICYmXG4gICAgICAgICAgICB0aGlzLmdldFRyYWNrcygpLmV2ZXJ5KCh0KSA9PiB0LnJlYWR5U3RhdGUgPT09ICdsaXZlJykpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IHRoaXMuc3RhdGUubWVkaWFTdHJlYW07XG4gICAgICAgICAgICB0aGlzLnVubXV0ZVRyYWNrcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvbnN0cmFpbnRzID0gdGhpcy5zdGF0ZS5kZWZhdWx0Q29uc3RyYWludHM7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29uc3RyYWludHMsXG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHRoaXMuc3RhdGUuc2VsZWN0ZWREZXZpY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGFpbnMgdHdvIG1lZGlhIHN0cmVhbXMgdG9nZXRoZXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3VyIGNhc2UsIGZpbHRlcnMgTWVkaWFTdHJlYW1zIGFyZSBkZXJpdmVkIGZyb20gdGhlaXIgcGFyZW50IE1lZGlhU3RyZWFtLlxuICAgICAgICAgICAgICogSG93ZXZlciwgb25jZSBhIGNoaWxkIGZpbHRlcidzIHRyYWNrIGlzIHN0b3BwZWQsXG4gICAgICAgICAgICAgKiB0aGUgdHJhY2tzIG9mIHRoZSBwYXJlbnQgTWVkaWFTdHJlYW0gYXJlbid0IGF1dG9tYXRpY2FsbHkgc3RvcHBlZC5cbiAgICAgICAgICAgICAqIFRoaXMgbGVhZHMgdG8gYSBzaXR1YXRpb24gd2hlcmUgdGhlIGNhbWVyYSBpbmRpY2F0b3IgbGlnaHQgaXMgc3RpbGwgb25cbiAgICAgICAgICAgICAqIGV2ZW4gdGhvdWdoIHRoZSB1c2VyIHN0b3BwZWQgcHVibGlzaGluZyB2aWRlby5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIGFyb3VuZCB0aGlzIGlzc3VlIGJ5IHN0b3BwaW5nIHRoZSBwYXJlbnQgTWVkaWFTdHJlYW0ncyB0cmFja3NcbiAgICAgICAgICAgICAqIGFzIHdlbGwgb25jZSB0aGUgY2hpbGQgZmlsdGVyJ3MgdHJhY2tzIGFyZSBzdG9wcGVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEl0IHdvcmtzIGJ5IHBhdGNoaW5nIHRoZSBzdG9wKCkgbWV0aG9kIG9mIHRoZSBjaGlsZCBmaWx0ZXIncyB0cmFja3MgdG8gYWxzbyBzdG9wXG4gICAgICAgICAgICAgKiB0aGUgcGFyZW50IE1lZGlhU3RyZWFtJ3MgdHJhY2tzIG9mIHRoZSBzYW1lIHR5cGUuIEhlcmUgd2UgYXNzdW1lIHRoYXRcbiAgICAgICAgICAgICAqIHRoZSBwYXJlbnQgTWVkaWFTdHJlYW0gaGFzIG9ubHkgb25lIHRyYWNrIG9mIGVhY2ggdHlwZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gcGFyZW50U3RyZWFtIHRoZSBwYXJlbnQgTWVkaWFTdHJlYW0uIE9taXQgZm9yIHRoZSByb290IHN0cmVhbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgY2hhaW5XaXRoID0gKHBhcmVudFN0cmVhbSkgPT4gYXN5bmMgKGZpbHRlclN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50U3RyZWFtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyU3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gT0w6IHRha2UgY2FyZSBvZiB0cmFjay5lbmFibGVkIHByb3BlcnR5IGFzIHdlbGxcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBhd2FpdCBwYXJlbnRTdHJlYW07XG4gICAgICAgICAgICAgICAgZmlsdGVyU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IHRyYWNrLnN0b3A7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdG9wLmNhbGwodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmdldFRyYWNrcygpLmZvckVhY2goKHBhcmVudFRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYWNrLmtpbmQgPT09IHRyYWNrLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhcmVudC5nZXRUcmFja3MoKS5mb3JFYWNoKChwYXJlbnRUcmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBwYXJlbnQgc3RyZWFtIGFicnVwdGx5IGVuZHMsIHdlIHByb3BhZ2F0ZSB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIGZpbHRlciBzdHJlYW0uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4gdGhlIGNhbWVyYS9taWNyb3Bob25lIHBlcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSByZXZva2VkIG9yIHdoZW4gdGhlIGRldmljZSBpcyBkaXNjb25uZWN0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZVBhcmVudFRyYWNrRW5kZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhY2sua2luZCAhPT0gdHJhY2sua2luZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZW5kZWQnKSk7IC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZVBhcmVudFRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZVBhcmVudFRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyU3RyZWFtO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHdlIHB1Ymxpc2ggdGhlIGxhc3QgTWVkaWFTdHJlYW0gb2YgdGhlIGNoYWluXG4gICAgICAgICAgICBzdHJlYW0gPSBhd2FpdCB0aGlzLmZpbHRlcnMucmVkdWNlKChwYXJlbnQsIGZpbHRlcikgPT4gcGFyZW50LnRoZW4oZmlsdGVyKS50aGVuKGNoYWluV2l0aChwYXJlbnQpKSwgdGhpcy5nZXRTdHJlYW0oY29uc3RyYWludHMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYWxsLnN0YXRlLmNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5FRCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubWVkaWFTdHJlYW0gIT09IHN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRNZWRpYVN0cmVhbShzdHJlYW0pO1xuICAgICAgICAgICAgdGhpcy5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZVByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzYWJsZVByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbWVkaWFEZXZpY2VLaW5kKCkge1xuICAgICAgICBpZiAodGhpcy50cmFja1R5cGUgPT09IFRyYWNrVHlwZS5BVURJTykge1xuICAgICAgICAgICAgcmV0dXJuICdhdWRpb2lucHV0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTykge1xuICAgICAgICAgICAgcmV0dXJuICd2aWRlb2lucHV0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGhhbmRsZURpc2Nvbm5lY3RlZE9yUmVwbGFjZWREZXZpY2VzKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChjcmVhdGVTdWJzY3JpcHRpb24oY29tYmluZUxhdGVzdChbXG4gICAgICAgICAgICBkZXZpY2VJZHMkLnBpcGUocGFpcndpc2UoKSksXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGVkRGV2aWNlJCxcbiAgICAgICAgXSksIGFzeW5jIChbW3ByZXZEZXZpY2VzLCBjdXJyZW50RGV2aWNlc10sIGRldmljZUlkXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzYWJsZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaXNEZXZpY2VEaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpc0RldmljZVJlcGxhY2VkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RGV2aWNlID0gdGhpcy5maW5kRGV2aWNlSW5MaXN0KGN1cnJlbnREZXZpY2VzLCBkZXZpY2VJZCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2RGV2aWNlID0gdGhpcy5maW5kRGV2aWNlSW5MaXN0KHByZXZEZXZpY2VzLCBkZXZpY2VJZCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnREZXZpY2UgJiYgcHJldkRldmljZSkge1xuICAgICAgICAgICAgICAgIGlzRGV2aWNlRGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnREZXZpY2UgJiZcbiAgICAgICAgICAgICAgICBwcmV2RGV2aWNlICYmXG4gICAgICAgICAgICAgICAgY3VycmVudERldmljZS5kZXZpY2VJZCA9PT0gcHJldkRldmljZS5kZXZpY2VJZCAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZ3JvdXBJZCAhPT0gcHJldkRldmljZS5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaXNEZXZpY2VSZXBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEZXZpY2VEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGV2aWNlUmVwbGFjZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1RyYWNrU3RvcHBlZER1ZVRvVHJhY2tFbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RyYWNrU3RvcHBlZER1ZVRvVHJhY2tFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGZpbmREZXZpY2VJbkxpc3QoZGV2aWNlcywgZGV2aWNlSWQpIHtcbiAgICAgICAgcmV0dXJuIGRldmljZXMuZmluZCgoZCkgPT4gZC5kZXZpY2VJZCA9PT0gZGV2aWNlSWQgJiYgZC5raW5kID09PSB0aGlzLm1lZGlhRGV2aWNlS2luZCk7XG4gICAgfVxufVxuXG5jbGFzcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIG5ldyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpc2FibGVNb2RlIHRoZSBkaXNhYmxlIG1vZGUgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uTmFtZSB0aGUgcGVybWlzc2lvbiBuYW1lIHRvIHVzZSBmb3IgcXVlcnlpbmcuXG4gICAgICogYHVuZGVmaW5lZGAgbWVhbnMgbm8gcGVybWlzc2lvbiBpcyByZXF1aXJlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkaXNhYmxlTW9kZSA9ICdzdG9wLXRyYWNrcycsIHBlcm1pc3Npb25OYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZU1vZGUgPSBkaXNhYmxlTW9kZTtcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uTmFtZSA9IHBlcm1pc3Npb25OYW1lO1xuICAgICAgICB0aGlzLnN0YXR1c1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMubWVkaWFTdHJlYW1TdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGV2aWNlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uc3RyYWludHNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBjdXJyZW50IG1lZGlhIHN0cmVhbSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGRldmljZSBpcyBjdXJyZW50bHkgZGlzYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtJCA9IHRoaXMubWVkaWFTdHJlYW1TdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGV2aWNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGV2aWNlJCA9IHRoaXMuc2VsZWN0ZWREZXZpY2VTdWJqZWN0XG4gICAgICAgICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBkZXZpY2Ugc3RhdHVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXR1cyQgPSB0aGlzLnN0YXR1c1N1YmplY3QuYXNPYnNlcnZhYmxlKCkucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIGZvciB0aGUgZGV2aWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uc3RyYWludHMkID0gdGhpcy5kZWZhdWx0Q29uc3RyYWludHNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JzZXJ2YWJsZSB0aGF0IHdpbGwgZW1pdCBgdHJ1ZWAgaWYgYnJvd3Nlci9zeXN0ZW0gcGVybWlzc2lvblxuICAgICAgICAgKiBpcyBncmFudGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQnJvd3NlclBlcm1pc3Npb24kID0gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGlmeUdyYW50ZWQgPSAoKSA9PiBzdWJzY3JpYmVyLm5leHQodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uc0FQSUF2YWlsYWJsZSA9ICEhbmF2aWdhdG9yPy5wZXJtaXNzaW9ucz8ucXVlcnk7XG4gICAgICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpIHx8ICF0aGlzLnBlcm1pc3Npb25OYW1lIHx8ICFwZXJtaXNzaW9uc0FQSUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIGdldExvZ2dlcihbJ2RldmljZXMnXSkoJ3dhcm4nLCBgUGVybWlzc2lvbnMgY2FuJ3QgYmUgcXVlcmllZC4gQXNzdW1pbmcgZ3JhbnRlZC5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZ5R3JhbnRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBlcm1pc3Npb25TdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG5vdGlmeSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoXG4gICAgICAgICAgICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdGhlICdjaGFuZ2UnIGV2ZW50IGRvZXNuJ3QgcmVsaWFibHkgZW1pdCBhbmQgaGVuY2UsXG4gICAgICAgICAgICAgICAgLy8gcGVybWlzc2lvblN0YXRlIHN0YXlzIGluICdwcm9tcHQnIHN0YXRlIGZvcmV2ZXIuXG4gICAgICAgICAgICAgICAgLy8gVHlwaWNhbGx5LCB0aGlzIGhhcHBlbnMgd2hlbiBhIHVzZXIgZ3JhbnRzIG9uZS10aW1lIHBlcm1pc3Npb24uXG4gICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBjaGVja2luZyBpZiBhIHBlcm1pc3Npb24gaXMgZ3JhbnRlZCwgd2UgY2hlY2sgaWYgaXQgaXNuJ3QgZGVuaWVkXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvblN0YXRlLnN0YXRlICE9PSAnZGVuaWVkJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmF2aWdhdG9yLnBlcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgLnF1ZXJ5KHsgbmFtZTogdGhpcy5wZXJtaXNzaW9uTmFtZSB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChwZXJtaXNzaW9uU3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvblN0YXRlID0gcGVybWlzc2lvblN0YXR1cztcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uU3RhdGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgbm90aWZ5KTtcbiAgICAgICAgICAgICAgICBub3RpZnkoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBwZXJtaXNzaW9uIGRvZXNuJ3QgZXhpc3Qgb3IgY2FuJ3QgYmUgcXVlcmllZCAtPiBhc3N1bWUgaXQncyBncmFudGVkXG4gICAgICAgICAgICAgICAgLy8gYW4gZXhhbXBsZSB3b3VsZCBiZSBGaXJlZm94LFxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIG5laXRoZXIgY2FtZXJhIG1pY3JvcGhvbmUgcGVybWlzc2lvbiBjYW4gYmUgcXVlcmllZFxuICAgICAgICAgICAgICAgIG5vdGlmeUdyYW50ZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uU3RhdGU/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG5vdGlmeSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5waXBlKHNoYXJlUmVwbGF5KDEpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICAgICAgICAgKiBub3QgZW1pdHRlZCBhIHZhbHVlIHlldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIFN1YmplY3QuXG4gICAgICAgICAqIEFuIGB1cGRhdGVgIGNhbiBlaXRoZXIgYmUgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB3aGljaCB0YWtlc1xuICAgICAgICAgKiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0IHRvIHVwZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHVwZGF0ZSB0aGUgdXBkYXRlIHRvIGFwcGx5IHRvIHRoZSBzdWJqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUgPSBzZXRDdXJyZW50VmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXZpY2Ugc3RhdHVzXG4gICAgICovXG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhdHVzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGV2aWNlXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5zZWxlY3RlZERldmljZSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBtZWRpYSBzdHJlYW0sIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBkZXZpY2UgaXMgY3VycmVudGx5IGRpc2FibGVkLlxuICAgICAqL1xuICAgIGdldCBtZWRpYVN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMubWVkaWFTdHJlYW0kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHN0YXR1c1xuICAgICAqL1xuICAgIHNldFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zdGF0dXNTdWJqZWN0LCBzdGF0dXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gc3RyZWFtIHRoZSBzdHJlYW0gdG8gc2V0LlxuICAgICAqL1xuICAgIHNldE1lZGlhU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm1lZGlhU3RyZWFtU3ViamVjdCwgc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5zZXREZXZpY2UodGhpcy5nZXREZXZpY2VJZEZyb21TdHJlYW0oc3RyZWFtKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBkZXZpY2UgaWQgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldERldmljZShkZXZpY2VJZCkge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNlbGVjdGVkRGV2aWNlU3ViamVjdCwgZGV2aWNlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIGZvciB0aGUgZGV2aWNlLlxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0Q29uc3RyYWludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmRlZmF1bHRDb25zdHJhaW50cyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIGZvciB0aGUgZGV2aWNlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byBzZXQuXG4gICAgICovXG4gICAgc2V0RGVmYXVsdENvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZGVmYXVsdENvbnN0cmFpbnRzU3ViamVjdCwgY29uc3RyYWludHMpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FtZXJhTWFuYWdlclN0YXRlIGV4dGVuZHMgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdG9wLXRyYWNrcycsIFxuICAgICAgICAvLyBgY2FtZXJhYCBpcyBub3QgaW4gdGhlIFczQyBzdGFuZGFyZCB5ZXQsXG4gICAgICAgIC8vIGJ1dCBpdCdzIHN1cHBvcnRlZCBieSBDaHJvbWUgYW5kIFNhZmFyaS5cbiAgICAgICAgJ2NhbWVyYScpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvblN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uJCA9IHRoaXMuZGlyZWN0aW9uU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHByZWZlcnJlZCBjYW1lcmEgZGlyZWN0aW9uXG4gICAgICogZnJvbnQgLSBtZWFucyB0aGUgY2FtZXJhIGZhY2luZyB0aGUgdXNlclxuICAgICAqIGJhY2sgLSBtZWFucyB0aGUgY2FtZXJhIGZhY2luZyB0aGUgZW52aXJvbm1lbnRcbiAgICAgKi9cbiAgICBnZXQgZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5kaXJlY3Rpb24kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmRpcmVjdGlvblN1YmplY3QsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldE1lZGlhU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICBzdXBlci5zZXRNZWRpYVN0cmVhbShzdHJlYW0pO1xuICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAvLyBSTiBnZXRTZXR0aW5ncygpIGRvZXNuJ3QgcmV0dXJuIGZhY2luZ01vZGUsIHNvIHdlIGRvbid0IHZlcmlmeSBjYW1lcmEgZGlyZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBpc1JlYWN0TmF0aXZlKClcbiAgICAgICAgICAgICAgICA/IHRoaXMuZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXT8uZ2V0U2V0dGluZ3MoKS5mYWNpbmdNb2RlID09PSAnZW52aXJvbm1lbnQnXG4gICAgICAgICAgICAgICAgICAgID8gJ2JhY2snXG4gICAgICAgICAgICAgICAgICAgIDogJ2Zyb250JztcbiAgICAgICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGV2aWNlSWRGcm9tU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0/LmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgfVxufVxuXG5jbGFzcyBDYW1lcmFNYW5hZ2VyIGV4dGVuZHMgSW5wdXRNZWRpYURldmljZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwpIHtcbiAgICAgICAgc3VwZXIoY2FsbCwgbmV3IENhbWVyYU1hbmFnZXJTdGF0ZSgpLCBUcmFja1R5cGUuVklERU8pO1xuICAgICAgICB0aGlzLnRhcmdldFJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICB3aWR0aDogMTI4MCxcbiAgICAgICAgICAgIGhlaWdodDogNzIwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIGNhbWVyYSBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGNhbWVyYSB0byBzZWxlY3QuXG4gICAgICovXG4gICAgYXN5bmMgc2VsZWN0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnN0YXRlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICAvLyBQcm92aWRpbmcgYm90aCBkZXZpY2UgaWQgYW5kIGRpcmVjdGlvbiBkb2Vzbid0IHdvcmssIHNvIHdlIGRlc2VsZWN0IHRoZSBkZXZpY2VcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXREZXZpY2UodW5kZWZpbmVkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHBseVNldHRpbmdzVG9TdHJlYW0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxpcHMgdGhlIGNhbWVyYSBkaXJlY3Rpb246IGlmIGl0J3MgZnJvbnQgaXQgd2lsbCBjaGFuZ2UgdG8gYmFjaywgaWYgaXQncyBiYWNrLCBpdCB3aWxsIGNoYW5nZSB0byBmcm9udC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGlmIHRoZXJlIGlzIG5vIGF2YWlsYWJsZSBjYW1lcmEgd2l0aCB0aGUgZGVzaXJlZCBkaXJlY3Rpb24sIHRoaXMgbWV0aG9kIHdpbGwgZG8gbm90aGluZy5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGZsaXAoKSB7XG4gICAgICAgIGNvbnN0IG5ld0RpcmVjdGlvbiA9IHRoaXMuc3RhdGUuZGlyZWN0aW9uID09PSAnZnJvbnQnID8gJ2JhY2snIDogJ2Zyb250JztcbiAgICAgICAgYXdhaXQgdGhpcy5zZWxlY3REaXJlY3Rpb24obmV3RGlyZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgYXN5bmMgc2VsZWN0VGFyZ2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbi5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBjb3VsZG4ndCBlbmFibGUgZGV2aWNlLCB0YXJnZXQgcmVzb2x1dGlvbiB3aWxsIGJlIGFwcGxpZWQgdGhlIG5leHQgdGltZSB1c2VyIGF0dGVtcHRzIHRvIHN0YXJ0IHRoZSBkZXZpY2VcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsICdjb3VsZCBub3QgYXBwbHkgdGFyZ2V0IHJlc29sdXRpb24nLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zdGF0ZVxuICAgICAgICAgICAgICAgIC5tZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdXG4gICAgICAgICAgICAgICAgPy5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLnRhcmdldFJlc29sdXRpb24ud2lkdGggfHxcbiAgICAgICAgICAgICAgICBoZWlnaHQgIT09IHRoaXMudGFyZ2V0UmVzb2x1dGlvbi5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcGx5U2V0dGluZ3NUb1N0cmVhbSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGAke3dpZHRofXgke2hlaWdodH0gdGFyZ2V0IHJlc29sdXRpb24gYXBwbGllZCB0byBtZWRpYSBzdHJlYW1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcmVmZXJyZWQgY29kZWMgZm9yIGVuY29kaW5nIHRoZSB2aWRlby5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbCBpbnRlcm5hbCB1c2Ugb25seSwgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkuXG4gICAgICogQHBhcmFtIGNvZGVjIHRoZSBjb2RlYyB0byB1c2UgZm9yIGVuY29kaW5nIHRoZSB2aWRlby5cbiAgICAgKi9cbiAgICBzZXRQcmVmZXJyZWRDb2RlYyhjb2RlYykge1xuICAgICAgICB0aGlzLnByZWZlcnJlZENvZGVjID0gY29kZWM7XG4gICAgfVxuICAgIGdldERldmljZXMoKSB7XG4gICAgICAgIHJldHVybiBnZXRWaWRlb0RldmljZXMoKTtcbiAgICB9XG4gICAgZ2V0U3RyZWFtKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLndpZHRoID0gdGhpcy50YXJnZXRSZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICBjb25zdHJhaW50cy5oZWlnaHQgPSB0aGlzLnRhcmdldFJlc29sdXRpb24uaGVpZ2h0O1xuICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYm90aCBkZXZpY2UgaWQgYW5kIGZhY2luZyBtb2RlXG4gICAgICAgIC8vIERldmljZSBpZCBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgIGlmICghY29uc3RyYWludHMuZGV2aWNlSWQgJiYgdGhpcy5zdGF0ZS5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLmZhY2luZ01vZGUgPVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGlyZWN0aW9uID09PSAnZnJvbnQnID8gJ3VzZXInIDogJ2Vudmlyb25tZW50JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0VmlkZW9TdHJlYW0oY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBwdWJsaXNoU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLnB1Ymxpc2hWaWRlb1N0cmVhbShzdHJlYW0sIHtcbiAgICAgICAgICAgIHByZWZlcnJlZENvZGVjOiB0aGlzLnByZWZlcnJlZENvZGVjLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcFB1Ymxpc2hTdHJlYW0oc3RvcFRyYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLnN0b3BQdWJsaXNoKFRyYWNrVHlwZS5WSURFTywgc3RvcFRyYWNrcyk7XG4gICAgfVxufVxuXG5jbGFzcyBNaWNyb3Bob25lTWFuYWdlclN0YXRlIGV4dGVuZHMgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdkaXNhYmxlLXRyYWNrcycsIFxuICAgICAgICAvLyBgbWljcm9waG9uZWAgaXMgbm90IGluIHRoZSBXM0Mgc3RhbmRhcmQgeWV0LFxuICAgICAgICAvLyBidXQgaXQncyBzdXBwb3J0ZWQgYnkgQ2hyb21lIGFuZCBTYWZhcmkuXG4gICAgICAgICdtaWNyb3Bob25lJyk7XG4gICAgICAgIHRoaXMuc3BlYWtpbmdXaGlsZU11dGVkU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICAgICAgICB0aGlzLnNwZWFraW5nV2hpbGVNdXRlZCQgPSB0aGlzLnNwZWFraW5nV2hpbGVNdXRlZFN1YmplY3RcbiAgICAgICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0cnVlYCBpZiB0aGUgdXNlcidzIG1pY3JvcGhvbmUgaXMgbXV0ZWQgYnV0IHRoZXknYXJlIHNwZWFraW5nLlxuICAgICAqXG4gICAgICogVGhpcyBmZWF0dXJlIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIFJlYWN0IE5hdGl2ZSBTREsuXG4gICAgICovXG4gICAgZ2V0IHNwZWFraW5nV2hpbGVNdXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc3BlYWtpbmdXaGlsZU11dGVkJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldFNwZWFraW5nV2hpbGVNdXRlZChpc1NwZWFraW5nKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc3BlYWtpbmdXaGlsZU11dGVkU3ViamVjdCwgaXNTcGVha2luZyk7XG4gICAgfVxuICAgIGdldERldmljZUlkRnJvbVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdPy5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgIH1cbn1cblxuY29uc3QgREVURUNUSU9OX0ZSRVFVRU5DWV9JTl9NUyA9IDUwMDtcbmNvbnN0IEFVRElPX0xFVkVMX1RIUkVTSE9MRCQxID0gMTUwO1xuY29uc3QgRkZUX1NJWkUgPSAxMjg7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc291bmQgZGV0ZWN0b3IuXG4gKlxuICogQHBhcmFtIGF1ZGlvU3RyZWFtIHRoZSBhdWRpbyBzdHJlYW0gdG8gb2JzZXJ2ZS4gRGVwZW5kaW5nIG9uIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uLCB0aGlzIHN0cmVhbSBtaWdodCBiZSBkZXN0cm95ZWQgd2hlbiB0aGUgc291bmQgZGV0ZWN0b3IgaXMgc3RvcHBlZC5cbiAqIEBwYXJhbSBvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQgYSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgc291bmQgc3RhdGUgY2hhbmdlcy5cbiAqIEBwYXJhbSBvcHRpb25zIGN1c3RvbSBvcHRpb25zIGZvciB0aGUgc291bmQgZGV0ZWN0b3IuXG4gKiBAcmV0dXJucyBhIGNsZWFuLXVwIGZ1bmN0aW9uIHdoaWNoIG9uY2UgaW52b2tlZCBzdG9wcyB0aGUgc291bmQgZGV0ZWN0b3IuXG4gKi9cbmNvbnN0IGNyZWF0ZVNvdW5kRGV0ZWN0b3IgPSAoYXVkaW9TdHJlYW0sIG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBkZXRlY3Rpb25GcmVxdWVuY3lJbk1zID0gREVURUNUSU9OX0ZSRVFVRU5DWV9JTl9NUywgYXVkaW9MZXZlbFRocmVzaG9sZCA9IEFVRElPX0xFVkVMX1RIUkVTSE9MRCQxLCBmZnRTaXplID0gRkZUX1NJWkUsIGRlc3Ryb3lTdHJlYW1PblN0b3AgPSB0cnVlLCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgY29uc3QgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICBhbmFseXNlci5mZnRTaXplID0gZmZ0U2l6ZTtcbiAgICBjb25zdCBtaWNyb3Bob25lID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGF1ZGlvU3RyZWFtKTtcbiAgICBtaWNyb3Bob25lLmNvbm5lY3QoYW5hbHlzZXIpO1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gICAgICAgIGFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKGRhdGEpO1xuICAgICAgICBjb25zdCBpc1NvdW5kRGV0ZWN0ZWQgPSBkYXRhLnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSA+PSBhdWRpb0xldmVsVGhyZXNob2xkKTtcbiAgICAgICAgY29uc3QgYXZlcmFnZWREYXRhVmFsdWUgPSBkYXRhLnJlZHVjZSgocHYsIGN2KSA9PiBwdiArIGN2LCAwKSAvIGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gYXZlcmFnZWREYXRhVmFsdWUgPiBhdWRpb0xldmVsVGhyZXNob2xkXG4gICAgICAgICAgICA/IDEwMFxuICAgICAgICAgICAgOiBNYXRoLnJvdW5kKChhdmVyYWdlZERhdGFWYWx1ZSAvIGF1ZGlvTGV2ZWxUaHJlc2hvbGQpICogMTAwKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgdHJhY2sgaXMgZGlzYWJsZWQsIGl0IHRha2VzIHRpbWUgZm9yIHRoZSBidWZmZXIgdG8gZW1wdHlcbiAgICAgICAgLy8gVGhpcyBjaGVjayB3aWxsIGVuc3VyZSB0aGF0IHdlIGRvbid0IHNlbmQgYW55dGhpbmcgaWYgdGhlIHRyYWNrIGlzIGRpc2FibGVkXG4gICAgICAgIGlmIChhdWRpb1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdPy5lbmFibGVkKSB7XG4gICAgICAgICAgICBvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQoeyBpc1NvdW5kRGV0ZWN0ZWQsIGF1ZGlvTGV2ZWw6IHBlcmNlbnRhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQoeyBpc1NvdW5kRGV0ZWN0ZWQ6IGZhbHNlLCBhdWRpb0xldmVsOiAwIH0pO1xuICAgICAgICB9XG4gICAgfSwgZGV0ZWN0aW9uRnJlcXVlbmN5SW5Ncyk7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIC8vIGNsZWFuLXVwIHRoZSBBdWRpb0NvbnRleHQgZWxlbWVudHNcbiAgICAgICAgbWljcm9waG9uZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIGFuYWx5c2VyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgYXdhaXQgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIC8vIHN0b3AgdGhlIHN0cmVhbVxuICAgICAgICBpZiAoZGVzdHJveVN0cmVhbU9uU3RvcCkge1xuICAgICAgICAgICAgYXVkaW9TdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgYXVkaW9TdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBGbGF0dGVuIHRoZSBzdGF0cyByZXBvcnQgaW50byBhbiBhcnJheSBvZiBzdGF0cyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSByZXBvcnQgdGhlIHJlcG9ydCB0byBmbGF0dGVuLlxuICovXG5jb25zdCBmbGF0dGVuID0gKHJlcG9ydCkgPT4ge1xuICAgIGNvbnN0IHN0YXRzID0gW107XG4gICAgcmVwb3J0LmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgc3RhdHMucHVzaChzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdHM7XG59O1xuY29uc3QgQVVESU9fTEVWRUxfVEhSRVNIT0xEID0gMC4yO1xuY2xhc3MgUk5TcGVlY2hEZXRlY3RvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGMxID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHt9KTtcbiAgICAgICAgdGhpcy5wYzIgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHNwZWVjaCBkZXRlY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1N0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYzEuYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjMi5hZGRJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBjMi5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGMxLmFkZEljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF1ZGlvU3RyZWFtXG4gICAgICAgICAgICAgICAgLmdldFRyYWNrcygpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKHRyYWNrKSA9PiB0aGlzLnBjMS5hZGRUcmFjayh0cmFjaywgYXVkaW9TdHJlYW0pKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5wYzEuY3JlYXRlT2ZmZXIoe30pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYzIuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYzEuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLnBjMi5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMxLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBjMi5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrcyA9IGF1ZGlvU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG11dGUgdGhlIGF1ZGlvIHRyYWNrIGZvciB0aGlzIHRlbXBvcmFyeSBzdHJlYW0sIG9yIGVsc2UgeW91IHdpbGwgaGVhciB5b3Vyc2VsZiB0d2ljZSB3aGlsZSBpbiB0aGUgY2FsbC5cbiAgICAgICAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiAodHJhY2suZW5hYmxlZCA9IGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb25uZWN0aW5nIGFuZCBuZWdvdGlhdGluZyBiZXR3ZWVuIFBlZXJDb25uZWN0aW9uczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIHNwZWVjaCBkZXRlY3Rpb24gYW5kIHJlbGVhc2VzIGFsbCBhbGxvY2F0ZWQgcmVzb3VyY2VzLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMucGMxLmNsb3NlKCk7XG4gICAgICAgIHRoaXMucGMyLmNsb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRoYXQgZGV0ZWN0cyB0aGUgYXVkaW8gbGV2ZWxzIGFuZCByZXR1cm5zIHRoZSBzdGF0dXMuXG4gICAgICovXG4gICAgb25TcGVha2luZ0RldGVjdGVkU3RhdGVDaGFuZ2Uob25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gKGF3YWl0IHRoaXMucGMxLmdldFN0YXRzKCkpO1xuICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gZmxhdHRlbihzdGF0cyk7XG4gICAgICAgICAgICAvLyBBdWRpbyBsZXZlbHMgYXJlIHByZXNlbnQgaW5zaWRlIHN0YXRzIG9mIHR5cGUgYG1lZGlhLXNvdXJjZWAgYW5kIG9mIGtpbmQgYGF1ZGlvYFxuICAgICAgICAgICAgY29uc3QgYXVkaW9NZWRpYVNvdXJjZVN0YXRzID0gcmVwb3J0LmZpbmQoKHN0YXQpID0+IHN0YXQudHlwZSA9PT0gJ21lZGlhLXNvdXJjZScgJiZcbiAgICAgICAgICAgICAgICBzdGF0LmtpbmQgPT09ICdhdWRpbycpO1xuICAgICAgICAgICAgaWYgKGF1ZGlvTWVkaWFTb3VyY2VTdGF0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXVkaW9MZXZlbCB9ID0gYXVkaW9NZWRpYVNvdXJjZVN0YXRzO1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb0xldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb0xldmVsID49IEFVRElPX0xFVkVMX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NvdW5kRGV0ZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9MZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NvdW5kRGV0ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvTGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBNaWNyb3Bob25lTWFuYWdlciBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsKSB7XG4gICAgICAgIHN1cGVyKGNhbGwsIG5ldyBNaWNyb3Bob25lTWFuYWdlclN0YXRlKCksIFRyYWNrVHlwZS5BVURJTyk7XG4gICAgICAgIGNvbWJpbmVMYXRlc3QoW1xuICAgICAgICAgICAgdGhpcy5jYWxsLnN0YXRlLmNhbGxpbmdTdGF0ZSQsXG4gICAgICAgICAgICB0aGlzLmNhbGwuc3RhdGUub3duQ2FwYWJpbGl0aWVzJCxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0ZWREZXZpY2UkLFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGF0dXMkLFxuICAgICAgICBdKS5zdWJzY3JpYmUoYXN5bmMgKFtjYWxsaW5nU3RhdGUsIG93bkNhcGFiaWxpdGllcywgZGV2aWNlSWQsIHN0YXR1c10pID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsaW5nU3RhdGUgIT09IENhbGxpbmdTdGF0ZS5KT0lORUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuTEVGVCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG93bkNhcGFiaWxpdGllcy5pbmNsdWRlcyhPd25DYXBhYmlsaXR5LlNFTkRfQVVESU8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0U3BlYWtpbmdXaGlsZU11dGVkRGV0ZWN0aW9uKGRldmljZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RGV2aWNlcygpIHtcbiAgICAgICAgcmV0dXJuIGdldEF1ZGlvRGV2aWNlcygpO1xuICAgIH1cbiAgICBnZXRTdHJlYW0oY29uc3RyYWludHMpIHtcbiAgICAgICAgcmV0dXJuIGdldEF1ZGlvU3RyZWFtKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgcHVibGlzaFN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5wdWJsaXNoQXVkaW9TdHJlYW0oc3RyZWFtKTtcbiAgICB9XG4gICAgc3RvcFB1Ymxpc2hTdHJlYW0oc3RvcFRyYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLnN0b3BQdWJsaXNoKFRyYWNrVHlwZS5BVURJTywgc3RvcFRyYWNrcyk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0U3BlYWtpbmdXaGlsZU11dGVkRGV0ZWN0aW9uKGRldmljZUlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbigpO1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJuU3BlZWNoRGV0ZWN0b3IgPSBuZXcgUk5TcGVlY2hEZXRlY3RvcigpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yblNwZWVjaERldGVjdG9yLnN0YXJ0KCk7XG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMucm5TcGVlY2hEZXRlY3Rvcj8ub25TcGVha2luZ0RldGVjdGVkU3RhdGVDaGFuZ2UoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTcGVha2luZ1doaWxlTXV0ZWQoZXZlbnQuaXNTb3VuZERldGVjdGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zb3VuZERldGVjdG9yQ2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucm5TcGVlY2hEZXRlY3Rvcj8uc3RvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucm5TcGVlY2hEZXRlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHN0YXJ0IGEgbmV3IHN0cmVhbSB0aGF0J3Mgbm90IGNvbm5lY3RlZCB0byBwdWJsaXNoZXJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRoaXMuZ2V0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zb3VuZERldGVjdG9yQ2xlYW51cCA9IGNyZWF0ZVNvdW5kRGV0ZWN0b3Ioc3RyZWFtLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldFNwZWFraW5nV2hpbGVNdXRlZChldmVudC5pc1NvdW5kRGV0ZWN0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3RvcFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvdW5kRGV0ZWN0b3JDbGVhbnVwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTcGVha2luZ1doaWxlTXV0ZWQoZmFsc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zb3VuZERldGVjdG9yQ2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5zb3VuZERldGVjdG9yQ2xlYW51cCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2NyZWVuU2hhcmVTdGF0ZSBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmF1ZGlvRW5hYmxlZFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRydWUpO1xuICAgICAgICB0aGlzLnNldHRpbmdzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgYXVkaW8gc3RhdHVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdWRpb0VuYWJsZWQkID0gdGhpcy5hdWRpb0VuYWJsZWRTdWJqZWN0XG4gICAgICAgICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBzZXR0aW5ncy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0dGluZ3MkID0gdGhpcy5zZXR0aW5nc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0RGV2aWNlSWRGcm9tU3RyZWFtID0gKHN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3RyYWNrXSA9IHN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFjaz8uZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIGF1ZGlvIHN0YXR1cy5cbiAgICAgKi9cbiAgICBnZXQgYXVkaW9FbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5hdWRpb0VuYWJsZWQkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBhdWRpbyBzdGF0dXMuXG4gICAgICovXG4gICAgc2V0QXVkaW9FbmFibGVkKGlzRW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmF1ZGlvRW5hYmxlZFN1YmplY3QsIGlzRW5hYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBnZXQgc2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnNldHRpbmdzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3MgdGhlIHNjcmVlbiBzaGFyZSBzZXR0aW5ncyB0byBzZXQuXG4gICAgICovXG4gICAgc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZXR0aW5nc1N1YmplY3QsIHNldHRpbmdzKTtcbiAgICB9XG59XG5cbmNsYXNzIFNjcmVlblNoYXJlTWFuYWdlciBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsKSB7XG4gICAgICAgIHN1cGVyKGNhbGwsIG5ldyBTY3JlZW5TaGFyZVN0YXRlKCksIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIGVuYWJsZSBzY3JlZW4gc2hhcmUgYXVkaW8gb3B0aW9ucyBvbiBzdXBwb3J0ZWQgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogTm90ZTogZm9yIG9uZ29pbmcgc2NyZWVuIHNoYXJlLCBhdWRpbyB3b24ndCBiZSBlbmFibGVkIHVudGlsIHlvdVxuICAgICAqIHJlLXB1Ymxpc2ggdGhlIHNjcmVlbiBzaGFyZSBzdHJlYW0uXG4gICAgICovXG4gICAgZW5hYmxlU2NyZWVuU2hhcmVBdWRpbygpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRBdWRpb0VuYWJsZWQodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgZGlzYWJsZSBzY3JlZW4gc2hhcmUgYXVkaW8gb3B0aW9ucyBvbiBzdXBwb3J0ZWQgcGxhdGZvcm1zLlxuICAgICAqL1xuICAgIGFzeW5jIGRpc2FibGVTY3JlZW5TaGFyZUF1ZGlvKCkge1xuICAgICAgICB0aGlzLnN0YXRlLnNldEF1ZGlvRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmNhbGwucHVibGlzaGVyPy5pc1B1Ymxpc2hpbmcoVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTykpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FsbC5zdG9wUHVibGlzaChUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2V0dGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNldHRpbmdzIHRoZSBzZXR0aW5ncyB0byBzZXQuXG4gICAgICovXG4gICAgc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfVxuICAgIGdldERldmljZXMoKSB7XG4gICAgICAgIHJldHVybiBvZihbXSk7IC8vIHRoZXJlIGFyZSBubyBkZXZpY2VzIHRvIGJlIGxpc3RlZCBmb3IgU2NyZWVuIFNoYXJlXG4gICAgfVxuICAgIGdldFN0cmVhbShjb25zdHJhaW50cykge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuYXVkaW9FbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTY3JlZW5TaGFyZVN0cmVhbShjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIHB1Ymxpc2hTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwucHVibGlzaFNjcmVlblNoYXJlU3RyZWFtKHN0cmVhbSwge1xuICAgICAgICAgICAgc2NyZWVuU2hhcmVTZXR0aW5nczogdGhpcy5zdGF0ZS5zZXR0aW5ncyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BQdWJsaXNoU3RyZWFtKHN0b3BUcmFja3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsLnN0b3BQdWJsaXNoKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUsIHN0b3BUcmFja3MpO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGwuc3RvcFB1Ymxpc2goVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTywgc3RvcFRyYWNrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgc2VsZWN0YCBtZXRob2QgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGV2aWNlSWQgaWdub3JlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzZWxlY3QoZGV2aWNlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGluIGZvciBTY3JlZW4gU2hhcmUnKTtcbiAgICB9XG59XG5cbmNsYXNzIFNwZWFrZXJTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREZXZpY2VTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCgnJyk7XG4gICAgICAgIHRoaXMudm9sdW1lU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoMSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBbVGVsbHMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gb3V0cHV0IGNoYW5nZSBvbiAnYXVkaW8nIGVsZW1lbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0RldmljZVNlbGVjdGlvblN1cHBvcnRlZCA9IGNoZWNrSWZBdWRpb091dHB1dENoYW5nZVN1cHBvcnRlZCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbiBvYnNlcnZhYmxlLCBvciB1bmRlZmluZWQgaWYgdGhlIG9ic2VydmFibGUgaGFzXG4gICAgICAgICAqIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSQgdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VmFsdWUgPSBnZXRDdXJyZW50VmFsdWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAgICAgICAgICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gICAgICAgICAqIHRoZSBjdXJyZW50IHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gdXBkYXRlLlxuICAgICAgICAgKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gICAgICAgICAqIEByZXR1cm4gdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSA9IHNldEN1cnJlbnRWYWx1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERldmljZSQgPSB0aGlzLnNlbGVjdGVkRGV2aWNlU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgdGhpcy52b2x1bWUkID0gdGhpcy52b2x1bWVTdWJqZWN0XG4gICAgICAgICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRldmljZVxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5zZWxlY3RlZERldmljZSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHZvbHVtZVxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAgICovXG4gICAgZ2V0IHZvbHVtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMudm9sdW1lJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBkZXZpY2VJZFxuICAgICAqL1xuICAgIHNldERldmljZShkZXZpY2VJZCkge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNlbGVjdGVkRGV2aWNlU3ViamVjdCwgZGV2aWNlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gdm9sdW1lXG4gICAgICovXG4gICAgc2V0Vm9sdW1lKHZvbHVtZSkge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnZvbHVtZVN1YmplY3QsIHZvbHVtZSk7XG4gICAgfVxufVxuXG5jbGFzcyBTcGVha2VyTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFNwZWFrZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2VzIHRoZSBtYW5hZ2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzKSA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICBpZiAoZGV2aWNlSWRzJCAmJiAhaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChjb21iaW5lTGF0ZXN0KFtkZXZpY2VJZHMkLCB0aGlzLnN0YXRlLnNlbGVjdGVkRGV2aWNlJF0pLnN1YnNjcmliZSgoW2RldmljZXMsIGRldmljZUlkXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2UgPSBkZXZpY2VzLmZpbmQoKGQpID0+IGQuZGV2aWNlSWQgPT09IGRldmljZUlkICYmIGQua2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgYXZhaWxhYmxlIGF1ZGlvIG91dHB1dCBkZXZpY2VzXG4gICAgICpcbiAgICAgKiBOb3RlOiBJdCBwcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gdXNlIGRldmljZXMgKGlmIG5vdCBhbHJlYWR5IGdyYW50ZWQpXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgaWYgYSBkZXZpY2UgaXMgY29ubmVjdGVkIG9yIGRpc2Nvbm5lY3RlZFxuICAgICAqL1xuICAgIGxpc3REZXZpY2VzKCkge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZS4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZ2V0c3RyZWFtLmlvL3ZpZGVvL2RvY3MvcmVhY3RuYXRpdmUvY29yZS9jYW1lcmEtYW5kLW1pY3JvcGhvbmUvI3NwZWFrZXItbWFuYWdlbWVudCBmb3IgbW9yZSBkZXRhaWxzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEF1ZGlvT3V0cHV0RGV2aWNlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGRldmljZUlkIGVtcHR5IHN0cmluZyBtZWFucyB0aGUgc3lzdGVtIGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3QoZGV2aWNlSWQpIHtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmUuIFBsZWFzZSB2aXNpdCBodHRwczovL2dldHN0cmVhbS5pby92aWRlby9kb2NzL3JlYWN0bmF0aXZlL2NvcmUvY2FtZXJhLWFuZC1taWNyb3Bob25lLyNzcGVha2VyLW1hbmFnZW1lbnQgZm9yIG1vcmUgZGV0YWlscycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0RGV2aWNlKGRldmljZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2b2x1bWUgb2YgdGhlIGF1ZGlvIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHZvbHVtZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgICAqL1xuICAgIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBpbiBSZWFjdCBOYXRpdmUuIFBsZWFzZSB2aXNpdCBodHRwczovL2dldHN0cmVhbS5pby92aWRlby9kb2NzL3JlYWN0bmF0aXZlL2NvcmUvY2FtZXJhLWFuZC1taWNyb3Bob25lLyNzcGVha2VyLW1hbmFnZW1lbnQgZm9yIG1vcmUgZGV0YWlscycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2b2x1bWUgJiYgKHZvbHVtZSA8IDAgfHwgdm9sdW1lID4gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVm9sdW1lIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2b2x1bWUgb2YgYSBwYXJ0aWNpcGFudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgcGFydGljaXBhbnQncyBzZXNzaW9uIGlkLlxuICAgICAqIEBwYXJhbSB2b2x1bWUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiBTZXQgaXQgdG8gYHVuZGVmaW5lZGAgdG8gdXNlIHRoZSBkZWZhdWx0IHZvbHVtZS5cbiAgICAgKi9cbiAgICBzZXRQYXJ0aWNpcGFudFZvbHVtZShzZXNzaW9uSWQsIHZvbHVtZSkge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZS4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZ2V0c3RyZWFtLmlvL3ZpZGVvL2RvY3MvcmVhY3RuYXRpdmUvY29yZS9jYW1lcmEtYW5kLW1pY3JvcGhvbmUvI3NwZWFrZXItbWFuYWdlbWVudCBmb3IgbW9yZSBkZXRhaWxzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZvbHVtZSAmJiAodm9sdW1lIDwgMCB8fCB2b2x1bWUgPiAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWb2x1bWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbC5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIHsgYXVkaW9Wb2x1bWU6IHZvbHVtZSB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgYENhbGxgLlxuICovXG5jbGFzcyBDYWxsIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBDYWxsYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IERvbid0IGNhbGwgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5LCBpbnN0ZWFkXG4gICAgICogVXNlIHRoZSBbYFN0cmVhbVZpZGVvQ2xpZW50LmNhbGxgXSguL1N0cmVhbVZpZGVvQ2xpZW50Lm1kLyNjYWxsKVxuICAgICAqIG1ldGhvZCB0byBjb25zdHJ1Y3QgYSBgQ2FsbGAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB0eXBlLCBpZCwgc3RyZWFtQ2xpZW50LCBtZW1iZXJzLCBvd25DYXBhYmlsaXRpZXMsIHNvcnRQYXJ0aWNpcGFudHNCeSwgY2xpZW50U3RvcmUsIHJpbmdpbmcgPSBmYWxzZSwgd2F0Y2hpbmcgPSBmYWxzZSwgfSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXRlIG9mIHRoaXMgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgQ2FsbFN0YXRlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRHluYXNjYWxlTWFuYWdlciBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHluYXNjYWxlTWFuYWdlciA9IG5ldyBEeW5hc2NhbGVNYW5hZ2VyKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlcm1pc3Npb25zIGNvbnRleHQgb2YgdGhpcyBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQgPSBuZXcgUGVybWlzc2lvbnNDb250ZXh0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBpbnN0YW5jZSBkZWRpY2F0ZWQgdG8gdGhpcyBDYWxsIGluc3RhbmNlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoKTtcbiAgICAgICAgdGhpcy50cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh7IHR5cGU6IERlYm91bmNlVHlwZS5NRURJVU0sIGRhdGE6IFtdIH0pO1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cyA9IDEwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IGhvb2tzL2Z1bmN0aW9ucyB0byBpbnZva2Ugd2hlbiB0aGUgY2FsbCBpcyBsZWZ0LlxuICAgICAgICAgKiBBIHR5cGljYWwgdXNlIGNhc2UgaXMgdG8gY2xlYW4gdXAgc29tZSBnbG9iYWwgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudEV2ZW50SGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgY2FuIHN1YnNjcmliZSB0byBXZWJTb2NrZXQgZXZlbnRzIHByb3ZpZGVkIGJ5IHRoZSBBUEkuIFRvIHJlbW92ZSBhIHN1YnNjcmlwdGlvbiwgY2FsbCB0aGUgYG9mZmAgbWV0aG9kLlxuICAgICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHN1YnNjcmliaW5nIHRvIFdlYlNvY2tldCBldmVudHMgaXMgYW4gYWR2YW5jZWQgdXNlLWNhc2UuXG4gICAgICAgICAqIEZvciBtb3N0IHVzZS1jYXNlcywgaXQgc2hvdWxkIGJlIGVub3VnaCB0byB3YXRjaCBmb3Igc3RhdGUgY2hhbmdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB0aGUgZXZlbnQgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIGZuIHRoZSBldmVudCBoYW5kbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbiA9IChldmVudE5hbWUsIGZuKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTZnVFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZkhhbmRsZXIgPSB0aGlzLnN0cmVhbUNsaWVudC5vbihldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jYWxsX2NpZCAmJiBldmVudC5jYWxsX2NpZCA9PT0gdGhpcy5jaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8ga2VlcCB0aGUgJ29mZicgcmVmZXJlbmNlIHJldHVybmVkIGJ5IHRoZSBzdHJlYW0gY2xpZW50XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNsaWVudEV2ZW50SGFuZGxlcnMuc2V0KGZuLCBvZmZIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHN1YnNjcmlwdGlvbiBmb3IgV2ViU29ja2V0IGV2ZW50cyB0aGF0IHdlcmUgY3JlYXRlZCBieSB0aGUgYG9uYCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgdGhlIGV2ZW50IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSBmbiB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2ZmID0gKGV2ZW50TmFtZSwgZm4pID0+IHtcbiAgICAgICAgICAgIGlmIChpc1NmdUV2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaGVyLm9mZihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gdGhlIHN0cmVhbSBjbGllbnQgZXZlbnQgYnkgdXNpbmcgdGhlICdvZmYnIHJlZmVyZW5jZVxuICAgICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZE9mZkhhbmRsZXIgPSB0aGlzLnN0cmVhbUNsaWVudEV2ZW50SGFuZGxlcnMuZ2V0KGZuKTtcbiAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkT2ZmSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRPZmZIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWF2ZSB0aGUgY2FsbCBhbmQgc3RvcCB0aGUgbWVkaWEgc3RyZWFtcyB0aGF0IHdlcmUgcHVibGlzaGVkIGJ5IHRoZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWF2ZSA9IGFzeW5jICh7IHJlamVjdCA9IGZhbHNlLCByZWFzb24gPSAndXNlciBpcyBsZWF2aW5nIHRoZSBjYWxsJywgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsaW5nU3RhdGUgPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZTtcbiAgICAgICAgICAgIGlmIChjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5MRUZUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbGVhdmUgY2FsbCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gbGVmdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lOSU5HKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnRDYWxsSm9pbmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yaW5naW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gSSdtIHRoZSBvbmUgd2hvIHN0YXJ0ZWQgdGhlIGNhbGwsIHNvIEkgc2hvdWxkIGNhbmNlbCBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNPdGhlclBhcnRpY2lwYW50cyA9IHRoaXMuc3RhdGUucmVtb3RlUGFydGljaXBhbnRzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDcmVhdGVkQnlNZSAmJiAhaGFzT3RoZXJQYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lnbmFscyBvdGhlciB1c2VycyB0aGF0IEkgaGF2ZSBjYW5jZWxsZWQgbXkgY2FsbCB0byB0aGVtXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSB0aGV5IGFjY2VwdGVkIGl0LlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWplY3QgJiYgY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuUklOR0lORykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaWduYWxzIG90aGVyIHVzZXJzIHRoYXQgSSBoYXZlIHJlamVjdGVkIHRoZSBpbmNvbWluZyBjYWxsLlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlcj8uc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0c1JlcG9ydGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zZnVTdGF0c1JlcG9ydGVyPy5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLnNmdVN0YXRzUmVwb3J0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXI/LmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hlcj8uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zZnVDbGllbnQ/LmNsb3NlKFN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSwgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuc2Z1Q2xpZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLm9mZkFsbCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLkxFRlQpO1xuICAgICAgICAgICAgLy8gQ2FsbCBhbGwgbGVhdmUgY2FsbCBob29rcywgZS5nLiB0byBjbGVhbiB1cCBnbG9iYWwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuZm9yRWFjaCgoaG9vaykgPT4gaG9vaygpKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50U3RvcmUudW5yZWdpc3RlckNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JlZW5TaGFyZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNwZWFrZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcE9uTGVhdmVQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhLnN0b3BPbkxlYXZlKSB7XG4gICAgICAgICAgICAgICAgc3RvcE9uTGVhdmVQcm9taXNlcy5wdXNoKHRoaXMuY2FtZXJhLmRpc2FibGUodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWljcm9waG9uZS5zdG9wT25MZWF2ZSkge1xuICAgICAgICAgICAgICAgIHN0b3BPbkxlYXZlUHJvbWlzZXMucHVzaCh0aGlzLm1pY3JvcGhvbmUuZGlzYWJsZSh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JlZW5TaGFyZS5zdG9wT25MZWF2ZSkge1xuICAgICAgICAgICAgICAgIHN0b3BPbkxlYXZlUHJvbWlzZXMucHVzaCh0aGlzLnNjcmVlblNoYXJlLmRpc2FibGUodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RvcE9uTGVhdmVQcm9taXNlcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkcyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMucmluZyBpZiBzZXQgdG8gdHJ1ZSwgYSBgY2FsbC5yaW5nYCBldmVudCB3aWxsIGJlIHNlbnQgdG8gdGhlIGNhbGwgbWVtYmVycy5cbiAgICAgICAgICogQHBhcmFtIHBhcmFtcy5ub3RpZnkgaWYgc2V0IHRvIHRydWUsIGEgYGNhbGwubm90aWZpY2F0aW9uYCBldmVudCB3aWxsIGJlIHNlbnQgdG8gdGhlIGNhbGwgbWVtYmVycy5cbiAgICAgICAgICogQHBhcmFtIHBhcmFtcy5tZW1iZXJzX2xpbWl0IHRoZSB0b3RhbCBudW1iZXIgb2YgbWVtYmVycyB0byByZXR1cm4gYXMgcGFydCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHJlYW1DbGllbnQuZ2V0KHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGgsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAocGFyYW1zPy5yaW5nICYmICF0aGlzLnJpbmdpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpbmdpbmdTdWJqZWN0Lm5leHQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UocmVzcG9uc2UuY2FsbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldE1lbWJlcnMocmVzcG9uc2UubWVtYmVycyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldE93bkNhcGFiaWxpdGllcyhyZXNwb25zZS5vd25fY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUNsaWVudC5faGFzQ29ubmVjdGlvbklEKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudFN0b3JlLnJlZ2lzdGVyQ2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZXZpY2VDb25maWcoKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWRzIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2FsbCBhbmQgY3JlYXRlcyBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSB0byBjcmVhdGUgdGhlIGNhbGwgd2l0aC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0T3JDcmVhdGUgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGE/LnJpbmcgJiYgIXRoaXMucmluZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMucmluZ2luZ1N1YmplY3QubmV4dCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShyZXNwb25zZS5jYWxsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0TWVtYmVycyhyZXNwb25zZS5tZW1iZXJzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0T3duQ2FwYWJpbGl0aWVzKHJlc3BvbnNlLm93bl9jYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtQ2xpZW50Ll9oYXNDb25uZWN0aW9uSUQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50U3RvcmUucmVnaXN0ZXJDYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBseURldmljZUNvbmZpZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNhbGxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgdG8gY3JlYXRlIHRoZSBjYWxsIHdpdGguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckNyZWF0ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2hvcnRjdXQgZm9yIHtAbGluayBDYWxsLmdldH0gd2l0aCBgcmluZ2AgcGFyYW1ldGVyIHNldCB0byBgdHJ1ZWAuXG4gICAgICAgICAqIFdpbGwgc2VuZCBhIGBjYWxsLnJpbmdgIGV2ZW50IHRvIHRoZSBjYWxsIG1lbWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJpbmcgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXQoeyByaW5nOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaG9ydGN1dCBmb3Ige0BsaW5rIENhbGwuZ2V0fSB3aXRoIGBub3RpZnlgIHBhcmFtZXRlciBzZXQgdG8gYHRydWVgLlxuICAgICAgICAgKiBXaWxsIHNlbmQgYSBgY2FsbC5ub3RpZmljYXRpb25gIGV2ZW50IHRvIHRoZSBjYWxsIG1lbWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vdGlmeSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldCh7IG5vdGlmeTogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBpbmNvbWluZyBjYWxsIGFzIGFjY2VwdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBvbmx5IGZvciBcInJpbmdpbmdcIiBjYWxsIGZsb3dzLlxuICAgICAgICAgKiB7QGxpbmsgQ2FsbC5qb2lufSBpbnZva2VzIHRoaXMgbWV0aG9kIGF1dG9tYXRpY2FsbHkgZm9yIHlvdSB3aGVuIGpvaW5pbmcgYSBjYWxsLlxuICAgICAgICAgKiBVbmxlc3MgeW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjdXN0b20gXCJyaW5naW5nXCIgZmxvdywgeW91IHNob3VsZCBub3QgdXNlIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY2NlcHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9hY2NlcHRgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBpbmNvbWluZyBjYWxsIGFzIHJlamVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBvbmx5IGZvciBcInJpbmdpbmdcIiBjYWxsIGZsb3dzLlxuICAgICAgICAgKiB7QGxpbmsgQ2FsbC5sZWF2ZX0gaW52b2tlcyB0aGlzIG1ldGhvZCBhdXRvbWF0aWNhbGx5IGZvciB5b3Ugd2hlbiB5b3UgbGVhdmUgb3IgcmVqZWN0IHRoaXMgY2FsbC5cbiAgICAgICAgICogVW5sZXNzIHlvdSBhcmUgaW1wbGVtZW50aW5nIGEgY3VzdG9tIFwicmluZ2luZ1wiIGZsb3csIHlvdSBzaG91bGQgbm90IHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVqZWN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vcmVqZWN0YCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIHN0YXJ0IHRvIHdhdGNoIGZvciBjYWxsIHJlbGF0ZWQgV2ViU29ja2V0IGV2ZW50cyBhbmQgaW5pdGlhdGUgYSBjYWxsIHNlc3Npb24gd2l0aCB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgb25jZSB0aGUgY2FsbCBqb2luLWZsb3cgaGFzIGZpbmlzaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5qb2luID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxpbmdTdGF0ZSA9IHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlO1xuICAgICAgICAgICAgaWYgKFtDYWxsaW5nU3RhdGUuSk9JTkVELCBDYWxsaW5nU3RhdGUuSk9JTklOR10uaW5jbHVkZXMoY2FsbGluZ1N0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ0pvaW4gbWV0aG9kIGNhbGxlZCB0d2ljZSwgeW91IHNob3VsZCBvbmx5IGNhbGwgdGhpcyBvbmNlJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIFN0YXRlOiBBbHJlYWR5IGpvaW5lZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5MRUZUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIFN0YXRlOiBDYW5ub3Qgam9pbiBhbHJlYWR5IGxlZnQgY2FsbC4gQ3JlYXRlIGEgbmV3IENhbGwgaW5zdGFuY2UgdG8gam9pbiBhIGNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc01pZ3JhdGluZyA9IGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLk1JR1JBVElORztcbiAgICAgICAgICAgIGNvbnN0IGlzUmVjb25uZWN0aW5nID0gY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLkpPSU5JTkcpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgJ1N0YXJ0aW5nIGpvaW4gZmxvdycpO1xuICAgICAgICAgICAgaWYgKGRhdGE/LnJpbmcgJiYgIXRoaXMucmluZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMucmluZ2luZ1N1YmplY3QubmV4dCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJpbmdpbmcgJiYgIXRoaXMuaXNDcmVhdGVkQnlNZSkge1xuICAgICAgICAgICAgICAgIC8vIHNpZ25hbHMgb3RoZXIgdXNlcnMgdGhhdCBJIGhhdmUgYWNjZXB0ZWQgdGhlIGluY29taW5nIGNhbGwuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hY2NlcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZnVTZXJ2ZXI7XG4gICAgICAgICAgICBsZXQgc2Z1VG9rZW47XG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbkNvbmZpZztcbiAgICAgICAgICAgIGxldCBzdGF0c09wdGlvbnM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNmdUNsaWVudD8uaXNGYXN0UmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBwcmV2aW91cyBTRlUgY29uZmlndXJhdGlvbiBhbmQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Db25maWcgPSB0aGlzLnB1Ymxpc2hlcj8uY29ubmVjdGlvbkNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHNmdVNlcnZlciA9IHRoaXMuc2Z1Q2xpZW50LnNmdVNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgc2Z1VG9rZW4gPSB0aGlzLnNmdUNsaWVudC50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHNPcHRpb25zID0gdGhpcy5zZnVTdGF0c1JlcG9ydGVyPy5vcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZnVsbCBqb2luIGZsb3cgLSBsZXQgdGhlIENvb3JkaW5hdG9yIHBpY2sgYSBuZXcgU0ZVIGZvciB1c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsID0gYXdhaXQgam9pbih0aGlzLnN0cmVhbUNsaWVudCwgdGhpcy50eXBlLCB0aGlzLmlkLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGNhbGwubWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldE1lbWJlcnMoY2FsbC5tZW1iZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMoY2FsbC5vd25DYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnID0gY2FsbC5jb25uZWN0aW9uQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBzZnVTZXJ2ZXIgPSBjYWxsLnNmdVNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgc2Z1VG9rZW4gPSBjYWxsLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICBzdGF0c09wdGlvbnMgPSBjYWxsLnN0YXRzT3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtQ2xpZW50Ll9oYXNDb25uZWN0aW9uSUQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnRTdG9yZS5yZWdpc3RlckNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgcHJldmlvdXMgY2FsbCBzdGF0ZSBpZiB0aGUgam9pbi1mbG93IGZhaWxzXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoY2FsbGluZ1N0YXRlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2Z1Q2xpZW50ID0gdGhpcy5zZnVDbGllbnQ7XG4gICAgICAgICAgICBjb25zdCBzZnVDbGllbnQgPSAodGhpcy5zZnVDbGllbnQgPSBuZXcgU3RyZWFtU2Z1Q2xpZW50KHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyOiB0aGlzLmRpc3BhdGNoZXIsXG4gICAgICAgICAgICAgICAgc2Z1U2VydmVyLFxuICAgICAgICAgICAgICAgIHRva2VuOiBzZnVUb2tlbixcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHByZXZpb3VzU2Z1Q2xpZW50Py5zZXNzaW9uSWQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY2xvc3VyZSB3aGljaCBoaWRlcyBhd2F5IHRoZSByZS1jb25uZWN0aW9uIGxvZ2ljLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCByZWNvbm5lY3QgPSBhc3luYyAoc3RyYXRlZ3ksIHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IENhbGxpbmdTdGF0ZS5NSUdSQVRJTkcgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID09PSBDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgcGFyYWxsZWwgcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKHN0cmF0ZWd5ID09PSAnbWlncmF0ZSdcbiAgICAgICAgICAgICAgICAgICAgPyBDYWxsaW5nU3RhdGUuTUlHUkFUSU5HXG4gICAgICAgICAgICAgICAgICAgIDogQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElORyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbWlncmF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYFtNaWdyYXRpb25dOiBtaWdyYXRpbmcgY2FsbCAke3RoaXMuY2lkfSBhd2F5IGZyb20gJHtzZnVTZXJ2ZXIuZWRnZV9uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuaXNNaWdyYXRpbmdBd2F5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBbUmVqb2luXTogJHtzdHJhdGVneX0gcmVqb2luIGNhbGwgJHt0aGlzLmNpZH0gKCR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30pLi4uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRha2UgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBcImxvY2FsIHBhcnRpY2lwYW50XCIgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyB3ZSdsbCBuZWVkIGl0IGZvciByZXN0b3JpbmcgdGhlIHByZXZpb3VzIHB1Ymxpc2hpbmcgc3RhdGUgbGF0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFBhcnRpY2lwYW50ID0gdGhpcy5zdGF0ZS5sb2NhbFBhcnRpY2lwYW50O1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ2Zhc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudC5jbG9zZShTdHJlYW1TZnVDbGllbnQuRVJST1JfQ09OTkVDVElPTl9CUk9LRU4sIGBhdHRlbXB0aW5nIGZhc3QgcmVjb25uZWN0OiAke3JlYXNvbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdmdWxsJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBtaWdyYXRpb24gb3IgcmVjb3Zlcnkgc2NlbmFyaW9zLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHRvIGFuIFNGVSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAocmV0cnlJbnRlcnZhbCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGZ1bGwtcmVjb25uZWN0LCB3ZSBuZWVkIHRvIGRpc3Bvc2UgYWxsIFBlZXIgQ29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyPy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyPy5jbG9zZSh7IHN0b3BUcmFja3M6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0c1JlcG9ydGVyPy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZnVTdGF0c1JlcG9ydGVyPy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Z1U3RhdHNSZXBvcnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW4gdXAgY3VycmVudCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudC5jbG9zZShTdHJlYW1TZnVDbGllbnQuTk9STUFMX0NMT1NVUkUsIGBhdHRlbXB0aW5nIGZ1bGwgcmVjb25uZWN0OiAke3JlYXNvbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5qb2luKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHN0cmF0ZWd5ID09PSAnbWlncmF0ZScgJiYgeyBtaWdyYXRpbmdfZnJvbTogc2Z1U2VydmVyLmVkZ2VfbmFtZSB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCBwcmV2aW91cyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbWlncmF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LmNsb3NlKFN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSwgJ2F0dGVtcHRpbmcgbWlncmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYFtSZWpvaW5dOiBBdHRlbXB0ICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gc3VjY2Vzc2Z1bCFgKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGRuJ3QgYmUgcmVwdWJsaXNoaW5nIHRoZSBzdHJlYW1zIGlmIHdlJ3JlIG1pZ3JhdGluZ1xuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSB1bmRlcmx5aW5nIHBlZXIgY29ubmVjdGlvbiB3aWxsIHRha2UgY2FyZSBvZiBpdCBhcyBwYXJ0XG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIGljZS1yZXN0YXJ0IHByb2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxQYXJ0aWNpcGFudCAmJiBzdHJhdGVneSA9PT0gJ2Z1bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXVkaW9TdHJlYW0sIHZpZGVvU3RyZWFtLCBzY3JlZW5TaGFyZVN0cmVhbSwgc2NyZWVuU2hhcmVBdWRpb1N0cmVhbSwgfSA9IGxvY2FsUGFydGljaXBhbnQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY3JlZW5TaGFyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcmVlblNoYXJlU3RyZWFtIHx8IHNjcmVlblNoYXJlQXVkaW9TdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblNoYXJlID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaGFyZVN0cmVhbT8uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblNoYXJlPy5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblNoYXJlQXVkaW9TdHJlYW0/LmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaGFyZT8uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBwcmV2aW91cyBwdWJsaXNoaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb1N0cmVhbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaEF1ZGlvU3RyZWFtKGF1ZGlvU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hWaWRlb1N0cmVhbSh2aWRlb1N0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZENvZGVjOiB0aGlzLmNhbWVyYS5wcmVmZXJyZWRDb2RlYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JlZW5TaGFyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaFNjcmVlblNoYXJlU3RyZWFtKHNjcmVlblNoYXJlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCBgW1Jlam9pbl06IFN0YXRlIHJlc3RvcmVkLiBBdHRlbXB0OiAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJlY29ubmVjdCBpZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIHVuZXhwZWN0ZWRseS4gZXhhbXBsZTpcbiAgICAgICAgICAgIC8vIC0gU0ZVIGNyYXNoIG9yIHJlc3RhcnRcbiAgICAgICAgICAgIC8vIC0gbmV0d29yayBjaGFuZ2VcbiAgICAgICAgICAgIHNmdUNsaWVudC5zaWduYWxSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBhIGhhbmRsZXIgZm9yIHRoZSBcImdvQXdheVwiIGV2ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgdW5yZWdpc3RlckdvQXdheSA9IHRoaXMuZGlzcGF0Y2hlci5vbignZ29Bd2F5JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVhc29uIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCBgW01pZ3JhdGlvbl06IEdvaW5nIGF3YXkgZnJvbSBTRlUuLi4gUmVhc29uOiAke0dvQXdheVJlYXNvbltyZWFzb25dfWApO1xuICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3QoJ21pZ3JhdGUnLCBHb0F3YXlSZWFzb25bcmVhc29uXSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgW01pZ3JhdGlvbl06IEZhaWxlZCB0byBtaWdyYXRlIHRvIGFub3RoZXIgU0ZVLmAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNmdUNsaWVudC5zaWduYWxXcy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVucmVnaXN0ZXIgdGhlIFwiZ29Bd2F5XCIgaGFuZGxlciwgYXMgd2Ugd29uJ3QgbmVlZCBpdCBhbnltb3JlIGZvciB0aGlzIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB1cGNvbWluZyByZS1qb2luIHdpbGwgcmVnaXN0ZXIgYSBuZXcgaGFuZGxlciBhbnl3YXlcbiAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlckdvQXdheSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgb24gcHVycG9zZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jb2RlID09PSBTdHJlYW1TZnVDbGllbnQuTk9STUFMX0NMT1NVUkUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgaWYgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWNhdXNlIG9mIGEgcG9saWN5IHZpb2xhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBlLmcuLCB0aGUgdXNlciBoYXMgYmVlbiBibG9ja2VkIGJ5IGFuIGFkbWluIG9yIG1vZGVyYXRvclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jb2RlID09PSBLbm93bkNvZGVzLldTX1BPTElDWV9WSU9MQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFNGVSBpcyBiZWluZyBzaHV0IGRvd24sIGl0IHNlbmRzIGEgZ29Bd2F5IG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoaWxlIHdlIG1pZ3JhdGUgdG8gYW5vdGhlciBTRlUsIHdlIG1pZ2h0IGhhdmUgdGhlIFdTIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIG9sZCBTRlUgY2xvc2VkIGFicnVwdGx5LiBJbiB0aGlzIGNhc2UsIHdlIGRvbid0IHdhbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmVjb25uZWN0IHRvIHRoZSBvbGQgU0ZVLCBidXQgcmF0aGVyIHRvIHRoZSBuZXcgb25lLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc01pZ3JhdGluZ0F3YXkgPSBlLmNvZGUgPT09IEtub3duQ29kZXMuV1NfQ0xPU0VEX0FCUlVQVExZICYmIHNmdUNsaWVudC5pc01pZ3JhdGluZ0F3YXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRmFzdFJlY29ubmVjdGluZyA9IGUuY29kZSA9PT0gS25vd25Db2Rlcy5XU19DTE9TRURfQUJSVVBUTFkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudC5pc0Zhc3RSZWNvbm5lY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pZ3JhdGluZ0F3YXkgfHwgaXNGYXN0UmVjb25uZWN0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVjYXVzZSBvZiBhIGZhc3QgcmVjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFN0cmVhbVNmdUNsaWVudC5FUlJPUl9DT05ORUNUSU9OX0JST0tFTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuaXNGYXN0UmVjb25uZWN0aW5nID0gdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gc2Z1Q2xpZW50LmlzRmFzdFJlY29ubmVjdGluZyA/ICdmYXN0JyA6ICdmdWxsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdChzdHJhdGVneSwgYFNGVSBjbG9zZWQgdGhlIFdTIHdpdGggY29kZTogJHtlLmNvZGV9YCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBbUmVqb2luXTogJHtzdHJhdGVneX0gcmVqb2luIGZhaWxlZCBmb3IgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSB0aW1lcy4gR2l2aW5nIHVwLmAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnW1Jlam9pbl06IFJlY29ubmVjdCBhdHRlbXB0cyBleGNlZWRlZC4gR2l2aW5nIHVwLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HX0ZBSUxFRCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaGFuZGxlcnMgZm9yIGNvbm5lY3Rpb24gb25saW5lL29mZmxpbmUgZXZlbnRzXG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZU9ubGluZUV2ZW50ID0gdGhpcy5zdHJlYW1DbGllbnQub24oJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSAhPT0gJ2Nvbm5lY3Rpb24uY2hhbmdlZCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIWUub25saW5lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVPbmxpbmVFdmVudCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDYWxsaW5nU3RhdGUgPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRSZWNvbm5lY3QgPSBjdXJyZW50Q2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuT0ZGTElORSB8fFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HX0ZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJlY29ubmVjdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgJ1tSZWpvaW5dOiBHb2luZyBvbmxpbmUuLi4nKTtcbiAgICAgICAgICAgICAgICBsZXQgaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudC5pc0Zhc3RSZWNvbm5lY3RpbmcgPSBpc0ZpcnN0UmVjb25uZWN0QXR0ZW1wdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlY29ubmVjdChpc0ZpcnN0UmVjb25uZWN0QXR0ZW1wdCA/ICdmYXN0JyA6ICdmdWxsJywgJ05ldHdvcms6IG9ubGluZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBicmVhayB0aGUgbG9vcCBpZiByZWpvaW4gaXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBbUmVqb2luXVtOZXR3b3JrXTogUmVqb2luIGZhaWxlZCBmb3IgYXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBhIGJpdCBiZWZvcmUgdHJ5aW5nIHRvIHJlY29ubmVjdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpKTtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaGVyZSwgaXQgbWVhbnMgdGhhdCB3ZSd2ZSBleGhhdXN0ZWQgYWxsIHRoZSByZWNvbm5lY3QgYXR0ZW1wdHNcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl1bTmV0d29ya106IFJlam9pbiBmYWlsZWQuIEdpdmluZyB1cC5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HX0ZBSUxFRCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlT2ZmbGluZUV2ZW50ID0gdGhpcy5zdHJlYW1DbGllbnQub24oJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSAhPT0gJ2Nvbm5lY3Rpb24uY2hhbmdlZCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZS5vbmxpbmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU9mZmxpbmVFdmVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlT25saW5lRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU9mZmxpbmVFdmVudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKHtcbiAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVyOiB0aGlzLmRpc3BhdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvU2V0dGluZ3MgPSB0aGlzLnN0YXRlLnNldHRpbmdzPy5hdWRpbztcbiAgICAgICAgICAgICAgICBjb25zdCBpc0R0eEVuYWJsZWQgPSAhIWF1ZGlvU2V0dGluZ3M/Lm9wdXNfZHR4X2VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWRFbmFibGVkID0gISFhdWRpb1NldHRpbmdzPy5yZWR1bmRhbnRfY29kaW5nX2VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIgPSBuZXcgUHVibGlzaGVyKHtcbiAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVyOiB0aGlzLmRpc3BhdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBpc0R0eEVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIGlzUmVkRW5hYmxlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0c1JlcG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0c1JlcG9ydGVyID0gY3JlYXRlU3RhdHNSZXBvcnRlcih7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXI6IHRoaXMuc3Vic2NyaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVyOiB0aGlzLnB1Ymxpc2hlcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbGllbnREZXRhaWxzID0gZ2V0Q2xpZW50RGV0YWlscygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNmdVN0YXRzUmVwb3J0ZXIgJiYgc3RhdHNPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZnVTdGF0c1JlcG9ydGVyID0gbmV3IFNmdVN0YXRzUmVwb3J0ZXIoc2Z1Q2xpZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudERldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHN0YXRzT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcjogdGhpcy5zdWJzY3JpYmVyLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXI6IHRoaXMucHVibGlzaGVyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Z1U3RhdHNSZXBvcnRlci5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyAxLiB3YWl0IGZvciB0aGUgc2lnbmFsIHNlcnZlciB0byBiZSByZWFkeSBiZWZvcmUgc2VuZGluZyBcImpvaW5SZXF1ZXN0XCJcbiAgICAgICAgICAgICAgICBzZnVDbGllbnQuc2lnbmFsUmVhZHlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHRoaXMubG9nZ2VyKCdlcnJvcicsICdTaWduYWwgcmVhZHkgZmFpbGVkJywgZXJyKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGFyZSBhIGdlbmVyaWMgU0RQIGFuZCBzZW5kIGl0IHRvIHRoZSBTRlUuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSB0aHJvdy1hd2F5IFNEUCB0aGF0IHRoZSBTRlUgd2lsbCB1c2UgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIGNsaWVudCAoY29kZWMgc3VwcG9ydCwgZXRjLilcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gZ2V0R2VuZXJpY1NkcCgncmVjdm9ubHknKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHNkcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gZ2V0Q3VycmVudFZhbHVlKHRoaXMudHJhY2tTdWJzY3JpcHRpb25zU3ViamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pZ3JhdGlvbiA9IGlzTWlncmF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tU2Z1SWQ6IGRhdGE/Lm1pZ3JhdGluZ19mcm9tIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IHN1YnNjcmlwdGlvbnMuZGF0YSB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdW5jZWRUcmFja3M6IHRoaXMucHVibGlzaGVyPy5nZXRDdXJyZW50VHJhY2tJbmZvcygpIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZnVDbGllbnQuam9pbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyU2RwOiBzZHAgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnREZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlncmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFzdFJlY29ubmVjdDogcHJldmlvdXNTZnVDbGllbnQ/LmlzRmFzdFJlY29ubmVjdGluZyA/PyBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gMi4gaW4gcGFyYWxsZWwsIHdhaXQgZm9yIHRoZSBTRlUgdG8gc2VuZCB1cyB0aGUgXCJqb2luUmVzcG9uc2VcIlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgU0ZVIHJlamVjdHMgdGhlIGpvaW4gcmVxdWVzdCBvclxuICAgICAgICAgICAgICAgIC8vIGZhaWxzIHRvIHJlc3BvbmQgaW4gdGltZVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2FsbFN0YXRlLCByZWNvbm5lY3RlZCB9ID0gYXdhaXQgdGhpcy53YWl0Rm9ySm9pblJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsICdbUmVqb2luXSBmYXN0IHJlY29ubmVjdGVkOicsIHJlY29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTWlncmF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlci5taWdyYXRlVG8oc2Z1Q2xpZW50LCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXIubWlncmF0ZVRvKHNmdUNsaWVudCwgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBTRlUgY2xpZW50IGluc3RhbmNlIG9uIHRoZSBzdWJzY3JpYmVyIGFuZCBwdWJsaXNoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5zZXRTZnVDbGllbnQoc2Z1Q2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyLnNldFNmdUNsaWVudChzZnVDbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHBlcmZvcm0gYSBmdWxsIElDRSByZXN0YXJ0IG9uIHRoZSBwdWJsaXNoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnJlc3RhcnRJY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2aW91c1NmdUNsaWVudD8uaXNGYXN0UmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNvbm5lY3Rpb24gd2Fzbid0IHBvc3NpYmxlLCBzbyB3ZSBuZWVkIHRvIGRvIGEgZnVsbCByZWpvaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZWNvbm5lY3QoJ2Z1bGwnLCAncmUtYXR0ZW1wdGluZycpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl06IFJlam9pbiBmYWlsZWQgZm9yY2VkIGZ1bGwgcmVqb2luLmAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFydGljaXBhbnRzID0gY2FsbFN0YXRlPy5wYXJ0aWNpcGFudHMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnRDb3VudCA9IGNhbGxTdGF0ZT8ucGFydGljaXBhbnRDb3VudDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydGVkQXQgPSBjYWxsU3RhdGU/LnN0YXJ0ZWRBdFxuICAgICAgICAgICAgICAgICAgICA/IFRpbWVzdGFtcC50b0RhdGUoY2FsbFN0YXRlLnN0YXJ0ZWRBdClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpbnMgPSBjYWxsU3RhdGU/LnBpbnMgPz8gW107XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRQYXJ0aWNpcGFudHMoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudExvb2t1cCA9IHRoaXMuc3RhdGUuZ2V0UGFydGljaXBhbnRMb29rdXBCeVNlc3Npb25JZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFBhcnRpY2lwYW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcHJlc2VydmUgdGhlIGxvY2FsIHN0YXRlIG9mIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGUuZy4gdmlkZW9EaW1lbnNpb24sIHZpc2liaWxpdHlTdGF0ZSwgcGlubmVkQXQsIGV0Yy4pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1BhcnRpY2lwYW50ID0gcGFydGljaXBhbnRMb29rdXBbcC5zZXNzaW9uSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocCwgZXhpc3RpbmdQYXJ0aWNpcGFudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTG9jYWxQYXJ0aWNpcGFudDogcC5zZXNzaW9uSWQgPT09IHNmdUNsaWVudC5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGU6IGV4aXN0aW5nUGFydGljaXBhbnQ/LnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID8/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9UcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblNoYXJlVHJhY2s6IFZpc2liaWxpdHlTdGF0ZS5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRQYXJ0aWNpcGFudENvdW50KHBhcnRpY2lwYW50Q291bnQ/LnRvdGFsIHx8IDApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0QW5vbnltb3VzUGFydGljaXBhbnRDb3VudChwYXJ0aWNpcGFudENvdW50Py5hbm9ueW1vdXMgfHwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTdGFydGVkQXQoc3RhcnRlZEF0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldFNlcnZlclNpZGVQaW5zKHBpbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwOyAvLyByZXNldCB0aGUgcmVjb25uZWN0IGF0dGVtcHRzIGNvdW50ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuSk9JTkVEKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRDYW1lcmEoeyBzZXRTdGF0dXM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdE1pYyh7IHNldFN0YXR1czogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ0NhbWVyYSBhbmQvb3IgbWljIGluaXQgZmFpbGVkIGR1cmluZyBqb2luIGNhbGwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDMuIG9uY2Ugd2UgaGF2ZSB0aGUgXCJqb2luUmVzcG9uc2VcIiwgYW5kIHBvc3NpYmx5IHJlY29uY2lsZWQgdGhlIGxvY2FsIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2NoZWR1bGUgYSBmYXN0IHN1YnNjcmlwdGlvbiB1cGRhdGUgZm9yIGFsbCByZW1vdGUgcGFydGljaXBhbnRzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3ZXJlIHZpc2libGUgYmVmb3JlIHdlIHJlY29ubmVjdGVkIG9yIG1pZ3JhdGVkIHRvIGEgbmV3IFNGVS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbW90ZVBhcnRpY2lwYW50cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlUGFydGljaXBhbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb25zKHJlbW90ZVBhcnRpY2lwYW50cywgRGVib3VuY2VUeXBlLkZBU1QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBKb2luZWQgY2FsbCAke3RoaXMuY2lkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGpvaW4gZmFpbGVkLCB0cnkgdG8gcmVqb2luXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBbUmVqb2luXTogUmVqb2luICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gZmFpbGVkLmAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlY29ubmVjdCgnZnVsbCcsICdwcmV2aW91cyBhdHRlbXB0IGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBbUmVqb2luXTogUmVqb2luICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gc3VjY2Vzc2Z1bCFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBbUmVqb2luXTogUmVqb2luIGZhaWxlZCBmb3IgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSB0aW1lcy4gR2l2aW5nIHVwLmApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HX0ZBSUxFRCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSm9pbiBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FpdEZvckpvaW5SZXNwb25zZSA9ICh0aW1lb3V0ID0gNTAwMCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub24oJ2pvaW5SZXNwb25zZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1dhaXRpbmcgZm9yIFwiam9pblJlc3BvbnNlXCIgaGFzIHRpbWVkIG91dCcpKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIHZpZGVvIHN0cmVhbSB0byB0aGUgY2FsbC5cbiAgICAgICAgICogVGhlIHN0cmVhbSB3aWxsIGJlIHN0b3BwZWQgaWYgdGhlIHVzZXIgY2hhbmdlcyBhbiBpbnB1dCBkZXZpY2UsIG9yIGlmIHRoZSB1c2VyIGxlYXZlcyB0aGUgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc2VjdXRpdmUgY2FsbHMgdG8gdGhpcyBtZXRob2Qgd2lsbCByZXBsYWNlIHRoZSBwcmV2aW91c2x5IHB1Ymxpc2hlZCBzdHJlYW0uXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyB2aWRlbyBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9TdHJlYW0gdGhlIHZpZGVvIHN0cmVhbSB0byBwdWJsaXNoLlxuICAgICAgICAgKiBAcGFyYW0gb3B0cyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBwdWJsaXNoaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnB1Ymxpc2hWaWRlb1N0cmVhbSA9IGFzeW5jICh2aWRlb1N0cmVhbSwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgd2FpdCB1bnRpbCB3ZSBnZXQgYSBKb2luUmVzcG9uc2UgZnJvbSB0aGUgU0ZVLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHJpc2sgYnJlYWtpbmcgdGhlIElDRVRyaWNrbGUgZmxvdy5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0Q2FsbEpvaW5lZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsICdUcnlpbmcgdG8gcHVibGlzaCB2aWRlbyBiZWZvcmUgam9pbiBpcyBjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgbm90IGpvaW5lZCB5ZXQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbdmlkZW9UcmFja10gPSB2aWRlb1N0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICAgICAgaWYgKCF2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYFRoZXJlIGlzIG5vIHZpZGVvIHRyYWNrIHRvIHB1Ymxpc2ggaW4gdGhlIHN0cmVhbS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoU3RyZWFtKHZpZGVvU3RyZWFtLCB2aWRlb1RyYWNrLCBUcmFja1R5cGUuVklERU8sIG9wdHMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIGF1ZGlvIHN0cmVhbSB0byB0aGUgY2FsbC5cbiAgICAgICAgICogVGhlIHN0cmVhbSB3aWxsIGJlIHN0b3BwZWQgaWYgdGhlIHVzZXIgY2hhbmdlcyBhbiBpbnB1dCBkZXZpY2UsIG9yIGlmIHRoZSB1c2VyIGxlYXZlcyB0aGUgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc2VjdXRpdmUgY2FsbHMgdG8gdGhpcyBtZXRob2Qgd2lsbCByZXBsYWNlIHRoZSBhdWRpbyBzdHJlYW0gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgcHVibGlzaGVkLlxuICAgICAgICAgKiBUaGUgcHJldmlvdXMgYXVkaW8gc3RyZWFtIHdpbGwgYmUgc3RvcHBlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGF1ZGlvU3RyZWFtIHRoZSBhdWRpbyBzdHJlYW0gdG8gcHVibGlzaC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHVibGlzaEF1ZGlvU3RyZWFtID0gYXN5bmMgKGF1ZGlvU3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgd2FpdCB1bnRpbCB3ZSBnZXQgYSBKb2luUmVzcG9uc2UgZnJvbSB0aGUgU0ZVLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHJpc2sgYnJlYWtpbmcgdGhlIElDRVRyaWNrbGUgZmxvdy5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0Q2FsbEpvaW5lZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsICdUcnlpbmcgdG8gcHVibGlzaCBhdWRpbyBiZWZvcmUgam9pbiBpcyBjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgbm90IGpvaW5lZCB5ZXQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbYXVkaW9UcmFja10gPSBhdWRpb1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgICAgICAgaWYgKCFhdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYFRoZXJlIGlzIG5vIGF1ZGlvIHRyYWNrIGluIHRoZSBzdHJlYW0gdG8gcHVibGlzaGApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2hTdHJlYW0oYXVkaW9TdHJlYW0sIGF1ZGlvVHJhY2ssIFRyYWNrVHlwZS5BVURJTyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gc2NyZWVuLXNoYXJlIHN0cmVhbSB0byB0aGUgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc2VjdXRpdmUgY2FsbHMgdG8gdGhpcyBtZXRob2Qgd2lsbCByZXBsYWNlIHRoZSBwcmV2aW91cyBzY3JlZW4tc2hhcmUgc3RyZWFtLlxuICAgICAgICAgKiBUaGUgcHJldmlvdXMgc2NyZWVuLXNoYXJlIHN0cmVhbSB3aWxsIGJlIHN0b3BwZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzY3JlZW5TaGFyZVN0cmVhbSB0aGUgc2NyZWVuLXNoYXJlIHN0cmVhbSB0byBwdWJsaXNoLlxuICAgICAgICAgKiBAcGFyYW0gb3B0cyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBwdWJsaXNoaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnB1Ymxpc2hTY3JlZW5TaGFyZVN0cmVhbSA9IGFzeW5jIChzY3JlZW5TaGFyZVN0cmVhbSwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgd2FpdCB1bnRpbCB3ZSBnZXQgYSBKb2luUmVzcG9uc2UgZnJvbSB0aGUgU0ZVLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHJpc2sgYnJlYWtpbmcgdGhlIElDRVRyaWNrbGUgZmxvdy5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0Q2FsbEpvaW5lZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsICdUcnlpbmcgdG8gcHVibGlzaCBzY3JlZW4gc2hhcmUgYmVmb3JlIGpvaW4gaXMgY29tcGxldGVkJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWxsIG5vdCBqb2luZWQgeWV0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3NjcmVlblNoYXJlVHJhY2tdID0gc2NyZWVuU2hhcmVTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgICAgIGlmICghc2NyZWVuU2hhcmVUcmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBUaGVyZSBpcyBubyB2aWRlbyB0cmFjayBpbiB0aGUgc2NyZWVuIHNoYXJlIHN0cmVhbSB0byBwdWJsaXNoYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXIucHVibGlzaFN0cmVhbShzY3JlZW5TaGFyZVN0cmVhbSwgc2NyZWVuU2hhcmVUcmFjaywgVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSwgb3B0cyk7XG4gICAgICAgICAgICBjb25zdCBbc2NyZWVuU2hhcmVBdWRpb1RyYWNrXSA9IHNjcmVlblNoYXJlU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgICAgICAgICBpZiAoc2NyZWVuU2hhcmVBdWRpb1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXIucHVibGlzaFN0cmVhbShzY3JlZW5TaGFyZVN0cmVhbSwgc2NyZWVuU2hhcmVBdWRpb1RyYWNrLCBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIHRyYWNrIHR5cGUgdG8gdGhlIGNhbGwsIGlmIGl0IGlzIGN1cnJlbnRseSBiZWluZyBwdWJsaXNoZWQuXG4gICAgICAgICAqIFVuZGVybHlpbmcgdHJhY2sgd2lsbCBiZSBzdG9wcGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIHB1Ymxpc2hlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUgdHJhY2sgdHlwZSB0byBzdG9wIHB1Ymxpc2hpbmcuXG4gICAgICAgICAqIEBwYXJhbSBzdG9wVHJhY2sgaWYgYHRydWVgIHRoZSB0cmFjayB3aWxsIGJlIHN0b3BwZWQsIGVsc2UgaXQgd2lsbCBiZSBqdXN0IGRpc2FibGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BQdWJsaXNoID0gYXN5bmMgKHRyYWNrVHlwZSwgc3RvcFRyYWNrID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCBgc3RvcFB1Ymxpc2ggJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0sIHN0b3AgdHJhY2tzOiAke3N0b3BUcmFja31gKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyPy51bnB1Ymxpc2hTdHJlYW0odHJhY2tUeXBlLCBzdG9wVHJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRyYWNrIHN1YnNjcmlwdGlvbiBjb25maWd1cmF0aW9uIGZvciBvbmUgb3IgbW9yZSBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqIFlvdSBoYXZlIHRvIGNyZWF0ZSBhIHN1YnNjcmlwdGlvbiBmb3IgZWFjaCBwYXJ0aWNpcGFudCBmb3IgYWxsIHRoZSBkaWZmZXJlbnQga2luZHMgb2YgdHJhY2tzIHlvdSB3YW50IHRvIHJlY2VpdmUuXG4gICAgICAgICAqIFlvdSBjYW4gb25seSBzdWJzY3JpYmUgZm9yIHRyYWNrcyBhZnRlciB0aGUgcGFydGljaXBhbnQgc3RhcnRlZCBwdWJsaXNoaW5nIHRoZSBnaXZlbiBraW5kIG9mIHRyYWNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIHN1YnNjcmlwdGlvbiB0byB1cGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBsaXN0IG9mIHN1YnNjcmlwdGlvbiBjaGFuZ2VzIHRvIGRvLlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgZGVib3VuY2UgdHlwZSB0byB1c2UgZm9yIHRoZSB1cGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnNQYXJ0aWFsID0gKHRyYWNrVHlwZSwgY2hhbmdlcywgdHlwZSA9IERlYm91bmNlVHlwZS5TTE9XKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2tUeXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgdXBkYXRlU3Vic2NyaXB0aW9uc1BhcnRpYWw6ICR7dHJhY2tUeXBlfSBpcyBkZXByZWNhdGVkLiBQbGVhc2Ugc3dpdGNoIHRvICd2aWRlb1RyYWNrJ2ApO1xuICAgICAgICAgICAgICAgIHRyYWNrVHlwZSA9ICd2aWRlb1RyYWNrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNrVHlwZSA9PT0gJ3NjcmVlbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGB1cGRhdGVTdWJzY3JpcHRpb25zUGFydGlhbDogJHt0cmFja1R5cGV9IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBzd2l0Y2ggdG8gJ3NjcmVlblNoYXJlVHJhY2snYCk7XG4gICAgICAgICAgICAgICAgdHJhY2tUeXBlID0gJ3NjcmVlblNoYXJlVHJhY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnRzID0gdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudHMoT2JqZWN0LmVudHJpZXMoY2hhbmdlcykucmVkdWNlKChhY2MsIFtzZXNzaW9uSWQsIGNoYW5nZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmRpbWVuc2lvbj8uaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kaW1lbnNpb24uaGVpZ2h0ID0gTWF0aC5jZWlsKGNoYW5nZS5kaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5kaW1lbnNpb24/LndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kaW1lbnNpb24ud2lkdGggPSBNYXRoLmNlaWwoY2hhbmdlLmRpbWVuc2lvbi53aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSB0cmFja1R5cGUgPT09ICd2aWRlb1RyYWNrJ1xuICAgICAgICAgICAgICAgICAgICA/ICd2aWRlb0RpbWVuc2lvbidcbiAgICAgICAgICAgICAgICAgICAgOiB0cmFja1R5cGUgPT09ICdzY3JlZW5TaGFyZVRyYWNrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnc2NyZWVuU2hhcmVEaW1lbnNpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBhY2Nbc2Vzc2lvbklkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwcm9wXTogY2hhbmdlLmRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KSk7XG4gICAgICAgICAgICBpZiAocGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb25zKHBhcnRpY2lwYW50cywgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucyA9IChwYXJ0aWNpcGFudHMsIHR5cGUgPSBEZWJvdW5jZVR5cGUuU0xPVykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gc3Vic2NyaWJlIHRvIG91ciBvd24gdHJhY2tzXG4gICAgICAgICAgICAgICAgaWYgKHAuaXNMb2NhbFBhcnRpY2lwYW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBhdWRpbyB0cmFja3MgZG9uJ3QgaGF2ZSB0byBiZSByZXF1ZXN0ZWQgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBTRlUgd2lsbCBpbXBsaWNpdGx5IHN1YnNjcmliZSB1cyB0byBhbGwgb2YgdGhlbSxcbiAgICAgICAgICAgICAgICAvLyBvbmNlIHRoZXkgYmVjb21lIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBpZiAocC52aWRlb0RpbWVuc2lvbiAmJiBwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhUcmFja1R5cGUuVklERU8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHAudXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBwLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZTogVHJhY2tUeXBlLlZJREVPLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uOiBwLnZpZGVvRGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHAuc2NyZWVuU2hhcmVEaW1lbnNpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZDogcC51c2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHAuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUeXBlOiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uOiBwLnNjcmVlblNoYXJlRGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHAudXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBwLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZTogVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2NoZWR1bGUgdXBkYXRlXG4gICAgICAgICAgICB0aGlzLnRyYWNrU3Vic2NyaXB0aW9uc1N1YmplY3QubmV4dCh7IHR5cGUsIGRhdGE6IHN1YnNjcmlwdGlvbnMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGVuaGFuY2UgdGhlIHJlcG9ydGVkIHN0YXRzIHdpdGggYWRkaXRpb25hbCBwYXJ0aWNpcGFudC1zcGVjaWZpYyBpbmZvcm1hdGlvbiAoYGNhbGxTdGF0c1JlcG9ydCRgIHN0YXRlIFtzdG9yZSB2YXJpYWJsZV0oLi9TdHJlYW1WaWRlb0NsaWVudC5tZC8jcmVhZG9ubHlzdGF0ZXN0b3JlKSkuXG4gICAgICAgICAqIFRoaXMgaXMgdXN1YWxseSBoZWxwZnVsIHdoZW4gZGV0YWlsZWQgc3RhdHMgZm9yIGEgc3BlY2lmaWMgcGFydGljaXBhbnQgYXJlIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbklkIHRvIHN0YXJ0IHJlcG9ydGluZyBmb3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0UmVwb3J0aW5nU3RhdHNGb3IgPSAoc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0c1JlcG9ydGVyPy5zdGFydFJlcG9ydGluZ1N0YXRzRm9yKHNlc3Npb25JZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHBvc2l0ZSBvZiBgc3RhcnRSZXBvcnRpbmdTdGF0c0ZvcmAuXG4gICAgICAgICAqIFdpbGwgdHVybiBvZmYgc3RhdHMgcmVwb3J0aW5nIGZvciBhIHNwZWNpZmljIHBhcnRpY2lwYW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uSWQgdG8gc3RvcCByZXBvcnRpbmcgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wUmVwb3J0aW5nU3RhdHNGb3IgPSAoc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0c1JlcG9ydGVyPy5zdG9wUmVwb3J0aW5nU3RhdHNGb3Ioc2Vzc2lvbklkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgbGFzdCBzZW50IHJlYWN0aW9uIGZvciB0aGUgdXNlciBob2xkaW5nIHRoZSBnaXZlbiBgc2Vzc2lvbklkYC4gVGhpcyBpcyBhIGxvY2FsIGFjdGlvbiwgaXQgd29uJ3QgcmVzZXQgdGhlIHJlYWN0aW9uIG9uIHRoZSBiYWNrZW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNldFJlYWN0aW9uID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIHtcbiAgICAgICAgICAgICAgICByZWFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBsaXN0IG9mIGNyaXRlcmlhIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cyBieS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNyaXRlcmlhIHRoZSBsaXN0IG9mIGNyaXRlcmlhIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cyBieS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U29ydFBhcnRpY2lwYW50c0J5ID0gKGNyaXRlcmlhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZXRTb3J0UGFydGljaXBhbnRzQnkoY3JpdGVyaWEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgbGlzdCBvZiB2aWRlbyBsYXllcnMgdG8gcHVibGlzaC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSBlbmFibGVkTGF5ZXJzIHRoZSBsaXN0IG9mIGxheWVycyB0byBlbmFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVB1Ymxpc2hRdWFsaXR5ID0gYXN5bmMgKGVuYWJsZWRMYXllcnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlcj8udXBkYXRlVmlkZW9QdWJsaXNoUXVhbGl0eShlbmFibGVkTGF5ZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hc3NlcnRDYWxsSm9pbmVkID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGUkXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoc3RhdGUpID0+IHN0YXRlICE9PSBDYWxsaW5nU3RhdGUuSk9JTkVELCB0cnVlKSwgZmlsdGVyKChzKSA9PiBzID09PSBDYWxsaW5nU3RhdGUuSk9JTkVEKSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kcyBhIHJlYWN0aW9uIHRvIHRoZSBvdGhlciBjYWxsIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlYWN0aW9uIHRoZSByZWFjdGlvbiB0byBzZW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kUmVhY3Rpb24gPSBhc3luYyAocmVhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3JlYWN0aW9uYCwgcmVhY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmxvY2tzIHRoZSB1c2VyIHdpdGggdGhlIGdpdmVuIGB1c2VySWRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciB0byBibG9jay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tVc2VyID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vYmxvY2tgLCB7XG4gICAgICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJsb2NrcyB0aGUgdXNlciB3aXRoIHRoZSBnaXZlbiBgdXNlcklkYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gdW5ibG9jay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5ibG9ja1VzZXIgPSBhc3luYyAodXNlcklkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS91bmJsb2NrYCwge1xuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTXV0ZXMgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIG11dGUgb3BlcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdXRlU2VsZiA9ICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBteVVzZXJJZCA9IHRoaXMuY3VycmVudFVzZXJJZDtcbiAgICAgICAgICAgIGlmIChteVVzZXJJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm11dGVVc2VyKG15VXNlcklkLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11dGVzIGFsbCB0aGUgb3RoZXIgcGFydGljaXBhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgbXV0ZSBvcGVyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11dGVPdGhlcnMgPSAodHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhY2tUeXBlID0gbXV0ZVR5cGVUb1RyYWNrVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIGlmICghdHJhY2tUeXBlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJJZHNUb011dGUgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydGljaXBhbnQgb2YgdGhpcy5zdGF0ZS5yZW1vdGVQYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydGljaXBhbnQucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKHRyYWNrVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcklkc1RvTXV0ZS5wdXNoKHBhcnRpY2lwYW50LnVzZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXV0ZVVzZXIodXNlcklkc1RvTXV0ZSwgdHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXRlcyB0aGUgdXNlciB3aXRoIHRoZSBnaXZlbiBgdXNlcklkYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gbXV0ZS5cbiAgICAgICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIG11dGUgb3BlcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdXRlVXNlciA9ICh1c2VySWQsIHR5cGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L211dGVfdXNlcnNgLCB7XG4gICAgICAgICAgICAgICAgdXNlcl9pZHM6IEFycmF5LmlzQXJyYXkodXNlcklkKSA/IHVzZXJJZCA6IFt1c2VySWRdLFxuICAgICAgICAgICAgICAgIFt0eXBlXTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBtdXRlIGFsbCB1c2VycyBpbiB0aGUgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIG11dGUgb3BlcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdXRlQWxsVXNlcnMgPSAodHlwZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vbXV0ZV91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBtdXRlX2FsbF91c2VyczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBbdHlwZV06IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyByZWNvcmRpbmcgdGhlIGNhbGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcgPSBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RhcnRfcmVjb3JkaW5nYCwgcmVxdWVzdCA/IHJlcXVlc3QgOiB7fSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyByZWNvcmRpbmcgdGhlIGNhbGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcFJlY29yZGluZyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0b3BfcmVjb3JkaW5nYCwge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHRoZSB0cmFuc2NyaXB0aW9uIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdCB0aGUgcmVxdWVzdCBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFRyYW5zY3JpcHRpb24gPSBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RhcnRfdHJhbnNjcmlwdGlvbmAsIHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgdGhlIHRyYW5zY3JpcHRpb24gb2YgdGhlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BUcmFuc2NyaXB0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RvcF90cmFuc2NyaXB0aW9uYCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kcyBhIGBjYWxsLnBlcm1pc3Npb25fcmVxdWVzdGAgZXZlbnQgdG8gYWxsIHVzZXJzIGNvbm5lY3RlZCB0byB0aGUgY2FsbC4gVGhlIGNhbGwgc2V0dGluZ3Mgb2JqZWN0IGNvbnRhaW5zIGluZm9tcmF0aW9uIGFib3V0IHdoaWNoIHBlcm1pc3Npb25zIGNhbiBiZSByZXF1ZXN0ZWQgZHVyaW5nIGEgY2FsbCAoZm9yIGV4YW1wbGUgYSB1c2VyIG1pZ2h0IGJlIGFsbG93ZWQgdG8gcmVxdWVzdCBwZXJtaXNzaW9uIHRvIHB1Ymxpc2ggYXVkaW8sIGJ1dCBub3QgdmlkZW8pLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1ZXN0UGVybWlzc2lvbnMgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGNhblJlcXVlc3RQZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zLmV2ZXJ5KChwZXJtaXNzaW9uKSA9PiB0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5jYW5SZXF1ZXN0KHBlcm1pc3Npb24pKTtcbiAgICAgICAgICAgIGlmICghY2FuUmVxdWVzdFBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgYXJlIG5vdCBhbGxvd2VkIHRvIHJlcXVlc3QgcGVybWlzc2lvbnM6ICR7cGVybWlzc2lvbnMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3JlcXVlc3RfcGVybWlzc2lvbmAsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHlvdSB0byBncmFudCBjZXJ0YWluIHBlcm1pc3Npb25zIHRvIGEgdXNlciBpbiBhIGNhbGwuXG4gICAgICAgICAqIFRoZSBwZXJtaXNzaW9ucyBhcmUgc3BlY2lmaWMgdG8gdGhlIGNhbGwgZXhwZXJpZW5jZSBhbmQgZG8gbm90IHN1cnZpdmUgdGhlIGNhbGwgaXRzZWxmLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTdXBwb3J0ZWQgcGVybWlzc2lvbnMgdGhhdCBjYW4gYmUgZ3JhbnRlZCBhcmU6XG4gICAgICAgICAqIC0gYHNlbmQtYXVkaW9gXG4gICAgICAgICAqIC0gYHNlbmQtdmlkZW9gXG4gICAgICAgICAqIC0gYHNjcmVlbnNoYXJlYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciB0byBncmFudCBwZXJtaXNzaW9ucyB0by5cbiAgICAgICAgICogQHBhcmFtIHBlcm1pc3Npb25zIHRoZSBwZXJtaXNzaW9ucyB0byBncmFudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JhbnRQZXJtaXNzaW9ucyA9IGFzeW5jICh1c2VySWQsIHBlcm1pc3Npb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVVc2VyUGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICBncmFudF9wZXJtaXNzaW9uczogcGVybWlzc2lvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyB5b3UgdG8gcmV2b2tlIGNlcnRhaW4gcGVybWlzc2lvbnMgZnJvbSBhIHVzZXIgaW4gYSBjYWxsLlxuICAgICAgICAgKiBUaGUgcGVybWlzc2lvbnMgYXJlIHNwZWNpZmljIHRvIHRoZSBjYWxsIGV4cGVyaWVuY2UgYW5kIGRvIG5vdCBzdXJ2aXZlIHRoZSBjYWxsIGl0c2VsZi5cbiAgICAgICAgICpcbiAgICAgICAgICogU3VwcG9ydGVkIHBlcm1pc3Npb25zIHRoYXQgY2FuIGJlIHJldm9rZWQgYXJlOlxuICAgICAgICAgKiAtIGBzZW5kLWF1ZGlvYFxuICAgICAgICAgKiAtIGBzZW5kLXZpZGVvYFxuICAgICAgICAgKiAtIGBzY3JlZW5zaGFyZWBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gcmV2b2tlIHBlcm1pc3Npb25zIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSBwZXJtaXNzaW9ucyB0aGUgcGVybWlzc2lvbnMgdG8gcmV2b2tlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXZva2VQZXJtaXNzaW9ucyA9IGFzeW5jICh1c2VySWQsIHBlcm1pc3Npb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVVc2VyUGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICByZXZva2VfcGVybWlzc2lvbnM6IHBlcm1pc3Npb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgeW91IHRvIGdyYW50IG9yIHJldm9rZSBhIHNwZWNpZmljIHBlcm1pc3Npb24gdG8gYSB1c2VyIGluIGEgY2FsbC4gVGhlIHBlcm1pc3Npb25zIGFyZSBzcGVjaWZpYyB0byB0aGUgY2FsbCBleHBlcmllbmNlIGFuZCBkbyBub3Qgc3Vydml2ZSB0aGUgY2FsbCBpdHNlbGYuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gcmV2b2tpbmcgYSBwZXJtaXNzaW9uLCB0aGlzIGVuZHBvaW50IHdpbGwgYWxzbyBtdXRlIHRoZSByZWxldmFudCB0cmFjayBmcm9tIHRoZSB1c2VyLiBUaGlzIGlzIHNpbWlsYXIgdG8gbXV0aW5nIGEgdXNlciB3aXRoIHRoZSBkaWZmZXJlbmNlIHRoYXQgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byB1bm11dGUgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICpcbiAgICAgICAgICogU3VwcG9ydGVkIHBlcm1pc3Npb25zIHRoYXQgY2FuIGJlIGdyYW50ZWQgb3IgcmV2b2tlZDogYHNlbmQtYXVkaW9gLCBgc2VuZC12aWRlb2AgYW5kIGBzY3JlZW5zaGFyZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBjYWxsLnBlcm1pc3Npb25zX3VwZGF0ZWRgIGV2ZW50IGlzIHNlbnQgdG8gYWxsIG1lbWJlcnMgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS91c2VyX3Blcm1pc3Npb25zYCwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgdGhlIGxpdmVzdHJlYW1pbmcgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIHRoZSByZXF1ZXN0IGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgdGhlIHJlcXVlc3QgcGFyYW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nb0xpdmUgPSBhc3luYyAoZGF0YSA9IHt9LCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L2dvX2xpdmVgLCBkYXRhLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgdGhlIGxpdmVzdHJlYW1pbmcgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BMaXZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RvcF9saXZlYCwge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHRoZSBicm9hZGNhc3Rpbmcgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0SExTID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RhcnRfYnJvYWRjYXN0aW5nYCwge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgdGhlIGJyb2FkY2FzdGluZyBvZiB0aGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcEhMUyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0b3BfYnJvYWRjYXN0aW5nYCwge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgY2FsbCBzZXR0aW5ncyBvciBjdXN0b20gZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVwZGF0ZXMgdGhlIHVwZGF0ZXMgdG8gYXBwbHkgdG8gdGhlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IGFzeW5jICh1cGRhdGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LnBhdGNoKGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9YCwgdXBkYXRlcyk7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGwsIG1lbWJlcnMsIG93bl9jYXBhYmlsaXRpZXMgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGNhbGwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRNZW1iZXJzKG1lbWJlcnMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMob3duX2NhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmRzIHRoZSBjYWxsLiBPbmNlIHRoZSBjYWxsIGlzIGVuZGVkLCBpdCBjYW5ub3QgYmUgcmUtam9pbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmRDYWxsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vbWFya19lbmRlZGApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGlucyB0aGUgZ2l2ZW4gc2Vzc2lvbiB0byB0aGUgdG9wIG9mIHRoZSBwYXJ0aWNpcGFudHMgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbklkIHRvIHBpbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGluID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIHtcbiAgICAgICAgICAgICAgICBwaW46IHtcbiAgICAgICAgICAgICAgICAgICAgaXNMb2NhbFBpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGlubmVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5waW5zIHRoZSBnaXZlbiBzZXNzaW9uIGZyb20gdGhlIHRvcCBvZiB0aGUgcGFydGljaXBhbnRzIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb25JZCB0byB1bnBpbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5waW4gPSAoc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwge1xuICAgICAgICAgICAgICAgIHBpbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQaW5zIHRoZSBnaXZlbiBzZXNzaW9uIHRvIHRoZSB0b3Agb2YgdGhlIHBhcnRpY2lwYW50cyBsaXN0IGZvciBldmVyeW9uZVxuICAgICAgICAgKiBpbiB0aGUgY2FsbC5cbiAgICAgICAgICogWW91IGNhbiBleGVjdXRlIHRoaXMgbWV0aG9kIG9ubHkgaWYgeW91IGhhdmUgdGhlIGBwaW4tZm9yLWV2ZXJ5b25lYCBjYXBhYmlsaXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdCB0aGUgcmVxdWVzdCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBpbkZvckV2ZXJ5b25lID0gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3BpbmAsIHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5waW5zIHRoZSBnaXZlbiBzZXNzaW9uIGZyb20gdGhlIHRvcCBvZiB0aGUgcGFydGljaXBhbnRzIGxpc3QgZm9yIGV2ZXJ5b25lXG4gICAgICAgICAqIGluIHRoZSBjYWxsLlxuICAgICAgICAgKiBZb3UgY2FuIGV4ZWN1dGUgdGhpcyBtZXRob2Qgb25seSBpZiB5b3UgaGF2ZSB0aGUgYHBpbi1mb3ItZXZlcnlvbmVgIGNhcGFiaWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZXF1ZXN0IHRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5waW5Gb3JFdmVyeW9uZSA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS91bnBpbmAsIHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUXVlcnkgY2FsbCBtZW1iZXJzIHdpdGggZmlsdGVyIHF1ZXJ5LiBUaGUgcmVzdWx0IHdvbid0IGJlIHN0b3JlZCBpbiBjYWxsIHN0YXRlLlxuICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeU1lbWJlcnMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoJy9jYWxsL21lbWJlcnMnLCB7XG4gICAgICAgICAgICAgICAgLi4uKHJlcXVlc3QgfHwge30pLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCB1cGRhdGUgdGhlIGNhbGwgbWVtYmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgdGhlIHJlcXVlc3QgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbE1lbWJlcnMgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vbWVtYmVyc2AsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGVzIGFuIGF1dG8tZHJvcCB0aW1lb3V0IGJhc2VkIG9uIHRoZSBjYWxsIHNldHRpbmdzLlxuICAgICAgICAgKiBBcHBsaWNhYmxlIG9ubHkgZm9yIHJpbmdpbmcgY2FsbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlQXV0b0Ryb3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kcm9wVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS5zZXR0aW5ncyQsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgaWYgdGhlIGNhbGwgaXMgbm90IHJpbmdpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGUgIT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEluTXMgPSBzZXR0aW5ncy5yaW5nLmF1dG9fY2FuY2VsX3RpbWVvdXRfbXM7XG4gICAgICAgICAgICAgICAgLy8gMCBtZWFucyBubyBhdXRvLWRyb3BcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dEluTXMgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRyb3BUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmUoeyByZWFzb246ICdyaW5nOiB0aW1lb3V0JyB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnRmFpbGVkIHRvIGRyb3AgY2FsbCcsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXRJbk1zKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiByZWNvcmRpbmdzIGZvciB0aGUgY3VycmVudCBjYWxsIG9yIGNhbGwgc2Vzc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGNhbGxTZXNzaW9uSWRgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVybiB0aGUgcmVjb3JkaW5ncyBmb3IgdGhhdCBjYWxsIHNlc3Npb24uXG4gICAgICAgICAqIE90aGVyd2lzZSwgYWxsIHJlY29yZGluZ3MgZm9yIHRoZSBjdXJyZW50IGNhbGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGxTZXNzaW9uSWQgdGhlIGNhbGwgc2Vzc2lvbiBpZCB0byByZXRyaWV2ZSByZWNvcmRpbmdzIGZvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVlcnlSZWNvcmRpbmdzID0gYXN5bmMgKGNhbGxTZXNzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIGxldCBlbmRwb2ludCA9IHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGg7XG4gICAgICAgICAgICBpZiAoY2FsbFNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gYCR7ZW5kcG9pbnR9LyR7Y2FsbFNlc3Npb25JZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmdldChgJHtlbmRwb2ludH0vcmVjb3JkaW5nc2ApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIHRyYW5zY3JpcHRpb25zIGZvciB0aGUgY3VycmVudCBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2NyaXB0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVlcnlUcmFuc2NyaXB0aW9ucyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vdHJhbnNjcmlwdGlvbnNgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIGNhbGwgc3RhdGlzdGljcyBmb3IgYSBwYXJ0aWN1bGFyIGNhbGwgc2Vzc2lvbiAoaGlzdG9yaWNhbCkuXG4gICAgICAgICAqIEhlcmUgYGNhbGxTZXNzaW9uSURgIGlzIG1hbmRhdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGxTZXNzaW9uSUQgdGhlIGNhbGwgc2Vzc2lvbiBJRCB0byByZXRyaWV2ZSBzdGF0aXN0aWNzIGZvci5cbiAgICAgICAgICogQHJldHVybnMgVGhlIGNhbGwgc3RhdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldENhbGxTdGF0cyA9IGFzeW5jIChjYWxsU2Vzc2lvbklEKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0YXRzLyR7Y2FsbFNlc3Npb25JRH1gO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmdldChlbmRwb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kcyBhIGN1c3RvbSBldmVudCB0byBhbGwgY2FsbCBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXlsb2FkIHRoZSBwYXlsb2FkIHRvIHNlbmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRDdXN0b21FdmVudCA9IGFzeW5jIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9ldmVudGAsIHsgY3VzdG9tOiBwYXlsb2FkIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFwcGx5RGV2aWNlQ29uZmlnID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0Q2FtZXJhKHsgc2V0U3RhdHVzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuaW5pdE1pYyh7IHNldFN0YXR1czogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGJlZ2luIHRyYWNraW5nIHRoZSBnaXZlbiBlbGVtZW50IGZvciB2aXNpYmlsaXR5IGNoYW5nZXMgd2l0aGluIHRoZVxuICAgICAgICAgKiBjb25maWd1cmVkIHZpZXdwb3J0IGVsZW1lbnQgKGBjYWxsLnNldFZpZXdwb3J0YCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHRyYWNrLlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSB2aWRlbyBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja0VsZW1lbnRWaXNpYmlsaXR5ID0gKGVsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5keW5hc2NhbGVNYW5hZ2VyLnRyYWNrRWxlbWVudFZpc2liaWxpdHkoZWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmlld3BvcnQgZWxlbWVudCB0byB0cmFjayBib3VuZCB2aWRlbyBlbGVtZW50cyBmb3IgdmlzaWJpbGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIHZpZXdwb3J0IGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0ID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmR5bmFzY2FsZU1hbmFnZXIuc2V0Vmlld3BvcnQoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBhIERPTSA8dmlkZW8+IGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIHZpZGVvIGVsZW1lbnQgd2lsbCBwbGF5XG4gICAgICAgICAqIHRoZSBjb3JyZWN0IHZpZGVvIHN0cmVhbSBmb3IgdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVuZGVyIHRoZSBob29kLCBpdCB3b3VsZCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHZpZGVvIGVsZW1lbnQgZGltZW5zaW9uc1xuICAgICAgICAgKiBhbmQgdXBkYXRlIHRoZSBzdWJzY3JpcHRpb24gYWNjb3JkaW5nbHkgaW4gb3JkZXIgdG8gb3B0aW1pemUgdGhlIGJhbmR3aWR0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBcInZpZXdwb3J0XCIgaXMgY29uZmlndXJlZCwgdGhlIHZpZGVvIGVsZW1lbnQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAqIHRyYWNrZWQgZm9yIHZpc2liaWxpdHkgYW5kIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZ2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50IHRoZSB2aWRlbyBlbGVtZW50IHRvIGJpbmQgdG8uXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIGtpbmQgb2YgdmlkZW8uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJpbmRWaWRlb0VsZW1lbnQgPSAodmlkZW9FbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdW5iaW5kID0gdGhpcy5keW5hc2NhbGVNYW5hZ2VyLmJpbmRWaWRlb0VsZW1lbnQodmlkZW9FbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSk7XG4gICAgICAgICAgICBpZiAoIXVuYmluZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZCh1bmJpbmQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmRlbGV0ZSh1bmJpbmQpO1xuICAgICAgICAgICAgICAgIHVuYmluZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIGEgRE9NIDxhdWRpbz4gZWxlbWVudCB0byB0aGUgZ2l2ZW4gc2Vzc2lvbiBpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtYWtlIHN1cmUgdGhhdCB0aGUgYXVkaW8gZWxlbWVudCB3aWxsXG4gICAgICAgICAqIHBsYXkgdGhlIGNvcnJlY3QgYXVkaW8gc3RyZWFtIGZvciB0aGUgZ2l2ZW4gc2Vzc2lvbiBpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGF1ZGlvRWxlbWVudCB0aGUgYXVkaW8gZWxlbWVudCB0byBiaW5kIHRvLlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIGF1ZGlvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kQXVkaW9FbGVtZW50ID0gKGF1ZGlvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUgPSAnYXVkaW9UcmFjaycpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVuYmluZCA9IHRoaXMuZHluYXNjYWxlTWFuYWdlci5iaW5kQXVkaW9FbGVtZW50KGF1ZGlvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpO1xuICAgICAgICAgICAgaWYgKCF1bmJpbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQodW5iaW5kKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5kZWxldGUodW5iaW5kKTtcbiAgICAgICAgICAgICAgICB1bmJpbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBhIERPTSA8aW1nPiBlbGVtZW50IHRvIHRoaXMgY2FsbCdzIHRodW1ibmFpbCAoaWYgZW5hYmxlZCBpbiBzZXR0aW5ncykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZUVsZW1lbnQgdGhlIGltYWdlIGVsZW1lbnQgdG8gYmluZCB0by5cbiAgICAgICAgICogQHBhcmFtIG9wdHMgb3B0aW9ucyBmb3IgdGhlIGJpbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJpbmRDYWxsVGh1bWJuYWlsRWxlbWVudCA9IChpbWFnZUVsZW1lbnQsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZmFsbGJhY2tJbWFnZVNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2V0c3RyZWFtLmlvL3JhbmRvbV9zdmcvP25hbWU9eCZpZD14JztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNyZWF0ZVN1YnNjcmlwdGlvbih0aGlzLnN0YXRlLnRodW1ibmFpbHMkLCAodGh1bWJuYWlscykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGh1bWJuYWlscylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aHVtYm5haWxVcmwgPSBuZXcgVVJMKHRodW1ibmFpbHMuaW1hZ2VfdXJsKTtcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxVcmwuc2VhcmNoUGFyYW1zLnNldCgndycsIFN0cmluZyhpbWFnZUVsZW1lbnQuY2xpZW50V2lkdGgpKTtcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxVcmwuc2VhcmNoUGFyYW1zLnNldCgnaCcsIFN0cmluZyhpbWFnZUVsZW1lbnQuY2xpZW50SGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IHRodW1ibmFpbFVybC50b1N0cmluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNpZCA9IGAke3R5cGV9OiR7aWR9YDtcbiAgICAgICAgdGhpcy5yaW5naW5nU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QocmluZ2luZyk7XG4gICAgICAgIHRoaXMud2F0Y2hpbmcgPSB3YXRjaGluZztcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBzdHJlYW1DbGllbnQ7XG4gICAgICAgIHRoaXMuY2xpZW50U3RvcmUgPSBjbGllbnRTdG9yZTtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aCA9IGAvY2FsbC8ke3RoaXMudHlwZX0vJHt0aGlzLmlkfWA7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnQ2FsbCddKTtcbiAgICAgICAgY29uc3QgY2FsbFR5cGVDb25maWcgPSBDYWxsVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudFNvcnRlciA9IHNvcnRQYXJ0aWNpcGFudHNCeSB8fCBjYWxsVHlwZUNvbmZpZy5vcHRpb25zLnNvcnRQYXJ0aWNpcGFudHNCeTtcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50U29ydGVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldFNvcnRQYXJ0aWNpcGFudHNCeShwYXJ0aWNpcGFudFNvcnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRNZW1iZXJzKG1lbWJlcnMgfHwgW10pO1xuICAgICAgICB0aGlzLnN0YXRlLnNldE93bkNhcGFiaWxpdGllcyhvd25DYXBhYmlsaXRpZXMgfHwgW10pO1xuICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShyaW5naW5nID8gQ2FsbGluZ1N0YXRlLlJJTkdJTkcgOiBDYWxsaW5nU3RhdGUuSURMRSk7XG4gICAgICAgIHRoaXMub24oJ2FsbCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHN0YXRlIHdpdGggdGhlIGxhdGVzdCBldmVudCBkYXRhXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZUZyb21FdmVudChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChyZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcywgdGhpcy5zdGF0ZSwgdGhpcy5kaXNwYXRjaGVyKSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFZmZlY3RzKCk7XG4gICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKGNyZWF0ZVN1YnNjcmlwdGlvbih0aGlzLnRyYWNrU3Vic2NyaXB0aW9uc1N1YmplY3QucGlwZShkZWJvdW5jZSgodikgPT4gdGltZXIodi50eXBlKSksIG1hcCQxKCh2KSA9PiB2LmRhdGEpKSwgKHN1YnNjcmlwdGlvbnMpID0+IHRoaXMuc2Z1Q2xpZW50Py51cGRhdGVTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMpKSk7XG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IENhbWVyYU1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMubWljcm9waG9uZSA9IG5ldyBNaWNyb3Bob25lTWFuYWdlcih0aGlzKTtcbiAgICAgICAgdGhpcy5zcGVha2VyID0gbmV3IFNwZWFrZXJNYW5hZ2VyKHRoaXMpO1xuICAgICAgICB0aGlzLnNjcmVlblNoYXJlID0gbmV3IFNjcmVlblNoYXJlTWFuYWdlcih0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJFZmZlY3RzKCkge1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgICAgLy8gaGFuZGxlcyB1cGRhdGluZyB0aGUgcGVybWlzc2lvbnMgY29udGV4dCB3aGVuIHRoZSBzZXR0aW5ncyBjaGFuZ2UuXG4gICAgICAgIGNyZWF0ZVN1YnNjcmlwdGlvbih0aGlzLnN0YXRlLnNldHRpbmdzJCwgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbnNDb250ZXh0LnNldENhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVuIHRoZSB1c2VyIHBlcm1pc3Npb25zIGFyZSBtb2RpZmllZC5cbiAgICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMuc3RhdGUub3duQ2FwYWJpbGl0aWVzJCwgKG93bkNhcGFiaWxpdGllcykgPT4ge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwZXJtaXNzaW9uIGNvbnRleHQuXG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5zZXRQZXJtaXNzaW9ucyhvd25DYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgdXNlciBzdGlsbCBoYXMgcHVibGlzaGluZyBwZXJtaXNzaW9ucyBhbmQgc3RvcCBwdWJsaXNoaW5nIGlmIG5vdC5cbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25Ub1RyYWNrVHlwZSA9IHtcbiAgICAgICAgICAgICAgICBbT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPXTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICAgICAgICAgIFtPd25DYXBhYmlsaXR5LlNFTkRfVklERU9dOiBUcmFja1R5cGUuVklERU8sXG4gICAgICAgICAgICAgICAgW093bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkVdOiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3Blcm1pc3Npb24sIHRyYWNrVHlwZV0gb2YgT2JqZWN0LmVudHJpZXMocGVybWlzc2lvblRvVHJhY2tUeXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5oYXNQZXJtaXNzaW9uKHBlcm1pc3Npb24pO1xuICAgICAgICAgICAgICAgIGlmICghaGFzUGVybWlzc2lvbiAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5wdWJsaXNoZXIuaXNQdWJsaXNoaW5nKHRyYWNrVHlwZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyLmlzTGl2ZSh0cmFja1R5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHRyYWNrcywgdGhlbiBub3RpZnkgZGV2aWNlIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wUHVibGlzaCh0cmFja1R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYEVycm9yIHN0b3BwaW5nIHB1Ymxpc2ggJHt0cmFja1R5cGV9YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRpc2FibGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5sb2dnZXIoJ2Vycm9yJywgYEVycm9yIGRpc2FibGluZyBjYW1lcmEgYWZ0ZXIgcGVybWlzc2lvbiByZXZva2VkYCwgZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tUeXBlID09PSBUcmFja1R5cGUuQVVESU8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmUuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRpc2FibGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5sb2dnZXIoJ2Vycm9yJywgYEVycm9yIGRpc2FibGluZyBtaWNyb3Bob25lIGFmdGVyIHBlcm1pc3Npb24gcmV2b2tlZGAsIGVycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICAgIC8vIGhhbmRsZXMgdGhlIGNhc2Ugd2hlbiB0aGUgdXNlciBpcyBibG9ja2VkIGJ5IHRoZSBjYWxsIG93bmVyLlxuICAgICAgICBjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS5ibG9ja2VkVXNlcklkcyQsIGFzeW5jIChibG9ja2VkVXNlcklkcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFibG9ja2VkVXNlcklkcyB8fCBibG9ja2VkVXNlcklkcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFVzZXJJZCA9IHRoaXMuY3VycmVudFVzZXJJZDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VXNlcklkICYmIGJsb2NrZWRVc2VySWRzLmluY2x1ZGVzKGN1cnJlbnRVc2VySWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCAnTGVhdmluZyBjYWxsIGJlY2F1c2Ugb2YgYmVpbmcgYmxvY2tlZCcpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubGVhdmUoeyByZWFzb246ICd1c2VyIGJsb2NrZWQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKFxuICAgICAgICAvLyB3YXRjaCBmb3IgYXV0byBkcm9wIGNhbmNlbGxhdGlvblxuICAgICAgICBjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGUkLCAoY2FsbGluZ1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmluZ2luZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTkVEIHx8XG4gICAgICAgICAgICAgICAgY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTklORyB8fFxuICAgICAgICAgICAgICAgIGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkxFRlQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kcm9wVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgICAgLy8gXCJyaW5naW5nXCIgbW9kZSBlZmZlY3RzIGFuZCBldmVudCBoYW5kbGVyc1xuICAgICAgICBjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5yaW5naW5nU3ViamVjdCwgKGlzUmluZ2luZykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1JpbmdpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUF1dG9Ecm9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLlJJTkdJTkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQocmVnaXN0ZXJSaW5naW5nQ2FsbEV2ZW50SGFuZGxlcnModGhpcykpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNhbGwgaXMgXCJyaW5naW5nXCIgdHlwZSBvZiBjYWxsLlxuICAgICAqL1xuICAgIGdldCByaW5naW5nKCkge1xuICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFZhbHVlKHRoaXMucmluZ2luZ1N1YmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgdXNlciBJRC5cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFVzZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50U3RvcmUuY29ubmVjdGVkVXNlcj8uaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNhbGwgd2FzIGNyZWF0ZWQgYnkgdGhlIGN1cnJlbnQgdXNlci5cbiAgICAgKi9cbiAgICBnZXQgaXNDcmVhdGVkQnlNZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY3JlYXRlZEJ5Py5pZCA9PT0gdGhpcy5jdXJyZW50VXNlcklkO1xuICAgIH1cbiAgICBhc3luYyBpbml0Q2FtZXJhKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgYW55IGluIHByb2dyZXNzIGNhbWVyYSBvcGVyYXRpb25cbiAgICAgICAgaWYgKHRoaXMuY2FtZXJhLmVuYWJsZVByb21pc2UpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FtZXJhLmVuYWJsZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FtZXJhLmRpc2FibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhbWVyYS5kaXNhYmxlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5sb2NhbFBhcnRpY2lwYW50Py52aWRlb1N0cmVhbSB8fFxuICAgICAgICAgICAgIXRoaXMucGVybWlzc2lvbnNDb250ZXh0Lmhhc1Blcm1pc3Npb24oJ3NlbmQtdmlkZW8nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBjYW1lcmEgZGlyZWN0aW9uIGlmIGl0J3Mgbm90IHlldCBzZXRcbiAgICAgICAgaWYgKCF0aGlzLmNhbWVyYS5zdGF0ZS5kaXJlY3Rpb24gJiYgIXRoaXMuY2FtZXJhLnN0YXRlLnNlbGVjdGVkRGV2aWNlKSB7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdERpcmVjdGlvbiA9ICdmcm9udCc7XG4gICAgICAgICAgICBjb25zdCBiYWNrZW5kU2V0dGluZyA9IHRoaXMuc3RhdGUuc2V0dGluZ3M/LnZpZGVvLmNhbWVyYV9mYWNpbmc7XG4gICAgICAgICAgICBpZiAoYmFja2VuZFNldHRpbmcpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0RGlyZWN0aW9uID0gYmFja2VuZFNldHRpbmcgPT09ICdmcm9udCcgPyAnZnJvbnQnIDogJ2JhY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuc3RhdGUuc2V0RGlyZWN0aW9uKGRlZmF1bHREaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0YXJnZXQgcmVzb2x1dGlvblxuICAgICAgICBjb25zdCB0YXJnZXRSZXNvbHV0aW9uID0gdGhpcy5zdGF0ZS5zZXR0aW5ncz8udmlkZW8udGFyZ2V0X3Jlc29sdXRpb247XG4gICAgICAgIGlmICh0YXJnZXRSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhbWVyYS5zZWxlY3RUYXJnZXRSZXNvbHV0aW9uKHRhcmdldFJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNldFN0YXR1cykge1xuICAgICAgICAgICAgLy8gUHVibGlzaCBhbHJlYWR5IHRoYXQgd2FzIHNldCBiZWZvcmUgd2Ugam9pbmVkXG4gICAgICAgICAgICBpZiAodGhpcy5jYW1lcmEuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5zdGF0ZS5tZWRpYVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5WSURFTykpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hWaWRlb1N0cmVhbSh0aGlzLmNhbWVyYS5zdGF0ZS5tZWRpYVN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWRDb2RlYzogdGhpcy5jYW1lcmEucHJlZmVycmVkQ29kZWMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBjYW1lcmEgaWYgYmFja2VuZCBjb25maWcgc3BlY2lmaWVzLCBhbmQgdGhlcmUgaXMgbm8gbG9jYWwgc2V0dGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhLnN0YXRlLnN0YXR1cyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXR0aW5ncz8udmlkZW8uY2FtZXJhX2RlZmF1bHRfb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNhbWVyYS5lbmFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbml0TWljKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgYW55IGluIHByb2dyZXNzIG1pYyBvcGVyYXRpb25cbiAgICAgICAgaWYgKHRoaXMubWljcm9waG9uZS5lbmFibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1pY3JvcGhvbmUuZW5hYmxlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taWNyb3Bob25lLmRpc2FibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1pY3JvcGhvbmUuZGlzYWJsZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubG9jYWxQYXJ0aWNpcGFudD8uYXVkaW9TdHJlYW0gfHxcbiAgICAgICAgICAgICF0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5oYXNQZXJtaXNzaW9uKCdzZW5kLWF1ZGlvJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zZXRTdGF0dXMpIHtcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggbWVkaWEgc3RyZWFtIHRoYXQgd2FzIHNldCBiZWZvcmUgd2Ugam9pbmVkXG4gICAgICAgICAgICBpZiAodGhpcy5taWNyb3Bob25lLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lLnN0YXRlLm1lZGlhU3RyZWFtICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucHVibGlzaGVyPy5pc1B1Ymxpc2hpbmcoVHJhY2tUeXBlLkFVRElPKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaEF1ZGlvU3RyZWFtKHRoaXMubWljcm9waG9uZS5zdGF0ZS5tZWRpYVN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBtaWMgaWYgYmFja2VuZCBjb25maWcgc3BlY2lmaWVzLCBhbmQgdGhlcmUgaXMgbm8gbG9jYWwgc2V0dGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMubWljcm9waG9uZS5zdGF0ZS5zdGF0dXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0dGluZ3M/LmF1ZGlvLm1pY19kZWZhdWx0X29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5taWNyb3Bob25lLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBJbnNpZ2h0TWV0cmljcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXJ0VGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdGhpcy53c1RvdGFsRmFpbHVyZXMgPSAwO1xuICAgICAgICB0aGlzLndzQ29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VDbGllbnRJZCA9IHJhbmRvbUlkKCk7XG4gICAgfVxufVxuLyoqXG4gKiBwb3N0SW5zaWdodHMgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHVzZWQgYnkgZW5kIHVzZXJzIGRpcmVjdGx5IHdpdGhpbiBjaGF0IGFwcGxpY2F0aW9uLCBhbmQgdGh1cyBpcyBrZXB0IGlzb2xhdGVkXG4gKiBmcm9tIGFsbCB0aGUgY2xpZW50L2Nvbm5lY3Rpb24gY29kZS9sb2dpYy5cbiAqXG4gKiBAcGFyYW0gaW5zaWdodFR5cGVcbiAqIEBwYXJhbSBpbnNpZ2h0c1xuICovXG5jb25zdCBwb3N0SW5zaWdodHMgPSBhc3luYyAoaW5zaWdodFR5cGUsIGluc2lnaHRzKSA9PiB7XG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSAzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXR0ZW1wdHM7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgYXhpb3MucG9zdChgaHR0cHM6Ly9jaGF0LWluc2lnaHRzLmdldHN0cmVhbS5pby9pbnNpZ2h0cy8ke2luc2lnaHRUeXBlfWAsIGluc2lnaHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoKGkgKyAxKSAqIDMwMDApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGJ1aWxkV3NGYXRhbEluc2lnaHQoY29ubmVjdGlvbiwgZXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgLi4uYnVpbGRXc0Jhc2VJbnNpZ2h0KGNvbm5lY3Rpb24pLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFdzQmFzZUluc2lnaHQoY29ubmVjdGlvbikge1xuICAgIGNvbnN0IHsgY2xpZW50IH0gPSBjb25uZWN0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlYWR5X3N0YXRlOiBjb25uZWN0aW9uLndzPy5yZWFkeVN0YXRlLFxuICAgICAgICB1cmw6IGNvbm5lY3Rpb24uX2J1aWxkVXJsKCksXG4gICAgICAgIGFwaV9rZXk6IGNsaWVudC5rZXksXG4gICAgICAgIHN0YXJ0X3RzOiBjbGllbnQuaW5zaWdodE1ldHJpY3MuY29ubmVjdGlvblN0YXJ0VGltZXN0YW1wLFxuICAgICAgICBlbmRfdHM6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICBhdXRoX3R5cGU6IGNsaWVudC5nZXRBdXRoVHlwZSgpLFxuICAgICAgICB0b2tlbjogY2xpZW50LnRva2VuTWFuYWdlci50b2tlbixcbiAgICAgICAgdXNlcl9pZDogY2xpZW50LnVzZXJJRCxcbiAgICAgICAgdXNlcl9kZXRhaWxzOiBjbGllbnQuX3VzZXIsXG4gICAgICAgIC8vIGRldmljZTogY2xpZW50Lm9wdGlvbnMuZGV2aWNlLFxuICAgICAgICBkZXZpY2U6ICdicm93c2VyJyxcbiAgICAgICAgY2xpZW50X2lkOiBjb25uZWN0aW9uLmNvbm5lY3Rpb25JRCxcbiAgICAgICAgd3NfZGV0YWlsczogY29ubmVjdGlvbi53cyxcbiAgICAgICAgd3NfY29uc2VjdXRpdmVfZmFpbHVyZXM6IGNsaWVudC5pbnNpZ2h0TWV0cmljcy53c0NvbnNlY3V0aXZlRmFpbHVyZXMsXG4gICAgICAgIHdzX3RvdGFsX2ZhaWx1cmVzOiBjbGllbnQuaW5zaWdodE1ldHJpY3Mud3NUb3RhbEZhaWx1cmVzLFxuICAgICAgICByZXF1ZXN0X2lkOiBjb25uZWN0aW9uLnJlcXVlc3RJRCxcbiAgICAgICAgb25saW5lOiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvcj8ub25MaW5lIDogbnVsbCxcbiAgICAgICAgdXNlcl9hZ2VudDogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3I/LnVzZXJBZ2VudCA6IG51bGwsXG4gICAgICAgIGluc3RhbmNlX2NsaWVudF9pZDogY2xpZW50Lmluc2lnaHRNZXRyaWNzLmluc3RhbmNlQ2xpZW50SWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3NTdWNjZXNzQWZ0ZXJGYWlsdXJlSW5zaWdodChjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGJ1aWxkV3NCYXNlSW5zaWdodChjb25uZWN0aW9uKTtcbn1cblxuLy8gVHlwZSBndWFyZHMgdG8gY2hlY2sgV2ViU29ja2V0IGVycm9yIHR5cGVcbmNvbnN0IGlzQ2xvc2VFdmVudCA9IChyZXMpID0+IHJlcy5jb2RlICE9PSB1bmRlZmluZWQ7XG5jb25zdCBpc0Vycm9yRXZlbnQgPSAocmVzKSA9PiByZXMuZXJyb3IgIT09IHVuZGVmaW5lZDtcbi8qKlxuICogU3RhYmxlV1NDb25uZWN0aW9uIC0gQSBXUyBjb25uZWN0aW9uIHRoYXQgcmVjb25uZWN0cyB1cG9uIGZhaWx1cmUuXG4gKiAtIHRoZSBicm93c2VyIHdpbGwgc29tZXRpbWVzIHJlcG9ydCB0aGF0IHlvdSdyZSBvbmxpbmUgb3Igb2ZmbGluZVxuICogLSB0aGUgV1MgY29ubmVjdGlvbiBjYW4gYnJlYWsgYW5kIGZhaWwgKHRoZXJlIGlzIGEgMzBzIGhlYWx0aCBjaGVjaylcbiAqIC0gc29tZXRpbWVzIHlvdXIgV1MgY29ubmVjdGlvbiB3aWxsIHNlZW0gdG8gd29yayB3aGlsZSB0aGUgdXNlciBpcyBpbiBmYWN0IG9mZmxpbmVcbiAqIC0gdG8gc3BlZWQgdXAgb25saW5lL29mZmxpbmUgZGV0ZWN0aW9uIHlvdSBjYW4gdXNlIHRoZSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScpO1xuICpcbiAqIFRoZXJlIGFyZSA0IHdheXMgaW4gd2hpY2ggYSBjb25uZWN0aW9uIGNhbiBiZWNvbWUgdW5oZWFsdGh5OlxuICogLSB3ZWJzb2NrZXQub25lcnJvciBpcyBjYWxsZWRcbiAqIC0gd2Vic29ja2V0Lm9uY2xvc2UgaXMgY2FsbGVkXG4gKiAtIHRoZSBoZWFsdGggY2hlY2sgZmFpbHMgYW5kIG5vIGV2ZW50IGlzIHJlY2VpdmVkIGZvciB+NDAgc2Vjb25kc1xuICogLSB0aGUgYnJvd3NlciBpbmRpY2F0ZXMgdGhlIGNvbm5lY3Rpb24gaXMgbm93IG9mZmxpbmVcbiAqXG4gKiBUaGVyZSBhcmUgMiBhc3N1bXB0aW9ucyB3ZSBtYWtlIGFib3V0IHRoZSBzZXJ2ZXI6XG4gKiAtIHN0YXRlIGNhbiBiZSByZWNvdmVyZWQgYnkgcXVlcnlpbmcgdGhlIGNoYW5uZWwgYWdhaW5cbiAqIC0gaWYgdGhlIHNlcnZlcnMgZmFpbHMgdG8gcHVibGlzaCBhIG1lc3NhZ2UgdG8gdGhlIGNsaWVudCwgdGhlIFdTIGNvbm5lY3Rpb24gaXMgZGVzdHJveWVkXG4gKi9cbmNsYXNzIFN0YWJsZVdTQ29ubmVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2xvZyA9IChtc2csIGV4dHJhID0ge30sIGxldmVsID0gJ2luZm8nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIobGV2ZWwsICdjb25uZWN0aW9uOicgKyBtc2csIHtcbiAgICAgICAgICAgICAgICAuLi5leHRyYSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldENsaWVudCA9IChjbGllbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVpbGRzIGFuZCByZXR1cm5zIHRoZSB1cmwgZm9yIHdlYnNvY2tldC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybnMgdXJsIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYnVpbGRVcmwgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICAvLyBjb25zdCBxcyA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmNsaWVudC5fYnVpbGRXU1BheWxvYWQodGhpcy5yZXF1ZXN0SUQpKTtcbiAgICAgICAgICAgIC8vIHBhcmFtcy5zZXQoJ2pzb24nLCBxcyk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdhcGlfa2V5JywgdGhpcy5jbGllbnQua2V5KTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ3N0cmVhbS1hdXRoLXR5cGUnLCB0aGlzLmNsaWVudC5nZXRBdXRoVHlwZSgpKTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ1gtU3RyZWFtLUNsaWVudCcsIHRoaXMuY2xpZW50LmdldFVzZXJBZ2VudCgpKTtcbiAgICAgICAgICAgIC8vIHBhcmFtcy5hcHBlbmQoJ2F1dGhvcml6YXRpb24nLCB0aGlzLmNsaWVudC5fZ2V0VG9rZW4oKSEpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuY2xpZW50LndzQmFzZVVSTH0vY29ubmVjdD8ke3BhcmFtcy50b1N0cmluZygpfWA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbmxpbmVTdGF0dXNDaGFuZ2VkIC0gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBjb25uZWN0cyBvciBkaXNjb25uZWN0cyBmcm9tIHRoZSBpbnRlcm5ldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgd2l0aCB0eXBlIG9ubGluZSBvciBvZmZsaW5lXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9ubGluZVN0YXR1c0NoYW5nZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnb2ZmbGluZScpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIHRoZSBjb25uZWN0aW9uIGFzIGRvd25cbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ29ubGluZVN0YXR1c0NoYW5nZWQoKSAtIFN0YXR1cyBjaGFuZ2luZyB0byBvZmZsaW5lJyk7XG4gICAgICAgICAgICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBhcHAgaXMgb2ZmbGluZSBzbyBkaXNwYXRjaCB0aGUgdW5oZWFsdGh5IGNvbm5lY3Rpb24gZXZlbnQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRIZWFsdGgoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ29ubGluZScpIHtcbiAgICAgICAgICAgICAgICAvLyByZXRyeSByaWdodCBub3cuLi5cbiAgICAgICAgICAgICAgICAvLyBXZSBjaGVjayB0aGlzLmlzSGVhbHRoeSwgbm90IHN1cmUgaWYgaXQncyBhbHdheXNcbiAgICAgICAgICAgICAgICAvLyBzbWFydCB0byBjcmVhdGUgYSBuZXcgV1MgY29ubmVjdGlvbiBpZiB0aGUgb2xkIG9uZSBpcyBzdGlsbCB1cCBhbmQgcnVubmluZy5cbiAgICAgICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHdlIGRpZG4ndCBtaXNzIGFueSBtZXNzYWdlcywgc28gdGhpcyBwcm9jZXNzIGlzIGp1c3QgZXhwZW5zaXZlIGFuZCBub3QgbmVlZGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgb25saW5lU3RhdHVzQ2hhbmdlZCgpIC0gU3RhdHVzIGNoYW5naW5nIHRvIG9ubGluZS4gaXNIZWFsdGh5OiAke3RoaXMuaXNIZWFsdGh5fWApO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0hlYWx0aHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KHsgaW50ZXJ2YWw6IDEwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbm9wZW4gPSAod3NJRCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMud3NJRCAhPT0gd3NJRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gdGhpcy5jbGllbnQudXNlcjtcbiAgICAgICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LmxvZ2dlcignZXJyb3InLCBgVXNlciBub3Qgc2V0LCBjYW4ndCBjb25uZWN0IHRvIFdTYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmNsaWVudC5fZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIoJ2Vycm9yJywgYFRva2VuIG5vdCBzZXQsIGNhbid0IGNvbm5lY3QgYXV0aGVudGljYXRlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgdXNlcl9kZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB1c2VyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiB1c2VyLmltYWdlLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b206IHVzZXIuY3VzdG9tLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGlvblNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy53cz8uc2VuZChKU09OLnN0cmluZ2lmeShhdXRoTWVzc2FnZSkpO1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdvbm9wZW4oKSAtIG9ub3BlbiBjYWxsYmFjaycsIHsgd3NJRCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSAod3NJRCwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLndzSUQgIT09IHdzSUQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdvbm1lc3NhZ2UoKSAtIG9ubWVzc2FnZSBjYWxsYmFjaycsIHsgZXZlbnQsIHdzSUQgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgLy8gd2Ugd2FpdCB0aWxsIHRoZSBmaXJzdCBtZXNzYWdlIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBvcGVuLlxuICAgICAgICAgICAgLy8gdGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IGF1dGggZXJyb3JzIGFuZCBzaW1pbGFyIGVycm9ycyB0cmlnZ2VyIGEgd3Mub25vcGVuIGFuZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhhdCBhIHdzLm9uY2xvc2UuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSZXNvbHZlZCAmJiBkYXRhICYmIGRhdGEudHlwZSA9PT0gJ2Nvbm5lY3Rpb24uZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdGhlIHR5cGVzIG9mIF9lcnJvckZyb21XU0V2ZW50IGFyZSBpbmNvcnJlY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RQcm9taXNlPy4odGhpcy5fZXJyb3JGcm9tV1NFdmVudChkYXRhLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnQuLlxuICAgICAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGRhdGEgJiZcbiAgICAgICAgICAgICAgICAoZGF0YS50eXBlID09PSAnaGVhbHRoLmNoZWNrJyB8fCBkYXRhLnR5cGUgPT09ICdjb25uZWN0aW9uLm9rJykpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5pdGlhbCBoZWFsdGgtY2hlY2sgc2hvdWxkIGNvbWUgZnJvbSB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZU5leHRQaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09ICdjb25uZWN0aW9uLm9rJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2U/LihkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRIZWFsdGgodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09ICdjb25uZWN0aW9uLmVycm9yJyAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlIH0gPSBkYXRhLmVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gS25vd25Db2Rlcy5UT0tFTl9FWFBJUkVEICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nKCdjb25uZWN0KCkgLSBXUyBmYWlsdXJlIGR1ZSB0byBleHBpcmVkIHRva2VuLCBzbyBnb2luZyB0byB0cnkgdG8gcmVsb2FkIHRva2VuIGFuZCByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KHsgcmVmcmVzaFRva2VuOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gKHdzSUQsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy53c0lEICE9PSB3c0lEKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnb25jbG9zZSgpIC0gb25jbG9zZSBjYWxsYmFjayAtICcgKyBldmVudC5jb2RlLCB7IGV2ZW50LCB3c0lEIH0pO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNvZGUgPT09IEtub3duQ29kZXMuV1NfQ0xPU0VEX1NVQ0NFU1MpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgcGVybWFuZW50IGVycm9yIHJhaXNlZCBieSBzdHJlYW0uLlxuICAgICAgICAgICAgICAgIC8vIHVzdWFsbHkgY2F1c2VkIGJ5IGludmFsaWQgYXV0aCBkZXRhaWxzXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFdTIGNvbm5lY3Rpb24gcmVqZWN0IHdpdGggZXJyb3IgJHtldmVudC5yZWFzb259YCk7XG4gICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXZlbnQucmVhc29uO1xuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBldmVudC5jb2RlO1xuICAgICAgICAgICAgICAgIGVycm9yLndhc0NsZWFuID0gZXZlbnQud2FzQ2xlYW47XG4gICAgICAgICAgICAgICAgZXJyb3IudGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0UHJvbWlzZT8uKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coYG9uY2xvc2UoKSAtIFdTIGNvbm5lY3Rpb24gcmVqZWN0IHdpdGggZXJyb3IgJHtldmVudC5yZWFzb259YCwge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMudG90YWxGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEhlYWx0aChmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdFByb21pc2U/Lih0aGlzLl9lcnJvckZyb21XU0V2ZW50KGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBvbmNsb3NlKCkgLSBXUyBjb25uZWN0aW9uIGNsb3NlZC4gQ2FsbGluZyByZWNvbm5lY3QgLi4uYCwge1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyByZWNvbm5lY3QgaWYgaXRzIGFuIGFibm9ybWFsIGZhaWx1cmVcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gKHdzSUQsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy53c0lEICE9PSB3c0lEKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgdGhpcy50b3RhbEZhaWx1cmVzICs9IDE7XG4gICAgICAgICAgICB0aGlzLl9zZXRIZWFsdGgoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0UHJvbWlzZT8uKHRoaXMuX2Vycm9yRnJvbVdTRXZlbnQoZXZlbnQpKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgb25lcnJvcigpIC0gV1MgY29ubmVjdGlvbiByZXN1bHRlZCBpbnRvIGVycm9yYCwgeyBldmVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogX3NldEhlYWx0aCAtIFNldHMgdGhlIGNvbm5lY3Rpb24gdG8gaGVhbHRoeSBvciB1bmhlYWx0aHkuXG4gICAgICAgICAqIEJyb2FkY2FzdHMgYW4gZXZlbnQgaW4gY2FzZSB0aGUgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBoZWFsdGh5IGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29ubmVjdGlvbiBpcyBoZWFsdGh5IG9yIG5vdFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc3BhdGNoSW1tZWRpYXRlbHkgYm9vbGVhbiBpbmRpY2F0aW5nIHRvIGRpc3BhdGNoIGV2ZW50IGltbWVkaWF0ZWx5IGV2ZW4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgdW5oZWFsdGh5XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zZXRIZWFsdGggPSAoaGVhbHRoeSwgZGlzcGF0Y2hJbW1lZGlhdGVseSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGVhbHRoeSA9PT0gdGhpcy5pc0hlYWx0aHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHkgPSBoZWFsdGh5O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZWFsdGh5IHx8IGRpc3BhdGNoSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgIG9ubGluZTogdGhpcy5pc0hlYWx0aHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UncmUgb2ZmbGluZSwgd2FpdCBmZXcgc2Vjb25kcyBhbmQgZmlyZSBhbmQgZXZlbnQgaWYgc3RpbGwgb2ZmbGluZVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNIZWFsdGh5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb25uZWN0aW9uLmNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICAgICBvbmxpbmU6IHRoaXMuaXNIZWFsdGh5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgNTAwMCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfZXJyb3JGcm9tV1NFdmVudCAtIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IGZvciB0aGUgV1MgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Vycm9yRnJvbVdTRXZlbnQgPSAoZXZlbnQsIGlzV1NGYWlsdXJlID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICAgICBsZXQgc3RhdHVzQ29kZTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKGlzQ2xvc2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gZXZlbnQuY29kZTtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gJ3Vua25vd24nO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBldmVudC5yZWFzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNFcnJvckV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBldmVudC5lcnJvci5jb2RlO1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSBldmVudC5lcnJvci5TdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBldmVudC5lcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gS2VlcGluZyB0aGlzIGB3YXJuYCBsZXZlbCBsb2csIHRvIGF2b2lkIGNsdXR0ZXJpbmcgb2YgZXJyb3IgbG9ncyBmcm9tIHdzIGZhaWx1cmVzLlxuICAgICAgICAgICAgdGhpcy5fbG9nKGBfZXJyb3JGcm9tV1NFdmVudCgpIC0gV1MgZmFpbGVkIHdpdGggY29kZSAke2NvZGV9YCwgeyBldmVudCB9LCAnd2FybicpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFdTIGZhaWxlZCB3aXRoIGNvZGUgJHtjb2RlfSBhbmQgcmVhc29uIC0gJHttZXNzYWdlfWApO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0YXR1c0NvZGUgZG9lcyBub3QgZXhpc3Qgb24gYW55IGV2ZW50IHR5cGVzIGJ1dCBoYXMgYmVlbiBsZWZ0XG4gICAgICAgICAgICAgKiBhcyBpcyB0byBwcmVzZXJ2ZSBKUyBmdW5jdGlvbmFsaXR5IGR1cmluZyB0aGUgVFMgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXJyb3IuU3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgICAgICBlcnJvci5pc1dTRmFpbHVyZSA9IGlzV1NGYWlsdXJlO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogX3NldHVwUHJvbWlzZSAtIHNldHMgdXAgdGhlIHRoaXMuY29ubmVjdE9wZW4gcHJvbWlzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2V0dXBDb25uZWN0aW9uUHJvbWlzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIG9uY2Ugd3Mub3BlbiBpcyBjYWxsZWQgKi9cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk9wZW4gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2hlZHVsZXMgYSBuZXh0IGhlYWx0aCBjaGVjayBwaW5nIGZvciB3ZWJzb2NrZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlTmV4dFBpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFsdGhDaGVja1RpbWVvdXRSZWYpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFsdGhDaGVja1RpbWVvdXRSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMzAgc2Vjb25kcyBpcyB0aGUgcmVjb21tZW5kZWQgaW50ZXJ2YWwgKG1lc3NlbmdlciB1c2VzIHRoaXMpXG4gICAgICAgICAgICB0aGlzLmhlYWx0aENoZWNrVGltZW91dFJlZiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHNlbmQgdGhlIGhlYWx0aGNoZWNrLi4uLCBzZXJ2ZXIgcmVwbGllcyB3aXRoIGEgaGVhbHRoIGNoZWNrIGV2ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IFt7IHR5cGU6ICdoZWFsdGguY2hlY2snLCBjbGllbnRfaWQ6IHRoaXMuY2xpZW50LmNsaWVudElEIH1dO1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBzZW5kIG9uIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cz8uc2VuZChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIHdpbGwgYWxyZWFkeSBiZSBkZXRlY3RlZCBlbHNld2hlcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLnBpbmdJbnRlcnZhbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzY2hlZHVsZUNvbm5lY3Rpb25DaGVjayAtIHNjaGVkdWxlcyBhIGNoZWNrIGZvciB0aW1lIGRpZmZlcmVuY2UgYmV0d2VlbiBsYXN0IHJlY2VpdmVkIGV2ZW50IGFuZCBub3cuXG4gICAgICAgICAqIElmIHRoZSBkaWZmZXJlbmNlIGlzIG1vcmUgdGhhbiAzNSBzZWNvbmRzLCBpdCBtZWFucyBvdXIgaGVhbHRoIGNoZWNrIGxvZ2ljIGhhcyBmYWlsZWQgYW5kIHdlYnNvY2tldCBuZWVkc1xuICAgICAgICAgKiB0byBiZSByZWNvbm5lY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RFdmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBub3cuZ2V0VGltZSgpIC0gdGhpcy5sYXN0RXZlbnQuZ2V0VGltZSgpID4gdGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2sgLSBnb2luZyB0byByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0SGVhbHRoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIC8qKiBjb25zZWN1dGl2ZSBmYWlsdXJlcyBpbmZsdWVuY2UgdGhlIGR1cmF0aW9uIG9mIHRoZSB0aW1lb3V0ICovXG4gICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgIC8qKiBrZWVwIHRyYWNrIG9mIHRoZSB0b3RhbCBudW1iZXIgb2YgZmFpbHVyZXMgKi9cbiAgICAgICAgdGhpcy50b3RhbEZhaWx1cmVzID0gMDtcbiAgICAgICAgLyoqIFdlIG9ubHkgbWFrZSAxIGF0dGVtcHQgdG8gcmVjb25uZWN0IGF0IHRoZSBzYW1lIHRpbWUuLiAqL1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKiogVHJ1ZSBhZnRlciB0aGUgYXV0aCBwYXlsb2FkIGlzIHNlbnQgdG8gdGhlIHNlcnZlciAqL1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uU2VudCA9IGZhbHNlO1xuICAgICAgICAvKiogVG8gYXZvaWQgcmVjb25uZWN0IGlmIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKi9cbiAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQm9vbGVhbiB0aGF0IGluZGljYXRlcyBpZiB0aGUgY29ubmVjdGlvbiBwcm9taXNlIGlzIHJlc29sdmVkICovXG4gICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQm9vbGVhbiB0aGF0IGluZGljYXRlcyBpZiB3ZSBoYXZlIGEgd29ya2luZyBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgKi9cbiAgICAgICAgdGhpcy5pc0hlYWx0aHkgPSBmYWxzZTtcbiAgICAgICAgLyoqIEluY3JlbWVudGVkIHdoZW4gYSBuZXcgV1MgY29ubmVjdGlvbiBpcyBtYWRlICovXG4gICAgICAgIHRoaXMud3NJRCA9IDE7XG4gICAgICAgIC8qKiBTdG9yZSB0aGUgbGFzdCBldmVudCB0aW1lIGZvciBoZWFsdGggY2hlY2tzICovXG4gICAgICAgIHRoaXMubGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgICAgLyoqIFNlbmQgYSBoZWFsdGggY2hlY2sgbWVzc2FnZSBldmVyeSAyNSBzZWNvbmRzICovXG4gICAgICAgIHRoaXMucGluZ0ludGVydmFsID0gMjUgKiAxMDAwO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXQgPSB0aGlzLnBpbmdJbnRlcnZhbCArIDEwICogMTAwMDtcbiAgICAgICAgYWRkQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKHRoaXMub25saW5lU3RhdHVzQ2hhbmdlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbm5lY3QgLSBDb25uZWN0IHRvIHRoZSBXUyBVUkxcbiAgICAgKiB0aGUgZGVmYXVsdCAxNXMgdGltZW91dCBhbGxvd3MgYmV0d2VlbiAyfjMgdHJpZXNcbiAgICAgKiBAcmV0dXJuIHtDb25uZWN0QVBJUmVzcG9uc2U8Q29ubmVjdGVkRXZlbnQ+fSBQcm9taXNlIHRoYXQgY29tcGxldGVzIG9uY2UgdGhlIGZpcnN0IGhlYWx0aCBjaGVjayBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCh0aW1lb3V0ID0gMTUwMDApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgWW91J3ZlIGNhbGxlZCBjb25uZWN0IHR3aWNlLCBjYW4gb25seSBhdHRlbXB0IDEgY29ubmVjdGlvbiBhdCB0aGUgdGltZWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWx0aENoZWNrID0gYXdhaXQgdGhpcy5fY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgY29ubmVjdCgpIC0gRXN0YWJsaXNoZWQgd3MgY29ubmVjdGlvbiB3aXRoIGhlYWx0aGNoZWNrOiAke2hlYWx0aENoZWNrfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gS25vd25Db2Rlcy5UT0tFTl9FWFBJUkVEICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuY2xpZW50LnRva2VuTWFuYWdlci5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKCdjb25uZWN0KCkgLSBXUyBmYWlsdXJlIGR1ZSB0byBleHBpcmVkIHRva2VuLCBzbyBnb2luZyB0byB0cnkgdG8gcmVsb2FkIHRva2VuIGFuZCByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3QoeyByZWZyZXNoVG9rZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvci5pc1dTRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBUEkgcmVqZWN0ZWQgdGhlIGNvbm5lY3Rpb24gYW5kIHdlIHNob3VsZCBub3QgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBTdGF0dXNDb2RlOiBlcnJvci5TdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV1NGYWlsdXJlOiBlcnJvci5pc1dTRmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fd2FpdEZvckhlYWx0aHkodGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIF93YWl0Rm9ySGVhbHRoeSBwb2xscyB0aGUgcHJvbWlzZSBjb25uZWN0aW9uIHRvIHNlZSBpZiBpdHMgcmVzb2x2ZWQgdW50aWwgaXQgdGltZXMgb3V0XG4gICAgICogdGhlIGRlZmF1bHQgMTVzIHRpbWVvdXQgYWxsb3dzIGJldHdlZW4gMn4zIHRyaWVzXG4gICAgICogQHBhcmFtIHRpbWVvdXQgZHVyYXRpb24obXMpXG4gICAgICovXG4gICAgYXN5bmMgX3dhaXRGb3JIZWFsdGh5KHRpbWVvdXQgPSAxNTAwMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSA1MDsgLy8gbXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0aW1lb3V0OyBpICs9IGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25uZWN0aW9uT3BlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RhdHVzQ29kZTogZXJyb3IuU3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNXU0ZhaWx1cmU6IGVycm9yLmlzV1NGYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJycsXG4gICAgICAgICAgICAgICAgICAgIFN0YXR1c0NvZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5pdGlhbCBXUyBjb25uZWN0aW9uIGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCcsXG4gICAgICAgICAgICAgICAgICAgIGlzV1NGYWlsdXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkaXNjb25uZWN0IC0gRGlzY29ubmVjdCB0aGUgY29ubmVjdGlvbiBhbmQgZG9lc24ndCByZWNvdmVyLi4uXG4gICAgICpcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fbG9nKGBkaXNjb25uZWN0KCkgLSBDbG9zaW5nIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBmb3Igd3NJRCAke3RoaXMud3NJRH1gKTtcbiAgICAgICAgdGhpcy53c0lEICs9IDE7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBzdGFydCBieSByZW1vdmluZyBhbGwgdGhlIGxpc3RlbmVyc1xuICAgICAgICBpZiAodGhpcy5oZWFsdGhDaGVja1RpbWVvdXRSZWYpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFsdGhDaGVja1RpbWVvdXRSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXRSZWYpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnModGhpcy5vbmxpbmVTdGF0dXNDaGFuZ2VkKTtcbiAgICAgICAgdGhpcy5pc0hlYWx0aHkgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVtb3ZlIHdzIGhhbmRsZXJzLi4uXG4gICAgICAgIGlmICh0aGlzLndzICYmIHRoaXMud3MucmVtb3ZlQWxsTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLndzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc0Nsb3NlZFByb21pc2U7XG4gICAgICAgIC8vIGFuZCBmaW5hbGx5IGNsb3NlLi4uXG4gICAgICAgIC8vIEFzc2lnbmluZyB0byBsb2NhbCBoZXJlIGJlY2F1c2Ugd2Ugd2lsbCByZW1vdmUgaXQgZnJvbSB0aGlzIGJlZm9yZSB0aGVcbiAgICAgICAgLy8gcHJvbWlzZSByZXNvbHZlcy5cbiAgICAgICAgY29uc3QgeyB3cyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHdzICYmIHdzLmNsb3NlICYmIHdzLnJlYWR5U3RhdGUgPT09IHdzLk9QRU4pIHtcbiAgICAgICAgICAgIGlzQ2xvc2VkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2coYGRpc2Nvbm5lY3QoKSAtIHJlc29sdmluZyBpc0Nsb3NlZFByb21pc2UgJHtldmVudCA/ICd3aXRoJyA6ICd3aXRob3V0J30gY2xvc2UgZnJhbWVgLCB7IGV2ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3cy5vbmNsb3NlID0gb25jbG9zZTtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHdlIGRvbid0IHJlY2VpdmUgY2xvc2UgZnJhbWUgd2Vic29ja2V0IHNlcnZlciBpbiB0aW1lLFxuICAgICAgICAgICAgICAgIC8vIGxldHMgbm90IHdhaXQgZm9yIG1vcmUgdGhhbiAxIHNlY29uZC5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KG9uY2xvc2UsIHRpbWVvdXQgIT0gbnVsbCA/IHRpbWVvdXQgOiAxMDAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbG9nKGBkaXNjb25uZWN0KCkgLSBNYW51YWxseSBjbG9zZWQgY29ubmVjdGlvbiBieSBjYWxsaW5nIGNsaWVudC5kaXNjb25uZWN0KClgKTtcbiAgICAgICAgICAgIHdzLmNsb3NlKEtub3duQ29kZXMuV1NfQ0xPU0VEX1NVQ0NFU1MsICdNYW51YWxseSBjbG9zZWQgY29ubmVjdGlvbiBieSBjYWxsaW5nIGNsaWVudC5kaXNjb25uZWN0KCknKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgZGlzY29ubmVjdCgpIC0gd3MgY29ubmVjdGlvbiBkb2Vzbid0IGV4aXN0IG9yIGl0IGlzIGFscmVhZHkgY2xvc2VkLmApO1xuICAgICAgICAgICAgaXNDbG9zZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMud3M7XG4gICAgICAgIHJldHVybiBpc0Nsb3NlZFByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIF9jb25uZWN0IC0gQ29ubmVjdCB0byB0aGUgV1MgZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Nvbm5lY3RBUElSZXNwb25zZTxDb25uZWN0ZWRFdmVudD59IFByb21pc2UgdGhhdCBjb21wbGV0ZXMgb25jZSB0aGUgZmlyc3QgaGVhbHRoIGNoZWNrIG1lc3NhZ2UgaXMgcmVjZWl2ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nIHx8XG4gICAgICAgICAgICAodGhpcy5pc0Rpc2Nvbm5lY3RlZCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLmVuYWJsZVdTRmFsbGJhY2spKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBzaW1wbHkgaWdub3JlIF9jb25uZWN0IGlmIGl0J3MgY3VycmVudGx5IHRyeWluZyB0byBjb25uZWN0XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SUQgPSByYW5kb21JZCgpO1xuICAgICAgICB0aGlzLmNsaWVudC5pbnNpZ2h0TWV0cmljcy5jb25uZWN0aW9uU3RhcnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgbGV0IGlzVG9rZW5SZWFkeSA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKGBfY29ubmVjdCgpIC0gd2FpdGluZyBmb3IgdG9rZW5gKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnRva2VuTWFuYWdlci50b2tlblJlYWR5KCk7XG4gICAgICAgICAgICBpc1Rva2VuUmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyB0b2tlbiBwcm92aWRlciBoYXMgZmFpbGVkIGJlZm9yZSwgc28gdHJ5IGFnYWluXG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghaXNUb2tlblJlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBfY29ubmVjdCgpIC0gdG9rZW5Qcm92aWRlciBmYWlsZWQgYmVmb3JlLCBzbyBnb2luZyB0byByZXRyeWApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnRva2VuTWFuYWdlci5sb2FkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvblByb21pc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHdzVVJMID0gdGhpcy5fYnVpbGRVcmwoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgX2Nvbm5lY3QoKSAtIENvbm5lY3RpbmcgdG8gJHt3c1VSTH1gLCB7XG4gICAgICAgICAgICAgICAgd3NVUkwsXG4gICAgICAgICAgICAgICAgcmVxdWVzdElEOiB0aGlzLnJlcXVlc3RJRCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQod3NVUkwpO1xuICAgICAgICAgICAgdGhpcy53cy5vbm9wZW4gPSB0aGlzLm9ub3Blbi5iaW5kKHRoaXMsIHRoaXMud3NJRCk7XG4gICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSB0aGlzLm9uY2xvc2UuYmluZCh0aGlzLCB0aGlzLndzSUQpO1xuICAgICAgICAgICAgdGhpcy53cy5vbmVycm9yID0gdGhpcy5vbmVycm9yLmJpbmQodGhpcywgdGhpcy53c0lEKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5vbm1lc3NhZ2UuYmluZCh0aGlzLCB0aGlzLndzSUQpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb25PcGVuO1xuICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklEID0gcmVzcG9uc2UuY29ubmVjdGlvbl9pZDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5yZXNvbHZlQ29ubmVjdGlvbklkPy4odGhpcy5jb25uZWN0aW9uSUQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudC5pbnNpZ2h0TWV0cmljcy53c0NvbnNlY3V0aXZlRmFpbHVyZXMgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Lm9wdGlvbnMuZW5hYmxlSW5zaWdodHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdEluc2lnaHRzKCd3c19zdWNjZXNzX2FmdGVyX2ZhaWx1cmUnLCBidWlsZFdzU3VjY2Vzc0FmdGVyRmFpbHVyZUluc2lnaHQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5pbnNpZ2h0TWV0cmljcy53c0NvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgX2Nvbm5lY3QoKSAtIEVycm9yIC0gYCwgZXJyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudC5vcHRpb25zLmVuYWJsZUluc2lnaHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzKys7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NUb3RhbEZhaWx1cmVzKys7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zaWdodHMgPSBidWlsZFdzRmF0YWxJbnNpZ2h0KHRoaXMsIGNvbnZlcnRFcnJvclRvSnNvbihlcnIpKTtcbiAgICAgICAgICAgICAgICBwb3N0SW5zaWdodHM/Lignd3NfZmF0YWwnLCBpbnNpZ2h0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5yZWplY3RDb25uZWN0aW9uSWQ/LigpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIF9yZWNvbm5lY3QgLSBSZXRyeSB0aGUgY29ubmVjdGlvbiB0byBXUyBlbmRwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHt7IGludGVydmFsPzogbnVtYmVyOyByZWZyZXNoVG9rZW4/OiBib29sZWFuIH19IG9wdGlvbnMgRm9sbG93aW5nIG9wdGlvbnMgYXJlIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICogLSBgaW50ZXJ2YWxgXHR7aW50fVx0XHRcdG51bWJlciBvZiBtcyB0aGF0IGZ1bmN0aW9uIHNob3VsZCB3YWl0IGJlZm9yZSByZWNvbm5lY3RpbmdcbiAgICAgKiAtIGByZWZyZXNoVG9rZW5gIHtib29sZWFufVx0cmVsb2FkL3JlZnJlc2ggdXNlciB0b2tlbiBiZSByZWZyZXNoZWQgYmVmb3JlIGF0dGVtcHRpbmcgcmVjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWNvbm5lY3Qob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gSW5pdGlhdGluZyB0aGUgcmVjb25uZWN0Jyk7XG4gICAgICAgIC8vIG9ubHkgYWxsb3cgMSBjb25uZWN0aW9uIGF0IHRoZSB0aW1lXG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZyB8fCB0aGlzLmlzSGVhbHRoeSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdfcmVjb25uZWN0KCkgLSBBYm9ydCAoMSkgc2luY2UgYWxyZWFkeSBjb25uZWN0aW5nIG9yIGhlYWx0aHknKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNvbm5lY3QgaW4gY2FzZSBvZiBvbiBlcnJvciBvciBvbiBjbG9zZVxuICAgICAgICAvLyBhbHNvIHJlY29ubmVjdCBpZiB0aGUgaGVhbHRoIGNoZWNrIGN5Y2xlIGZhaWxzXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgICAgIGlmICghaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGludGVydmFsID0gcmV0cnlJbnRlcnZhbCh0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlY29ubmVjdCwgb3IgdHJ5IGFnYWluIGFmdGVyIGEgbGl0dGxlIHdoaWxlLi4uXG4gICAgICAgIGF3YWl0IHNsZWVwKGludGVydmFsKTtcbiAgICAgICAgLy8gQ2hlY2sgb25jZSBhZ2FpbiBpZiBieSBzb21lIG90aGVyIGNhbGwgdG8gX3JlY29ubmVjdCBpcyBhY3RpdmUgb3IgY29ubmVjdGlvbiBpc1xuICAgICAgICAvLyBhbHJlYWR5IHJlc3RvcmVkLCB0aGVuIG5vIG5lZWQgdG8gcHJvY2VlZC5cbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nIHx8IHRoaXMuaXNIZWFsdGh5KSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIEFib3J0ICgyKSBzaW5jZSBhbHJlYWR5IGNvbm5lY3Rpbmcgb3IgaGVhbHRoeScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRGlzY29ubmVjdGVkICYmIHRoaXMuY2xpZW50Lm9wdGlvbnMuZW5hYmxlV1NGYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdfcmVjb25uZWN0KCkgLSBBYm9ydCAoMykgc2luY2UgZGlzY29ubmVjdCgpIGlzIGNhbGxlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gRGVzdHJveWluZyBjdXJyZW50IFdTIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgLy8gY2xlYW51cCB0aGUgb2xkIGNvbm5lY3Rpb25cbiAgICAgICAgdGhpcy5fZGVzdHJveUN1cnJlbnRXU0Nvbm5lY3Rpb24oKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIubG9hZFRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gV2FpdGluZyBmb3IgcmVjb3ZlckNhbGxCYWNrJyk7XG4gICAgICAgICAgICAvLyBhd2FpdCB0aGlzLmNsaWVudC5yZWNvdmVyU3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gRmluaXNoZWQgcmVjb3ZlckNhbGxCYWNrJyk7XG4gICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gV1MgZmFpbHVyZSBkdWUgdG8gZXhwaXJlZCB0b2tlbiwgc28gZ29pbmcgdG8gdHJ5IHRvIHJlbG9hZCB0b2tlbiBhbmQgcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdCh7IHJlZnJlc2hUb2tlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY29ubmVjdCBvbiBXUyBmYWlsdXJlcywgZG9uJ3QgcmVjb25uZWN0IGlmIHRoZXJlIGlzIGEgY29kZSBidWdcbiAgICAgICAgICAgIGlmIChlcnJvci5pc1dTRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gV1MgZmFpbHVyZSwgc28gZ29pbmcgdG8gdHJ5IHRvIHJlY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gPT0gRU5EID09Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIF9kZXN0cm95Q3VycmVudFdTQ29ubmVjdGlvbiAtIFJlbW92ZXMgdGhlIGN1cnJlbnQgV1MgY29ubmVjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgX2Rlc3Ryb3lDdXJyZW50V1NDb25uZWN0aW9uKCkge1xuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIElELCBtZWFuaW5nIHdlIHdpbGwgaWdub3JlIGFsbCBtZXNzYWdlcyBmcm9tIHRoZSBvbGRcbiAgICAgICAgLy8gd3MgY29ubmVjdGlvbiBmcm9tIG5vdyBvbi5cbiAgICAgICAgdGhpcy53c0lEICs9IDE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzPy53cz8ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzPy53cz8uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY2FyZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhhcnJheU9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcnJheU9yU3RyaW5nID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzTWFwU3RyaW5nQ2FsbGJhY2soYXJyYXlPclN0cmluZywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gISFjYWxsYmFjayAmJiBpc1N0cmluZyhhcnJheU9yU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIG1hcChhcnJheU9yU3RyaW5nLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGlmIChpc1N0cmluZyhhcnJheU9yU3RyaW5nKSAmJiBpc01hcFN0cmluZ0NhbGxiYWNrKGFycmF5T3JTdHJpbmcsIGNhbGxiYWNrKSkge1xuICAgICAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gYXJyYXlPclN0cmluZy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgaWYgKGFycmF5T3JTdHJpbmcuY2hhckF0KGspKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga1ZhbHVlID0gYXJyYXlPclN0cmluZy5jaGFyQXQoayk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkVmFsdWUgPSBjYWxsYmFjayhrVmFsdWUsIGssIGFycmF5T3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJlc1trXSA9IG1hcHBlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc1N0cmluZyhhcnJheU9yU3RyaW5nKSAmJlxuICAgICAgICAhaXNNYXBTdHJpbmdDYWxsYmFjayhhcnJheU9yU3RyaW5nLCBjYWxsYmFjaykpIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IGFycmF5T3JTdHJpbmcubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChrIGluIGFycmF5T3JTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrVmFsdWUgPSBhcnJheU9yU3RyaW5nW2tdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gY2FsbGJhY2soa1ZhbHVlLCBrLCBhcnJheU9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXNba10gPSBtYXBwZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuY29uc3QgZW5jb2RlQmFzZTY0ID0gKGRhdGEpID0+IGZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkobWFwKGRhdGEsIChjaGFyKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKSk7XG4vLyBiYXNlLTY0IGRlY29kZXIgdGhyb3dzIGV4Y2VwdGlvbiBpZiBlbmNvZGVkIHN0cmluZyBpcyBub3QgcGFkZGVkIGJ5ICc9JyB0byBtYWtlIHN0cmluZyBsZW5ndGhcbi8vIGluIG11bHRpcGxlcyBvZiA0LiBTbyBnb25uYSB1c2Ugb3VyIG93biBtZXRob2QgZm9yIHRoaXMgcHVycG9zZSB0byBrZWVwIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDI2XG5jb25zdCBkZWNvZGVCYXNlNjQgPSAocykgPT4ge1xuICAgIGNvbnN0IGUgPSB7fSwgdyA9IFN0cmluZy5mcm9tQ2hhckNvZGUsIEwgPSBzLmxlbmd0aDtcbiAgICBsZXQgaSwgYiA9IDAsIGMsIHgsIGwgPSAwLCBhLCByID0gJyc7XG4gICAgY29uc3QgQSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICBlW0EuY2hhckF0KGkpXSA9IGk7XG4gICAgfVxuICAgIGZvciAoeCA9IDA7IHggPCBMOyB4KyspIHtcbiAgICAgICAgYyA9IGVbcy5jaGFyQXQoeCldO1xuICAgICAgICBiID0gKGIgPDwgNikgKyBjO1xuICAgICAgICBsICs9IDY7XG4gICAgICAgIHdoaWxlIChsID49IDgpIHtcbiAgICAgICAgICAgICgoYSA9IChiID4+PiAobCAtPSA4KSkgJiAweGZmKSB8fCB4IDwgTCAtIDIpICYmIChyICs9IHcoYSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBKV1QgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBVc2VyU2Vzc2lvblxuICogQG1ldGhvZCBKV1RVc2VyVG9rZW5cbiAqIEBtZW1iZXJvZiBzaWduaW5nXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTZWNyZXR9IGFwaVNlY3JldCAtIEFQSSBTZWNyZXQga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIC0gVGhlIHVzZXJfaWQga2V5IGluIHRoZSBKV1QgcGF5bG9hZFxuICogQHBhcmFtIHtVUn0gW2V4dHJhRGF0YV0gLSBFeHRyYSB0aGF0IHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBKV1QgdG9rZW5cbiAqIEBwYXJhbSB7U2lnbk9wdGlvbnN9IFtqd3RPcHRpb25zXSAtIE9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzdCB0byBqd3Quc2lnblxuICogQHJldHVybiB7c3RyaW5nfSBKV1QgVG9rZW5cbiAqL1xuZnVuY3Rpb24gSldUVXNlclRva2VuKGFwaVNlY3JldCwgdXNlcklkLCBleHRyYURhdGEgPSB7fSwgand0T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZXJJZCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAuLi5leHRyYURhdGEsXG4gICAgfTtcbiAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgY2xlYXIgZXJyb3Igd2hlbiBqd3QgaXMgc2hpbW1lZCAoaWUuIGJyb3dzZXIgYnVpbGQpXG4gICAgaWYgKGp3dCA9PSBudWxsIHx8IGp3dC5zaWduID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGp3dCBjcnlwdG8sIGlmIHlvdSBhcmUgZ2V0dGluZyB0aGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgeW91IGFyZSB0cnlpbmcgdG8gZ2VuZXJhdGUgdG9rZW5zIG9uIGJyb3dzZXIgb3IgUmVhY3QgTmF0aXZlIChvciBvdGhlciBlbnZpcm9ubWVudCB3aGVyZSBjcnlwdG8gZnVuY3Rpb25zIGFyZSBub3QgYXZhaWxhYmxlKS4gUGxlYXNlIE5vdGU6IHRva2VuIHNob3VsZCBvbmx5IGJlIGdlbmVyYXRlZCBzZXJ2ZXItc2lkZS5gKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBhbGdvcml0aG06ICdIUzI1NicsIG5vVGltZXN0YW1wOiB0cnVlIH0sIGp3dE9wdGlvbnMpO1xuICAgIGlmIChwYXlsb2FkLmlhdCkge1xuICAgICAgICBvcHRzLm5vVGltZXN0YW1wID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBhcGlTZWNyZXQsIG9wdHMpO1xufVxuZnVuY3Rpb24gSldUU2VydmVyVG9rZW4oYXBpU2VjcmV0LCBqd3RPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBzZXJ2ZXI6IHRydWUsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IGFsZ29yaXRobTogJ0hTMjU2Jywgbm9UaW1lc3RhbXA6IHRydWUgfSwgand0T3B0aW9ucyk7XG4gICAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIGFwaVNlY3JldCwgb3B0cyk7XG59XG5mdW5jdGlvbiBVc2VyRnJvbVRva2VuKHRva2VuKSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IGI2NFBheWxvYWQgPSBmcmFnbWVudHNbMV07XG4gICAgY29uc3QgcGF5bG9hZCA9IGRlY29kZUJhc2U2NChiNjRQYXlsb2FkKTtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShwYXlsb2FkKTtcbiAgICByZXR1cm4gZGF0YS51c2VyX2lkO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gRGV2VG9rZW4odXNlcklkKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2V5SmhiR2NpT2lKSVV6STFOaUlzSW5SNWNDSTZJa3BYVkNKOScsIC8ve1wiYWxnXCI6IFwiSFMyNTZcIiwgXCJ0eXBcIjogXCJKV1RcIn1cbiAgICAgICAgZW5jb2RlQmFzZTY0KEpTT04uc3RyaW5naWZ5KHsgdXNlcl9pZDogdXNlcklkIH0pKSxcbiAgICAgICAgJ2RldnRva2VuJywgLy8gaGFyZGNvZGVkIHNpZ25hdHVyZVxuICAgIF0uam9pbignLicpO1xufVxuXG4vKipcbiAqIFRva2VuTWFuYWdlclxuICpcbiAqIEhhbmRsZXMgYWxsIHRoZSBvcGVyYXRpb25zIGFyb3VuZCB1c2VyIHRva2VuLlxuICovXG5jbGFzcyBUb2tlbk1hbmFnZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlY3JldH0gc2VjcmV0XG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VjcmV0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHN0YXRpYyBzdHJpbmcgdG9rZW4gb3IgdG9rZW4gcHJvdmlkZXIuXG4gICAgICAgICAqIFRva2VuIHByb3ZpZGVyIHNob3VsZCByZXR1cm4gYSB0b2tlbiBzdHJpbmcgb3IgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHN0cmluZyB0b2tlbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtUb2tlbk9yUHJvdmlkZXJ9IHRva2VuT3JQcm92aWRlciAtIHRoZSB0b2tlbiBvciB0b2tlbiBwcm92aWRlci5cbiAgICAgICAgICogQHBhcmFtIHtVc2VyUmVzcG9uc2V9IHVzZXIgLSB0aGUgdXNlciBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNBbm9ueW1vdXMgLSB3aGV0aGVyIHRoZSB1c2VyIGlzIGFub255bW91cyBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFRva2VuT3JQcm92aWRlciA9IGFzeW5jICh0b2tlbk9yUHJvdmlkZXIsIHVzZXIsIGlzQW5vbnltb3VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlVG9rZW4odG9rZW5PclByb3ZpZGVyLCB1c2VyLCBpc0Fub255bW91cyk7XG4gICAgICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odG9rZW5PclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5Qcm92aWRlciA9IHRva2VuT3JQcm92aWRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAncHJvdmlkZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbk9yUHJvdmlkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuT3JQcm92aWRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnc3RhdGljJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdG9rZW5PclByb3ZpZGVyICYmIHRoaXMudXNlciAmJiB0aGlzLnNlY3JldCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW4gPSBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXIuaWQsIHt9LCB7fSk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ3N0YXRpYyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRUb2tlbigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSB0b2tlbiBtYW5hZ2VyLlxuICAgICAgICAgKiBVc2VmdWwgZm9yIGNsaWVudCBkaXNjb25uZWN0aW9uIG9yIHN3aXRjaGluZyB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNldCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmxvYWRUb2tlblByb21pc2UgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBWYWxpZGF0ZXMgdGhlIHVzZXIgdG9rZW4uXG4gICAgICAgIHRoaXMudmFsaWRhdGVUb2tlbiA9ICh0b2tlbk9yUHJvdmlkZXIsIHVzZXIsIGlzQW5vbnltb3VzKSA9PiB7XG4gICAgICAgICAgICAvLyBhbGxvdyBlbXB0eSB0b2tlbiBmb3IgYW5vbiB1c2VyXG4gICAgICAgICAgICBpZiAodXNlciAmJiBpc0Fub255bW91cyAmJiAhdG9rZW5PclByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIERvbid0IGFsbG93IGVtcHR5IHRva2VuIGZvciBub24tc2VydmVyIHNpZGUgY2xpZW50LlxuICAgICAgICAgICAgaWYgKCF0aGlzLnNlY3JldCAmJiAhdG9rZW5PclByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyV2l0aElkIHRva2VuIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbk9yUHJvdmlkZXIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdG9rZW5PclByb3ZpZGVyICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICFpc0Z1bmN0aW9uKHRva2VuT3JQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXIgdG9rZW4gc2hvdWxkIGVpdGhlciBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuT3JQcm92aWRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBlbXB0eSB0b2tlbiBmb3IgYW5vbnltb3VzIHVzZXJzXG4gICAgICAgICAgICAgICAgaWYgKGlzQW5vbnltb3VzICYmIHRva2VuT3JQcm92aWRlciA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblVzZXJJZCA9IFVzZXJGcm9tVG9rZW4odG9rZW5PclByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5PclByb3ZpZGVyICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuVXNlcklkID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNlcklkID09PSAnJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCFpc0Fub255bW91cyAmJiB0b2tlblVzZXJJZCAhPT0gdXNlci5pZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlclRva2VuIGRvZXMgbm90IGhhdmUgYSB1c2VyX2lkIG9yIGlzIG5vdCBtYXRjaGluZyB3aXRoIHVzZXIuaWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlc29sdmVzIHdoZW4gdG9rZW4gaXMgcmVhZHkuIFRoaXMgZnVuY3Rpb24gaXMgc2ltcGx5IHRvIGNoZWNrIGlmIGxvYWRUb2tlbiBpcyBpbiBwcm9ncmVzcywgaW4gd2hpY2hcbiAgICAgICAgLy8gY2FzZSBhIGZ1bmN0aW9uIHNob3VsZCB3YWl0LlxuICAgICAgICB0aGlzLnRva2VuUmVhZHkgPSAoKSA9PiB0aGlzLmxvYWRUb2tlblByb21pc2U7XG4gICAgICAgIC8vIEZldGNoZXMgYSB0b2tlbiBmcm9tIHRva2VuUHJvdmlkZXIgZnVuY3Rpb24gYW5kIHNldHMgaW4gdG9rZW5NYW5hZ2VyLlxuICAgICAgICAvLyBJbiBjYXNlIG9mIHN0YXRpYyB0b2tlbiwgaXQgd2lsbCBzaW1wbHkgcmVzb2x2ZSB0byBzdGF0aWMgdG9rZW4uXG4gICAgICAgIHRoaXMubG9hZFRva2VuID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3JcbiAgICAgICAgICAgIHRoaXMubG9hZFRva2VuUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5Qcm92aWRlciAmJiB0eXBlb2YgdGhpcy50b2tlblByb3ZpZGVyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbiA9IGF3YWl0IHRoaXMudG9rZW5Qcm92aWRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgQ2FsbCB0byB0b2tlblByb3ZpZGVyIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRUb2tlblByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJldHVybnMgYSBjdXJyZW50IHRva2VuXG4gICAgICAgIHRoaXMuZ2V0VG9rZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudXNlciAmJiAhdGhpcy50b2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VjcmV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpXVFNlcnZlclRva2VuKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQm90aCBzZWNyZXQgYW5kIHVzZXIgdG9rZW5zIGFyZSBub3Qgc2V0LiBFaXRoZXIgY2xpZW50LmNvbm5lY3RVc2VyIHdhc24ndCBjYWxsZWQgb3IgY2xpZW50LmRpc2Nvbm5lY3Qgd2FzIGNhbGxlZGApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gKCkgPT4gdGhpcy50eXBlID09PSAnc3RhdGljJztcbiAgICAgICAgdGhpcy5sb2FkVG9rZW5Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgaWYgKHNlY3JldCkge1xuICAgICAgICAgICAgdGhpcy5zZWNyZXQgPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gJ3N0YXRpYyc7XG4gICAgICAgIGlmICh0aGlzLnNlY3JldCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IEpXVFNlcnZlclRva2VuKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgQVBJRXJyb3JDb2RlcyA9IHtcbiAgICAnLTEnOiB7IG5hbWU6ICdJbnRlcm5hbFN5c3RlbUVycm9yJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICAgJzInOiB7IG5hbWU6ICdBY2Nlc3NLZXlFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnMyc6IHsgbmFtZTogJ0F1dGhlbnRpY2F0aW9uRmFpbGVkRXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgICAnNCc6IHsgbmFtZTogJ0lucHV0RXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzYnOiB7IG5hbWU6ICdEdXBsaWNhdGVVc2VybmFtZUVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc5JzogeyBuYW1lOiAnUmF0ZUxpbWl0RXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgICAnMTYnOiB7IG5hbWU6ICdEb2VzTm90RXhpc3RFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnMTcnOiB7IG5hbWU6ICdOb3RBbGxvd2VkRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzE4JzogeyBuYW1lOiAnRXZlbnROb3RTdXBwb3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnMTknOiB7IG5hbWU6ICdDaGFubmVsRmVhdHVyZU5vdFN1cHBvcnRlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICcyMCc6IHsgbmFtZTogJ01lc3NhZ2VUb29Mb25nRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzIxJzogeyBuYW1lOiAnTXVsdGlwbGVOZXN0aW5nTGV2ZWxFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnMjInOiB7IG5hbWU6ICdQYXlsb2FkVG9vQmlnRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzIzJzogeyBuYW1lOiAnUmVxdWVzdFRpbWVvdXRFcnJvcicsIHJldHJ5YWJsZTogdHJ1ZSB9LFxuICAgICcyNCc6IHsgbmFtZTogJ01heEhlYWRlclNpemVFeGNlZWRlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc0MCc6IHsgbmFtZTogJ0F1dGhFcnJvclRva2VuRXhwaXJlZCcsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNDEnOiB7IG5hbWU6ICdBdXRoRXJyb3JUb2tlbk5vdFZhbGlkWWV0JywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc0Mic6IHsgbmFtZTogJ0F1dGhFcnJvclRva2VuVXNlZEJlZm9yZUlzc3VlZEF0JywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc0Myc6IHsgbmFtZTogJ0F1dGhFcnJvclRva2VuU2lnbmF0dXJlSW52YWxpZCcsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNDQnOiB7IG5hbWU6ICdDdXN0b21Db21tYW5kRW5kcG9pbnRNaXNzaW5nRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzQ1JzogeyBuYW1lOiAnQ3VzdG9tQ29tbWFuZEVuZHBvaW50Q2FsbEVycm9yJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICAgJzQ2JzogeyBuYW1lOiAnQ29ubmVjdGlvbklETm90Rm91bmRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNjAnOiB7IG5hbWU6ICdDb29sRG93bkVycm9yJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICAgJzY5JzogeyBuYW1lOiAnRXJyV3JvbmdSZWdpb24nLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzcwJzogeyBuYW1lOiAnRXJyUXVlcnlDaGFubmVsUGVybWlzc2lvbnMnLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzcxJzogeyBuYW1lOiAnRXJyVG9vTWFueUNvbm5lY3Rpb25zJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICAgJzk5JzogeyBuYW1lOiAnQXBwU3VzcGVuZGVkRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG59O1xuZnVuY3Rpb24gaXNBUElFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmV0cnlhYmxlKGVycm9yKSB7XG4gICAgaWYgKCFlcnJvci5jb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZXJyID0gQVBJRXJyb3JDb2Rlc1tgJHtlcnJvci5jb2RlfWBdO1xuICAgIGlmICghZXJyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGVyci5yZXRyeWFibGU7XG59XG5mdW5jdGlvbiBpc0Nvbm5lY3Rpb25JREVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgPT09IDQ2OyAvLyBDb25uZWN0aW9uSUROb3RGb3VuZEVycm9yXG59XG5mdW5jdGlvbiBpc1dTRmFpbHVyZShlcnIpIHtcbiAgICBpZiAodHlwZW9mIGVyci5pc1dTRmFpbHVyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBlcnIuaXNXU0ZhaWx1cmU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGVyci5tZXNzYWdlKS5pc1dTRmFpbHVyZTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRXJyb3JSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gIXJlcy5zdGF0dXMgfHwgcmVzLnN0YXR1cyA8IDIwMCB8fCAzMDAgPD0gcmVzLnN0YXR1cztcbn1cblxudmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgQ29ubmVjdGlvblN0YXRlW1wiQ2xvc2VkXCJdID0gXCJDTE9TRURcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0ZWRcIl0gPSBcIkNPTk5FQ1RFRFwiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSBcIkRJU0NPTk5FQ1RFRFwiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtcIkluaXRcIl0gPSBcIklOSVRcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmNsYXNzIFdTQ29ubmVjdGlvbkZhbGxiYWNrIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuX29ubGluZVN0YXR1c0NoYW5nZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgX29ubGluZVN0YXR1c0NoYW5nZWQoKSAtICR7ZXZlbnQudHlwZX1gKTtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnb2ZmbGluZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuQ2xvc2VkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFRva2VuPy5jYW5jZWwoJ2Rpc2Nvbm5lY3QoKSBpcyBjYWxsZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnb25saW5lJyAmJiB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5fcmVxID0gYXN5bmMgKHBhcmFtcywgY29uZmlnLCByZXRyeSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbmNlbFRva2VuICYmICFwYXJhbXMuY2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFRva2VuID0gYXhpb3MuQ2FuY2VsVG9rZW4uc291cmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmRvQXhpb3NSZXF1ZXN0KCdnZXQnLCB0aGlzLmNsaWVudC5iYXNlVVJMLnJlcGxhY2UoJzozMDMwJywgJzo4OTAwJykgKyAnL2xvbmdwb2xsJywgLy8gcmVwbGFjZSBwb3J0IGlmIHByZXNlbnQgZm9yIHRlc3Rpbmcgd2l0aCBsb2NhbCBBUElcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB7IC4uLmNvbmZpZywgY2FuY2VsVG9rZW46IHRoaXMuY2FuY2VsVG9rZW4/LnRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljRW5kcG9pbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDsgLy8gYWx3YXlzIHJlc2V0IGluIGNhc2Ugb2Ygbm8gZXJyb3JcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAocmV0cnkgJiYgaXNFcnJvclJldHJ5YWJsZShlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgX3JlcSgpIC0gUmV0cnlhYmxlIGVycm9yLCByZXRyeWluZyByZXF1ZXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwodGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXEocGFyYW1zLCBjb25maWcsIHJldHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5fcG9sbCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3JlcSh7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogMzAwMDAsXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpOyAvLyAzMHMgPT4gQVBJIHJlc3BvbmRzIGluIDIwcyBpZiB0aGVyZSBpcyBubyBldmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ldmVudHM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoZGF0YS5ldmVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4aW9zLmlzQ2FuY2VsKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgX3BvbGwoKSAtIGF4aW9zIGNhbmNlbGVkIHJlcXVlc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiogY2xpZW50LmRvQXhpb3NSZXF1ZXN0IHdpbGwgdGFrZSBjYXJlIG9mIFRPS0VOX0VYUElSRUQgZXJyb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb25uZWN0aW9uSURFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2coYF9wb2xsKCkgLSBDb25uZWN0aW9uSUQgZXJyb3IsIGNvbm5lY3Rpbmcgd2l0aG91dCBJRC4uLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBUElFcnJvcihlcnIpICYmICFpc0Vycm9yUmV0cnlhYmxlKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwodGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogY29ubmVjdCB0cnkgdG8gb3BlbiBhIGxvbmdwb2xsIHJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHJlY29ubmVjdCBzaG91bGQgYmUgZmFsc2UgZm9yIGZpcnN0IGNhbGwgYW5kIHRydWUgZm9yIHN1YnNlcXVlbnQgY2FsbHMgdG8ga2VlcCB0aGUgY29ubmVjdGlvbiBhbGl2ZSBhbmQgY2FsbCByZWNvdmVyU3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdCA9IGFzeW5jIChyZWNvbm5lY3QgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKCdjb25uZWN0KCkgLSBjb25uZWN0aW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MnLCB7IHJlY29ubmVjdCB9LCAnd2FybicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKCdjb25uZWN0KCkgLSBhbHJlYWR5IGNvbm5lY3RlZCBhbmQgcG9sbGluZycsIHsgcmVjb25uZWN0IH0sICd3YXJuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uSUQgPSB1bmRlZmluZWQ7IC8vIGNvbm5lY3Qgc2hvdWxkIGJlIHNlbnQgd2l0aCBlbXB0eSBjb25uZWN0aW9uX2lkIHNvIEFQSSBjcmVhdGVzIG9uZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGV2ZW50IH0gPSBhd2FpdCB0aGlzLl9yZXEoeyBqc29uOiB0aGlzLmNsaWVudC5fYnVpbGRXU1BheWxvYWQoKSB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDgwMDAsIC8vIDhzXG4gICAgICAgICAgICAgICAgfSwgcmVjb25uZWN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JRCA9IGV2ZW50LmNvbm5lY3Rpb25faWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQucmVzb2x2ZUNvbm5lY3Rpb25JZD8uKCk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNsb3NlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQucmVqZWN0Q29ubmVjdGlvbklkPy4oKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpc0hlYWx0aHkgY2hlY2tzIGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbklEIGFuZCBjb25uZWN0aW9uIGlzIGluIENvbm5lY3RlZCBzdGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0hlYWx0aHkgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmNvbm5lY3Rpb25JRCAmJiB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QgPSBhc3luYyAodGltZW91dCA9IDIwMDApID0+IHtcbiAgICAgICAgICAgIHJlbW92ZUNvbm5lY3Rpb25FdmVudExpc3RlbmVycyh0aGlzLl9vbmxpbmVTdGF0dXNDaGFuZ2VkKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxUb2tlbj8uY2FuY2VsKCdkaXNjb25uZWN0KCkgaXMgY2FsbGVkJyk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbl9pZCA9IHRoaXMuY29ubmVjdGlvbklEO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uSUQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlcSh7IGNsb3NlOiB0cnVlLCBjb25uZWN0aW9uX2lkIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBkaXNjb25uZWN0KCkgLSBDbG9zZWQgY29ubmVjdGlvbklEYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBkaXNjb25uZWN0KCkgLSBGYWlsZWRgLCB7IGVyciB9LCAnZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuSW5pdDtcbiAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgYWRkQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKHRoaXMuX29ubGluZVN0YXR1c0NoYW5nZWQpO1xuICAgIH1cbiAgICBfbG9nKG1zZywgZXh0cmEgPSB7fSwgbGV2ZWwgPSAnaW5mbycpIHtcbiAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyKGxldmVsLCAnV1NDb25uZWN0aW9uRmFsbGJhY2s6JyArIG1zZywge1xuICAgICAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fbG9nKGBfc2V0U3RhdGUoKSAtICR7c3RhdGV9YCk7XG4gICAgICAgIC8vIHRyYW5zaXRpb24gZnJvbSBjb25uZWN0aW5nID0+IGNvbm5lY3RlZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcgJiZcbiAgICAgICAgICAgIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIG9ubGluZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQgfHxcbiAgICAgICAgICAgIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIG9ubGluZTogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbn1cblxuY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnbG9jYXRpb24nXSk7XG5jb25zdCBISU5UX1VSTCA9IGBodHRwczovL2hpbnQuc3RyZWFtLWlvLXZpZGVvLmNvbS9gO1xuY29uc3QgZ2V0TG9jYXRpb25IaW50ID0gYXN5bmMgKGhpbnRVcmwgPSBISU5UX1VSTCwgdGltZW91dCA9IDIwMDApID0+IHtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChoaW50VXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGF3c1BvcCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LWFtei1jZi1wb3AnKSB8fCAnRVJSJztcbiAgICAgICAgbG9nZ2VyKCdkZWJ1ZycsIGBMb2NhdGlvbiBoZWFkZXI6ICR7YXdzUG9wfWApO1xuICAgICAgICByZXR1cm4gYXdzUG9wLnN1YnN0cmluZygwLCAzKTsgLy8gQU1TMS1QMiAtPiBBTVNcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyKCd3YXJuJywgYEZhaWxlZCB0byBnZXQgbG9jYXRpb24gaGludCBmcm9tICR7aGludFVybH1gLCBlKTtcbiAgICAgICAgcmV0dXJuICdFUlInO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxufTtcblxuY2xhc3MgU3RyZWFtQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSBhcGkga2V5XG4gICAgICogQHBhcmFtIHtTdHJlYW1DbGllbnRPcHRpb25zfSBbb3B0aW9uc10gLSBhZGRpdGlvbmFsIG9wdGlvbnMsIGhlcmUgeW91IGNhbiBwYXNzIGN1c3RvbSBvcHRpb25zIHRvIGF4aW9zIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlY3JldF0gLSB0aGUgYXBpIHNlY3JldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYnJvd3Nlcl0gLSBlbmZvcmNlIHRoZSBjbGllbnQgdG8gYmUgaW4gYnJvd3NlciBtb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53YXJtVXBdIC0gZGVmYXVsdCB0byBmYWxzZSwgaWYgdHJ1ZSwgY2xpZW50IHdpbGwgb3BlbiBhIGNvbm5lY3Rpb24gYXMgc29vbiBhcyBwb3NzaWJsZSB0byBzcGVlZCB1cCBmb2xsb3dpbmcgcmVxdWVzdHNcbiAgICAgKiBAcGFyYW0ge0xvZ2dlcn0gW29wdGlvbnMuTG9nZ2VyXSAtIGN1c3RvbSBsb2dnZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGltZW91dF0gLSBkZWZhdWx0IHRvIDMwMDBcbiAgICAgKiBAcGFyYW0ge2h0dHBzQWdlbnR9IFtvcHRpb25zLmh0dHBzQWdlbnRdIC0gY3VzdG9tIGh0dHBzQWdlbnQsIGluIG5vZGUgaXQncyBkZWZhdWx0IHRvIGh0dHBzLmFnZW50KClcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZGV2VG9rZW4gPSAodXNlcklEKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gRGV2VG9rZW4odXNlcklEKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRBdXRoVHlwZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFub255bW91cyA/ICdhbm9ueW1vdXMnIDogJ2p3dCc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0QmFzZVVSTCA9IChiYXNlVVJMKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMO1xuICAgICAgICAgICAgdGhpcy53c0Jhc2VVUkwgPSB0aGlzLmJhc2VVUkxcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnaHR0cCcsICd3cycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJzozMDMwJywgJzo4ODAwJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25IaW50ID0gYXN5bmMgKGhpbnRVcmwsIHRpbWVvdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhpbnQgPSBhd2FpdCB0aGlzLmxvY2F0aW9uSGludDtcbiAgICAgICAgICAgIGlmICghaGludCB8fCBoaW50ID09PSAnRVJSJykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb25IaW50ID0gZ2V0TG9jYXRpb25IaW50KGhpbnRVcmwgPz8gdGhpcy5vcHRpb25zLmxvY2F0aW9uSGludFVybCwgdGltZW91dCA/PyB0aGlzLm9wdGlvbnMubG9jYXRpb25IaW50VGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb25IaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhpbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2dldENvbm5lY3Rpb25JRCA9ICgpID0+IHRoaXMud3NDb25uZWN0aW9uPy5jb25uZWN0aW9uSUQgfHwgdGhpcy53c0ZhbGxiYWNrPy5jb25uZWN0aW9uSUQ7XG4gICAgICAgIHRoaXMuX2hhc0Nvbm5lY3Rpb25JRCA9ICgpID0+IEJvb2xlYW4odGhpcy5fZ2V0Q29ubmVjdGlvbklEKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogY29ubmVjdFVzZXIgLSBTZXQgdGhlIGN1cnJlbnQgdXNlciBhbmQgb3BlbiBhIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2VyIERhdGEgYWJvdXQgdGhpcyB1c2VyLiBJRSB7bmFtZTogXCJqb2huXCJ9XG4gICAgICAgICAqIEBwYXJhbSB7VG9rZW5PclByb3ZpZGVyfSB1c2VyVG9rZW5PclByb3ZpZGVyIFRva2VuIG9yIHByb3ZpZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0Nvbm5lY3RBUElSZXNwb25zZX0gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIHNldHVwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RVc2VyID0gYXN5bmMgKHVzZXIsIHVzZXJUb2tlbk9yUHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgIGlmICghdXNlci5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwiaWRcIiBmaWVsZCBvbiB0aGUgdXNlciBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGxpbmcgY29ubmVjdFVzZXIgbXVsdGlwbGUgdGltZXMgaXMgcG90ZW50aWFsbHkgdGhlIHJlc3VsdCBvZiBhICBiYWQgaW50ZWdyYXRpb24sIGhvd2V2ZXIsXG4gICAgICAgICAgICAgKiBJZiB0aGUgdXNlciBpZCByZW1haW5zIHRoZSBzYW1lIHdlIGRvbid0IHRocm93IGVycm9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJJRCA9PT0gdXNlci5pZCAmJiB0aGlzLnNldFVzZXJQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnQ29uc2VjdXRpdmUgY2FsbHMgdG8gY29ubmVjdFVzZXIgaXMgZGV0ZWN0ZWQsIGlkZWFsbHkgeW91IHNob3VsZCBvbmx5IGNhbGwgdGhpcyBmdW5jdGlvbiBvbmNlIGluIHlvdXIgYXBwLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFVzZXJQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudXNlcklEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgY2xpZW50LmRpc2Nvbm5lY3QoKSBiZWZvcmUgdHJ5aW5nIHRvIGNvbm5lY3QgYXMgYSBkaWZmZXJlbnQgdXNlci4gY29ubmVjdFVzZXIgd2FzIGNhbGxlZCB0d2ljZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5faXNVc2luZ1NlcnZlckF1dGgoKSB8fCB0aGlzLm5vZGUpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMub3B0aW9ucy5hbGxvd1NlcnZlclNpZGVDb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnUGxlYXNlIGRvIG5vdCB1c2UgY29ubmVjdFVzZXIgc2VydmVyIHNpZGUuIGNvbm5lY3RVc2VyIGltcGFjdHMgTUFVIGFuZCBjb25jdXJyZW50IGNvbm5lY3Rpb24gdXNhZ2UgYW5kIHRodXMgeW91ciBiaWxsLiBJZiB5b3UgaGF2ZSBhIHZhbGlkIHVzZS1jYXNlLCBhZGQgXCJhbGxvd1NlcnZlclNpZGVDb25uZWN0OiB0cnVlXCIgdG8gdGhlIGNsaWVudCBvcHRpb25zIHRvIGRpc2FibGUgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgZ2VuZXJhdGUgdGhlIGNsaWVudCBpZCBjbGllbnQgc2lkZVxuICAgICAgICAgICAgdGhpcy51c2VySUQgPSB1c2VyLmlkO1xuICAgICAgICAgICAgdGhpcy5hbm9ueW1vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHNldFRva2VuUHJvbWlzZSA9IHRoaXMuX3NldFRva2VuKHVzZXIsIHVzZXJUb2tlbk9yUHJvdmlkZXIsIHRoaXMuYW5vbnltb3VzKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFVzZXIodXNlcik7XG4gICAgICAgICAgICBjb25zdCB3c1Byb21pc2UgPSB0aGlzLm9wZW5Db25uZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNldFVzZXJQcm9taXNlID0gUHJvbWlzZS5hbGwoW3NldFRva2VuUHJvbWlzZSwgd3NQcm9taXNlXSkudGhlbigocmVzdWx0KSA9PiByZXN1bHRbMV0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXRVc2VyUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZXJzaXN0VXNlck9uQ29ubmVjdGlvbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW51cCBjbGllbnQgdG8gYWxsb3cgdGhlIHVzZXIgdG8gcmV0cnkgY29ubmVjdFVzZXIgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFVzZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZXRUb2tlbiA9ICh1c2VyLCB1c2VyVG9rZW5PclByb3ZpZGVyLCBpc0Fub255bW91cykgPT4gdGhpcy50b2tlbk1hbmFnZXIuc2V0VG9rZW5PclByb3ZpZGVyKHVzZXJUb2tlbk9yUHJvdmlkZXIsIHVzZXIsIGlzQW5vbnltb3VzKTtcbiAgICAgICAgdGhpcy5fc2V0VXNlciA9ICh1c2VyKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgb25lIGlzIHVzZWQgYnkgdGhlIGZyb250ZW5kLiBUaGlzIGlzIGEgY29weSBvZiB0aGUgY3VycmVudCB1c2VyIG9iamVjdCBzdG9yZWQgb24gYmFja2VuZC5cbiAgICAgICAgICAgICAqIEl0IGNvbnRhaW5zIHJlc2VydmVkIHByb3BlcnRpZXMgYW5kIG93biB1c2VyIHByb3BlcnRpZXMgd2hpY2ggYXJlIG5vdCBwcmVzZW50IGluIGB0aGlzLl91c2VyYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgICAgIHRoaXMudXNlcklEID0gdXNlci5pZDtcbiAgICAgICAgICAgIC8vIHRoaXMgb25lIGlzIGFjdHVhbGx5IHVzZWQgZm9yIHJlcXVlc3RzLiBUaGlzIGlzIGEgY29weSBvZiBjdXJyZW50IHVzZXIgcHJvdmlkZWQgdG8gYGNvbm5lY3RVc2VyYCBmdW5jdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB7IC4uLnVzZXIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2Nvbm5lY3RzIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiwgd2l0aG91dCByZW1vdmluZyB0aGUgdXNlciBzZXQgb24gY2xpZW50LlxuICAgICAgICAgKiBjbGllbnQuY2xvc2VDb25uZWN0aW9uIHdpbGwgbm90IHRyaWdnZXIgZGVmYXVsdCBhdXRvLXJldHJ5IG1lY2hhbmlzbSBmb3IgcmVjb25uZWN0aW9uLiBZb3UgbmVlZFxuICAgICAgICAgKiB0byBjYWxsIGNsaWVudC5vcGVuQ29ubmVjdGlvbiB0byByZWNvbm5lY3QgdG8gd2Vic29ja2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIG1haW5seSB1c2VmdWwgb24gbW9iaWxlIHNpZGUuIFlvdSBjYW4gb25seSByZWNlaXZlIHB1c2ggbm90aWZpY2F0aW9uc1xuICAgICAgICAgKiBpZiB5b3UgZG9uJ3QgaGF2ZSBhY3RpdmUgd2Vic29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICAgICAqIFNvIHdoZW4geW91ciBhcHAgZ29lcyB0byBiYWNrZ3JvdW5kLCB5b3UgY2FuIGNhbGwgYGNsaWVudC5jbG9zZUNvbm5lY3Rpb25gLlxuICAgICAgICAgKiBBbmQgd2hlbiBhcHAgY29tZXMgYmFjayB0byBmb3JlZ3JvdW5kLCBjYWxsIGBjbGllbnQub3BlbkNvbm5lY3Rpb25gLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdGltZW91dCBNYXggbnVtYmVyIG9mIG1zLCB0byB3YWl0IGZvciBjbG9zZSBldmVudCBvZiB3ZWJzb2NrZXQsIGJlZm9yZSBmb3JjZWZ1bGx5IGFzc3VtaW5nIHN1Y2Nlc2Z1bCBkaXNjb25uZWN0aW9uLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb24gPSBhc3luYyAodGltZW91dCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW5pbmdJbnRlcnZhbFJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFuaW5nSW50ZXJ2YWxSZWYpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5pbmdJbnRlcnZhbFJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLndzQ29ubmVjdGlvbj8uZGlzY29ubmVjdCh0aW1lb3V0KSxcbiAgICAgICAgICAgICAgICB0aGlzLndzRmFsbGJhY2s/LmRpc2Nvbm5lY3QodGltZW91dCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgV2ViU29ja2V0IGNvbm5lY3Rpb24gd2l0aCB0aGUgY3VycmVudCB1c2VyLiBSZXR1cm5zIGVtcHR5IHByb21pc2UsIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBjb25uZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5Db25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVzZXJJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdVc2VyV2l0aElkIGlzIG5vdCBzZXQgb24gY2xpZW50LCB1c2UgY2xpZW50LmNvbm5lY3RVc2VyIG9yIGNsaWVudC5jb25uZWN0QW5vbnltb3VzVXNlciBpbnN0ZWFkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy53c0Nvbm5lY3Rpb24/LmlzQ29ubmVjdGluZyAmJiB0aGlzLndzUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgJ2NsaWVudDpvcGVuQ29ubmVjdGlvbigpIC0gY29ubmVjdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3NQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLndzQ29ubmVjdGlvbj8uaXNIZWFsdGh5IHx8IHRoaXMud3NGYWxsYmFjaz8uaXNIZWFsdGh5KCkpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQ29ubmVjdGlvbklEKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsICdjbGllbnQ6b3BlbkNvbm5lY3Rpb24oKSAtIG9wZW5Db25uZWN0aW9uIGNhbGxlZCB0d2ljZSwgaGVhbHRoeSBjb25uZWN0aW9uIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uSWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25JZCA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3RDb25uZWN0aW9uSWQgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50SUQgPSBgJHt0aGlzLnVzZXJJRH0tLSR7cmFuZG9tSWQoKX1gO1xuICAgICAgICAgICAgdGhpcy53c1Byb21pc2UgPSB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndzUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplRGF0ZSA9IChiZWZvcmUpID0+IHtcbiAgICAgICAgICAgIGlmIChiZWZvcmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlID0gYmVmb3JlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVmb3JlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvbid0IHBhc3MgYmxhbmsgc3RyaW5nIGZvciBzaW5jZSwgdXNlIG51bGwgaW5zdGVhZCBpZiByZXNldHRpbmcgdGhlIHRva2VuIHJldm9rZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZWZvcmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNjb25uZWN0cyB0aGUgd2Vic29ja2V0IGFuZCByZW1vdmVzIHRoZSB1c2VyIGZyb20gY2xpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdGltZW91dCBNYXggbnVtYmVyIG9mIG1zLCB0byB3YWl0IGZvciBjbG9zZSBldmVudCBvZiB3ZWJzb2NrZXQsIGJlZm9yZSBmb3JjZWZ1bGx5IGFzc3VtaW5nIHN1Y2Nlc3NmdWwgZGlzY29ubmVjdGlvbi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFVzZXIgPSBhc3luYyAodGltZW91dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCAnY2xpZW50OmRpc2Nvbm5lY3QoKSAtIERpc2Nvbm5lY3RpbmcgdGhlIGNsaWVudCcpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB1c2VyIHNwZWNpZmljIGZpZWxkc1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudXNlcjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl91c2VyO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudXNlcklEO1xuICAgICAgICAgICAgdGhpcy5hbm9ueW1vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2VDb25uZWN0aW9uKHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy50b2tlbk1hbmFnZXIucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklkUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0Q29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlQ29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3RHdWVzdFVzZXIgPSBhc3luYyAodXNlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlID0gdGhpcy5kb0F4aW9zUmVxdWVzdCgncG9zdCcsICcvZ3Vlc3QnLCB7XG4gICAgICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgICAgICAuLi51c2VyLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiAnZ3Vlc3QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB7IHB1YmxpY0VuZHBvaW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmd1ZXN0VXNlckNyZWF0ZVByb21pc2U7XG4gICAgICAgICAgICB0aGlzLmd1ZXN0VXNlckNyZWF0ZVByb21pc2UuZmluYWxseSgoKSA9PiAodGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlID0gdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0VXNlcihyZXNwb25zZS51c2VyLCByZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogY29ubmVjdEFub255bW91c1VzZXIgLSBTZXQgYW4gYW5vbnltb3VzIHVzZXIgYW5kIG9wZW4gYSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0QW5vbnltb3VzVXNlciA9IGFzeW5jICh1c2VyLCB0b2tlbk9yUHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVDb25uZWN0aW9uSWQgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0Q29ubmVjdGlvbklkID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFub255bW91cyA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXRUb2tlbih1c2VyLCB0b2tlbk9yUHJvdmlkZXIsIHRoaXMuYW5vbnltb3VzKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFVzZXIodXNlcik7XG4gICAgICAgICAgICAvLyBzb21lIGVuZHBvaW50cyByZXF1aXJlIGEgY29ubmVjdGlvbl9pZCB0byBiZSByZXNvbHZlZC5cbiAgICAgICAgICAgIC8vIGFzIGFub255bW91cyB1c2VycyBhcmVuJ3QgYWxsb3dlZCB0byBvcGVuIFdTIGNvbm5lY3Rpb25zLCB3ZSBqdXN0XG4gICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBjb25uZWN0aW9uX2lkIGhlcmUuXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVDb25uZWN0aW9uSWQ/LigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogb24gLSBMaXN0ZW4gdG8gZXZlbnRzIG9uIGFsbCBjaGFubmVscyBhbmQgdXNlcnMgeW91ciB3YXRjaGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBjbGllbnQub24oJ21lc3NhZ2UubmV3JywgZXZlbnQgPT4ge2NvbnNvbGUubG9nKFwibXkgbmV3IG1lc3NhZ2VcIiwgZXZlbnQsIGNoYW5uZWwuc3RhdGUubWVzc2FnZXMpfSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yIChvcHRpb25hbClcbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBjYWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCwgd2hlbiBjYWxsZWQsIHVuc3Vic2NyaWJlcyB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYEFkZGluZyBsaXN0ZW5lciBmb3IgJHtldmVudE5hbWV9IGV2ZW50YCk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdPy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogb2ZmIC0gUmVtb3ZlIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9mZiA9IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgUmVtb3ZpbmcgbGlzdGVuZXIgZm9yICR7ZXZlbnROYW1lfSBldmVudGApO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0/LmZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9PSBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xvZ0FwaVJlcXVlc3QgPSAodHlwZSwgdXJsLCBkYXRhLCBjb25maWcpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd0cmFjZScsIGBjbGllbnQ6ICR7dHlwZX0gLSBSZXF1ZXN0IC0gJHt1cmx9YCwge1xuICAgICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xvZ0FwaVJlc3BvbnNlID0gKHR5cGUsIHVybCwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd0cmFjZScsIGBjbGllbnQ6JHt0eXBlfSAtIFJlc3BvbnNlIC0gdXJsOiAke3VybH0gPiBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCwge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xvZ0FwaUVycm9yID0gKHR5cGUsIHVybCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBjbGllbnQ6JHt0eXBlfSAtIEVycm9yIC0gdXJsOiAke3VybH1gLCB7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZG9BeGlvc1JlcXVlc3QgPSBhc3luYyAodHlwZSwgdXJsLCBkYXRhLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wdWJsaWNFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbk1hbmFnZXIudG9rZW5SZWFkeSgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmd1ZXN0VXNlckNyZWF0ZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklkUHJvbWlzZSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RDb25maWcgPSB0aGlzLl9lbnJpY2hBeGlvc09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dBcGlSZXF1ZXN0KHR5cGUsIHVybCwgZGF0YSwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5nZXQodXJsLCByZXF1ZXN0Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UuZGVsZXRlKHVybCwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncG9zdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5wb3N0KHVybCwgZGF0YSwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncHV0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLnB1dCh1cmwsIGRhdGEsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLnBhdGNoKHVybCwgZGF0YSwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3B0aW9ucyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5vcHRpb25zKHVybCwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXF1ZXN0IHR5cGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nQXBpUmVzcG9uc2UodHlwZSwgdXJsLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlIC8qKlRPRE86IGdlbmVyYWxpemUgZXJyb3IgdHlwZXMgICovKSB7XG4gICAgICAgICAgICAgICAgZS5jbGllbnRfcmVxdWVzdF9pZCA9IHJlcXVlc3RDb25maWcuaGVhZGVycz8uWyd4LWNsaWVudC1yZXF1ZXN0LWlkJ107XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGUucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nQXBpRXJyb3IodHlwZSwgdXJsLCBlLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqIGNvbm5lY3Rpb25fZmFsbGJhY2sgZGVwZW5kcyBvbiB0aGlzIHRva2VuIGV4cGlyYXRpb24gbG9naWMgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucmVzcG9uc2UuZGF0YS5jb2RlID09PSBLbm93bkNvZGVzLlRPS0VOX0VYUElSRUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnRva2VuTWFuYWdlci5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHJldHJ5SW50ZXJ2YWwodGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuTWFuYWdlci5sb2FkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRvQXhpb3NSZXF1ZXN0KHR5cGUsIHVybCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UoZS5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dBcGlFcnJvcih0eXBlLCB1cmwsIGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXQgPSAodXJsLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQXhpb3NSZXF1ZXN0KCdnZXQnLCB1cmwsIG51bGwsIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wdXQgPSAodXJsLCBkYXRhLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQXhpb3NSZXF1ZXN0KCdwdXQnLCB1cmwsIGRhdGEsIHsgcGFyYW1zIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBvc3QgPSAodXJsLCBkYXRhLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQXhpb3NSZXF1ZXN0KCdwb3N0JywgdXJsLCBkYXRhLCB7IHBhcmFtcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYXRjaCA9ICh1cmwsIGRhdGEsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9BeGlvc1JlcXVlc3QoJ3BhdGNoJywgdXJsLCBkYXRhLCB7IHBhcmFtcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGUgPSAodXJsLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQXhpb3NSZXF1ZXN0KCdkZWxldGUnLCB1cmwsIG51bGwsIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lcnJvckZyb21SZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGVycjtcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvckZyb21SZXNwb25zZShgU3RyZWFtIGVycm9yIEhUVFAgY29kZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLmNvZGUpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoYFN0cmVhbSBlcnJvciBjb2RlICR7cmVzcG9uc2UuZGF0YS5jb2RlfTogJHtyZXNwb25zZS5kYXRhLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSByZXNwb25zZS5kYXRhLmNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnIucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIGVyci5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIGlmIChpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvckZyb21SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnJlY2VpdmVkX2F0KVxuICAgICAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVkX2F0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBEaXNwYXRjaGluZyBldmVudDogJHtldmVudC50eXBlfWAsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gY2FsbCBnZW5lcmljIGxpc3RlbmVyc1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycy5hbGwgfHwgW10pIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxsIHR5cGUgc3BlY2lmaWMgbGlzdGVuZXJzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzW2V2ZW50LnR5cGVdIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy51c2VySUQgfHwgIXRoaXMuX3VzZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ2FsbCBjb25uZWN0VXNlciBvciBjb25uZWN0QW5vbnltb3VzVXNlciBiZWZvcmUgc3RhcnRpbmcgdGhlIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy53c0Jhc2VVUkwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignV2Vic29ja2V0IGJhc2UgdXJsIG5vdCBzZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jbGllbnRJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdjbGllbnRJRCBpcyBub3Qgc2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMud3NDb25uZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy53YXJtVXAgfHwgdGhpcy5vcHRpb25zLmVuYWJsZUluc2lnaHRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NheUhpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgU3RhYmxlV1NDb25uZWN0aW9uIGhhbmRsZXMgYWxsIHRoZSByZWNvbm5lY3Rpb24gbG9naWMuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLndzQ29ubmVjdGlvbiAmJiB0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGF2b2lkaW5nIGFkZGluZyB0cyBnZW5lcmljcyBvbiB3c0Nvbm5lY3Rpb24gaW4gb3B0aW9ucyBzaW5jZSBpdHMgb25seSB1c2VmdWwgZm9yIHVuaXQgdGVzdCBwdXJwb3NlLlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy53c0Nvbm5lY3Rpb24uc2V0Q2xpZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMud3NDb25uZWN0aW9uID0gdGhpcy5vcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIC53c0Nvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLndzQ29ubmVjdGlvbiA9IG5ldyBTdGFibGVXU0Nvbm5lY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGZhbGxiYWNrIGlzIHVzZWQgYmVmb3JlLCBjb250aW51ZSB1c2luZyBpdCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIFdTIHRvIGZhaWxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53c0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndzRmFsbGJhY2suY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsICdTdHJlYW1DbGllbnQuY29ubmVjdDogdGhpcy53c0Nvbm5lY3Rpb24uY29ubmVjdCgpJyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgV1NGYWxsYmFjayBpcyBlbmFibGVkLCB3cyBjb25uZWN0IHNob3VsZCB0aW1lb3V0IGZhc3RlciBzbyBmYWxsYmFjayBjYW4gdHJ5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud3NDb25uZWN0aW9uLmNvbm5lY3QodGhpcy5vcHRpb25zLmVuYWJsZVdTRmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmRlZmF1bHRXU1RpbWVvdXRXaXRoRmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmRlZmF1bHRXU1RpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIHJ1biBmYWxsYmFjayBvbmx5IGlmIGl0J3MgV1MvTmV0d29yayBlcnJvciBhbmQgbm90IGEgbm9ybWFsIEFQSSBlcnJvclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBicm93c2VyIGlzIG9ubGluZSBiZWZvcmUgZXZlbiB0cnlpbmcgdGhlIGxvbmdwb2xsXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVXU0ZhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgaXNXU0ZhaWx1cmUoZXJyKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc09ubGluZSh0aGlzLmxvZ2dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnY2xpZW50OmNvbm5lY3QoKSAtIFdTIGZhaWxlZCwgZmFsbGJhY2sgdG8gbG9uZ3BvbGwnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogJ3RyYW5zcG9ydC5jaGFuZ2VkJywgbW9kZTogJ2xvbmdwb2xsJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53c0Nvbm5lY3Rpb24uX2Rlc3Ryb3lDdXJyZW50V1NDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3NDb25uZWN0aW9uLmRpc2Nvbm5lY3QoKS50aGVuKCk7IC8vIGNsb3NlIFdTIHNvIG5vIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3NGYWxsYmFjayA9IG5ldyBXU0Nvbm5lY3Rpb25GYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMud3NGYWxsYmFjay5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHRoZSBjb25uZWN0aXZpdHkgd2l0aCBzZXJ2ZXIgZm9yIHdhcm11cCBwdXJwb3NlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2F5SGkgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRfcmVxdWVzdF9pZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IEF4aW9zSGVhZGVycy5mcm9tKHtcbiAgICAgICAgICAgICAgICAgICAgJ3gtY2xpZW50LXJlcXVlc3QtaWQnOiBjbGllbnRfcmVxdWVzdF9pZCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRvQXhpb3NSZXF1ZXN0KCdnZXQnLCB0aGlzLmJhc2VVUkwgKyAnL2hpJywgbnVsbCwgb3B0cykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUluc2lnaHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RJbnNpZ2h0cygnaHR0cF9oaV9mYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlfa2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9yZXF1ZXN0X2lkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRVc2VyQWdlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gXCIwLjYuMTBcIiA7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudXNlckFnZW50IHx8XG4gICAgICAgICAgICAgICAgYHN0cmVhbS12aWRlby1qYXZhc2NyaXB0LWNsaWVudC0ke3RoaXMubm9kZSA/ICdub2RlJyA6ICdicm93c2VyJ30tJHt2ZXJzaW9ufWApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFVzZXJBZ2VudCA9ICh1c2VyQWdlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXNlckFnZW50ID0gdXNlckFnZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogX2lzVXNpbmdTZXJ2ZXJBdXRoIC0gUmV0dXJucyB0cnVlIGlmIHdlJ3JlIHVzaW5nIHNlcnZlciBzaWRlIGF1dGhcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzVXNpbmdTZXJ2ZXJBdXRoID0gKCkgPT4gISF0aGlzLnNlY3JldDtcbiAgICAgICAgdGhpcy5fZW5yaWNoQXhpb3NPcHRpb25zID0gKG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IG9wdGlvbnMucHVibGljRW5kcG9pbnQgJiYgIXRoaXMudXNlciA/IHVuZGVmaW5lZCA6IHRoaXMuX2dldFRva2VuKCk7XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gdG9rZW4gPyB7IEF1dGhvcml6YXRpb246IHRva2VuIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgc2lnbmFsID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRSZXF1ZXN0QWJvcnRDb250cm9sbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsID0gdGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycz8uWyd4LWNsaWVudC1yZXF1ZXN0LWlkJ10pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgJ3gtY2xpZW50LXJlcXVlc3QtaWQnOiByYW5kb21JZCgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICB1c2VyX2lkOiB0aGlzLnVzZXJJRCxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbl9pZDogdGhpcy5fZ2V0Q29ubmVjdGlvbklEKCksXG4gICAgICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS1hdXRoLXR5cGUnOiBvcHRpb25zLnB1YmxpY0VuZHBvaW50ICYmICF0aGlzLnVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ2Fub255bW91cydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5nZXRBdXRoVHlwZSgpLFxuICAgICAgICAgICAgICAgICAgICAnWC1TdHJlYW0tQ2xpZW50JzogdGhpcy5nZXRVc2VyQWdlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uKHNpZ25hbCA/IHsgc2lnbmFsIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5jb25maWcsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmF4aW9zUmVxdWVzdENvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2dldFRva2VuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRva2VuTWFuYWdlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuTWFuYWdlci5nZXRUb2tlbigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogZW5jb2RlIHdzIHVybCBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zIGpzb24gc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idWlsZFdTUGF5bG9hZCA9IChjbGllbnRfcmVxdWVzdF9pZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiB0aGlzLnVzZXJJRCxcbiAgICAgICAgICAgICAgICB1c2VyX2RldGFpbHM6IHRoaXMuX3VzZXIsXG4gICAgICAgICAgICAgICAgY2xpZW50X3JlcXVlc3RfaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNyZWF0ZXMgYW4gYWJvcnQgY29udHJvbGxlciB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgbmV4dCBIVFRQIFJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUFib3J0Q29udHJvbGxlckZvck5leHRSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5leHRSZXF1ZXN0QWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNyZWF0ZVRva2VuIC0gQ3JlYXRlcyBhIHRva2VuIHRvIGF1dGhlbnRpY2F0ZSB0aGlzIHVzZXIuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgICogVGhlIHJlc3VsdGluZyB0b2tlbiBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBjbGllbnQgc2lkZSB3aGVuIHRoZSB1c2VycyByZWdpc3RlcnMgb3IgbG9ncyBpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCBUaGUgVXNlcldpdGhJZCBJRFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2V4cF0gVGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRva2VuIGV4cHJlc3NlZCBpbiB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoXG4gICAgICAgICAqIEBwYXJhbSBjYWxsX2NpZHMgZm9yIGFub255bW91cyB0b2tlbnMgeW91IGhhdmUgdG8gcHJvdmlkZSB0aGUgY2FsbCBjaWRzIHRoZSB1c2UgY2FuIGpvaW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIGEgdG9rZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlVG9rZW4gPSAodXNlcklELCBleHAsIGlhdCwgY2FsbF9jaWRzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWNyZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGB0b2tlbnMgY2FuIG9ubHkgYmUgY3JlYXRlZCBzZXJ2ZXItc2lkZSB1c2luZyB0aGUgQVBJIFNlY3JldGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB7fTtcbiAgICAgICAgICAgIGlmIChleHApIHtcbiAgICAgICAgICAgICAgICBleHRyYS5leHAgPSBleHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWF0KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuaWF0ID0gaWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxfY2lkcykge1xuICAgICAgICAgICAgICAgIGV4dHJhLmNhbGxfY2lkcyA9IGNhbGxfY2lkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXJJRCwgZXh0cmEsIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IHRoZSBrZXlcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIC8vIHNldCB0aGUgc2VjcmV0XG4gICAgICAgIHRoaXMuc2VjcmV0ID0gb3B0aW9ucz8uc2VjcmV0O1xuICAgICAgICAvLyBzZXQgdGhlIG9wdGlvbnMuLi4gYW5kIGZpZ3VyZSBvdXQgZGVmYXVsdHMuLi5cbiAgICAgICAgY29uc3QgaW5wdXRPcHRpb25zID0gb3B0aW9uc1xuICAgICAgICAgICAgPyBvcHRpb25zXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBicm93c2VyOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuYnJvd3NlciA9IGlucHV0T3B0aW9ucy5icm93c2VyIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB0aGlzLm5vZGUgPSAhdGhpcy5icm93c2VyO1xuICAgICAgICBpZiAodGhpcy5icm93c2VyKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uSGludCA9IGdldExvY2F0aW9uSGludChvcHRpb25zPy5sb2NhdGlvbkhpbnRVcmwsIG9wdGlvbnM/LmxvY2F0aW9uSGludFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLCAvLyBtYWtpbmcgc3VyZSBjb29raWVzIGFyZSBub3Qgc2VudFxuICAgICAgICAgICAgd2FybVVwOiBmYWxzZSxcbiAgICAgICAgICAgIC4uLmlucHV0T3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMubm9kZSAmJiAhdGhpcy5vcHRpb25zLmh0dHBzQWdlbnQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5odHRwc0FnZW50ID0gbmV3IGh0dHBzLkFnZW50KHtcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAga2VlcEFsaXZlTXNlY3M6IDMwMDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEJhc2VVUkwodGhpcy5vcHRpb25zLmJhc2VVUkwgfHwgJ2h0dHBzOi8vdmlkZW8uc3RyZWFtLWlvLWFwaS5jb20vdmlkZW8nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5TVFJFQU1fTE9DQUxfVEVTVF9SVU4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QmFzZVVSTCgnaHR0cDovL2xvY2FsaG9zdDozMDMwL3ZpZGVvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5TVFJFQU1fTE9DQUxfVEVTVF9IT1NUKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJhc2VVUkwoYGh0dHA6Ly8ke3Byb2Nlc3MuZW52LlNUUkVBTV9MT0NBTF9URVNUX0hPU1R9L3ZpZGVvYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5heGlvc0luc3RhbmNlID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGJhc2VVUkw6IHRoaXMuYmFzZVVSTCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdTIGNvbm5lY3Rpb24gaXMgaW5pdGlhbGl6ZWQgd2hlbiBzZXRVc2VyIGlzIGNhbGxlZFxuICAgICAgICB0aGlzLndzQ29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMud3NQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRVc2VyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8vIG1hcHBpbmcgYmV0d2VlbiBjaGFubmVsIGdyb3VwcyBhbmQgY29uZmlnc1xuICAgICAgICB0aGlzLmFub255bW91cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZSA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnM/LnBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZTtcbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZXJ2ZXItc2lkZSBjbGllbnQsIHRoZW4gbGV0cyBpbml0aWFsaXplIHRoZSB0b2tlbk1hbmFnZXIsIHNpbmNlIHRva2VuIHdpbGwgYmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZyb20gc2VjcmV0LlxuICAgICAgICB0aGlzLnRva2VuTWFuYWdlciA9IG5ldyBUb2tlbk1hbmFnZXIodGhpcy5zZWNyZXQpO1xuICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICB0aGlzLmluc2lnaHRNZXRyaWNzID0gbmV3IEluc2lnaHRNZXRyaWNzKCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFdTVGltZW91dFdpdGhGYWxsYmFjayA9IDYwMDA7XG4gICAgICAgIHRoaXMuZGVmYXVsdFdTVGltZW91dCA9IDE1MDAwO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGlzRnVuY3Rpb24oaW5wdXRPcHRpb25zLmxvZ2dlcilcbiAgICAgICAgICAgID8gaW5wdXRPcHRpb25zLmxvZ2dlclxuICAgICAgICAgICAgOiAoKSA9PiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGBTdHJlYW1WaWRlb0NsaWVudGAgaW5zdGFuY2UgbGV0cyB5b3UgY29tbXVuaWNhdGUgd2l0aCBvdXIgQVBJLCBhbmQgYXV0aGVudGljYXRlIHVzZXJzLlxuICovXG5jbGFzcyBTdHJlYW1WaWRlb0NsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYXBpS2V5T3JBcmdzLCBvcHRzKSB7XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSAnd2Fybic7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1RvVW5yZWdpc3RlciA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzY29ubmVjdHMgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgdXNlciBmcm9tIHRoZSBjbGllbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBkaXNjb25uZWN0ZWQsIHRoZSBjb25uZWN0ZWQgdXNlciBbc3RhdGUgdmFyaWFibGVdKCNyZWFkb25seXN0YXRlc3RvcmUpIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdGltZW91dCBNYXggbnVtYmVyIG9mIG1zLCB0byB3YWl0IGZvciBjbG9zZSBldmVudCBvZiB3ZWJzb2NrZXQsIGJlZm9yZSBmb3JjZWZ1bGx5IGFzc3VtaW5nIHN1Y2Nlc3NmdWwgZGlzY29ubmVjdGlvbi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFVzZXIgPSBhc3luYyAodGltZW91dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0cmVhbUNsaWVudC51c2VyICYmICF0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlzY29ubmVjdFVzZXIgPSAoKSA9PiB0aGlzLnN0cmVhbUNsaWVudC5kaXNjb25uZWN0VXNlcih0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdGlvblByb21pc2UgPSB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4gZGlzY29ubmVjdFVzZXIoKSlcbiAgICAgICAgICAgICAgICA6IGRpc2Nvbm5lY3RVc2VyKCk7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlLmZpbmFsbHkoKCkgPT4gKHRoaXMuZGlzY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdGlvblByb21pc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIuZm9yRWFjaCgodW5yZWdpc3RlcikgPT4gdW5yZWdpc3RlcigpKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1RvVW5yZWdpc3RlciA9IFtdO1xuICAgICAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnNldENvbm5lY3RlZFVzZXIodW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gc3Vic2NyaWJlIHRvIFdlYlNvY2tldCBldmVudHMgcHJvdmlkZWQgYnkgdGhlIEFQSS5cbiAgICAgICAgICogVG8gcmVtb3ZlIGEgc3Vic2NyaXB0aW9uLCBjYWxsIHRoZSBgb2ZmYCBtZXRob2Qgb3IsIGV4ZWN1dGUgdGhlIHJldHVybmVkIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHN1YnNjcmliaW5nIHRvIFdlYlNvY2tldCBldmVudHMgaXMgYW4gYWR2YW5jZWQgdXNlLWNhc2UsIGZvciBtb3N0IHVzZS1jYXNlcyBpdCBzaG91bGQgYmUgZW5vdWdoIHRvIHdhdGNoIGZvciBjaGFuZ2VzIGluIHRoZSByZWFjdGl2ZSBbc3RhdGUgc3RvcmVdKCNyZWFkb25seXN0YXRlc3RvcmUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHRoZSBldmVudCBuYW1lIG9yICdhbGwnLlxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbiA9IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgc3Vic2NyaXB0aW9uIGZvciBXZWJTb2NrZXQgZXZlbnRzIHRoYXQgd2VyZSBjcmVhdGVkIGJ5IHRoZSBgb25gIG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB0aGUgZXZlbnQgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayB3aGljaCB3YXMgcGFzc2VkIHRvIHRoZSBgb25gIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2ZmID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKiBAcGFyYW0gaWQgdGhlIGlkIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxsID0gKHR5cGUsIGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbGwoe1xuICAgICAgICAgICAgICAgIHN0cmVhbUNsaWVudDogdGhpcy5zdHJlYW1DbGllbnQsXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgY2xpZW50U3RvcmU6IHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBndWVzdCB1c2VyIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgZ3Vlc3QgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlR3Vlc3RVc2VyID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5kb0F4aW9zUmVxdWVzdCgncG9zdCcsICcvZ3Vlc3QnLCBkYXRhLCB7IHB1YmxpY0VuZHBvaW50OiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBxdWVyeSB0aGUgQVBJIGZvciBjYWxscyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgdGhlIHF1ZXJ5IGRhdGEuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnF1ZXJ5Q2FsbHMgPSBhc3luYyAoZGF0YSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoJy9jYWxscycsIGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgY2FsbHMgPSByZXNwb25zZS5jYWxscy5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsID0gbmV3IENhbGwoe1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW1DbGllbnQ6IHRoaXMuc3RyZWFtQ2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBpZDogYy5jYWxsLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjLmNhbGwudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyczogYy5tZW1iZXJzLFxuICAgICAgICAgICAgICAgICAgICBvd25DYXBhYmlsaXRpZXM6IGMub3duX2NhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hpbmc6IGRhdGEud2F0Y2gsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FsbC5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGMuY2FsbCk7XG4gICAgICAgICAgICAgICAgY2FsbC5hcHBseURldmljZUNvbmZpZygpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLndhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZS5yZWdpc3RlckNhbGwoY2FsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGNhbGxzOiBjYWxscyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgY2FsbCBzdGF0aXN0aWNzIHJlcG9ydHMgbWF0Y2hpbmcgYSBwYXJ0aWN1bGFyIGNvbmRpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgRmlsdGVyIGFuZCBzb3J0IGNvbmRpdGlvbnMgZm9yIHJldHJpZXZpbmcgYXZhaWxhYmxlIGNhbGwgcmVwb3J0IHN1bW1hcmllcy5cbiAgICAgICAgICogQHJldHVybnMgTGlzdCB3aXRoIHN1bW1hcnkgb2YgYXZhaWxhYmxlIGNhbGwgcmVwb3J0cyBtYXRjaGluZyB0aGUgY29uZGl0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeUNhbGxTdGF0cyA9IGFzeW5jIChkYXRhID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAvY2FsbC9zdGF0c2AsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIGRhdGEgY2VudGVycyBhdmFpbGFibGUgZm9yIGhvc3RpbmcgY2FsbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkZ2VzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmdldChgL2VkZ2VzYCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGREZXZpY2UgLSBBZGRzIGEgcHVzaCBkZXZpY2UgZm9yIGEgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBkZXZpY2UgaWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHB1c2hfcHJvdmlkZXIgdGhlIHB1c2ggcHJvdmlkZXIgbmFtZSAoZWcuIGFwbiwgZmlyZWJhc2UpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdXNoX3Byb3ZpZGVyX25hbWUgdXNlciBwcm92aWRlZCBwdXNoIHByb3ZpZGVyIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VySURdIHRoZSB1c2VyIGlkIChkZWZhdWx0cyB0byBjdXJyZW50IHVzZXIpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZvaXBfdG9rZW5dIGVuYWJsZXMgdXNlIG9mIFZvSVAgdG9rZW4gZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBvbiBpT1MgcGxhdGZvcm1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkRGV2aWNlID0gYXN5bmMgKGlkLCBwdXNoX3Byb3ZpZGVyLCBwdXNoX3Byb3ZpZGVyX25hbWUsIHVzZXJJRCwgdm9pcF90b2tlbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoJy9kZXZpY2VzJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHB1c2hfcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgdm9pcF90b2tlbixcbiAgICAgICAgICAgICAgICAuLi4odXNlcklEICE9IG51bGwgPyB7IHVzZXJfaWQ6IHVzZXJJRCB9IDoge30pLFxuICAgICAgICAgICAgICAgIC4uLihwdXNoX3Byb3ZpZGVyX25hbWUgIT0gbnVsbCA/IHsgcHVzaF9wcm92aWRlcl9uYW1lIH0gOiB7fSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldERldmljZXMgLSBSZXR1cm5zIHRoZSBkZXZpY2VzIGFzc29jaWF0ZWQgd2l0aCBhIGN1cnJlbnQgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJJRF0gVXNlciBJRC4gT25seSB3b3JrcyBvbiBzZXJ2ZXJzaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldERldmljZXMgPSBhc3luYyAodXNlcklEKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdHJlYW1DbGllbnQuZ2V0KCcvZGV2aWNlcycsIHVzZXJJRCA/IHsgdXNlcl9pZDogdXNlcklEIH0gOiB7fSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmVEZXZpY2UgLSBSZW1vdmVzIHRoZSBkZXZpY2Ugd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgZGV2aWNlIGlkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcklEXSBUaGUgdXNlciBpZC4gT25seSBzcGVjaWZ5IHRoaXMgZm9yIHNlcnZlcnNpZGUgcmVxdWVzdHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlRGV2aWNlID0gYXN5bmMgKGlkLCB1c2VySUQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5kZWxldGUoJy9kZXZpY2VzJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIC4uLih1c2VySUQgPyB7IHVzZXJfaWQ6IHVzZXJJRCB9IDoge30pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHJpbmdpbmcgY2FsbHMgZnJvbSBwdXNoIG5vdGlmaWNhdGlvbnMuIElmIHRoZSBjYWxsIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsX2NpZFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblJpbmdpbmdDYWxsID0gYXN5bmMgKGNhbGxfY2lkKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIHRoZSBjYWxsIGFuZCBpcyBhbHJlYWR5IHJpbmdpbmcsIHdlIGRvbid0IG5lZWQgdG8gY3JlYXRlIGEgbmV3IGNhbGxcbiAgICAgICAgICAgIC8vIGFzIGNsaWVudCB3b3VsZCBoYXZlIHJlY2VpdmVkIHRoZSBjYWxsLnJpbmcgc3RhdGUgYmVjYXVzZSB0aGUgYXBwIGhhZCBXUyBhbGl2ZSB3aGVuIHJlY2VpdmluZyBwdXNoIG5vdGlmaWNhdGlvbnNcbiAgICAgICAgICAgIGxldCBjYWxsID0gdGhpcy5yZWFkT25seVN0YXRlU3RvcmUuY2FsbHMuZmluZCgoYykgPT4gYy5jaWQgPT09IGNhbGxfY2lkICYmIGMucmluZ2luZyk7XG4gICAgICAgICAgICBpZiAoIWNhbGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgaXQgbWVhbnMgdGhhdCBXUyBpcyBub3QgYWxpdmUgd2hlbiByZWNlaXZpbmcgdGhlIHB1c2ggbm90aWZpY2F0aW9ucyBhbmQgd2UgbmVlZCB0byBmZXRjaCB0aGUgY2FsbFxuICAgICAgICAgICAgICAgIGNvbnN0IFtjYWxsVHlwZSwgY2FsbElkXSA9IGNhbGxfY2lkLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgY2FsbCA9IG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtQ2xpZW50OiB0aGlzLnN0cmVhbUNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY2FsbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHJpbmdpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbC5nZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29ubmVjdHMgdGhlIGdpdmVuIGFub255bW91cyB1c2VyIHRvIHRoZSBjbGllbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2VyIHRoZSB1c2VyIHRvIGNvbm5lY3QuXG4gICAgICAgICAqIEBwYXJhbSB0b2tlbk9yUHJvdmlkZXIgYSB0b2tlbiBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRva2VuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0QW5vbnltb3VzVXNlciA9IGFzeW5jICh1c2VyLCB0b2tlbk9yUHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RBbm9ueW1vdXNVc2VyID0gKCkgPT4gdGhpcy5zdHJlYW1DbGllbnQuY29ubmVjdEFub255bW91c1VzZXIodXNlciwgdG9rZW5PclByb3ZpZGVyKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4gY29ubmVjdEFub255bW91c1VzZXIoKSlcbiAgICAgICAgICAgICAgICA6IGNvbm5lY3RBbm9ueW1vdXNVc2VyKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLmZpbmFsbHkoKCkgPT4gKHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbG9nZ2VyID0gbG9nVG9Db25zb2xlO1xuICAgICAgICBsZXQgbG9nTGV2ZWwgPSAnd2Fybic7XG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5T3JBcmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbG9nTGV2ZWwgPSBvcHRzPy5sb2dMZXZlbCB8fCBsb2dMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlciA9IG9wdHM/LmxvZ2dlciB8fCBsb2dnZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMZXZlbCA9IGFwaUtleU9yQXJncy5vcHRpb25zPy5sb2dMZXZlbCB8fCBsb2dMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlciA9IGFwaUtleU9yQXJncy5vcHRpb25zPy5sb2dnZXIgfHwgbG9nZ2VyO1xuICAgICAgICB9XG4gICAgICAgIHNldExvZ2dlcihsb2dnZXIsIGxvZ0xldmVsKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydjbGllbnQnXSk7XG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5T3JBcmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBuZXcgU3RyZWFtQ2xpZW50KGFwaUtleU9yQXJncywge1xuICAgICAgICAgICAgICAgIHBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50ID0gbmV3IFN0cmVhbUNsaWVudChhcGlLZXlPckFyZ3MuYXBpS2V5LCB7XG4gICAgICAgICAgICAgICAgcGVyc2lzdFVzZXJPbkNvbm5lY3Rpb25GYWlsdXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLmFwaUtleU9yQXJncy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNka0luZm8gPSBnZXRTZGtJbmZvKCk7XG4gICAgICAgICAgICBpZiAoc2RrSW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50LnNldFVzZXJBZ2VudCh0aGlzLnN0cmVhbUNsaWVudC5nZXRVc2VyQWdlbnQoKSArXG4gICAgICAgICAgICAgICAgICAgIGAtdmlkZW8tJHtTZGtUeXBlW3Nka0luZm8udHlwZV0udG9Mb3dlckNhc2UoKX0tc2RrLSR7c2RrSW5mby5tYWpvcn0uJHtzZGtJbmZvLm1pbm9yfS4ke3Nka0luZm8ucGF0Y2h9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlID0gbmV3IFN0cmVhbVZpZGVvV3JpdGVhYmxlU3RhdGVTdG9yZSgpO1xuICAgICAgICB0aGlzLnJlYWRPbmx5U3RhdGVTdG9yZSA9IG5ldyBTdHJlYW1WaWRlb1JlYWRPbmx5U3RhdGVTdG9yZSh0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUpO1xuICAgICAgICBpZiAodHlwZW9mIGFwaUtleU9yQXJncyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhcGlLZXlPckFyZ3MudXNlcjtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYXBpS2V5T3JBcmdzLnRva2VuIHx8IGFwaUtleU9yQXJncy50b2tlblByb3ZpZGVyO1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RVc2VyKHVzZXIsIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJlYWN0aXZlIHN0YXRlIHN0b3JlLCB1c2UgdGhpcyBpZiB5b3Ugd2FudCB0byBiZSBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvIHRoZSBjbGllbnQgc3RhdGVcbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRPbmx5U3RhdGVTdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdGhlIGdpdmVuIHVzZXIgdG8gdGhlIGNsaWVudC5cbiAgICAgKiBPbmx5IG9uZSB1c2VyIGNhbiBjb25uZWN0IGF0IGEgdGltZSwgaWYgeW91IHdhbnQgdG8gY2hhbmdlIHVzZXJzLCBjYWxsIGBkaXNjb25uZWN0VXNlcmAgYmVmb3JlIGNvbm5lY3RpbmcgYSBuZXcgdXNlci5cbiAgICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgY29ubmVjdGVkIHVzZXIgW3N0YXRlIHZhcmlhYmxlXSgjcmVhZG9ubHlzdGF0ZXN0b3JlKSB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciB0aGUgdXNlciB0byBjb25uZWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbiBhIHRva2VuIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdFVzZXIodXNlciwgdG9rZW4pIHtcbiAgICAgICAgaWYgKHVzZXIudHlwZSA9PT0gJ2Fub255bW91cycpIHtcbiAgICAgICAgICAgIHVzZXIuaWQgPSAnIWFub24nO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEFub255bW91c1VzZXIodXNlciwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb25uZWN0VXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5jb25uZWN0VXNlcih1c2VyLCB0b2tlbik7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1c2VyLnR5cGUgPT09ICdndWVzdCcpIHtcbiAgICAgICAgICAgIGNvbm5lY3RVc2VyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5jb25uZWN0R3Vlc3RVc2VyKHVzZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZVxuICAgICAgICAgICAgPyB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4gY29ubmVjdFVzZXIoKSlcbiAgICAgICAgICAgIDogY29ubmVjdFVzZXIoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZT8uZmluYWxseSgoKSA9PiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZCkpO1xuICAgICAgICBjb25zdCBjb25uZWN0VXNlclJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgICAgICAgLy8gY29ubmVjdFVzZXJSZXNwb25zZSB3aWxsIGJlIHZvaWQgaWYgY29ubmVjdFVzZXIgY2FsbGVkIHR3aWNlIGZvciB0aGUgc2FtZSB1c2VyXG4gICAgICAgIGlmIChjb25uZWN0VXNlclJlc3BvbnNlPy5tZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnNldENvbm5lY3RlZFVzZXIoY29ubmVjdFVzZXJSZXNwb25zZS5tZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyLnB1c2godGhpcy5vbignY29ubmVjdGlvbi5jaGFuZ2VkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQub25saW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbHNUb1JlV2F0Y2ggPSB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUuY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoY2FsbCkgPT4gY2FsbC53YXRjaGluZylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoY2FsbCkgPT4gY2FsbC5jaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYFJld2F0Y2hpbmcgY2FsbHMgYWZ0ZXIgY29ubmVjdGlvbiBjaGFuZ2VkICR7Y2FsbHNUb1JlV2F0Y2guam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbHNUb1JlV2F0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5Q2FsbHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfY29uZGl0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpZDogeyAkaW46IGNhbGxzVG9SZVdhdGNoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydDogW3sgZmllbGQ6ICdjaWQnLCBkaXJlY3Rpb246IDEgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gcmUtd2F0Y2ggY2FsbHMnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyLnB1c2godGhpcy5vbignY2FsbC5jcmVhdGVkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGwsIG1lbWJlcnMgfSA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKHVzZXIuaWQgPT09IGNhbGwuY3JlYXRlZF9ieS5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ1JlY2VpdmVkIGBjYWxsLmNyZWF0ZWRgIHNlbnQgYnkgdGhlIGN1cnJlbnQgdXNlcicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYE5ldyBjYWxsIGNyZWF0ZWQgYW5kIHJlZ2lzdGVyZWQ6ICR7Y2FsbC5jaWR9YCk7XG4gICAgICAgICAgICBjb25zdCBuZXdDYWxsID0gbmV3IENhbGwoe1xuICAgICAgICAgICAgICAgIHN0cmVhbUNsaWVudDogdGhpcy5zdHJlYW1DbGllbnQsXG4gICAgICAgICAgICAgICAgdHlwZTogY2FsbC50eXBlLFxuICAgICAgICAgICAgICAgIGlkOiBjYWxsLmlkLFxuICAgICAgICAgICAgICAgIG1lbWJlcnMsXG4gICAgICAgICAgICAgICAgY2xpZW50U3RvcmU6IHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3Q2FsbC5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGNhbGwpO1xuICAgICAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnJlZ2lzdGVyQ2FsbChuZXdDYWxsKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIucHVzaCh0aGlzLm9uKCdjYWxsLnJpbmcnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FsbCwgbWVtYmVycyB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBpZiAodXNlci5pZCA9PT0gY2FsbC5jcmVhdGVkX2J5LmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgJ1JlY2VpdmVkIGBjYWxsLnJpbmdgIHNlbnQgYnkgdGhlIGN1cnJlbnQgdXNlciBzbyBpZ25vcmluZyB0aGUgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY2FsbCBtaWdodCBhbHJlYWR5IGJlIHRyYWNrZWQgYnkgdGhlIGNsaWVudCxcbiAgICAgICAgICAgIC8vIGlmIGBjYWxsLmNyZWF0ZWRgIHdhcyByZWNlaXZlZCBiZWZvcmUgYGNhbGwucmluZ2AuXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIGNsZWFudXAgdGhlIGFscmVhZHkgdHJhY2tlZCBjYWxsLlxuICAgICAgICAgICAgY29uc3QgcHJldkNhbGwgPSB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUuZmluZENhbGwoY2FsbC50eXBlLCBjYWxsLmlkKTtcbiAgICAgICAgICAgIGF3YWl0IHByZXZDYWxsPy5sZWF2ZSh7IHJlYXNvbjogJ2NsZWFuaW5nLXVwIGluIGNhbGwucmluZycgfSk7XG4gICAgICAgICAgICAvLyB3ZSBjcmVhdGUgYSBuZXcgY2FsbFxuICAgICAgICAgICAgY29uc3QgdGhlQ2FsbCA9IG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICBzdHJlYW1DbGllbnQ6IHRoaXMuc3RyZWFtQ2xpZW50LFxuICAgICAgICAgICAgICAgIHR5cGU6IGNhbGwudHlwZSxcbiAgICAgICAgICAgICAgICBpZDogY2FsbC5pZCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzLFxuICAgICAgICAgICAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgICAgICAgICAgICAgcmluZ2luZzogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhlQ2FsbC5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGNhbGwpO1xuICAgICAgICAgICAgLy8gd2UgZmV0Y2ggdGhlIGxhdGVzdCBtZXRhZGF0YSBmb3IgdGhlIGNhbGwgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICBhd2FpdCB0aGVDYWxsLmdldCgpO1xuICAgICAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnJlZ2lzdGVyQ2FsbCh0aGVDYWxsKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gY29ubmVjdFVzZXJSZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWRkRGV2aWNlIC0gQWRkcyBhIHB1c2ggZGV2aWNlIGZvciBhIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGRldmljZSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdXNoX3Byb3ZpZGVyIHRoZSBwdXNoIHByb3ZpZGVyIG5hbWUgKGVnLiBhcG4sIGZpcmViYXNlKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdXNoX3Byb3ZpZGVyX25hbWUgdXNlciBwcm92aWRlZCBwdXNoIHByb3ZpZGVyIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJJRF0gdGhlIHVzZXIgaWQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgdXNlcilcbiAgICAgKi9cbiAgICBhc3luYyBhZGRWb2lwRGV2aWNlKGlkLCBwdXNoX3Byb3ZpZGVyLCBwdXNoX3Byb3ZpZGVyX25hbWUsIHVzZXJJRCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGREZXZpY2UoaWQsIHB1c2hfcHJvdmlkZXIsIHB1c2hfcHJvdmlkZXJfbmFtZSwgdXNlcklELCB0cnVlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSB0aGUgYEBzdHJlYW0taW8vbm9kZS1zZGtgIHBhY2thZ2UgaW5zdGVhZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2V0c3RyZWFtLmlvL3ZpZGVvL2RvY3MvYXBpL1xuICovXG5jbGFzcyBTdHJlYW1WaWRlb1NlcnZlckNsaWVudCBleHRlbmRzIFN0cmVhbVZpZGVvQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhcGlLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoeyBhcGlLZXksIG9wdGlvbnMgfSk7XG4gICAgICAgIHRoaXMuZ2V0Q2FsbFR5cGVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmdldCgnL2NhbGx0eXBlcycpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENhbGxUeXBlID0gKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQoYC9jYWxsdHlwZXMvJHtuYW1lfWApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbGxUeXBlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KCcvY2FsbHR5cGVzJywgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FsbFR5cGUgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmRlbGV0ZShgL2NhbGx0eXBlcy8ke25hbWV9YCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbFR5cGUgPSAobmFtZSwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnB1dChgL2NhbGx0eXBlcy8ke25hbWV9YCwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdEV4dGVybmFsU3RvcmFnZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQoJy9leHRlcm5hbF9zdG9yYWdlJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KCcvZXh0ZXJuYWxfc3RvcmFnZScsIHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZUV4dGVybmFsU3RvcmFnZSA9IChuYW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZGVsZXRlKGAvZXh0ZXJuYWxfc3RvcmFnZS8ke25hbWV9YCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZXJuYWxTdG9yYWdlID0gKG5hbWUsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wdXQoYC9leHRlcm5hbF9zdG9yYWdlLyR7bmFtZX1gLCByZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGVja0V4dGVybmFsU3RvcmFnZSA9IChuYW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZ2V0KGAvZXh0ZXJuYWxfc3RvcmFnZS8ke25hbWV9L2NoZWNrYCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNyZWF0ZVRva2VuIC0gQ3JlYXRlcyBhIHRva2VuIHRvIGF1dGhlbnRpY2F0ZSB0aGlzIHVzZXIuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBzZXJ2ZXIgc2lkZS5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIHRva2VuIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGNsaWVudCBzaWRlIHdoZW4gdGhlIHVzZXJzIHJlZ2lzdGVyIG9yIGxvZ3MgaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklEIFRoZSBVc2VyIElEXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtleHBdIFRoZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0b2tlbiBleHByZXNzZWQgaW4gdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaWF0XSBUaGUgdGltZXN0YW1wIHdoZW4gYSB0b2tlbiBoYXMgYmVlbiBpc3N1ZWRcbiAgICAgKiBAcGFyYW0gY2FsbF9jaWRzIGZvciBhbm9ueW1vdXMgdG9rZW5zIHlvdSBoYXZlIHRvIHByb3ZpZGUgdGhlIGNhbGwgY2lkcyB0aGUgdXNlIGNhbiBqb2luXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgYSB0b2tlblxuICAgICAqL1xuICAgIGNyZWF0ZVRva2VuKHVzZXJJRCwgZXhwLCBpYXQsIGNhbGxfY2lkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuY3JlYXRlVG9rZW4odXNlcklELCBleHAsIGlhdCwgY2FsbF9jaWRzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEF1ZGlvU2V0dGluZ3NEZWZhdWx0RGV2aWNlRW51bSwgQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSwgYnJvd3NlcnMgYXMgQnJvd3NlcnMsIENhbGwsIENhbGxTdGF0ZSwgQ2FsbFR5cGUsIENhbGxUeXBlcywgQ2FsbGluZ1N0YXRlLCBDYW1lcmFNYW5hZ2VyLCBDYW1lcmFNYW5hZ2VyU3RhdGUsIENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtLCBEZWJvdW5jZVR5cGUsIER5bmFzY2FsZU1hbmFnZXIsIEVycm9yRnJvbVJlc3BvbnNlLCBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlciwgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSwgTGF5b3V0U2V0dGluZ3NOYW1lRW51bSwgTGF5b3V0U2V0dGluZ3NSZXF1ZXN0TmFtZUVudW0sIE1pY3JvcGhvbmVNYW5hZ2VyLCBNaWNyb3Bob25lTWFuYWdlclN0YXRlLCBPd25DYXBhYmlsaXR5LCBSZWNvcmRTZXR0aW5nc1JlcXVlc3RNb2RlRW51bSwgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0UXVhbGl0eUVudW0sIHJ4VXRpbHMgYXMgUnhVdGlscywgU2NyZWVuU2hhcmVNYW5hZ2VyLCBTY3JlZW5TaGFyZVN0YXRlLCBldmVudHMgYXMgU2Z1RXZlbnRzLCBtb2RlbHMgYXMgU2Z1TW9kZWxzLCBTcGVha2VyTWFuYWdlciwgU3BlYWtlclN0YXRlLCBTdHJlYW1TZnVDbGllbnQsIFN0cmVhbVZpZGVvQ2xpZW50LCBTdHJlYW1WaWRlb1JlYWRPbmx5U3RhdGVTdG9yZSwgU3RyZWFtVmlkZW9TZXJ2ZXJDbGllbnQsIFN0cmVhbVZpZGVvV3JpdGVhYmxlU3RhdGVTdG9yZSwgVHJhbnNjcmlwdGlvblNldHRpbmdzTW9kZUVudW0sIFRyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSwgVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0sIFZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSwgVmlld3BvcnRUcmFja2VyLCBWaXNpYmlsaXR5U3RhdGUsIGNoZWNrSWZBdWRpb091dHB1dENoYW5nZVN1cHBvcnRlZCwgY29tYmluZUNvbXBhcmF0b3JzLCBjb25kaXRpb25hbCwgY3JlYXRlU291bmREZXRlY3RvciwgZGVmYXVsdFNvcnRQcmVzZXQsIGRlc2NlbmRpbmcsIGRldmljZUlkcyQsIGRpc3Bvc2VPZk1lZGlhU3RyZWFtLCBkb21pbmFudFNwZWFrZXIsIGdldEF1ZGlvRGV2aWNlcywgZ2V0QXVkaW9PdXRwdXREZXZpY2VzLCBnZXRBdWRpb1N0cmVhbSwgZ2V0Q2xpZW50RGV0YWlscywgZ2V0RGV2aWNlSW5mbywgZ2V0TG9nZ2VyLCBnZXRPU0luZm8sIGdldFNjcmVlblNoYXJlU3RyZWFtLCBnZXRTZGtJbmZvLCBnZXRWaWRlb0RldmljZXMsIGdldFZpZGVvU3RyZWFtLCBnZXRXZWJSVENJbmZvLCBsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0LCBsb2dMZXZlbHMsIGxvZ1RvQ29uc29sZSwgbmFtZSwgbm9vcENvbXBhcmF0b3IsIHBhZ2luYXRlZExheW91dFNvcnRQcmVzZXQsIHBpbm5lZCwgcHVibGlzaGluZ0F1ZGlvLCBwdWJsaXNoaW5nVmlkZW8sIHJlYWN0aW9uVHlwZSwgcm9sZSwgc2NyZWVuU2hhcmluZywgc2V0RGV2aWNlSW5mbywgc2V0TG9nTGV2ZWwsIHNldExvZ2dlciwgc2V0T1NJbmZvLCBzZXRTZGtJbmZvLCBzZXRXZWJSVENJbmZvLCBzcGVha2VyTGF5b3V0U29ydFByZXNldCwgc3BlYWtpbmcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1lc3NhZ2VUeXBlIiwiaXNKc29uT2JqZWN0IiwidHlwZW9mSnNvblZhbHVlIiwicmVmbGVjdGlvbk1lcmdlUGFydGlhbCIsIlVua25vd25GaWVsZEhhbmRsZXIiLCJXaXJlVHlwZSIsIlBiTG9uZyIsIlNlcnZpY2VUeXBlIiwic3RhY2tJbnRlcmNlcHQiLCJheGlvcyIsIkF4aW9zSGVhZGVycyIsIkF4aW9zRXJyb3IiLCJUd2lycEZldGNoVHJhbnNwb3J0IiwiUmVwbGF5U3ViamVjdCIsImNvbWJpbmVMYXRlc3QiLCJCZWhhdmlvclN1YmplY3QiLCJtYXAiLCJtYXAkMSIsInNoYXJlUmVwbGF5IiwiZGlzdGluY3RVbnRpbENoYW5nZWQiLCJ0YWtlV2hpbGUiLCJkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCIsIm1lcmdlIiwiZnJvbSIsIk9ic2VydmFibGUiLCJkZWJvdW5jZVRpbWUiLCJjb25jYXRNYXAiLCJwYWlyd2lzZSIsIm9mIiwiZmlsdGVyIiwiZGVib3VuY2UiLCJ0aW1lciIsIlNEUCIsIlVBUGFyc2VyIiwiV2ViU29ja2V0IiwiaHR0cHMiLCJqd3QiLCJmcm9tQnl0ZUFycmF5IiwiQXVkaW9TZXR0aW5nc0RlZmF1bHREZXZpY2VFbnVtIiwiU1BFQUtFUiIsIkVBUlBJRUNFIiwiQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSIsIkNyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtIiwiRklSRUJBU0UiLCJBUE4iLCJIVUFXRUkiLCJYSUFPTUkiLCJMYXlvdXRTZXR0aW5nc05hbWVFbnVtIiwiU1BPVExJR0hUIiwiR1JJRCIsIlNJTkdMRV9QQVJUSUNJUEFOVCIsIk1PQklMRSIsIkNVU1RPTSIsIkxheW91dFNldHRpbmdzUmVxdWVzdE5hbWVFbnVtIiwiT3duQ2FwYWJpbGl0eSIsIkJMT0NLX1VTRVJTIiwiQ1JFQVRFX0NBTEwiLCJDUkVBVEVfUkVBQ1RJT04iLCJFTkRfQ0FMTCIsIkpPSU5fQkFDS1NUQUdFIiwiSk9JTl9DQUxMIiwiSk9JTl9FTkRFRF9DQUxMIiwiTVVURV9VU0VSUyIsIlBJTl9GT1JfRVZFUllPTkUiLCJSRUFEX0NBTEwiLCJSRU1PVkVfQ0FMTF9NRU1CRVIiLCJTQ1JFRU5TSEFSRSIsIlNFTkRfQVVESU8iLCJTRU5EX1ZJREVPIiwiU1RBUlRfQlJPQURDQVNUX0NBTEwiLCJTVEFSVF9SRUNPUkRfQ0FMTCIsIlNUQVJUX1RSQU5TQ1JJUFRJT05fQ0FMTCIsIlNUT1BfQlJPQURDQVNUX0NBTEwiLCJTVE9QX1JFQ09SRF9DQUxMIiwiU1RPUF9UUkFOU0NSSVBUSU9OX0NBTEwiLCJVUERBVEVfQ0FMTCIsIlVQREFURV9DQUxMX01FTUJFUiIsIlVQREFURV9DQUxMX1BFUk1JU1NJT05TIiwiVVBEQVRFX0NBTExfU0VUVElOR1MiLCJSZWNvcmRTZXR0aW5nc1JlcXVlc3RNb2RlRW51bSIsIkFWQUlMQUJMRSIsIkRJU0FCTEVEIiwiQVVUT19PTiIsIlJlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtIiwiXzM2MFAiLCJfNDgwUCIsIl83MjBQIiwiXzEwODBQIiwiXzE0NDBQIiwiVHJhbnNjcmlwdGlvblNldHRpbmdzTW9kZUVudW0iLCJUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0iLCJWaWRlb1NldHRpbmdzQ2FtZXJhRmFjaW5nRW51bSIsIkZST05UIiwiQkFDSyIsIkVYVEVSTkFMIiwiVmlkZW9TZXR0aW5nc1JlcXVlc3RDYW1lcmFGYWNpbmdFbnVtIiwiRXJyb3JGcm9tUmVzcG9uc2UiLCJFcnJvciIsIk51bGxWYWx1ZSIsIlN0cnVjdCRUeXBlIiwiY29uc3RydWN0b3IiLCJubyIsIm5hbWUiLCJraW5kIiwiSyIsIlYiLCJUIiwiVmFsdWUiLCJpbnRlcm5hbEpzb25Xcml0ZSIsIm1lc3NhZ2UiLCJvcHRpb25zIiwianNvbiIsImsiLCJ2IiwiT2JqZWN0IiwiZW50cmllcyIsImZpZWxkcyIsInRvSnNvbiIsImludGVybmFsSnNvblJlYWQiLCJ0YXJnZXQiLCJnbG9iYWxUaGlzIiwidHlwZU5hbWUiLCJjcmVhdGUiLCJmcm9tSnNvbiIsInZhbHVlIiwibWVzc2FnZVByb3RvdHlwZSIsInVuZGVmaW5lZCIsImludGVybmFsQmluYXJ5UmVhZCIsInJlYWRlciIsImxlbmd0aCIsImVuZCIsInBvcyIsImZpZWxkTm8iLCJ3aXJlVHlwZSIsInRhZyIsImJpbmFyeVJlYWRNYXAxIiwidSIsInJlYWRVbmtub3duRmllbGQiLCJkIiwic2tpcCIsIm9uUmVhZCIsImxlbiIsInVpbnQzMiIsImtleSIsInZhbCIsInN0cmluZyIsImludGVybmFsQmluYXJ5V3JpdGUiLCJ3cml0ZXIiLCJrZXlzIiwiTGVuZ3RoRGVsaW1pdGVkIiwiZm9yayIsImpvaW4iLCJ3cml0ZVVua25vd25GaWVsZHMiLCJvbldyaXRlIiwiU3RydWN0IiwiVmFsdWUkVHlwZSIsIm9uZW9mIiwiTGlzdFZhbHVlIiwib25lb2ZLaW5kIiwiYm9vbFZhbHVlIiwibnVtYmVyVmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInN0cmluZ1ZhbHVlIiwibGlzdFZhbHVlRmllbGQiLCJmaW5kIiwiZiIsImxpc3RWYWx1ZSIsInN0cnVjdFZhbHVlRmllbGQiLCJzdHJ1Y3RWYWx1ZSIsIm51bGxWYWx1ZSIsIk5VTExfVkFMVUUiLCJBcnJheSIsImlzQXJyYXkiLCJpbnQzMiIsImRvdWJsZSIsImJvb2wiLCJWYXJpbnQiLCJCaXQ2NCIsIkxpc3RWYWx1ZSRUeXBlIiwicmVwZWF0IiwidmFsdWVzIiwicHVzaCIsImkiLCJUaW1lc3RhbXAkVHlwZSIsIm5vdyIsIm1zZyIsIm1zIiwiRGF0ZSIsInNlY29uZHMiLCJNYXRoIiwiZmxvb3IiLCJ0b1N0cmluZyIsIm5hbm9zIiwidG9EYXRlIiwidG9OdW1iZXIiLCJjZWlsIiwiZnJvbURhdGUiLCJkYXRlIiwiZ2V0VGltZSIsInBhcnNlIiwieiIsIm5hbm9zU3RyIiwic3Vic3RyaW5nIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwibWF0Y2hlcyIsIm1hdGNoIiwiaXNOYU4iLCJwYXJzZUludCIsImludDY0IiwiVGltZXN0YW1wIiwiUGVlclR5cGUiLCJDb25uZWN0aW9uUXVhbGl0eSIsIlZpZGVvUXVhbGl0eSIsIlRyYWNrVHlwZSIsIkVycm9yQ29kZSIsIlNka1R5cGUiLCJUcmFja1VucHVibGlzaFJlYXNvbiIsIkdvQXdheVJlYXNvbiIsIkNhbGxTdGF0ZSRUeXBlIiwiUGFydGljaXBhbnQiLCJQYXJ0aWNpcGFudENvdW50IiwiUGluIiwicGFydGljaXBhbnRzIiwicGlucyIsInN0YXJ0ZWRBdCIsInBhcnRpY2lwYW50Q291bnQiLCJDYWxsU3RhdGUkMSIsIlBhcnRpY2lwYW50Q291bnQkVHlwZSIsInRvdGFsIiwiYW5vbnltb3VzIiwiUGluJFR5cGUiLCJ1c2VySWQiLCJzZXNzaW9uSWQiLCJQYXJ0aWNpcGFudCRUeXBlIiwicHVibGlzaGVkVHJhY2tzIiwidHJhY2tMb29rdXBQcmVmaXgiLCJjb25uZWN0aW9uUXVhbGl0eSIsImlzU3BlYWtpbmciLCJpc0RvbWluYW50U3BlYWtlciIsImF1ZGlvTGV2ZWwiLCJpbWFnZSIsInJvbGVzIiwiZSIsImpvaW5lZEF0IiwiZmxvYXQiLCJjdXN0b20iLCJCaXQzMiIsIlN0cmVhbVF1YWxpdHkkVHlwZSIsInZpZGVvUXVhbGl0eSIsIlN0cmVhbVF1YWxpdHkiLCJWaWRlb0RpbWVuc2lvbiRUeXBlIiwid2lkdGgiLCJoZWlnaHQiLCJWaWRlb0RpbWVuc2lvbiIsIlZpZGVvTGF5ZXIkVHlwZSIsInJpZCIsImJpdHJhdGUiLCJmcHMiLCJxdWFsaXR5IiwidmlkZW9EaW1lbnNpb24iLCJWaWRlb0xheWVyIiwiQ29kZWMkVHlwZSIsInBheWxvYWRUeXBlIiwiZm10cExpbmUiLCJjbG9ja1JhdGUiLCJlbmNvZGluZ1BhcmFtZXRlcnMiLCJmZWVkYmFja3MiLCJDb2RlYyIsIklDRVRyaWNrbGUkVHlwZSQxIiwiSUNFVHJpY2tsZSRUeXBlIiwicGVlclR5cGUiLCJpY2VDYW5kaWRhdGUiLCJJQ0VUcmlja2xlJDEiLCJUcmFja0luZm8kVHlwZSIsInRyYWNrSWQiLCJ0cmFja1R5cGUiLCJsYXllcnMiLCJtaWQiLCJkdHgiLCJzdGVyZW8iLCJyZWQiLCJUcmFja0luZm8iLCJDYWxsJFR5cGUiLCJ0eXBlIiwiaWQiLCJjcmVhdGVkQnlVc2VySWQiLCJob3N0VXNlcklkIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiQ2FsbCQxIiwiRXJyb3IkVHlwZSQxIiwiRXJyb3IkVHlwZSIsImNvZGUiLCJzaG91bGRSZXRyeSIsIkVycm9yJDIiLCJDbGllbnREZXRhaWxzJFR5cGUiLCJTZGsiLCJPUyIsIkJyb3dzZXIiLCJEZXZpY2UiLCJzZGsiLCJvcyIsImJyb3dzZXIiLCJkZXZpY2UiLCJDbGllbnREZXRhaWxzIiwiU2RrJFR5cGUiLCJtYWpvciIsIm1pbm9yIiwicGF0Y2giLCJPUyRUeXBlIiwidmVyc2lvbiIsImFyY2hpdGVjdHVyZSIsIkJyb3dzZXIkVHlwZSIsIkRldmljZSRUeXBlIiwiQ2FsbEdyYW50cyRUeXBlIiwiY2FuUHVibGlzaEF1ZGlvIiwiY2FuUHVibGlzaFZpZGVvIiwiY2FuU2NyZWVuc2hhcmUiLCJDYWxsR3JhbnRzIiwibW9kZWxzIiwiZnJlZXplIiwiX19wcm90b19fIiwiQ2FsbCIsIkNhbGxTdGF0ZSIsIklDRVRyaWNrbGUiLCJTZW5kU3RhdHNSZXF1ZXN0JFR5cGUiLCJzdWJzY3JpYmVyU3RhdHMiLCJwdWJsaXNoZXJTdGF0cyIsIndlYnJ0Y1ZlcnNpb24iLCJzZGtWZXJzaW9uIiwiU2VuZFN0YXRzUmVxdWVzdCIsIlNlbmRTdGF0c1Jlc3BvbnNlJFR5cGUiLCJlcnJvciIsIlNlbmRTdGF0c1Jlc3BvbnNlIiwiSUNFUmVzdGFydFJlcXVlc3QkVHlwZSIsIklDRVJlc3RhcnRSZXF1ZXN0IiwiSUNFUmVzdGFydFJlc3BvbnNlJFR5cGUiLCJJQ0VSZXN0YXJ0UmVzcG9uc2UiLCJVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCRUeXBlIiwiVHJhY2tNdXRlU3RhdGUiLCJtdXRlU3RhdGVzIiwiVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QiLCJVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2UkVHlwZSIsIlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSIsIlRyYWNrTXV0ZVN0YXRlJFR5cGUiLCJtdXRlZCIsIkF1ZGlvTXV0ZUNoYW5nZWQkVHlwZSIsIlZpZGVvTXV0ZUNoYW5nZWQkVHlwZSIsIlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0JFR5cGUiLCJUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMiLCJ0cmFja3MiLCJVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCIsIlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSRUeXBlIiwiVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlIiwiVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzJFR5cGUiLCJkaW1lbnNpb24iLCJTZW5kQW5zd2VyUmVxdWVzdCRUeXBlIiwic2RwIiwiU2VuZEFuc3dlclJlcXVlc3QiLCJTZW5kQW5zd2VyUmVzcG9uc2UkVHlwZSIsIlNlbmRBbnN3ZXJSZXNwb25zZSIsIklDRVRyaWNrbGVSZXNwb25zZSRUeXBlIiwiSUNFVHJpY2tsZVJlc3BvbnNlIiwiU2V0UHVibGlzaGVyUmVxdWVzdCRUeXBlIiwiU2V0UHVibGlzaGVyUmVxdWVzdCIsIlNldFB1Ymxpc2hlclJlc3BvbnNlJFR5cGUiLCJpY2VSZXN0YXJ0IiwiU2V0UHVibGlzaGVyUmVzcG9uc2UiLCJTaWduYWxTZXJ2ZXIiLCJJIiwiTyIsIlZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5IiwiU2Z1RXZlbnQkVHlwZSIsIlN1YnNjcmliZXJPZmZlciIsIlB1Ymxpc2hlckFuc3dlciIsIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsIkF1ZGlvTGV2ZWxDaGFuZ2VkIiwiQ2hhbmdlUHVibGlzaFF1YWxpdHkiLCJQYXJ0aWNpcGFudEpvaW5lZCIsIlBhcnRpY2lwYW50TGVmdCIsIkRvbWluYW50U3BlYWtlckNoYW5nZWQiLCJKb2luUmVzcG9uc2UiLCJIZWFsdGhDaGVja1Jlc3BvbnNlIiwiVHJhY2tQdWJsaXNoZWQiLCJUcmFja1VucHVibGlzaGVkIiwiRXJyb3IkMSIsIkNhbGxHcmFudHNVcGRhdGVkIiwiR29Bd2F5IiwiSUNFUmVzdGFydCIsIlBpbnNDaGFuZ2VkIiwiZXZlbnRQYXlsb2FkIiwic3Vic2NyaWJlck9mZmVyIiwicHVibGlzaGVyQW5zd2VyIiwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIiwiYXVkaW9MZXZlbENoYW5nZWQiLCJpY2VUcmlja2xlIiwiY2hhbmdlUHVibGlzaFF1YWxpdHkiLCJwYXJ0aWNpcGFudEpvaW5lZCIsInBhcnRpY2lwYW50TGVmdCIsImRvbWluYW50U3BlYWtlckNoYW5nZWQiLCJqb2luUmVzcG9uc2UiLCJoZWFsdGhDaGVja1Jlc3BvbnNlIiwidHJhY2tQdWJsaXNoZWQiLCJ0cmFja1VucHVibGlzaGVkIiwiY2FsbEdyYW50c1VwZGF0ZWQiLCJnb0F3YXkiLCJwaW5zVXBkYXRlZCIsIlNmdUV2ZW50IiwiUGluc0NoYW5nZWQkVHlwZSIsIklDRVJlc3RhcnQkVHlwZSIsIlNmdVJlcXVlc3QkVHlwZSIsIkpvaW5SZXF1ZXN0IiwiSGVhbHRoQ2hlY2tSZXF1ZXN0IiwicmVxdWVzdFBheWxvYWQiLCJqb2luUmVxdWVzdCIsImhlYWx0aENoZWNrUmVxdWVzdCIsIlNmdVJlcXVlc3QiLCJIZWFsdGhDaGVja1JlcXVlc3QkVHlwZSIsIkhlYWx0aENoZWNrUmVzcG9uc2UkVHlwZSIsIlRyYWNrUHVibGlzaGVkJFR5cGUiLCJwYXJ0aWNpcGFudCIsIlRyYWNrVW5wdWJsaXNoZWQkVHlwZSIsImNhdXNlIiwiSm9pblJlcXVlc3QkVHlwZSIsIk1pZ3JhdGlvbiIsInRva2VuIiwic3Vic2NyaWJlclNkcCIsImZhc3RSZWNvbm5lY3QiLCJjbGllbnREZXRhaWxzIiwibWlncmF0aW9uIiwiTWlncmF0aW9uJFR5cGUiLCJmcm9tU2Z1SWQiLCJhbm5vdW5jZWRUcmFja3MiLCJzdWJzY3JpcHRpb25zIiwiSm9pblJlc3BvbnNlJFR5cGUiLCJyZWNvbm5lY3RlZCIsImNhbGxTdGF0ZSIsIlBhcnRpY2lwYW50Sm9pbmVkJFR5cGUiLCJjYWxsQ2lkIiwiUGFydGljaXBhbnRMZWZ0JFR5cGUiLCJTdWJzY3JpYmVyT2ZmZXIkVHlwZSIsIlB1Ymxpc2hlckFuc3dlciRUeXBlIiwiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJFR5cGUiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8iLCJjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8kVHlwZSIsIkRvbWluYW50U3BlYWtlckNoYW5nZWQkVHlwZSIsIkF1ZGlvTGV2ZWwkVHlwZSIsImxldmVsIiwiQXVkaW9MZXZlbCIsIkF1ZGlvTGV2ZWxDaGFuZ2VkJFR5cGUiLCJhdWRpb0xldmVscyIsIkF1ZGlvTWVkaWFSZXF1ZXN0JFR5cGUiLCJjaGFubmVsQ291bnQiLCJBdWRpb01lZGlhUmVxdWVzdCIsIkF1ZGlvU2VuZGVyJFR5cGUiLCJtZWRpYVJlcXVlc3QiLCJjb2RlYyIsIkF1ZGlvU2VuZGVyIiwiVmlkZW9NZWRpYVJlcXVlc3QkVHlwZSIsImlkZWFsSGVpZ2h0IiwiaWRlYWxXaWR0aCIsImlkZWFsRnJhbWVSYXRlIiwiVmlkZW9NZWRpYVJlcXVlc3QiLCJWaWRlb0xheWVyU2V0dGluZyRUeXBlIiwiYWN0aXZlIiwibWF4Qml0cmF0ZSIsInNjYWxlUmVzb2x1dGlvbkRvd25CeSIsInByaW9yaXR5IiwibWF4RnJhbWVyYXRlIiwiVmlkZW9MYXllclNldHRpbmciLCJWaWRlb1NlbmRlciRUeXBlIiwiVmlkZW9TZW5kZXIiLCJDaGFuZ2VQdWJsaXNoUXVhbGl0eSRUeXBlIiwiYXVkaW9TZW5kZXJzIiwidmlkZW9TZW5kZXJzIiwiQ2FsbEdyYW50c1VwZGF0ZWQkVHlwZSIsImN1cnJlbnRHcmFudHMiLCJHb0F3YXkkVHlwZSIsInJlYXNvbiIsImV2ZW50cyIsIlZpc2liaWxpdHlTdGF0ZSIsIkRlYm91bmNlVHlwZSIsIlNpZ25hbFNlcnZlckNsaWVudCIsIl90cmFuc3BvcnQiLCJtZXRob2RzIiwic2V0UHVibGlzaGVyIiwiaW5wdXQiLCJtZXRob2QiLCJvcHQiLCJtZXJnZU9wdGlvbnMiLCJzZW5kQW5zd2VyIiwidXBkYXRlU3Vic2NyaXB0aW9ucyIsInVwZGF0ZU11dGVTdGF0ZXMiLCJzZW5kU3RhdHMiLCJkZWZhdWx0T3B0aW9ucyIsImJhc2VVcmwiLCJzZW5kSnNvbiIsInRpbWVvdXQiLCJqc29uT3B0aW9ucyIsImlnbm9yZVVua25vd25GaWVsZHMiLCJ3aXRoSGVhZGVycyIsImhlYWRlcnMiLCJpbnRlcmNlcHRVbmFyeSIsIm5leHQiLCJtZXRhIiwiY3JlYXRlU2lnbmFsQ2xpZW50IiwidHJhbnNwb3J0IiwiaXNSZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ0b0xvd2VyQ2FzZSIsImxvZ0xldmVscyIsInRyYWNlIiwiZGVidWciLCJpbmZvIiwid2FybiIsImxvZ2dlciQ0IiwibG9nVG9Db25zb2xlIiwibG9nTGV2ZWwiLCJhcmdzIiwibG9nTWV0aG9kIiwiY29uc29sZSIsImxvZyIsInNldExvZ2dlciIsImwiLCJsdmwiLCJzZXRMb2dMZXZlbCIsImdldExvZ2dlciIsIndpdGhUYWdzIiwibG9nZ2VyTWV0aG9kIiwidGFncyIsInJlc3VsdCIsImdldFByZWZlcnJlZENvZGVjcyIsInByZWZlcnJlZENvZGVjIiwiY29kZWNUb1JlbW92ZSIsImxvZ2dlciIsIlJUQ1J0cFNlbmRlciIsImNhcCIsImdldENhcGFiaWxpdGllcyIsIm1hdGNoZWQiLCJwYXJ0aWFsTWF0Y2hlZCIsInVubWF0Y2hlZCIsImNvZGVjcyIsImZvckVhY2giLCJjIiwibWltZVR5cGUiLCJzaG91bGRSZW1vdmVDb2RlYyIsIm1hdGNoZXNDb2RlYyIsInNkcEZtdHBMaW5lIiwiaW5jbHVkZXMiLCJnZXRHZW5lcmljU2RwIiwiZGlyZWN0aW9uIiwidGVtcFBjIiwiUlRDUGVlckNvbm5lY3Rpb24iLCJhZGRUcmFuc2NlaXZlciIsIm9mZmVyIiwiY3JlYXRlT2ZmZXIiLCJnZXRUcmFuc2NlaXZlcnMiLCJ0Iiwic3RvcCIsImNsb3NlIiwic2Z1RXZlbnRLaW5kcyIsImlzU2Z1RXZlbnQiLCJldmVudE5hbWUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJEaXNwYXRjaGVyIiwic3Vic2NyaWJlcnMiLCJkaXNwYXRjaCIsImV2ZW50S2luZCIsInBheWxvYWQiLCJsaXN0ZW5lcnMiLCJmbiIsIm9uIiwiX2EiLCJvZmYiLCJvZmZBbGwiLCJJY2VUcmlja2xlQnVmZmVyIiwic3Vic2NyaWJlckNhbmRpZGF0ZXMiLCJwdWJsaXNoZXJDYW5kaWRhdGVzIiwiU1VCU0NSSUJFUiIsIlBVQkxJU0hFUl9VTlNQRUNJRklFRCIsImdldEljZUNhbmRpZGF0ZSIsImNhbmRpZGF0ZSIsInVzZXJuYW1lRnJhZ21lbnQiLCJzcGxpdHRlZENhbmRpZGF0ZSIsInNwbGl0IiwidWZyYWdJbmRleCIsImZpbmRJbmRleCIsInMiLCJKU09OIiwic3RyaW5naWZ5IiwidG9KU09OIiwic2RrSW5mbyIsIm9zSW5mbyIsImRldmljZUluZm8iLCJ3ZWJSdGNJbmZvIiwic2V0U2RrSW5mbyIsImdldFNka0luZm8iLCJzZXRPU0luZm8iLCJnZXRPU0luZm8iLCJzZXREZXZpY2VJbmZvIiwiZ2V0RGV2aWNlSW5mbyIsImdldFdlYlJUQ0luZm8iLCJzZXRXZWJSVENJbmZvIiwiZ2V0Q2xpZW50RGV0YWlscyIsInVzZXJBZ2VudCIsImNwdSIsImdldFJlc3VsdCIsInZlbmRvciIsIm1vZGVsIiwiQm9vbGVhbiIsIkRFRkFVTFRfQklUUkFURSIsImRlZmF1bHRUYXJnZXRSZXNvbHV0aW9uIiwiZmluZE9wdGltYWxWaWRlb0xheWVycyIsInZpZGVvVHJhY2siLCJ0YXJnZXRSZXNvbHV0aW9uIiwib3B0aW1hbFZpZGVvTGF5ZXJzIiwic2V0dGluZ3MiLCJnZXRTZXR0aW5ncyIsInciLCJoIiwiaXNSTklvcyIsImdldENvbXB1dGVkTWF4Qml0cmF0ZSIsImRvd25zY2FsZUZhY3RvciIsInVuc2hpZnQiLCJyb3VuZCIsInEiLCJ3aXRoU2ltdWxjYXN0Q29uc3RyYWludHMiLCJjdXJyZW50V2lkdGgiLCJjdXJyZW50SGVpZ2h0IiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJjdXJyZW50UGl4ZWxzIiwidGFyZ2V0UGl4ZWxzIiwicmVkdWN0aW9uRmFjdG9yIiwic2l6ZSIsIm1heCIsImxheWVyIiwicmlkTWFwcGluZyIsImluZGV4IiwiZmluZE9wdGltYWxTY3JlZW5TaGFyaW5nTGF5ZXJzIiwicHJlZmVyZW5jZXMiLCJ0cmFja1R5cGVUb1BhcnRpY2lwYW50U3RyZWFtS2V5IiwiU0NSRUVOX1NIQVJFIiwiU0NSRUVOX1NIQVJFX0FVRElPIiwiVklERU8iLCJBVURJTyIsIlVOU1BFQ0lGSUVEIiwiZXhoYXVzdGl2ZVRyYWNrVHlwZUNoZWNrIiwibXV0ZVR5cGVUb1RyYWNrVHlwZSIsIm11dGVUeXBlIiwiZXhoYXVzdGl2ZU11dGVUeXBlQ2hlY2siLCJpc0Z1bmN0aW9uUGF0Y2giLCJ1cGRhdGUiLCJnZXRDdXJyZW50VmFsdWUiLCJvYnNlcnZhYmxlJCIsImVyciIsInN1YnNjcmliZSIsInVuc3Vic2NyaWJlIiwic2V0Q3VycmVudFZhbHVlIiwic3ViamVjdCIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsIm9ic2VydmFibGUiLCJoYW5kbGVyIiwic3Vic2NyaXB0aW9uIiwicnhVdGlscyIsImNvbWJpbmVDb21wYXJhdG9ycyIsImNvbXBhcmF0b3JzIiwiYSIsImIiLCJjb21wYXJhdG9yIiwiZGVzY2VuZGluZyIsImNvbmRpdGlvbmFsIiwicHJlZGljYXRlIiwibm9vcENvbXBhcmF0b3IiLCJkb21pbmFudFNwZWFrZXIiLCJzcGVha2luZyIsInNjcmVlblNoYXJpbmciLCJoYXNTY3JlZW5TaGFyZSIsInB1Ymxpc2hpbmdWaWRlbyIsImhhc1ZpZGVvIiwicHVibGlzaGluZ0F1ZGlvIiwiaGFzQXVkaW8iLCJwaW5uZWQiLCJwaW4iLCJpc0xvY2FsUGluIiwicGlubmVkQXQiLCJyZWFjdGlvblR5cGUiLCJyZWFjdGlvbiIsInJvbGUiLCJoYXNBbnlSb2xlIiwicCIsInNvbWUiLCJyIiwiaWZJbnZpc2libGVCeSIsInZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlIiwiSU5WSVNJQkxFIiwiaWZJbnZpc2libGVPclVua25vd25CeSIsIlVOS05PV04iLCJkZWZhdWx0U29ydFByZXNldCIsInNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0IiwicGFnaW5hdGVkTGF5b3V0U29ydFByZXNldCIsImxpdmVzdHJlYW1PckF1ZGlvUm9vbVNvcnRQcmVzZXQiLCJDYWxsaW5nU3RhdGUiLCJkZWZhdWx0RWdyZXNzIiwiYnJvYWRjYXN0aW5nIiwiaGxzIiwicGxheWxpc3RfdXJsIiwicnRtcHMiLCJiYWNrc3RhZ2VTdWJqZWN0IiwiYmxvY2tlZFVzZXJJZHNTdWJqZWN0IiwiY3JlYXRlZEF0U3ViamVjdCIsImVuZGVkQXRTdWJqZWN0Iiwic3RhcnRzQXRTdWJqZWN0IiwidXBkYXRlZEF0U3ViamVjdCIsImNyZWF0ZWRCeVN1YmplY3QiLCJjdXN0b21TdWJqZWN0IiwiZWdyZXNzU3ViamVjdCIsImluZ3Jlc3NTdWJqZWN0IiwicmVjb3JkaW5nU3ViamVjdCIsInNlc3Npb25TdWJqZWN0Iiwic2V0dGluZ3NTdWJqZWN0IiwidHJhbnNjcmliaW5nU3ViamVjdCIsImVuZGVkQnlTdWJqZWN0IiwidGh1bWJuYWlsc1N1YmplY3QiLCJtZW1iZXJzU3ViamVjdCIsIm93bkNhcGFiaWxpdGllc1N1YmplY3QiLCJjYWxsaW5nU3RhdGVTdWJqZWN0Iiwic3RhcnRlZEF0U3ViamVjdCIsInBhcnRpY2lwYW50Q291bnRTdWJqZWN0IiwiYW5vbnltb3VzUGFydGljaXBhbnRDb3VudFN1YmplY3QiLCJwYXJ0aWNpcGFudHNTdWJqZWN0IiwiY2FsbFN0YXRzUmVwb3J0U3ViamVjdCIsInNvcnRQYXJ0aWNpcGFudHNCeSIsInNldFNvcnRQYXJ0aWNpcGFudHNCeSIsInBzIiwic2V0UGFydGljaXBhbnRDb3VudCIsImNvdW50Iiwic2V0U3RhcnRlZEF0Iiwic2V0QW5vbnltb3VzUGFydGljaXBhbnRDb3VudCIsInNldFBhcnRpY2lwYW50cyIsInNldENhbGxpbmdTdGF0ZSIsInN0YXRlIiwic2V0Q2FsbFN0YXRzUmVwb3J0IiwicmVwb3J0Iiwic2V0TWVtYmVycyIsIm1lbWJlcnMiLCJzZXRPd25DYXBhYmlsaXRpZXMiLCJjYXBhYmlsaXRpZXMiLCJmaW5kUGFydGljaXBhbnRCeVNlc3Npb25JZCIsImdldFBhcnRpY2lwYW50TG9va3VwQnlTZXNzaW9uSWQiLCJyZWR1Y2UiLCJsb29rdXBUYWJsZSIsInVwZGF0ZVBhcnRpY2lwYW50IiwidGhlUGF0Y2giLCJ1cGRhdGVkUGFydGljaXBhbnQiLCJ1cGRhdGVPckFkZFBhcnRpY2lwYW50IiwidXBkYXRlUGFydGljaXBhbnRzIiwidXBkYXRlRnJvbUV2ZW50IiwiZXZlbnQiLCJldmVudEhhbmRsZXJzIiwic2V0U2VydmVyU2lkZVBpbnMiLCJwaW5zTG9va3VwIiwibG9va3VwIiwic2VydmVyU2lkZVBpbm5lZEF0IiwidXBkYXRlRnJvbUNhbGxSZXNwb25zZSIsImJhY2tzdGFnZSIsImJsb2NrZWRfdXNlcl9pZHMiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsInN0YXJ0c19hdCIsImVuZGVkX2F0IiwiY3JlYXRlZF9ieSIsImVncmVzcyIsImluZ3Jlc3MiLCJyZWNvcmRpbmciLCJzZXNzaW9uIiwidHJhbnNjcmliaW5nIiwidGh1bWJuYWlscyIsInVwZGF0ZUZyb21NZW1iZXJSZW1vdmVkIiwibSIsImluZGV4T2YiLCJ1c2VyX2lkIiwidXBkYXRlRnJvbU1lbWJlckFkZGVkIiwidXBkYXRlRnJvbUhMU0Jyb2FkY2FzdFN0b3BwZWQiLCJ1cGRhdGVGcm9tSExTQnJvYWRjYXN0aW5nRmFpbGVkIiwidXBkYXRlRnJvbUhMU0Jyb2FkY2FzdFN0YXJ0ZWQiLCJobHNfcGxheWxpc3RfdXJsIiwidXBkYXRlRnJvbVNlc3Npb25QYXJ0aWNpcGFudExlZnQiLCJwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZSIsInVzZXIiLCJ1c2VyX3Nlc3Npb25faWQiLCJ1cGRhdGVGcm9tU2Vzc2lvblBhcnRpY2lwYW50Sm9pbmVkIiwic2hvdWxkSW5zZXJ0UGFydGljaXBhbnQiLCJ1cGRhdGVkUGFydGljaXBhbnRzIiwiaW5jcmVtZW50IiwidXBkYXRlTWVtYmVycyIsIm1lbWJlciIsIm1lbWJlclVwZGF0ZSIsInVwZGF0ZVBhcnRpY2lwYW50UmVhY3Rpb24iLCJlbW9qaV9jb2RlIiwidW5ibG9ja1VzZXIiLCJjdXJyZW50IiwiYmxvY2tVc2VyIiwidXBkYXRlT3duQ2FwYWJpbGl0aWVzIiwibG9jYWxQYXJ0aWNpcGFudCIsIm93bl9jYXBhYmlsaXRpZXMiLCJwYXJ0aWNpcGFudHMkIiwiYXNPYnNlcnZhYmxlIiwicGlwZSIsInNvcnQiLCJidWZmZXJTaXplIiwicmVmQ291bnQiLCJsb2NhbFBhcnRpY2lwYW50JCIsImlzTG9jYWxQYXJ0aWNpcGFudCIsInJlbW90ZVBhcnRpY2lwYW50cyQiLCJwaW5uZWRQYXJ0aWNpcGFudHMkIiwiZG9taW5hbnRTcGVha2VyJCIsImhhc09uZ29pbmdTY3JlZW5TaGFyZSQiLCJzdGFydGVkQXQkIiwicGFydGljaXBhbnRDb3VudCQiLCJhbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50JCIsImNhbGxTdGF0c1JlcG9ydCQiLCJtZW1iZXJzJCIsIm93bkNhcGFiaWxpdGllcyQiLCJjYWxsaW5nU3RhdGUkIiwiYmFja3N0YWdlJCIsImJsb2NrZWRVc2VySWRzJCIsImNyZWF0ZWRBdCQiLCJlbmRlZEF0JCIsInN0YXJ0c0F0JCIsInVwZGF0ZWRBdCQiLCJjcmVhdGVkQnkkIiwiY3VzdG9tJCIsImVncmVzcyQiLCJpbmdyZXNzJCIsInJlY29yZGluZyQiLCJzZXNzaW9uJCIsInNldHRpbmdzJCIsInRyYW5zY3JpYmluZyQiLCJlbmRlZEJ5JCIsInRodW1ibmFpbHMkIiwiYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCIsInJlbW90ZVBhcnRpY2lwYW50cyIsInBpbm5lZFBhcnRpY2lwYW50cyIsImhhc09uZ29pbmdTY3JlZW5TaGFyZSIsImNhbGxpbmdTdGF0ZSIsImNhbGxTdGF0c1JlcG9ydCIsIm93bkNhcGFiaWxpdGllcyIsImJsb2NrZWRVc2VySWRzIiwiZW5kZWRBdCIsInN0YXJ0c0F0IiwiY3JlYXRlZEJ5IiwiZW5kZWRCeSIsIlN0cmVhbVZpZGVvV3JpdGVhYmxlU3RhdGVTdG9yZSIsImNvbm5lY3RlZFVzZXJTdWJqZWN0IiwiY2FsbHNTdWJqZWN0Iiwic2V0Q29ubmVjdGVkVXNlciIsInNldENhbGxzIiwiY2FsbHMiLCJyZWdpc3RlckNhbGwiLCJjaWQiLCJ1bnJlZ2lzdGVyQ2FsbCIsImZpbmRDYWxsIiwiTEVGVCIsImxlYXZlIiwiY2F0Y2giLCJjb25uZWN0ZWRVc2VyIiwiU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUiLCJzdG9yZSIsImNvbm5lY3RlZFVzZXIkIiwiY2FsbHMkIiwiZ2V0UnRwTWFwIiwibGluZSIsInJ0cFJlZ2V4IiwicnRwTWF0Y2giLCJleGVjIiwib3JpZ2luYWwiLCJnZXRGbXRwIiwiZm10cFJlZ2V4IiwiZm10cE1hdGNoIiwiY29uZmlnIiwiZ2V0TWVkaWEiLCJtZWRpYVR5cGUiLCJyZWdleCIsIlJlZ0V4cCIsIm1lZGlhV2l0aFBvcnRzIiwiY29kZWNPcmRlciIsImdldE1lZGlhU2VjdGlvbiIsIm1lZGlhIiwicnRwTWFwIiwiZm10cCIsImlzVGhlUmVxdWlyZWRNZWRpYVNlY3Rpb24iLCJpc1ZhbGlkTGluZSIsInRlc3QiLCJfbWVkaWEiLCJydHBNYXBMaW5lIiwiZ2V0T3B1c0ZtdHAiLCJzZWN0aW9uIiwiY29kZWNJZCIsInRvZ2dsZUR0eCIsImVuYWJsZSIsIm9wdXNGbXRwIiwibWF0Y2hEdHgiLCJyZXF1aXJlZER0eENvbmZpZyIsIm5ld0ZtdHAiLCJlbmFibGVIaWdoUXVhbGl0eUF1ZGlvIiwidHJhY2tNaWQiLCJtaW4iLCJwYXJzZWRTZHAiLCJhdWRpb01lZGlhIiwiU3RyaW5nIiwib3B1c1J0cCIsInJ0cCIsIndyaXRlIiwibG9nZ2VyJDMiLCJQdWJsaXNoZXIiLCJjb25uZWN0aW9uQ29uZmlndXJhdGlvbiIsInBjIiwiZ2V0Q29uZmlndXJhdGlvbiIsIl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbiIsImNvbm5lY3Rpb25Db25maWciLCJzZnVDbGllbnQiLCJkaXNwYXRjaGVyIiwiaXNEdHhFbmFibGVkIiwiaXNSZWRFbmFibGVkIiwiaWNlUmVzdGFydERlbGF5IiwidHJhbnNjZWl2ZXJSZWdpc3RyeSIsInB1Ymxpc2hPcHRpb25zUGVyVHJhY2tUeXBlIiwiTWFwIiwidHJhbnNjZWl2ZXJJbml0T3JkZXIiLCJ0cmFja0tpbmRNYXBwaW5nIiwidHJhY2tMYXllcnNDYWNoZSIsImlzSWNlUmVzdGFydGluZyIsImNyZWF0ZVBlZXJDb25uZWN0aW9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uSWNlQ2FuZGlkYXRlIiwib25OZWdvdGlhdGlvbk5lZWRlZCIsIm9uSWNlQ2FuZGlkYXRlRXJyb3IiLCJvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UiLCJvblNpZ25hbGluZ1N0YXRlQ2hhbmdlIiwic3RvcFRyYWNrcyIsInN0b3BQdWJsaXNoaW5nIiwiY2xlYXJUaW1lb3V0IiwiaWNlUmVzdGFydFRpbWVvdXQiLCJ1bnN1YnNjcmliZU9uSWNlUmVzdGFydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwdWJsaXNoU3RyZWFtIiwibWVkaWFTdHJlYW0iLCJ0cmFjayIsIm9wdHMiLCJyZWFkeVN0YXRlIiwidHJhbnNjZWl2ZXIiLCJzZW5kZXIiLCJoYW5kbGVUcmFja0VuZGVkIiwibm90aWZ5VHJhY2tNdXRlU3RhdGVDaGFuZ2VkIiwidmlkZW8iLCJ0YXJnZXRfcmVzb2x1dGlvbiIsInZpZGVvRW5jb2RpbmdzIiwic2NyZWVuU2hhcmVTZXR0aW5ncyIsIm9zTmFtZSIsImNvZGVjUHJlZmVyZW5jZXMiLCJnZXRDb2RlY1ByZWZlcmVuY2VzIiwiZW5hYmxlZCIsInN0cmVhbXMiLCJzZW5kRW5jb2RpbmdzIiwic2V0Iiwic2V0Q29kZWNQcmVmZXJlbmNlcyIsInByZXZpb3VzVHJhY2siLCJyZXBsYWNlVHJhY2siLCJ1bnB1Ymxpc2hTdHJlYW0iLCJzdG9wVHJhY2siLCJpc1B1Ymxpc2hpbmciLCJ0cmFuc2NlaXZlckZvclRyYWNrVHlwZSIsImlzTGl2ZSIsImlzTXV0ZWQiLCJ1cGRhdGVNdXRlU3RhdGUiLCJhdWRpb09yVmlkZW9PclNjcmVlblNoYXJlU3RyZWFtIiwiZ2V0U2VuZGVycyIsInNpZ25hbGluZ1N0YXRlIiwicmVtb3ZlVHJhY2siLCJ1cGRhdGVWaWRlb1B1Ymxpc2hRdWFsaXR5IiwiZW5hYmxlZExheWVycyIsInZpZGVvU2VuZGVyIiwicGFyYW1zIiwiZ2V0UGFyYW1ldGVycyIsImVuY29kaW5ncyIsImNoYW5nZWQiLCJlbmFibGVkUmlkcyIsImx5IiwiZW5jIiwic2hvdWxkRW5hYmxlIiwidmxzIiwiYWN0aXZlTGF5ZXJzIiwic2V0UGFyYW1ldGVycyIsImdldFN0YXRzIiwic2VsZWN0b3IiLCJkZWZhdWx0QXVkaW9Db2RlYyIsInNldFNmdUNsaWVudCIsIm1pZ3JhdGVUbyIsInNldENvbmZpZ3VyYXRpb24iLCJzaG91bGRSZXN0YXJ0SWNlIiwiaWNlQ29ubmVjdGlvblN0YXRlIiwibmVnb3RpYXRlIiwicmVzdGFydEljZSIsIm11bmdlQ29kZWNzIiwiZXh0cmFjdE1pZCIsInRyYWNrSW5mb3MiLCJnZXRDdXJyZW50VHJhY2tJbmZvcyIsInNldExvY2FsRGVzY3JpcHRpb24iLCJyZXNwb25zZSIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiaWNlVHJpY2tsZUJ1ZmZlciIsImFkZEljZUNhbmRpZGF0ZSIsIm1zaWQiLCJoZXVyaXN0aWNNaWQiLCJsb2NhbERlc2NyaXB0aW9uIiwib3B0aW1hbExheWVycyIsInB1Ymxpc2hPcHRzIiwiZ2V0Iiwib3B0aW1hbExheWVyIiwicmlkVG9WaWRlb1F1YWxpdHkiLCJpc0F1ZGlvVHJhY2siLCJ0cmFja1NldHRpbmdzIiwiaXNTdGVyZW8iLCJlcnJvck1lc3NhZ2UiLCJSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQiLCJlcnJvckNvZGUiLCJlcnJvclRleHQiLCJpY2VTdGF0ZSIsImhhc05ldHdvcmtDb25uZWN0aW9uIiwiT0ZGTElORSIsInNldFRpbWVvdXQiLCJpY2VHYXRoZXJpbmdTdGF0ZSIsIkxPV19VTlNQRUNJRklFRCIsIk1JRCIsIkhJR0giLCJsb2dnZXIkMiIsIlN1YnNjcmliZXIiLCJoYW5kbGVPblRyYWNrIiwidW5yZWdpc3Rlck9uU3Vic2NyaWJlck9mZmVyIiwidW5yZWdpc3Rlck9uSWNlUmVzdGFydCIsInByZXZpb3VzUEMiLCJ0cmFja0lkc1RvTWlncmF0ZSIsIlNldCIsImdldFJlY2VpdmVycyIsImFkZCIsIm1pZ3JhdGlvblRpbWVvdXRJZCIsImNsZWFudXBNaWdyYXRpb24iLCJoYW5kbGVUcmFja01pZ3JhdGlvbiIsImRlbGV0ZSIsImhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsImNvbm5lY3Rpb25TdGF0ZSIsInByZXZpb3VzSXNJY2VSZXN0YXJ0aW5nIiwicHJpbWFyeVN0cmVhbSIsInBhcnRpY2lwYW50VG9VcGRhdGUiLCJzdHJlYW1LaW5kUHJvcCIsIlRSQUNLX1RZUEVfQVVESU8iLCJUUkFDS19UWVBFX1ZJREVPIiwiVFJBQ0tfVFlQRV9TQ1JFRU5fU0hBUkUiLCJUUkFDS19UWVBFX1NDUkVFTl9TSEFSRV9BVURJTyIsInByZXZpb3VzU3RyZWFtIiwiZ2V0VHJhY2tzIiwiYW5zd2VyIiwiY3JlYXRlQW5zd2VyIiwiY3JlYXRlV2ViU29ja2V0U2lnbmFsQ2hhbm5lbCIsImVuZHBvaW50Iiwib25NZXNzYWdlIiwid3MiLCJiaW5hcnlUeXBlIiwiZGF0YSIsIkFycmF5QnVmZmVyIiwiZnJvbUJpbmFyeSIsIlVpbnQ4QXJyYXkiLCJmcm9tSnNvblN0cmluZyIsInNsZWVwIiwiUHJvbWlzZSIsImlzRnVuY3Rpb24iLCJGdW5jdGlvbiIsIktub3duQ29kZXMiLCJUT0tFTl9FWFBJUkVEIiwiV1NfQ0xPU0VEX1NVQ0NFU1MiLCJXU19DTE9TRURfQUJSVVBUTFkiLCJXU19QT0xJQ1lfVklPTEFUSU9OIiwicmV0cnlJbnRlcnZhbCIsIm51bWJlck9mRmFpbHVyZXMiLCJyYW5kb20iLCJyYW5kb21JZCIsImdlbmVyYXRlVVVJRHY0IiwiaGV4IiwiYnl0ZXMiLCJwYWRTdGFydCIsImdldFJhbmRvbUJ5dGVzIiwic3ViYXJyYXkiLCJnZXRSYW5kb21WYWx1ZXNXaXRoTWF0aFJhbmRvbSIsInBvdyIsImJ5dGVMZW5ndGgiLCJnZXRSYW5kb21WYWx1ZXMiLCJjcnlwdG8iLCJiaW5kIiwibXNDcnlwdG8iLCJjb252ZXJ0RXJyb3JUb0pzb24iLCJqc29uT2JqIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl8iLCJpc09ubGluZSIsIm5hdiIsIndpbmRvdyIsIm9uTGluZSIsImFkZENvbm5lY3Rpb25FdmVudExpc3RlbmVycyIsImNiIiwicmVtb3ZlQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzIiwiU3RyZWFtU2Z1Q2xpZW50Iiwic2Z1U2VydmVyIiwiaXNNaWdyYXRpbmdBd2F5IiwiaXNGYXN0UmVjb25uZWN0aW5nIiwicGluZ0ludGVydmFsSW5NcyIsInVuaGVhbHRoeVRpbWVvdXRJbk1zIiwic2lnbmFsV3MiLCJDTE9TRUQiLCJ1bnN1YnNjcmliZUljZVRyaWNrbGUiLCJjbGVhckludGVydmFsIiwia2VlcEFsaXZlSW50ZXJ2YWwiLCJjb25uZWN0aW9uQ2hlY2tUaW1lb3V0IiwicmV0cnlhYmxlIiwicnBjIiwic3RhdHMiLCJzZW5kIiwic2lnbmFsUmVhZHkiLCJ0aGVuIiwic2lnbmFsIiwiT1BFTiIsImVkZ2VOYW1lIiwidG9CaW5hcnkiLCJrZWVwQWxpdmUiLCJzZXRJbnRlcnZhbCIsInNjaGVkdWxlQ29ubmVjdGlvbkNoZWNrIiwibGFzdE1lc3NhZ2VUaW1lc3RhbXAiLCJ0aW1lU2luY2VMYXN0TWVzc2FnZSIsIkVSUk9SX0NPTk5FQ1RJT05fVU5IRUFMVEhZIiwiZWRnZV9uYW1lIiwibG9nSW50ZXJjZXB0b3IiLCJ1cmwiLCJpbnRlcmNlcHRvcnMiLCJBdXRob3JpemF0aW9uIiwid3NfZW5kcG9pbnQiLCJyZXNvbHZlIiwib25PcGVuIiwiTk9STUFMX0NMT1NVUkUiLCJFUlJPUl9DT05ORUNUSU9OX0JST0tFTiIsIk1BWF9SRVRSSUVTIiwicmV0cnlBdHRlbXB0IiwicnBjQ2FsbFJlc3VsdCIsIndhdGNoQ2FsbEFjY2VwdGVkIiwib25DYWxsQWNjZXB0ZWQiLCJjdXJyZW50VXNlcklkIiwiUklOR0lORyIsIndhdGNoQ2FsbFJlamVjdGVkIiwib25DYWxsUmVqZWN0ZWQiLCJldmVudENhbGwiLCJjYWxsU2Vzc2lvbiIsInJlamVjdGVkQnkiLCJyZWplY3RlZF9ieSIsImlzQ3JlYXRlZEJ5TWUiLCJldmVyeW9uZUVsc2VSZWplY3RlZCIsImV2ZXJ5Iiwid2F0Y2hDYWxsRW5kZWQiLCJvbkNhbGxFbmRlZCIsIkpPSU5FRCIsIkpPSU5JTkciLCJ3YXRjaENhbGxHcmFudHNVcGRhdGVkIiwib25DYWxsR3JhbnRzVXBkYXRlZCIsIm5leHRDYXBhYmlsaXRpZXMiLCJjYXBhYmlsaXR5IiwibG9nZ2VyJDEiLCJ3YXRjaENoYW5nZVB1Ymxpc2hRdWFsaXR5IiwidXBkYXRlUHVibGlzaFF1YWxpdHkiLCJ3YXRjaENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsInBhdGNoZXMiLCJ3YXRjaFBhcnRpY2lwYW50Q291bnRDaGFuZ2VkIiwid2F0Y2hMaXZlRW5kZWQiLCJMSVZFX0VOREVEIiwicGVybWlzc2lvbnNDb250ZXh0IiwiaGFzUGVybWlzc2lvbiIsIndhdGNoU2Z1RXJyb3JSZXBvcnRzIiwid2F0Y2hQaW5zVXBkYXRlZCIsIm9uUGluc1VwZGF0ZWQiLCJoYW5kbGVSZW1vdGVTb2Z0TXV0ZSIsIk1PREVSQVRJT04iLCJjYW1lcmEiLCJkaXNhYmxlIiwibWljcm9waG9uZSIsInB1Ymxpc2hlciIsInN0b3BQdWJsaXNoIiwid2F0Y2hQYXJ0aWNpcGFudEpvaW5lZCIsIm9uUGFydGljaXBhbnRKb2luZWQiLCJhc3NpZ24iLCJzY3JlZW5TaGFyZVRyYWNrIiwid2F0Y2hQYXJ0aWNpcGFudExlZnQiLCJvblBhcnRpY2lwYW50TGVmdCIsIndhdGNoVHJhY2tQdWJsaXNoZWQiLCJvblRyYWNrUHVibGlzaGVkIiwidW5pcXVlIiwid2F0Y2hUcmFja1VucHVibGlzaGVkIiwib25UcmFja1VucHVibGlzaGVkIiwiYXJyIiwid2F0Y2hEb21pbmFudFNwZWFrZXJDaGFuZ2VkIiwid2F0Y2hBdWRpb0xldmVsQ2hhbmdlZCIsInJlZ2lzdGVyRXZlbnRIYW5kbGVycyIsInJpbmdpbmciLCJyZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyIsImNvb3JkaW5hdG9yUmluZ0V2ZW50cyIsImh0dHBDbGllbnQiLCJjcmVkZW50aWFscyIsInN0YXRzX29wdGlvbnMiLCJkb0pvaW4iLCJ0b1J0Y0NvbmZpZ3VyYXRpb24iLCJpY2Vfc2VydmVycyIsInNlcnZlciIsIm1ldGFkYXRhIiwic3RhdHNPcHRpb25zIiwibG9jYXRpb24iLCJnZXRMb2NhdGlvbkhpbnQiLCJyZXF1ZXN0IiwicG9zdCIsInJ0Y0NvbmZpZyIsImljZVNlcnZlcnMiLCJpY2UiLCJ1cmxzIiwidXNlcm5hbWUiLCJjcmVkZW50aWFsIiwicGFzc3dvcmQiLCJmbGF0dGVuJDEiLCJjcmVhdGVTdGF0c1JlcG9ydGVyIiwic3Vic2NyaWJlciIsInBvbGxpbmdJbnRlcnZhbEluTXMiLCJnZXRSYXdTdGF0c0ZvclRyYWNrIiwiZ2V0U3RhdHNGb3JTdHJlYW0iLCJzdGF0c0ZvclN0cmVhbSIsInRyYW5zZm9ybSIsInRyYWNrS2luZCIsInN0YXJ0UmVwb3J0aW5nU3RhdHNGb3IiLCJzZXNzaW9uSWRzVG9UcmFjayIsInJ1biIsInN0b3BSZXBvcnRpbmdTdGF0c0ZvciIsInBhcnRpY2lwYW50U3RhdHMiLCJzZXNzaW9uSWRzIiwiaGFzIiwibWVyZ2VkU3RyZWFtIiwiTWVkaWFTdHJlYW0iLCJ2aWRlb1N0cmVhbSIsImdldFZpZGVvVHJhY2tzIiwiYXVkaW9TdHJlYW0iLCJnZXRBdWRpb1RyYWNrcyIsImFsbCIsImFnZ3JlZ2F0ZSIsInN1YnNjcmliZXJSYXdTdGF0cyIsInB1Ymxpc2hlclJhd1N0YXRzIiwiZGF0YWNlbnRlciIsInRpbWVzdGFtcCIsInRpbWVvdXRJZCIsImxvb3AiLCJzdGF0IiwicnRjU3RyZWFtU3RhdHMiLCJ0cmFuc3BvcnRJZCIsInJvdW5kVHJpcFRpbWUiLCJkdGxzU3RhdGUiLCJjYW5kaWRhdGVQYWlyIiwic2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQiLCJjdXJyZW50Um91bmRUcmlwVGltZSIsImJ5dGVzU2VudCIsImJ5dGVzUmVjZWl2ZWQiLCJmcmFtZUhlaWdodCIsImZyYW1lV2lkdGgiLCJmcmFtZXNQZXJTZWNvbmQiLCJqaXR0ZXIiLCJxdWFsaXR5TGltaXRhdGlvblJlYXNvbiIsInNzcmMiLCJyYXdTdGF0cyIsImFnZ3JlZ2F0ZWRTdGF0cyIsInJhd1JlcG9ydCIsInRvdGFsQnl0ZXNTZW50IiwidG90YWxCeXRlc1JlY2VpdmVkIiwiYXZlcmFnZUppdHRlckluTXMiLCJhdmVyYWdlUm91bmRUcmlwVGltZUluTXMiLCJxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMiLCJoaWdoZXN0RnJhbWVXaWR0aCIsImhpZ2hlc3RGcmFtZUhlaWdodCIsImhpZ2hlc3RGcmFtZXNQZXJTZWNvbmQiLCJtYXhBcmVhIiwiYXJlYSIsImFjYyIsInN0cmVhbSIsInN0cmVhbUFyZWEiLCJTZnVTdGF0c1JlcG9ydGVyIiwic2RrTmFtZSIsIndlYlJUQ1ZlcnNpb24iLCJzdGFydCIsInJlcG9ydGluZ19pbnRlcnZhbF9tcyIsImludGVydmFsSWQiLCJ3ZWJSVENJbmZvIiwiUkVBQ1QiLCJSRUFDVF9OQVRJVkUiLCJERUZBVUxUX1RIUkVTSE9MRCIsIlZpZXdwb3J0VHJhY2tlciIsImVsZW1lbnRIYW5kbGVyTWFwIiwib2JzZXJ2ZXIiLCJxdWV1ZVNldCIsInNldFZpZXdwb3J0Iiwidmlld3BvcnRFbGVtZW50IiwiY2xlYW51cCIsImRpc2Nvbm5lY3QiLCJjbGVhciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cnkiLCJyb290IiwidGhyZXNob2xkIiwicXVldWVFbGVtZW50IiwicXVldWVIYW5kbGVyIiwiY29udGFpbnMiLCJvYnNlcnZlIiwiZWxlbWVudCIsInF1ZXVlSXRlbSIsInVub2JzZXJ2ZSIsImlzU2FmYXJpIiwiaXNGaXJlZm94IiwiaXNDaHJvbWUiLCJicm93c2VycyIsIkRFRkFVTFRfVklFV1BPUlRfVklTSUJJTElUWV9TVEFURSIsIkR5bmFzY2FsZU1hbmFnZXIiLCJ2aWV3cG9ydFRyYWNrZXIiLCJ0cmFja0VsZW1lbnRWaXNpYmlsaXR5IiwicHJldmlvdXNWaXNpYmlsaXR5U3RhdGUiLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImRvY3VtZW50IiwiZnVsbHNjcmVlbkVsZW1lbnQiLCJWSVNJQkxFIiwiYmluZFZpZGVvRWxlbWVudCIsInZpZGVvRWxlbWVudCIsImJvdW5kUGFydGljaXBhbnQiLCJyZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyIsImRlYm91bmNlVHlwZSIsInVwZGF0ZVN1YnNjcmlwdGlvbnNQYXJ0aWFsIiwicGFydGljaXBhbnQkIiwidmlld3BvcnRWaXNpYmlsaXR5U3RhdGVTdWJzY3JpcHRpb24iLCJuZXh0Vmlld3BvcnRWaXNpYmlsaXR5U3RhdGUiLCJNRURJVU0iLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImxhc3REaW1lbnNpb25zIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsImN1cnJlbnREaW1lbnNpb25zIiwiU0xPVyIsInB1Ymxpc2hlZFRyYWNrc1N1YnNjcmlwdGlvbiIsIkZBU1QiLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwic3RyZWFtU3Vic2NyaXB0aW9uIiwic291cmNlIiwic2NyZWVuU2hhcmVTdHJlYW0iLCJzcmNPYmplY3QiLCJwbGF5IiwiYmluZEF1ZGlvRWxlbWVudCIsImF1ZGlvRWxlbWVudCIsInVwZGF0ZU1lZGlhU3RyZWFtU3Vic2NyaXB0aW9uIiwic2NyZWVuU2hhcmVBdWRpb1N0cmVhbSIsInNlbGVjdGVkRGV2aWNlIiwic3BlYWtlciIsInNldFNpbmtJZCIsInNpbmtJZFN1YnNjcmlwdGlvbiIsInNlbGVjdGVkRGV2aWNlJCIsImRldmljZUlkIiwidm9sdW1lU3Vic2NyaXB0aW9uIiwidm9sdW1lJCIsInZvbHVtZSIsImF1ZGlvVm9sdW1lIiwiUGVybWlzc2lvbnNDb250ZXh0IiwicGVybWlzc2lvbnMiLCJzZXRQZXJtaXNzaW9ucyIsInNldENhbGxTZXR0aW5ncyIsInBlcm1pc3Npb24iLCJjYW5SZXF1ZXN0IiwiYXVkaW8iLCJzY3JlZW5zaGFyaW5nIiwiYWNjZXNzX3JlcXVlc3RfZW5hYmxlZCIsIkNhbGxUeXBlIiwiQ2FsbFR5cGVzUmVnaXN0cnkiLCJjYWxsVHlwZXMiLCJyZWdpc3RlciIsImNhbGxUeXBlIiwidW5yZWdpc3RlciIsIkNhbGxUeXBlcyIsImdldERldmljZXMiLCJjb25zdHJhaW50cyIsImVudW1lcmF0ZSIsImRldmljZXMiLCJtZWRpYURldmljZXMiLCJlbnVtZXJhdGVEZXZpY2VzIiwibmVlZHNHZXRVc2VyTWVkaWEiLCJsYWJlbCIsImdldFVzZXJNZWRpYSIsImRpc3Bvc2VPZk1lZGlhU3RyZWFtIiwiY29tcGxldGUiLCJjaGVja0lmQXVkaW9PdXRwdXRDaGFuZ2VTdXBwb3J0ZWQiLCJjcmVhdGVFbGVtZW50IiwiYXVkaW9EZXZpY2VDb25zdHJhaW50cyIsImF1dG9HYWluQ29udHJvbCIsIm5vaXNlU3VwcHJlc3Npb24iLCJlY2hvQ2FuY2VsbGF0aW9uIiwidmlkZW9EZXZpY2VDb25zdHJhaW50cyIsIm1lbW9pemVkT2JzZXJ2YWJsZSIsIm1lbW9pemVkIiwiZ2V0RGV2aWNlQ2hhbmdlT2JzZXJ2ZXIiLCJub3RpZnkiLCJnZXRBdWRpb0RldmljZXNPYnNlcnZlciIsImdldEF1ZGlvT3V0cHV0RGV2aWNlc09ic2VydmVyIiwiZ2V0VmlkZW9EZXZpY2VzT2JzZXJ2ZXIiLCJnZXRBdWRpb0RldmljZXMiLCJnZXRWaWRlb0RldmljZXMiLCJnZXRBdWRpb091dHB1dERldmljZXMiLCJnZXRTdHJlYW0iLCJnZXRBdWRpb1N0cmVhbSIsInRyYWNrQ29uc3RyYWludHMiLCJnZXRWaWRlb1N0cmVhbSIsImdldFNjcmVlblNoYXJlU3RyZWFtIiwiZ2V0RGlzcGxheU1lZGlhIiwiaWRlYWwiLCJzeXN0ZW1BdWRpbyIsImRldmljZUlkcyQiLCJyZWxlYXNlIiwiSW5wdXRNZWRpYURldmljZU1hbmFnZXIiLCJzdG9wT25MZWF2ZSIsImlzVHJhY2tTdG9wcGVkRHVlVG9UcmFja0VuZCIsImZpbHRlcnMiLCJkaXNwb3NlIiwiaGFuZGxlRGlzY29ubmVjdGVkT3JSZXBsYWNlZERldmljZXMiLCJsaXN0RGV2aWNlcyIsInN0YXR1cyIsImVuYWJsZVByb21pc2UiLCJ1bm11dGVTdHJlYW0iLCJzZXRTdGF0dXMiLCJmb3JjZVN0b3AiLCJwcmV2U3RhdHVzIiwiZGlzYWJsZU1vZGUiLCJkaXNhYmxlUHJvbWlzZSIsIm11dGVTdHJlYW0iLCJyZXN1bWUiLCJ0b2dnbGUiLCJyZWdpc3RlckZpbHRlciIsImFwcGx5U2V0dGluZ3NUb1N0cmVhbSIsInNldERlZmF1bHRDb25zdHJhaW50cyIsInNlbGVjdCIsInNldERldmljZSIsInN0b3BQdWJsaXNoU3RyZWFtIiwibXV0ZUxvY2FsU3RyZWFtIiwiYWxsRW5kZWQiLCJzZXRNZWRpYVN0cmVhbSIsIm11dGVUcmFja3MiLCJ1bm11dGVUcmFja3MiLCJkZWZhdWx0Q29uc3RyYWludHMiLCJjaGFpbldpdGgiLCJwYXJlbnRTdHJlYW0iLCJmaWx0ZXJTdHJlYW0iLCJwYXJlbnQiLCJvcmlnaW5hbFN0b3AiLCJwYXJlbnRUcmFjayIsImhhbmRsZVBhcmVudFRyYWNrRW5kZWQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJtZWRpYURldmljZUtpbmQiLCJwcmV2RGV2aWNlcyIsImN1cnJlbnREZXZpY2VzIiwiaXNEZXZpY2VEaXNjb25uZWN0ZWQiLCJpc0RldmljZVJlcGxhY2VkIiwiY3VycmVudERldmljZSIsImZpbmREZXZpY2VJbkxpc3QiLCJwcmV2RGV2aWNlIiwiZ3JvdXBJZCIsIklucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUiLCJwZXJtaXNzaW9uTmFtZSIsInN0YXR1c1N1YmplY3QiLCJtZWRpYVN0cmVhbVN1YmplY3QiLCJzZWxlY3RlZERldmljZVN1YmplY3QiLCJkZWZhdWx0Q29uc3RyYWludHNTdWJqZWN0IiwibWVkaWFTdHJlYW0kIiwic3RhdHVzJCIsImRlZmF1bHRDb25zdHJhaW50cyQiLCJoYXNCcm93c2VyUGVybWlzc2lvbiQiLCJub3RpZnlHcmFudGVkIiwicGVybWlzc2lvbnNBUElBdmFpbGFibGUiLCJxdWVyeSIsInBlcm1pc3Npb25TdGF0ZSIsInBlcm1pc3Npb25TdGF0dXMiLCJnZXREZXZpY2VJZEZyb21TdHJlYW0iLCJDYW1lcmFNYW5hZ2VyU3RhdGUiLCJkaXJlY3Rpb25TdWJqZWN0IiwiZGlyZWN0aW9uJCIsInNldERpcmVjdGlvbiIsImZhY2luZ01vZGUiLCJDYW1lcmFNYW5hZ2VyIiwic2VsZWN0RGlyZWN0aW9uIiwiZmxpcCIsIm5ld0RpcmVjdGlvbiIsInNlbGVjdFRhcmdldFJlc29sdXRpb24iLCJyZXNvbHV0aW9uIiwic2V0UHJlZmVycmVkQ29kZWMiLCJwdWJsaXNoVmlkZW9TdHJlYW0iLCJNaWNyb3Bob25lTWFuYWdlclN0YXRlIiwic3BlYWtpbmdXaGlsZU11dGVkU3ViamVjdCIsInNwZWFraW5nV2hpbGVNdXRlZCQiLCJzcGVha2luZ1doaWxlTXV0ZWQiLCJzZXRTcGVha2luZ1doaWxlTXV0ZWQiLCJERVRFQ1RJT05fRlJFUVVFTkNZX0lOX01TIiwiQVVESU9fTEVWRUxfVEhSRVNIT0xEJDEiLCJGRlRfU0laRSIsImNyZWF0ZVNvdW5kRGV0ZWN0b3IiLCJvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQiLCJkZXRlY3Rpb25GcmVxdWVuY3lJbk1zIiwiYXVkaW9MZXZlbFRocmVzaG9sZCIsImZmdFNpemUiLCJkZXN0cm95U3RyZWFtT25TdG9wIiwiYXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0IiwiYW5hbHlzZXIiLCJjcmVhdGVBbmFseXNlciIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwiY29ubmVjdCIsImZyZXF1ZW5jeUJpbkNvdW50IiwiZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEiLCJpc1NvdW5kRGV0ZWN0ZWQiLCJhdmVyYWdlZERhdGFWYWx1ZSIsInB2IiwiY3YiLCJwZXJjZW50YWdlIiwiZmxhdHRlbiIsIkFVRElPX0xFVkVMX1RIUkVTSE9MRCIsIlJOU3BlZWNoRGV0ZWN0b3IiLCJwYzEiLCJwYzIiLCJhZGRUcmFjayIsImF1ZGlvVHJhY2tzIiwib25TcGVha2luZ0RldGVjdGVkU3RhdGVDaGFuZ2UiLCJhdWRpb01lZGlhU291cmNlU3RhdHMiLCJNaWNyb3Bob25lTWFuYWdlciIsInN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24iLCJzdGFydFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbiIsInB1Ymxpc2hBdWRpb1N0cmVhbSIsInJuU3BlZWNoRGV0ZWN0b3IiLCJzb3VuZERldGVjdG9yQ2xlYW51cCIsIlNjcmVlblNoYXJlU3RhdGUiLCJhcmd1bWVudHMiLCJhdWRpb0VuYWJsZWRTdWJqZWN0IiwiYXVkaW9FbmFibGVkJCIsImF1ZGlvRW5hYmxlZCIsInNldEF1ZGlvRW5hYmxlZCIsImlzRW5hYmxlZCIsInNldFNldHRpbmdzIiwiU2NyZWVuU2hhcmVNYW5hZ2VyIiwiZW5hYmxlU2NyZWVuU2hhcmVBdWRpbyIsImRpc2FibGVTY3JlZW5TaGFyZUF1ZGlvIiwicHVibGlzaFNjcmVlblNoYXJlU3RyZWFtIiwiU3BlYWtlclN0YXRlIiwidm9sdW1lU3ViamVjdCIsImlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkIiwic2V0Vm9sdW1lIiwiU3BlYWtlck1hbmFnZXIiLCJzZXRQYXJ0aWNpcGFudFZvbHVtZSIsInN0cmVhbUNsaWVudCIsImNsaWVudFN0b3JlIiwid2F0Y2hpbmciLCJkeW5hc2NhbGVNYW5hZ2VyIiwidHJhY2tTdWJzY3JpcHRpb25zU3ViamVjdCIsInJlY29ubmVjdEF0dGVtcHRzIiwibWF4UmVjb25uZWN0QXR0ZW1wdHMiLCJsZWF2ZUNhbGxIb29rcyIsInN0cmVhbUNsaWVudEV2ZW50SGFuZGxlcnMiLCJvZmZIYW5kbGVyIiwiY2FsbF9jaWQiLCJyZWdpc3RlcmVkT2ZmSGFuZGxlciIsInJlamVjdCIsImFzc2VydENhbGxKb2luZWQiLCJoYXNPdGhlclBhcnRpY2lwYW50cyIsInN0YXRzUmVwb3J0ZXIiLCJzZnVTdGF0c1JlcG9ydGVyIiwiaG9vayIsInNjcmVlblNoYXJlIiwic3RvcE9uTGVhdmVQcm9taXNlcyIsInN0cmVhbUNsaWVudEJhc2VQYXRoIiwicmluZyIsInJpbmdpbmdTdWJqZWN0IiwiX2hhc0Nvbm5lY3Rpb25JRCIsImFwcGx5RGV2aWNlQ29uZmlnIiwiZ2V0T3JDcmVhdGUiLCJhY2NlcHQiLCJpc01pZ3JhdGluZyIsIk1JR1JBVElORyIsImlzUmVjb25uZWN0aW5nIiwiUkVDT05ORUNUSU5HIiwic2Z1VG9rZW4iLCJwcmV2aW91c1NmdUNsaWVudCIsInJlY29ubmVjdCIsInN0cmF0ZWd5IiwiY3VycmVudFN0YXRlIiwibWlncmF0aW5nX2Zyb20iLCJ1bnJlZ2lzdGVyR29Bd2F5IiwiUkVDT05ORUNUSU5HX0ZBSUxFRCIsInVuc3Vic2NyaWJlT25saW5lRXZlbnQiLCJvbmxpbmUiLCJjdXJyZW50Q2FsbGluZ1N0YXRlIiwic2hvdWxkUmVjb25uZWN0IiwiaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQiLCJ1bnN1YnNjcmliZU9mZmxpbmVFdmVudCIsImF1ZGlvU2V0dGluZ3MiLCJvcHVzX2R0eF9lbmFibGVkIiwicmVkdW5kYW50X2NvZGluZ19lbmFibGVkIiwid2FpdEZvckpvaW5SZXNwb25zZSIsImN1cnJlbnRQYXJ0aWNpcGFudHMiLCJwYXJ0aWNpcGFudExvb2t1cCIsImV4aXN0aW5nUGFydGljaXBhbnQiLCJpbml0Q2FtZXJhIiwiaW5pdE1pYyIsImF1ZGlvVHJhY2siLCJzY3JlZW5TaGFyZUF1ZGlvVHJhY2siLCJjaGFuZ2VzIiwiY2hhbmdlIiwicHJvcCIsInNjcmVlblNoYXJlRGltZW5zaW9uIiwicmVzZXRSZWFjdGlvbiIsImNyaXRlcmlhIiwic2VuZFJlYWN0aW9uIiwibXV0ZVNlbGYiLCJteVVzZXJJZCIsIm11dGVVc2VyIiwibXV0ZU90aGVycyIsInVzZXJJZHNUb011dGUiLCJ1c2VyX2lkcyIsIm11dGVBbGxVc2VycyIsIm11dGVfYWxsX3VzZXJzIiwic3RhcnRSZWNvcmRpbmciLCJzdG9wUmVjb3JkaW5nIiwic3RhcnRUcmFuc2NyaXB0aW9uIiwic3RvcFRyYW5zY3JpcHRpb24iLCJyZXF1ZXN0UGVybWlzc2lvbnMiLCJjYW5SZXF1ZXN0UGVybWlzc2lvbnMiLCJncmFudFBlcm1pc3Npb25zIiwidXBkYXRlVXNlclBlcm1pc3Npb25zIiwiZ3JhbnRfcGVybWlzc2lvbnMiLCJyZXZva2VQZXJtaXNzaW9ucyIsInJldm9rZV9wZXJtaXNzaW9ucyIsImdvTGl2ZSIsInN0b3BMaXZlIiwic3RhcnRITFMiLCJzdG9wSExTIiwidXBkYXRlcyIsImVuZENhbGwiLCJ1bnBpbiIsInBpbkZvckV2ZXJ5b25lIiwidW5waW5Gb3JFdmVyeW9uZSIsInF1ZXJ5TWVtYmVycyIsInVwZGF0ZUNhbGxNZW1iZXJzIiwic2NoZWR1bGVBdXRvRHJvcCIsImRyb3BUaW1lb3V0IiwidGltZW91dEluTXMiLCJhdXRvX2NhbmNlbF90aW1lb3V0X21zIiwicXVlcnlSZWNvcmRpbmdzIiwiY2FsbFNlc3Npb25JZCIsInF1ZXJ5VHJhbnNjcmlwdGlvbnMiLCJnZXRDYWxsU3RhdHMiLCJjYWxsU2Vzc2lvbklEIiwic2VuZEN1c3RvbUV2ZW50IiwidW5iaW5kIiwiYmluZENhbGxUaHVtYm5haWxFbGVtZW50IiwiaW1hZ2VFbGVtZW50IiwiaGFuZGxlRXJyb3IiLCJzcmMiLCJmYWxsYmFja0ltYWdlU291cmNlIiwidGh1bWJuYWlsVXJsIiwiVVJMIiwiaW1hZ2VfdXJsIiwic2VhcmNoUGFyYW1zIiwiY2FsbFR5cGVDb25maWciLCJwYXJ0aWNpcGFudFNvcnRlciIsIklETEUiLCJyZWdpc3RlckVmZmVjdHMiLCJwZXJtaXNzaW9uVG9UcmFja1R5cGUiLCJpc1JpbmdpbmciLCJkZWZhdWx0RGlyZWN0aW9uIiwiYmFja2VuZFNldHRpbmciLCJjYW1lcmFfZmFjaW5nIiwiY2FtZXJhX2RlZmF1bHRfb24iLCJtaWNfZGVmYXVsdF9vbiIsIkluc2lnaHRNZXRyaWNzIiwiY29ubmVjdGlvblN0YXJ0VGltZXN0YW1wIiwid3NUb3RhbEZhaWx1cmVzIiwid3NDb25zZWN1dGl2ZUZhaWx1cmVzIiwiaW5zdGFuY2VDbGllbnRJZCIsInBvc3RJbnNpZ2h0cyIsImluc2lnaHRUeXBlIiwiaW5zaWdodHMiLCJtYXhBdHRlbXB0cyIsImJ1aWxkV3NGYXRhbEluc2lnaHQiLCJjb25uZWN0aW9uIiwiYnVpbGRXc0Jhc2VJbnNpZ2h0IiwiY2xpZW50IiwicmVhZHlfc3RhdGUiLCJfYnVpbGRVcmwiLCJhcGlfa2V5Iiwic3RhcnRfdHMiLCJpbnNpZ2h0TWV0cmljcyIsImVuZF90cyIsImF1dGhfdHlwZSIsImdldEF1dGhUeXBlIiwidG9rZW5NYW5hZ2VyIiwidXNlcklEIiwidXNlcl9kZXRhaWxzIiwiX3VzZXIiLCJjbGllbnRfaWQiLCJjb25uZWN0aW9uSUQiLCJ3c19kZXRhaWxzIiwid3NfY29uc2VjdXRpdmVfZmFpbHVyZXMiLCJ3c190b3RhbF9mYWlsdXJlcyIsInJlcXVlc3RfaWQiLCJyZXF1ZXN0SUQiLCJ1c2VyX2FnZW50IiwiaW5zdGFuY2VfY2xpZW50X2lkIiwiYnVpbGRXc1N1Y2Nlc3NBZnRlckZhaWx1cmVJbnNpZ2h0IiwiaXNDbG9zZUV2ZW50IiwicmVzIiwiaXNFcnJvckV2ZW50IiwiU3RhYmxlV1NDb25uZWN0aW9uIiwiX2xvZyIsImV4dHJhIiwic2V0Q2xpZW50IiwiVVJMU2VhcmNoUGFyYW1zIiwiZ2V0VXNlckFnZW50Iiwid3NCYXNlVVJMIiwib25saW5lU3RhdHVzQ2hhbmdlZCIsIl9zZXRIZWFsdGgiLCJpc0hlYWx0aHkiLCJfcmVjb25uZWN0IiwiaW50ZXJ2YWwiLCJvbm9wZW4iLCJ3c0lEIiwiX2dldFRva2VuIiwiYXV0aE1lc3NhZ2UiLCJhdXRoZW50aWNhdGlvblNlbnQiLCJvbm1lc3NhZ2UiLCJpc1Jlc29sdmVkIiwicmVqZWN0UHJvbWlzZSIsIl9lcnJvckZyb21XU0V2ZW50IiwibGFzdEV2ZW50Iiwic2NoZWR1bGVOZXh0UGluZyIsInJlc29sdmVQcm9taXNlIiwiaXNDb25uZWN0aW5nIiwiY29uc2VjdXRpdmVGYWlsdXJlcyIsImlzU3RhdGljIiwiY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZiIsInJlZnJlc2hUb2tlbiIsIm9uY2xvc2UiLCJ3YXNDbGVhbiIsInRvdGFsRmFpbHVyZXMiLCJvbmVycm9yIiwiaGVhbHRoeSIsImRpc3BhdGNoSW1tZWRpYXRlbHkiLCJpc1dTRmFpbHVyZSIsInN0YXR1c0NvZGUiLCJTdGF0dXNDb2RlIiwiX3NldHVwQ29ubmVjdGlvblByb21pc2UiLCJjb25uZWN0aW9uT3BlbiIsImhlYWx0aENoZWNrVGltZW91dFJlZiIsImNsaWVudElEIiwicGluZ0ludGVydmFsIiwiaXNEaXNjb25uZWN0ZWQiLCJoZWFsdGhDaGVjayIsIl9jb25uZWN0IiwiX3dhaXRGb3JIZWFsdGh5IiwicmFjZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImlzQ2xvc2VkUHJvbWlzZSIsImVuYWJsZVdTRmFsbGJhY2siLCJpc1Rva2VuUmVhZHkiLCJ0b2tlblJlYWR5IiwibG9hZFRva2VuIiwid3NVUkwiLCJjb25uZWN0aW9uX2lkIiwicmVzb2x2ZUNvbm5lY3Rpb25JZCIsImVuYWJsZUluc2lnaHRzIiwicmVqZWN0Q29ubmVjdGlvbklkIiwiX2Rlc3Ryb3lDdXJyZW50V1NDb25uZWN0aW9uIiwiaXNTdHJpbmciLCJhcnJheU9yU3RyaW5nIiwiaXNNYXBTdHJpbmdDYWxsYmFjayIsImNhbGxiYWNrIiwiY2hhckF0Iiwia1ZhbHVlIiwibWFwcGVkVmFsdWUiLCJlbmNvZGVCYXNlNjQiLCJjaGFyIiwiY2hhckNvZGVBdCIsImRlY29kZUJhc2U2NCIsImZyb21DaGFyQ29kZSIsIkwiLCJ4IiwiQSIsIkpXVFVzZXJUb2tlbiIsImFwaVNlY3JldCIsImV4dHJhRGF0YSIsImp3dE9wdGlvbnMiLCJUeXBlRXJyb3IiLCJzaWduIiwiYWxnb3JpdGhtIiwibm9UaW1lc3RhbXAiLCJpYXQiLCJKV1RTZXJ2ZXJUb2tlbiIsIlVzZXJGcm9tVG9rZW4iLCJmcmFnbWVudHMiLCJiNjRQYXlsb2FkIiwiRGV2VG9rZW4iLCJUb2tlbk1hbmFnZXIiLCJzZWNyZXQiLCJzZXRUb2tlbk9yUHJvdmlkZXIiLCJ0b2tlbk9yUHJvdmlkZXIiLCJpc0Fub255bW91cyIsInZhbGlkYXRlVG9rZW4iLCJ0b2tlblByb3ZpZGVyIiwicmVzZXQiLCJsb2FkVG9rZW5Qcm9taXNlIiwidG9rZW5Vc2VySWQiLCJnZXRUb2tlbiIsIkFQSUVycm9yQ29kZXMiLCJpc0FQSUVycm9yIiwiaXNFcnJvclJldHJ5YWJsZSIsImlzQ29ubmVjdGlvbklERXJyb3IiLCJpc0Vycm9yUmVzcG9uc2UiLCJDb25uZWN0aW9uU3RhdGUiLCJXU0Nvbm5lY3Rpb25GYWxsYmFjayIsIl9vbmxpbmVTdGF0dXNDaGFuZ2VkIiwiX3NldFN0YXRlIiwiQ2xvc2VkIiwiY2FuY2VsVG9rZW4iLCJjYW5jZWwiLCJfcmVxIiwicmV0cnkiLCJDYW5jZWxUb2tlbiIsImRvQXhpb3NSZXF1ZXN0IiwiYmFzZVVSTCIsInB1YmxpY0VuZHBvaW50IiwiX3BvbGwiLCJDb25uZWN0ZWQiLCJpc0NhbmNlbCIsIkRpc2Nvbm5lY3RlZCIsIkNvbm5lY3RpbmciLCJfYnVpbGRXU1BheWxvYWQiLCJJbml0IiwiSElOVF9VUkwiLCJoaW50VXJsIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnQiLCJmZXRjaCIsImF3c1BvcCIsIlN0cmVhbUNsaWVudCIsIm5leHRSZXF1ZXN0QWJvcnRDb250cm9sbGVyIiwiZGV2VG9rZW4iLCJzZXRCYXNlVVJMIiwiaGludCIsImxvY2F0aW9uSGludCIsImxvY2F0aW9uSGludFVybCIsImxvY2F0aW9uSGludFRpbWVvdXQiLCJfZ2V0Q29ubmVjdGlvbklEIiwid3NDb25uZWN0aW9uIiwid3NGYWxsYmFjayIsImNvbm5lY3RVc2VyIiwidXNlclRva2VuT3JQcm92aWRlciIsInNldFVzZXJQcm9taXNlIiwiX2lzVXNpbmdTZXJ2ZXJBdXRoIiwibm9kZSIsImFsbG93U2VydmVyU2lkZUNvbm5lY3QiLCJzZXRUb2tlblByb21pc2UiLCJfc2V0VG9rZW4iLCJfc2V0VXNlciIsIndzUHJvbWlzZSIsIm9wZW5Db25uZWN0aW9uIiwicGVyc2lzdFVzZXJPbkNvbm5lY3Rpb25GYWlsdXJlIiwiY2xvc2VDb25uZWN0aW9uIiwiZGlzY29ubmVjdFVzZXIiLCJjbGVhbmluZ0ludGVydmFsUmVmIiwiY29ubmVjdGlvbklkUHJvbWlzZSIsIl9ub3JtYWxpemVEYXRlIiwiYmVmb3JlIiwiY29ubmVjdEd1ZXN0VXNlciIsImd1ZXN0VXNlckNyZWF0ZVByb21pc2UiLCJmaW5hbGx5IiwiYWNjZXNzX3Rva2VuIiwiY29ubmVjdEFub255bW91c1VzZXIiLCJfbG9nQXBpUmVxdWVzdCIsIl9sb2dBcGlSZXNwb25zZSIsIl9sb2dBcGlFcnJvciIsInJlcXVlc3RDb25maWciLCJfZW5yaWNoQXhpb3NPcHRpb25zIiwiYXhpb3NJbnN0YW5jZSIsInB1dCIsImhhbmRsZVJlc3BvbnNlIiwiY2xpZW50X3JlcXVlc3RfaWQiLCJlcnJvckZyb21SZXNwb25zZSIsInJlY2VpdmVkX2F0IiwibGlzdGVuZXIiLCJ3YXJtVXAiLCJfc2F5SGkiLCJkZWZhdWx0V1NUaW1lb3V0V2l0aEZhbGxiYWNrIiwiZGVmYXVsdFdTVGltZW91dCIsIm1vZGUiLCJzZXRVc2VyQWdlbnQiLCJhdXRob3JpemF0aW9uIiwiYXhpb3NSZXF1ZXN0Q29uZmlnIiwiY3JlYXRlQWJvcnRDb250cm9sbGVyRm9yTmV4dFJlcXVlc3QiLCJjcmVhdGVUb2tlbiIsImV4cCIsImNhbGxfY2lkcyIsImlucHV0T3B0aW9ucyIsIndpdGhDcmVkZW50aWFscyIsImh0dHBzQWdlbnQiLCJBZ2VudCIsImtlZXBBbGl2ZU1zZWNzIiwicHJvY2VzcyIsImVudiIsIlNUUkVBTV9MT0NBTF9URVNUX1JVTiIsIlNUUkVBTV9MT0NBTF9URVNUX0hPU1QiLCJTdHJlYW1WaWRlb0NsaWVudCIsImFwaUtleU9yQXJncyIsImV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIiLCJjb25uZWN0aW9uUHJvbWlzZSIsImRpc2Nvbm5lY3Rpb25Qcm9taXNlIiwid3JpdGVhYmxlU3RhdGVTdG9yZSIsImNyZWF0ZUd1ZXN0VXNlciIsInF1ZXJ5Q2FsbHMiLCJ3YXRjaCIsInF1ZXJ5Q2FsbFN0YXRzIiwiZWRnZXMiLCJhZGREZXZpY2UiLCJwdXNoX3Byb3ZpZGVyIiwicHVzaF9wcm92aWRlcl9uYW1lIiwidm9pcF90b2tlbiIsInJlbW92ZURldmljZSIsIm9uUmluZ2luZ0NhbGwiLCJyZWFkT25seVN0YXRlU3RvcmUiLCJjYWxsSWQiLCJhcGlLZXkiLCJjb25uZWN0VXNlclJlc3BvbnNlIiwibWUiLCJjYWxsc1RvUmVXYXRjaCIsImZpbHRlcl9jb25kaXRpb25zIiwiJGluIiwiZmllbGQiLCJuZXdDYWxsIiwicHJldkNhbGwiLCJ0aGVDYWxsIiwiYWRkVm9pcERldmljZSIsIlN0cmVhbVZpZGVvU2VydmVyQ2xpZW50IiwiZ2V0Q2FsbFR5cGVzIiwiZ2V0Q2FsbFR5cGUiLCJjcmVhdGVDYWxsVHlwZSIsImRlbGV0ZUNhbGxUeXBlIiwidXBkYXRlQ2FsbFR5cGUiLCJsaXN0RXh0ZXJuYWxTdG9yYWdlIiwiY3JlYXRlRXh0ZXJuYWxTdG9yYWdlIiwiZGVsZXRlRXh0ZXJuYWxTdG9yYWdlIiwidXBkYXRlRXh0ZXJuYWxTdG9yYWdlIiwiY2hlY2tFeHRlcm5hbFN0b3JhZ2UiLCJCcm93c2VycyIsIlJ4VXRpbHMiLCJTZnVFdmVudHMiLCJTZnVNb2RlbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stream-io/video-filters-web/dist/index.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@stream-io/video-filters-web/dist/index.es.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SegmentationLevel: () => (/* binding */ SegmentationLevel),\n/* harmony export */   createRenderer: () => (/* binding */ createRenderer),\n/* harmony export */   isPlatformSupported: () => (/* binding */ isPlatformSupported),\n/* harmony export */   loadTFLite: () => (/* binding */ loadTFLite)\n/* harmony export */ });\n/* harmony import */ var wasm_feature_detect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wasm-feature-detect */ \"(ssr)/./node_modules/wasm-feature-detect/dist/esm/index.js\");\n\n\n/**\n * Checks if the current platform is a mobile device.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n */\nconst isMobile = () => /Mobi/i.test(navigator.userAgent);\n/**\n * Runs a check to see if the current platform supports\n * the necessary APIs required for the video filters.\n */\nconst isPlatformSupported = async () => typeof document !== 'undefined' &&\n    typeof window !== 'undefined' &&\n    typeof navigator !== 'undefined' &&\n    !isMobile() && // we don't support mobile devices yet due to performance issues\n    typeof WebAssembly !== 'undefined' &&\n    !!window.WebGL2RenderingContext && // WebGL2 is required for the video filters\n    !!document.createElement('canvas').getContext('webgl2') &&\n    (await (0,wasm_feature_detect__WEBPACK_IMPORTED_MODULE_0__.simd)()); // SIMD is required for the wasm module\n\n/**\n * Use it along with boyswan.glsl-literal VSCode extension\n * to get GLSL syntax highlighting.\n * https://marketplace.visualstudio.com/items?itemName=boyswan.glsl-literal\n *\n * On VSCode OSS, boyswan.glsl-literal requires slevesque.shader extension\n * to be installed as well.\n * https://marketplace.visualstudio.com/items?itemName=slevesque.shader\n */\nconst glsl = String.raw;\nfunction createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer) {\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    const texCoordAttributeLocation = gl.getAttribLocation(program, 'a_texCoord');\n    gl.enableVertexAttribArray(texCoordAttributeLocation);\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    return program;\n}\nfunction createProgram(gl, vertexShader, fragmentShader) {\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error(`Could not link WebGL program: ${gl.getProgramInfoLog(program)}`);\n    }\n    return program;\n}\nfunction compileShader(gl, shaderType, shaderSource) {\n    const shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        throw new Error(`Could not compile shader: ${gl.getShaderInfoLog(shader)}`);\n    }\n    return shader;\n}\nfunction createTexture(gl, internalformat, width, height, minFilter = gl.NEAREST, magFilter = gl.NEAREST) {\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n    gl.texStorage2D(gl.TEXTURE_2D, 1, internalformat, width, height);\n    return texture;\n}\nasync function readPixelsAsync(gl, x, y, width, height, format, type, dest) {\n    const buf = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);\n    gl.readPixels(x, y, width, height, format, type, 0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);\n    gl.deleteBuffer(buf);\n    return dest;\n}\nasync function getBufferSubDataAsync(gl, target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {\n    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    const res = await clientWaitAsync(gl, sync);\n    gl.deleteSync(sync);\n    if (res !== gl.WAIT_FAILED) {\n        gl.bindBuffer(target, buffer);\n        gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);\n        gl.bindBuffer(target, null);\n    }\n}\nfunction clientWaitAsync(gl, sync) {\n    return new Promise((resolve) => {\n        function test() {\n            const res = gl.clientWaitSync(sync, 0, 0);\n            if (res === gl.WAIT_FAILED) {\n                resolve(res);\n                return;\n            }\n            if (res === gl.TIMEOUT_EXPIRED) {\n                setTimeout(test);\n                return;\n            }\n            resolve(res);\n        }\n        setTimeout(test);\n    });\n}\n\nfunction buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {\n    const blurPass = buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel);\n    const blendPass = buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas);\n    function render() {\n        blurPass.render();\n        blendPass.render();\n    }\n    function updateCoverage(coverage) {\n        blendPass.updateCoverage(coverage);\n    }\n    function cleanUp() {\n        blendPass.cleanUp();\n        blurPass.cleanUp();\n    }\n    return {\n        render,\n        updateCoverage,\n        cleanUp,\n    };\n}\nfunction buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {\n    const weights = blurLevel === 'low'\n        ? [0.227027027, 0.1545945946, 0.1016216216, 0.0340540541, 0.0142162162]\n        : blurLevel === 'medium'\n            ? [0.327027027, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162]\n            : [0.627027027, 0.3445945946, 0.2216216216, 0.0540540541, 0.0162162162];\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform vec2 u_texelSize;\n\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    const float offset[5] = float[](0.0, 1.0, 2.0, 3.0, 4.0);\n    const float weight[5] = float[](\n      ${weights.join(',')}\n    );\n\n    void main() {\n      vec4 centerColor = texture(u_inputFrame, v_texCoord);\n      float personMask = texture(u_personMask, v_texCoord).a;\n\n      vec4 frameColor = centerColor * weight[0] * (1.0 - personMask);\n\n      for (int i = 1; i < 5; i++) {\n        vec2 offset = vec2(offset[i]) * u_texelSize;\n\n        vec2 texCoord = v_texCoord + offset;\n        frameColor += texture(u_inputFrame, texCoord)\n           * weight[i]\n           * (1.0 - texture(u_personMask, texCoord).a);\n\n        texCoord = v_texCoord - offset;\n        frameColor += texture(u_inputFrame, texCoord)\n          * weight[i]\n          * (1.0 - texture(u_personMask, texCoord).a);\n      }\n      outColor = vec4(frameColor.rgb + (1.0 - frameColor.a) * centerColor.rgb, 1.0);\n    }\n  `;\n    const scale = 0.5;\n    const outputWidth = canvas.width * scale;\n    const outputHeight = canvas.height * scale;\n    const texelWidth = 1 / outputWidth;\n    const texelHeight = 1 / outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize');\n    const texture1 = createTexture(gl, gl.RGBA8, outputWidth, outputHeight, gl.NEAREST, \n    // @ts-expect-error types are incomplete\n    gl.LINEAR);\n    const texture2 = createTexture(gl, gl.RGBA8, outputWidth, outputHeight, gl.NEAREST, \n    // @ts-expect-error types are incomplete\n    gl.LINEAR);\n    const frameBuffer1 = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture1, 0);\n    const frameBuffer2 = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2, 0);\n    gl.useProgram(program);\n    gl.uniform1i(personMaskLocation, 1);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.uniform1i(inputFrameLocation, 0);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);\n        for (let i = 0; i < 3; i++) {\n            gl.uniform2f(texelSizeLocation, 0, texelHeight);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            gl.activeTexture(gl.TEXTURE2);\n            gl.bindTexture(gl.TEXTURE_2D, texture1);\n            gl.uniform1i(inputFrameLocation, 2);\n            gl.uniform2f(texelSizeLocation, texelWidth, 0);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n            gl.bindTexture(gl.TEXTURE_2D, texture2);\n        }\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer2);\n        gl.deleteFramebuffer(frameBuffer1);\n        gl.deleteTexture(texture2);\n        gl.deleteTexture(texture1);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return {\n        render,\n        cleanUp,\n    };\n}\nfunction buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas) {\n    const vertexShaderSource = glsl `#version 300 es\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `;\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_blurredInputFrame;\n    uniform vec2 u_coverage;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    void main() {\n      vec3 color = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 blurredColor = texture(u_blurredInputFrame, v_texCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(mix(blurredColor, color, personMask), 1.0);\n    }\n  `;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const blurredInputFrame = gl.getUniformLocation(program, 'u_blurredInputFrame');\n    const coverageLocation = gl.getUniformLocation(program, 'u_coverage');\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(personMaskLocation, 1);\n    gl.uniform1i(blurredInputFrame, 2);\n    gl.uniform2f(coverageLocation, 0, 1);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateCoverage(coverage) {\n        gl.useProgram(program);\n        gl.uniform2f(coverageLocation, coverage[0], coverage[1]);\n    }\n    function cleanUp() {\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n    }\n    return {\n        render,\n        updateCoverage,\n        cleanUp,\n    };\n}\n\nfunction buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas) {\n    const vertexShaderSource = glsl `#version 300 es\n\n    uniform vec2 u_backgroundScale;\n    uniform vec2 u_backgroundOffset;\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n    out vec2 v_backgroundCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n      v_backgroundCoord = a_texCoord * u_backgroundScale + u_backgroundOffset;\n    }\n  `;\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_background;\n    uniform vec2 u_coverage;\n    uniform float u_lightWrapping;\n    uniform float u_blendMode;\n\n    in vec2 v_texCoord;\n    in vec2 v_backgroundCoord;\n\n    out vec4 outColor;\n\n    vec3 screen(vec3 a, vec3 b) {\n      return 1.0 - (1.0 - a) * (1.0 - b);\n    }\n\n    vec3 linearDodge(vec3 a, vec3 b) {\n      return a + b;\n    }\n\n    void main() {\n      vec3 frameColor = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 backgroundColor = texture(u_background, v_backgroundCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      float lightWrapMask = 1.0 - max(0.0, personMask - u_coverage.y) / (1.0 - u_coverage.y);\n      vec3 lightWrap = u_lightWrapping * lightWrapMask * backgroundColor;\n\n      frameColor = u_blendMode * linearDodge(frameColor, lightWrap)\n        + (1.0 - u_blendMode) * screen(frameColor, lightWrap);\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(frameColor * personMask + backgroundColor * (1.0 - personMask), 1.0);\n    }\n  `;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const outputRatio = outputWidth / outputHeight;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const backgroundScaleLocation = gl.getUniformLocation(program, 'u_backgroundScale');\n    const backgroundOffsetLocation = gl.getUniformLocation(program, 'u_backgroundOffset');\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const personMaskLocation = gl.getUniformLocation(program, 'u_personMask');\n    const backgroundLocation = gl.getUniformLocation(program, 'u_background');\n    const coverageLocation = gl.getUniformLocation(program, 'u_coverage');\n    const lightWrappingLocation = gl.getUniformLocation(program, 'u_lightWrapping');\n    const blendModeLocation = gl.getUniformLocation(program, 'u_blendMode');\n    gl.useProgram(program);\n    gl.uniform2f(backgroundScaleLocation, 1, 1);\n    gl.uniform2f(backgroundOffsetLocation, 0, 0);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(personMaskLocation, 1);\n    gl.uniform2f(coverageLocation, 0, 1);\n    gl.uniform1f(lightWrappingLocation, 0);\n    gl.uniform1f(blendModeLocation, 0);\n    let backgroundTexture = null;\n    // TODO Find a better to handle background being loaded\n    if (backgroundImage?.complete) {\n        updateBackgroundImage(backgroundImage);\n    }\n    else if (backgroundImage) {\n        backgroundImage.onload = () => {\n            updateBackgroundImage(backgroundImage);\n        };\n    }\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);\n        if (backgroundTexture !== null) {\n            gl.activeTexture(gl.TEXTURE2);\n            gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);\n            // TODO Handle correctly the background not loaded yet\n            gl.uniform1i(backgroundLocation, 2);\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateBackgroundImage(bgImage) {\n        backgroundTexture = createTexture(gl, gl.RGBA8, bgImage.naturalWidth, bgImage.naturalHeight, \n        // @ts-expect-error types are incomplete\n        gl.LINEAR, gl.LINEAR);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, bgImage.naturalWidth, bgImage.naturalHeight, gl.RGBA, gl.UNSIGNED_BYTE, bgImage);\n        let xOffset = 0;\n        let yOffset = 0;\n        let backgroundWidth = bgImage.naturalWidth;\n        let backgroundHeight = bgImage.naturalHeight;\n        const backgroundRatio = backgroundWidth / backgroundHeight;\n        if (backgroundRatio < outputRatio) {\n            backgroundHeight = backgroundWidth / outputRatio;\n            yOffset = (bgImage.naturalHeight - backgroundHeight) / 2;\n        }\n        else {\n            backgroundWidth = backgroundHeight * outputRatio;\n            xOffset = (bgImage.naturalWidth - backgroundWidth) / 2;\n        }\n        const xScale = backgroundWidth / bgImage.naturalWidth;\n        const yScale = backgroundHeight / bgImage.naturalHeight;\n        xOffset /= bgImage.naturalWidth;\n        yOffset /= bgImage.naturalHeight;\n        gl.uniform2f(backgroundScaleLocation, xScale, yScale);\n        gl.uniform2f(backgroundOffsetLocation, xOffset, yOffset);\n    }\n    function updateCoverage(coverage) {\n        gl.useProgram(program);\n        gl.uniform2f(coverageLocation, coverage[0], coverage[1]);\n    }\n    function updateLightWrapping(lightWrapping) {\n        gl.useProgram(program);\n        gl.uniform1f(lightWrappingLocation, lightWrapping);\n    }\n    function updateBlendMode(blendMode) {\n        gl.useProgram(program);\n        gl.uniform1f(blendModeLocation, blendMode === 'screen' ? 0 : 1);\n    }\n    function cleanUp() {\n        gl.deleteTexture(backgroundTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n    }\n    return {\n        render,\n        updateCoverage,\n        updateLightWrapping,\n        updateBlendMode,\n        cleanUp,\n    };\n}\n\nfunction buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, inputTexture, outputTexture, canvas, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_segmentationMask;\n    uniform vec2 u_texelSize;\n    uniform float u_step;\n    uniform float u_radius;\n    uniform float u_offset;\n    uniform float u_sigmaTexel;\n    uniform float u_sigmaColor;\n\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    float gaussian(float x, float sigma) {\n      float coeff = -0.5 / (sigma * sigma * 4.0 + 1.0e-6);\n      return exp((x * x) * coeff);\n    }\n\n    void main() {\n      vec2 centerCoord = v_texCoord;\n      vec3 centerColor = texture(u_inputFrame, centerCoord).rgb;\n      float newVal = 0.0;\n\n      float spaceWeight = 0.0;\n      float colorWeight = 0.0;\n      float totalWeight = 0.0;\n\n      // Subsample kernel space.\n      for (float i = -u_radius + u_offset; i <= u_radius; i += u_step) {\n        for (float j = -u_radius + u_offset; j <= u_radius; j += u_step) {\n          vec2 shift = vec2(j, i) * u_texelSize;\n          vec2 coord = vec2(centerCoord + shift);\n          vec3 frameColor = texture(u_inputFrame, coord).rgb;\n          float outVal = texture(u_segmentationMask, coord).a;\n\n          spaceWeight = gaussian(distance(centerCoord, coord), u_sigmaTexel);\n          colorWeight = gaussian(distance(centerColor, frameColor), u_sigmaColor);\n          totalWeight += spaceWeight * colorWeight;\n\n          newVal += spaceWeight * colorWeight * outVal;\n        }\n      }\n      newVal /= totalWeight;\n\n      outColor = vec4(vec3(0.0), newVal);\n    }\n  `;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const { width: outputWidth, height: outputHeight } = canvas;\n    const texelWidth = 1 / outputWidth;\n    const texelHeight = 1 / outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const segmentationMaskLocation = gl.getUniformLocation(program, 'u_segmentationMask');\n    const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize');\n    const stepLocation = gl.getUniformLocation(program, 'u_step');\n    const radiusLocation = gl.getUniformLocation(program, 'u_radius');\n    const offsetLocation = gl.getUniformLocation(program, 'u_offset');\n    const sigmaTexelLocation = gl.getUniformLocation(program, 'u_sigmaTexel');\n    const sigmaColorLocation = gl.getUniformLocation(program, 'u_sigmaColor');\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    gl.uniform1i(segmentationMaskLocation, 1);\n    gl.uniform2f(texelSizeLocation, texelWidth, texelHeight);\n    // Ensures default values are configured to prevent infinite\n    // loop in fragment shader\n    updateSigmaSpace(0);\n    updateSigmaColor(0);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, inputTexture);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function updateSigmaSpace(sigmaSpace) {\n        sigmaSpace *= Math.max(outputWidth / segmentationWidth, outputHeight / segmentationHeight);\n        const kSparsityFactor = 0.66; // Higher is sparser.\n        const step = Math.max(1, Math.sqrt(sigmaSpace) * kSparsityFactor);\n        const radius = sigmaSpace;\n        const offset = step > 1 ? step * 0.5 : 0;\n        const sigmaTexel = Math.max(texelWidth, texelHeight) * sigmaSpace;\n        gl.useProgram(program);\n        gl.uniform1f(stepLocation, step);\n        gl.uniform1f(radiusLocation, radius);\n        gl.uniform1f(offsetLocation, offset);\n        gl.uniform1f(sigmaTexelLocation, sigmaTexel);\n    }\n    function updateSigmaColor(sigmaColor) {\n        gl.useProgram(program);\n        gl.uniform1f(sigmaColorLocation, sigmaColor);\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, updateSigmaSpace, updateSigmaColor, cleanUp };\n}\n\nfunction buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n    uniform sampler2D u_inputFrame;\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    void main() {\n      outColor = texture(u_inputFrame, v_texCoord);\n    }\n  `;\n    // TFLite memory will be accessed as float32\n    const tfliteInputMemoryOffset = tflite._getInputMemoryOffset() / 4;\n    const { width: outputWidth, height: outputHeight } = segmentationConfig;\n    const outputPixelCount = outputWidth * outputHeight;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame');\n    const outputTexture = createTexture(gl, gl.RGBA8, outputWidth, outputHeight);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    const outputPixels = new Uint8Array(outputPixelCount * 4);\n    gl.useProgram(program);\n    gl.uniform1i(inputFrameLocation, 0);\n    function render() {\n        gl.viewport(0, 0, outputWidth, outputHeight);\n        gl.useProgram(program);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        // Downloads pixels asynchronously from GPU while rendering the current frame.\n        // The pixels will be available in the next frame render which results\n        // in offsets in the segmentation output but increases the frame rate.\n        readPixelsAsync(gl, 0, 0, outputWidth, outputHeight, gl.RGBA, gl.UNSIGNED_BYTE, outputPixels);\n        for (let i = 0; i < outputPixelCount; i++) {\n            const tfliteIndex = tfliteInputMemoryOffset + i * 3;\n            const outputIndex = i * 4;\n            tflite.HEAPF32[tfliteIndex] = outputPixels[outputIndex] / 255;\n            tflite.HEAPF32[tfliteIndex + 1] = outputPixels[outputIndex + 1] / 255;\n            tflite.HEAPF32[tfliteIndex + 2] = outputPixels[outputIndex + 2] / 255;\n        }\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteTexture(outputTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, cleanUp };\n}\n\nfunction buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, outputTexture, segmentationConfig) {\n    const fragmentShaderSource = glsl `#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputSegmentation;\n    in vec2 v_texCoord;\n    out vec4 outColor;\n\n    void main() {\n      vec2 segmentation = texture(u_inputSegmentation, v_texCoord).rg;\n      float shift = max(segmentation.r, segmentation.g);\n      float backgroundExp = exp(segmentation.r - shift);\n      float personExp = exp(segmentation.g - shift);\n      outColor = vec4(vec3(0.0), personExp / (backgroundExp + personExp));\n    }\n  `;\n    // TFLite memory will be accessed as float32\n    const tfliteOutputMemoryOffset = tflite._getOutputMemoryOffset() / 4;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n    const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);\n    const inputLocation = gl.getUniformLocation(program, 'u_inputSegmentation');\n    const inputTexture = createTexture(gl, gl.RG32F, segmentationWidth, segmentationHeight);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);\n    gl.useProgram(program);\n    gl.uniform1i(inputLocation, 1);\n    function render() {\n        gl.viewport(0, 0, segmentationWidth, segmentationHeight);\n        gl.useProgram(program);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, inputTexture);\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, segmentationWidth, segmentationHeight, gl.RG, gl.FLOAT, tflite.HEAPF32, tfliteOutputMemoryOffset);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    }\n    function cleanUp() {\n        gl.deleteFramebuffer(frameBuffer);\n        gl.deleteTexture(inputTexture);\n        gl.deleteProgram(program);\n        gl.deleteShader(fragmentShader);\n    }\n    return { render, cleanUp };\n}\n\nfunction buildWebGL2Pipeline(videoSource, backgroundImage, blurLevel, backgroundFilter, canvas, tflite, segmentationConfig) {\n    const gl = canvas.getContext('webgl2');\n    if (!gl)\n        throw new Error('WebGL2 is not supported');\n    const { width: frameWidth, height: frameHeight } = videoSource;\n    const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;\n    const vertexShaderSource = glsl `#version 300 es\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n    out vec2 v_texCoord;\n\n    void main() {\n      gl_Position = vec4(a_position, 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `;\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const vertexArray = gl.createVertexArray();\n    gl.bindVertexArray(vertexArray);\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    const texCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    // We don't use texStorage2D here because texImage2D seems faster\n    // to upload video texture than texSubImage2D even though the latter\n    // is supposed to be the recommended way:\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#use_texstorage_to_create_textures\n    const inputFrameTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    // TODO Rename segmentation and person mask to be more specific\n    const segmentationTexture = createTexture(gl, gl.RGBA8, segmentationWidth, segmentationHeight);\n    const personMaskTexture = createTexture(gl, gl.RGBA8, frameWidth, frameHeight);\n    const resizingStage = buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig);\n    const loadSegmentationStage = buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationTexture, segmentationConfig);\n    const jointBilateralFilterStage = buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, segmentationTexture, personMaskTexture, canvas, segmentationConfig);\n    const backgroundStage = backgroundFilter === 'blur'\n        ? buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel || 'high')\n        : buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas);\n    function render() {\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);\n        // texImage2D seems faster than texSubImage2D to upload\n        // video texture\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoSource);\n        gl.bindVertexArray(vertexArray);\n        resizingStage.render();\n        tflite._runInference();\n        loadSegmentationStage.render();\n        jointBilateralFilterStage.render();\n        backgroundStage.render();\n    }\n    function updatePostProcessingConfig() {\n        jointBilateralFilterStage.updateSigmaSpace(1);\n        jointBilateralFilterStage.updateSigmaColor(0.1);\n        if (backgroundFilter === 'image') {\n            const backgroundImageStage = backgroundStage;\n            backgroundImageStage.updateCoverage([0.5, 0.75]);\n            backgroundImageStage.updateLightWrapping(0.3);\n            backgroundImageStage.updateBlendMode('screen');\n        }\n        else if (backgroundFilter === 'blur') {\n            const backgroundBlurStage = backgroundStage;\n            backgroundBlurStage.updateCoverage([0.5, 0.75]);\n        }\n        else {\n            // TODO Handle no background in a separate pipeline path\n            const backgroundImageStage = backgroundStage;\n            backgroundImageStage.updateCoverage([0, 0.9999]);\n            backgroundImageStage.updateLightWrapping(0);\n        }\n    }\n    function cleanUp() {\n        backgroundStage.cleanUp();\n        jointBilateralFilterStage.cleanUp();\n        loadSegmentationStage.cleanUp();\n        resizingStage.cleanUp();\n        gl.deleteTexture(personMaskTexture);\n        gl.deleteTexture(segmentationTexture);\n        gl.deleteTexture(inputFrameTexture);\n        gl.deleteBuffer(texCoordBuffer);\n        gl.deleteBuffer(positionBuffer);\n        gl.deleteVertexArray(vertexArray);\n        gl.deleteShader(vertexShader);\n    }\n    return { render, updatePostProcessingConfig, cleanUp };\n}\n\nvar SegmentationLevel;\n(function (SegmentationLevel) {\n    SegmentationLevel[\"LOW\"] = \"low\";\n    SegmentationLevel[\"HIGH\"] = \"high\";\n})(SegmentationLevel || (SegmentationLevel = {}));\nconst getSegmentationParams = (level) => {\n    if (level === SegmentationLevel.HIGH) {\n        return { width: 256, height: 144 };\n    }\n    return { width: 160, height: 96 };\n};\n\nfunction createRenderer(tflite, videoSource, targetCanvas, options) {\n    const { backgroundFilter, backgroundImage, backgroundBlurLevel, segmentationLevel = SegmentationLevel.HIGH, fps = 30, } = options;\n    if (backgroundFilter === 'image' && !backgroundImage) {\n        throw new Error(`backgroundImage element is required when backgroundFilter is image`);\n    }\n    const pipeline = buildWebGL2Pipeline(videoSource, backgroundImage, backgroundBlurLevel, backgroundFilter, targetCanvas, tflite, getSegmentationParams(segmentationLevel));\n    const id = setInterval(() => {\n        pipeline.render();\n        if (backgroundFilter === 'image') {\n            pipeline.updatePostProcessingConfig();\n        }\n    }, 1000 / (fps <= 0 ? 30 : fps));\n    return {\n        dispose: () => {\n            pipeline.cleanUp();\n            clearInterval(id);\n        },\n    };\n}\n\nconst createTFLiteSIMDModule = (__Module) => {\n  __Module = __Module || {};\n\n  var _scriptDir =\n    typeof document !== 'undefined' && document.currentScript\n      ? document.currentScript.src\n      : undefined;\n\n  var Module = typeof __Module != 'undefined' ? __Module : {};\n  var readyPromiseResolve, readyPromiseReject;\n  Module['ready'] = new Promise(function (resolve, reject) {\n    readyPromiseResolve = resolve;\n    readyPromiseReject = reject;\n  });\n  var moduleOverrides = Object.assign({}, Module);\n  var thisProgram = './this.program';\n  var quit_ = (status, toThrow) => {\n    throw toThrow;\n  };\n  var ENVIRONMENT_IS_WEB = true;\n  var scriptDirectory = '';\n\n  function locateFile(path) {\n    if (Module['locateFile']) {\n      return Module['locateFile'](path, scriptDirectory);\n    }\n    return scriptDirectory + path;\n  }\n\n  var readBinary;\n  {\n    if (typeof document != 'undefined' && document.currentScript) {\n      scriptDirectory = document.currentScript.src;\n    }\n    if (_scriptDir) {\n      scriptDirectory = _scriptDir;\n    }\n    if (scriptDirectory.indexOf('blob:') !== 0) {\n      scriptDirectory = scriptDirectory.substr(\n        0,\n        scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,\n      );\n    } else {\n      scriptDirectory = '';\n    }\n  }\n  var out = Module['print'] || console.log.bind(console);\n  var err = Module['printErr'] || console.warn.bind(console);\n  Object.assign(Module, moduleOverrides);\n  moduleOverrides = null;\n  if (Module['arguments']) Module['arguments'];\n  if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n  if (Module['quit']) quit_ = Module['quit'];\n  var wasmBinary;\n  if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n  var noExitRuntime = Module['noExitRuntime'] || true;\n  if (typeof WebAssembly != 'object') {\n    abort('no native wasm support detected');\n  }\n  var wasmMemory;\n  var ABORT = false;\n\n  var UTF8Decoder =\n    typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\n\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n    var endIdx = idx + maxBytesToRead;\n    var endPtr = idx;\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n    }\n    var str = '';\n    while (idx < endPtr) {\n      var u0 = heapOrArray[idx++];\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n      var u1 = heapOrArray[idx++] & 63;\n      if ((u0 & 224) == 192) {\n        str += String.fromCharCode(((u0 & 31) << 6) | u1);\n        continue;\n      }\n      var u2 = heapOrArray[idx++] & 63;\n      if ((u0 & 240) == 224) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u0 =\n          ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 65536;\n        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n      }\n    }\n    return str;\n  }\n\n  var buffer, HEAP8, HEAPU8, HEAPU32;\n\n  function updateGlobalBufferAndViews(buf) {\n    buffer = buf;\n    Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n    Module['HEAP16'] = new Int16Array(buf);\n    Module['HEAP32'] = new Int32Array(buf);\n    Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n    Module['HEAPU16'] = new Uint16Array(buf);\n    Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n    Module['HEAPF32'] = new Float32Array(buf);\n    Module['HEAPF64'] = new Float64Array(buf);\n  }\n\n  Module['INITIAL_MEMORY'] || 16777216;\n  var __ATPRERUN__ = [];\n  var __ATINIT__ = [];\n  var __ATPOSTRUN__ = [];\n\n  function keepRuntimeAlive() {\n    return noExitRuntime;\n  }\n\n  function preRun() {\n    if (Module['preRun']) {\n      if (typeof Module['preRun'] == 'function')\n        Module['preRun'] = [Module['preRun']];\n      while (Module['preRun'].length) {\n        addOnPreRun(Module['preRun'].shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPRERUN__);\n  }\n\n  function initRuntime() {\n    callRuntimeCallbacks(__ATINIT__);\n  }\n\n  function postRun() {\n    if (Module['postRun']) {\n      if (typeof Module['postRun'] == 'function')\n        Module['postRun'] = [Module['postRun']];\n      while (Module['postRun'].length) {\n        addOnPostRun(Module['postRun'].shift());\n      }\n    }\n    callRuntimeCallbacks(__ATPOSTRUN__);\n  }\n\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb);\n  }\n\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb);\n  }\n\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb);\n  }\n\n  var runDependencies = 0;\n  var dependenciesFulfilled = null;\n\n  function addRunDependency(id) {\n    runDependencies++;\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies);\n    }\n  }\n\n  function removeRunDependency(id) {\n    runDependencies--;\n    if (Module['monitorRunDependencies']) {\n      Module['monitorRunDependencies'](runDependencies);\n    }\n    if (runDependencies == 0) {\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback();\n      }\n    }\n  }\n\n  function abort(what) {\n    {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n    }\n    what = 'Aborted(' + what + ')';\n    err(what);\n    ABORT = true;\n    what += '. Build with -sASSERTIONS for more info.';\n    var e = new WebAssembly.RuntimeError(what);\n    readyPromiseReject(e);\n    throw e;\n  }\n\n  var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n  function isDataURI(filename) {\n    return filename.startsWith(dataURIPrefix);\n  }\n\n  var wasmBinaryFile;\n  wasmBinaryFile = 'tflite-simd.wasm';\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile);\n  }\n\n  function getBinary(file) {\n    try {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) ;\n      throw 'both async and sync fetching of the wasm failed';\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n    } catch (err) {\n      abort(err);\n    }\n  }\n\n  function getBinaryPromise() {\n    if (!wasmBinary && (ENVIRONMENT_IS_WEB )) {\n      if (typeof fetch == 'function') {\n        return fetch(wasmBinaryFile, { credentials: 'same-origin' })\n          .then(function (response) {\n            if (!response['ok']) {\n              throw (\n                \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\"\n              );\n            }\n            return response['arrayBuffer']();\n          })\n          .catch(function () {\n            return getBinary(wasmBinaryFile);\n          });\n      }\n    }\n    return Promise.resolve().then(function () {\n      return getBinary(wasmBinaryFile);\n    });\n  }\n\n  function createWasm() {\n    var info = {\n      env: asmLibraryArg,\n      wasi_snapshot_preview1: asmLibraryArg,\n    };\n\n    function receiveInstance(instance, module) {\n      var exports = instance.exports;\n      Module['asm'] = exports;\n      wasmMemory = Module['asm']['memory'];\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      Module['asm']['__indirect_function_table'];\n      addOnInit(Module['asm']['__wasm_call_ctors']);\n      removeRunDependency();\n    }\n\n    addRunDependency();\n\n    function receiveInstantiationResult(result) {\n      receiveInstance(result['instance']);\n    }\n\n    function instantiateArrayBuffer(receiver) {\n      return getBinaryPromise()\n        .then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        })\n        .then(function (instance) {\n          return instance;\n        })\n        .then(receiver, function (reason) {\n          err('failed to asynchronously prepare wasm: ' + reason);\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync() {\n      if (\n        !wasmBinary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(\n          function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiationResult, function (reason) {\n              err('wasm streaming compile failed: ' + reason);\n              err('falling back to ArrayBuffer instantiation');\n              return instantiateArrayBuffer(receiveInstantiationResult);\n            });\n          },\n        );\n      } else {\n        return instantiateArrayBuffer(receiveInstantiationResult);\n      }\n    }\n\n    if (Module['instantiateWasm']) {\n      try {\n        var exports = Module['instantiateWasm'](info, receiveInstance);\n        return exports;\n      } catch (e) {\n        err('Module.instantiateWasm callback failed with error: ' + e);\n        readyPromiseReject(e);\n      }\n    }\n    instantiateAsync().catch(readyPromiseReject);\n    return {};\n  }\n\n  function ExitStatus(status) {\n    this.name = 'ExitStatus';\n    this.message = 'Program terminated with exit(' + status + ')';\n    this.status = status;\n  }\n\n  function callRuntimeCallbacks(callbacks) {\n    while (callbacks.length > 0) {\n      callbacks.shift()(Module);\n    }\n  }\n\n  function __dlinit(main_dso_handle) {}\n\n  var dlopenMissingError =\n    'To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking';\n\n  function __dlopen_js(filename, flag) {\n    abort(dlopenMissingError);\n  }\n\n  function __dlsym_js(handle, symbol) {\n    abort(dlopenMissingError);\n  }\n\n  var nowIsMonotonic = true;\n\n  function __emscripten_get_now_is_monotonic() {\n    return nowIsMonotonic;\n  }\n\n  function __mmap_js(len, prot, flags, fd, off, allocated) {\n    return -52;\n  }\n\n  function __munmap_js(addr, len, prot, flags, fd, offset) {}\n\n  function _abort() {\n    abort('');\n  }\n\n  function _emscripten_date_now() {\n    return Date.now();\n  }\n\n  function getHeapMax() {\n    return 2147483648;\n  }\n\n  function _emscripten_get_heap_max() {\n    return getHeapMax();\n  }\n\n  var _emscripten_get_now;\n  _emscripten_get_now = () => performance.now();\n\n  function _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.copyWithin(dest, src, src + num);\n  }\n\n  function emscripten_realloc_buffer(size) {\n    try {\n      wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      return 1;\n    } catch (e) {}\n  }\n\n  function _emscripten_resize_heap(requestedSize) {\n    var oldSize = HEAPU8.length;\n    requestedSize = requestedSize >>> 0;\n    var maxHeapSize = getHeapMax();\n    if (requestedSize > maxHeapSize) {\n      return false;\n    }\n    let alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\n    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n      overGrownHeapSize = Math.min(\n        overGrownHeapSize,\n        requestedSize + 100663296,\n      );\n      var newSize = Math.min(\n        maxHeapSize,\n        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536),\n      );\n      var replacement = emscripten_realloc_buffer(newSize);\n      if (replacement) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var ENV = {};\n\n  function getExecutableName() {\n    return thisProgram || './this.program';\n  }\n\n  function getEnvStrings() {\n    if (!getEnvStrings.strings) {\n      var lang =\n        (\n          (typeof navigator == 'object' &&\n            navigator.languages &&\n            navigator.languages[0]) ||\n          'C'\n        ).replace('-', '_') + '.UTF-8';\n      var env = {\n        USER: 'web_user',\n        LOGNAME: 'web_user',\n        PATH: '/',\n        PWD: '/',\n        HOME: '/home/web_user',\n        LANG: lang,\n        _: getExecutableName(),\n      };\n      for (var x in ENV) {\n        if (ENV[x] === undefined) delete env[x];\n        else env[x] = ENV[x];\n      }\n      var strings = [];\n      for (var x in env) {\n        strings.push(x + '=' + env[x]);\n      }\n      getEnvStrings.strings = strings;\n    }\n    return getEnvStrings.strings;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\n    for (var i = 0; i < str.length; ++i) {\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n    }\n    if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n  }\n\n  function _environ_get(__environ, environ_buf) {\n    var bufSize = 0;\n    getEnvStrings().forEach(function (string, i) {\n      var ptr = environ_buf + bufSize;\n      HEAPU32[(__environ + i * 4) >> 2] = ptr;\n      writeAsciiToMemory(string, ptr);\n      bufSize += string.length + 1;\n    });\n    return 0;\n  }\n\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\n    var strings = getEnvStrings();\n    HEAPU32[penviron_count >> 2] = strings.length;\n    var bufSize = 0;\n    strings.forEach(function (string) {\n      bufSize += string.length + 1;\n    });\n    HEAPU32[penviron_buf_size >> 2] = bufSize;\n    return 0;\n  }\n\n  function _proc_exit(code) {\n    if (!keepRuntimeAlive()) {\n      if (Module['onExit']) Module['onExit'](code);\n      ABORT = true;\n    }\n    quit_(code, new ExitStatus(code));\n  }\n\n  function exitJS(status, implicit) {\n    _proc_exit(status);\n  }\n\n  var _exit = exitJS;\n\n  function _fd_close(fd) {\n    return 52;\n  }\n\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n    return 70;\n  }\n\n  var printCharBuffers = [null, [], []];\n\n  function printChar(stream, curr) {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    var buffer = printCharBuffers[stream];\n    if (curr === 0 || curr === 10) {\n      (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n      buffer.length = 0;\n    } else {\n      buffer.push(curr);\n    }\n  }\n\n  function _fd_write(fd, iov, iovcnt, pnum) {\n    var num = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAPU32[iov >> 2];\n      var len = HEAPU32[(iov + 4) >> 2];\n      iov += 8;\n      for (var j = 0; j < len; j++) {\n        printChar(fd, HEAPU8[ptr + j]);\n      }\n      num += len;\n    }\n    HEAPU32[pnum >> 2] = num;\n    return 0;\n  }\n\n  function getRandomDevice() {\n    if (\n      typeof crypto == 'object' &&\n      typeof crypto['getRandomValues'] == 'function'\n    ) {\n      var randomBuffer = new Uint8Array(1);\n      return () => {\n        crypto.getRandomValues(randomBuffer);\n        return randomBuffer[0];\n      };\n    } else return () => abort('randomDevice');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function _getentropy(buffer, size) {\n    if (!_getentropy.randomDevice) {\n      _getentropy.randomDevice = getRandomDevice();\n    }\n    for (var i = 0; i < size; i++) {\n      HEAP8[(buffer + i) >> 0] = _getentropy.randomDevice();\n    }\n    return 0;\n  }\n\n  var asmLibraryArg = {\n    _dlinit: __dlinit,\n    _dlopen_js: __dlopen_js,\n    _dlsym_js: __dlsym_js,\n    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,\n    _mmap_js: __mmap_js,\n    _munmap_js: __munmap_js,\n    abort: _abort,\n    emscripten_date_now: _emscripten_date_now,\n    emscripten_get_heap_max: _emscripten_get_heap_max,\n    emscripten_get_now: _emscripten_get_now,\n    emscripten_memcpy_big: _emscripten_memcpy_big,\n    emscripten_resize_heap: _emscripten_resize_heap,\n    environ_get: _environ_get,\n    environ_sizes_get: _environ_sizes_get,\n    exit: _exit,\n    fd_close: _fd_close,\n    fd_seek: _fd_seek,\n    fd_write: _fd_write,\n    getentropy: _getentropy,\n  };\n  createWasm();\n  (Module['___wasm_call_ctors'] = function () {\n    return (Module['___wasm_call_ctors'] =\n      Module['asm']['__wasm_call_ctors']).apply(null, arguments);\n  });\n  (Module['_getModelBufferMemoryOffset'] =\n    function () {\n      return (Module[\n        '_getModelBufferMemoryOffset'\n      ] =\n        Module['asm']['getModelBufferMemoryOffset']).apply(null, arguments);\n    });\n  (Module['_getInputMemoryOffset'] = function () {\n    return (Module['_getInputMemoryOffset'] =\n      Module['asm']['getInputMemoryOffset']).apply(null, arguments);\n  });\n  (Module['_getInputHeight'] = function () {\n    return (Module['_getInputHeight'] =\n      Module['asm']['getInputHeight']).apply(null, arguments);\n  });\n  (Module['_getInputWidth'] = function () {\n    return (Module['_getInputWidth'] =\n      Module['asm']['getInputWidth']).apply(null, arguments);\n  });\n  (Module['_getInputChannelCount'] = function () {\n    return (Module['_getInputChannelCount'] =\n      Module['asm']['getInputChannelCount']).apply(null, arguments);\n  });\n  (Module['_getOutputMemoryOffset'] = function () {\n    return (Module['_getOutputMemoryOffset'] =\n      Module['asm']['getOutputMemoryOffset']).apply(null, arguments);\n  });\n  (Module['_getOutputHeight'] = function () {\n    return (Module['_getOutputHeight'] =\n      Module['asm']['getOutputHeight']).apply(null, arguments);\n  });\n  (Module['_getOutputWidth'] = function () {\n    return (Module['_getOutputWidth'] =\n      Module['asm']['getOutputWidth']).apply(null, arguments);\n  });\n  (Module['_getOutputChannelCount'] = function () {\n    return (Module['_getOutputChannelCount'] =\n      Module['asm']['getOutputChannelCount']).apply(null, arguments);\n  });\n  (Module['_loadModel'] = function () {\n    return (Module['_loadModel'] =\n      Module['asm']['loadModel']).apply(null, arguments);\n  });\n  (Module['_runInference'] = function () {\n    return (Module['_runInference'] =\n      Module['asm']['runInference']).apply(null, arguments);\n  });\n  (Module['_malloc'] = function () {\n    return (Module['_malloc'] = Module['asm']['malloc']).apply(\n      null,\n      arguments,\n    );\n  });\n  (Module['___errno_location'] = function () {\n    return (Module['___errno_location'] =\n      Module['asm']['__errno_location']).apply(null, arguments);\n  });\n  (Module['___dl_seterr'] = function () {\n    return (Module['___dl_seterr'] =\n      Module['asm']['__dl_seterr']).apply(null, arguments);\n  });\n  (Module['stackSave'] = function () {\n    return (Module['stackSave'] = Module['asm']['stackSave']).apply(\n      null,\n      arguments,\n    );\n  });\n  (Module['stackRestore'] = function () {\n    return (Module['stackRestore'] =\n      Module['asm']['stackRestore']).apply(null, arguments);\n  });\n  (Module['stackAlloc'] = function () {\n    return (Module['stackAlloc'] =\n      Module['asm']['stackAlloc']).apply(null, arguments);\n  });\n  (Module['dynCall_jjj'] = function () {\n    return (Module['dynCall_jjj'] =\n      Module['asm']['dynCall_jjj']).apply(null, arguments);\n  });\n  (Module['dynCall_jiii'] = function () {\n    return (Module['dynCall_jiii'] =\n      Module['asm']['dynCall_jiii']).apply(null, arguments);\n  });\n  (Module['dynCall_iiiijj'] = function () {\n    return (Module['dynCall_iiiijj'] =\n      Module['asm']['dynCall_iiiijj']).apply(null, arguments);\n  });\n  (Module['dynCall_viijj'] = function () {\n    return (Module['dynCall_viijj'] =\n      Module['asm']['dynCall_viijj']).apply(null, arguments);\n  });\n  (Module['dynCall_viiijjj'] = function () {\n    return (Module['dynCall_viiijjj'] =\n      Module['asm']['dynCall_viiijjj']).apply(null, arguments);\n  });\n  (Module['dynCall_iijjiiii'] = function () {\n    return (Module['dynCall_iijjiiii'] =\n      Module['asm']['dynCall_iijjiiii']).apply(null, arguments);\n  });\n  (Module['dynCall_jiji'] = function () {\n    return (Module['dynCall_jiji'] =\n      Module['asm']['dynCall_jiji']).apply(null, arguments);\n  });\n  var calledRun;\n  dependenciesFulfilled = function runCaller() {\n    if (!calledRun) run();\n    if (!calledRun) dependenciesFulfilled = runCaller;\n  };\n\n  function run(args) {\n    if (runDependencies > 0) {\n      return;\n    }\n    preRun();\n    if (runDependencies > 0) {\n      return;\n    }\n\n    function doRun() {\n      if (calledRun) return;\n      calledRun = true;\n      Module['calledRun'] = true;\n      if (ABORT) return;\n      initRuntime();\n      readyPromiseResolve(Module);\n      if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n      postRun();\n    }\n\n    if (Module['setStatus']) {\n      Module['setStatus']('Running...');\n      setTimeout(function () {\n        setTimeout(function () {\n          Module['setStatus']('');\n        }, 1);\n        doRun();\n      }, 1);\n    } else {\n      doRun();\n    }\n  }\n\n  if (Module['preInit']) {\n    if (typeof Module['preInit'] == 'function')\n      Module['preInit'] = [Module['preInit']];\n    while (Module['preInit'].length > 0) {\n      Module['preInit'].pop()();\n    }\n  }\n  run();\n\n  return __Module.ready;\n};\n\nconst version = \"0.1.0\" ;\nconst packageName = \"@stream-io/video-filters-web\" ;\n\n// @ts-expect-error - module is not declared\n// This is a WebAssembly module compiled from the TensorFlow Lite C++ library.\nconst createTFLite = createTFLiteSIMDModule;\nconst loadTFLite = async (options = {}) => {\n    const { basePath = `https://unpkg.com/${packageName}@${version}/tf`, tfFilePath = `${basePath}/tflite/tflite-simd.wasm`, modelFilePath = `${basePath}/models/segm_full_v679.tflite`, } = options;\n    const [tfLite, model] = await Promise.all([\n        createTFLite({ locateFile: () => tfFilePath }),\n        fetchModel(modelFilePath),\n    ]);\n    const modelBufferOffset = tfLite._getModelBufferMemoryOffset();\n    tfLite.HEAPU8.set(new Uint8Array(model), modelBufferOffset);\n    tfLite._loadModel(model.byteLength);\n    return tfLite;\n};\nlet lastModelFilePath = '';\nlet modelFileCache;\nconst fetchModel = async (modelFilePath) => {\n    const model = modelFilePath === lastModelFilePath && modelFileCache\n        ? modelFileCache\n        : await fetch(modelFilePath).then((r) => r.arrayBuffer());\n    // Cache the model file for future use.\n    modelFileCache = model;\n    lastModelFilePath = modelFilePath;\n    return model;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1maWx0ZXJzLXdlYi9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlEQUFJLEtBQUs7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDhCQUE4QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDRCQUE0QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdURBQXVEO0FBQ25FLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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cmNlcyI6WyJ3ZWJwYWNrOi8veW9vbS8uL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL3ZpZGVvLWZpbHRlcnMtd2ViL2Rpc3QvaW5kZXguZXMuanM/NjZkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzaW1kIH0gZnJvbSAnd2FzbS1mZWF0dXJlLWRldGVjdCc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHBsYXRmb3JtIGlzIGEgbW9iaWxlIGRldmljZS5cbiAqXG4gKiBTZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jyb3dzZXJfZGV0ZWN0aW9uX3VzaW5nX3RoZV91c2VyX2FnZW50XG4gKi9cbmNvbnN0IGlzTW9iaWxlID0gKCkgPT4gL01vYmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLyoqXG4gKiBSdW5zIGEgY2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHBsYXRmb3JtIHN1cHBvcnRzXG4gKiB0aGUgbmVjZXNzYXJ5IEFQSXMgcmVxdWlyZWQgZm9yIHRoZSB2aWRlbyBmaWx0ZXJzLlxuICovXG5jb25zdCBpc1BsYXRmb3JtU3VwcG9ydGVkID0gYXN5bmMgKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAhaXNNb2JpbGUoKSAmJiAvLyB3ZSBkb24ndCBzdXBwb3J0IG1vYmlsZSBkZXZpY2VzIHlldCBkdWUgdG8gcGVyZm9ybWFuY2UgaXNzdWVzXG4gICAgdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICEhd2luZG93LldlYkdMMlJlbmRlcmluZ0NvbnRleHQgJiYgLy8gV2ViR0wyIGlzIHJlcXVpcmVkIGZvciB0aGUgdmlkZW8gZmlsdGVyc1xuICAgICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnd2ViZ2wyJykgJiZcbiAgICAoYXdhaXQgc2ltZCgpKTsgLy8gU0lNRCBpcyByZXF1aXJlZCBmb3IgdGhlIHdhc20gbW9kdWxlXG5cbi8qKlxuICogVXNlIGl0IGFsb25nIHdpdGggYm95c3dhbi5nbHNsLWxpdGVyYWwgVlNDb2RlIGV4dGVuc2lvblxuICogdG8gZ2V0IEdMU0wgc3ludGF4IGhpZ2hsaWdodGluZy5cbiAqIGh0dHBzOi8vbWFya2V0cGxhY2UudmlzdWFsc3R1ZGlvLmNvbS9pdGVtcz9pdGVtTmFtZT1ib3lzd2FuLmdsc2wtbGl0ZXJhbFxuICpcbiAqIE9uIFZTQ29kZSBPU1MsIGJveXN3YW4uZ2xzbC1saXRlcmFsIHJlcXVpcmVzIHNsZXZlc3F1ZS5zaGFkZXIgZXh0ZW5zaW9uXG4gKiB0byBiZSBpbnN0YWxsZWQgYXMgd2VsbC5cbiAqIGh0dHBzOi8vbWFya2V0cGxhY2UudmlzdWFsc3R1ZGlvLmNvbS9pdGVtcz9pdGVtTmFtZT1zbGV2ZXNxdWUuc2hhZGVyXG4gKi9cbmNvbnN0IGdsc2wgPSBTdHJpbmcucmF3O1xuZnVuY3Rpb24gY3JlYXRlUGlwZWxpbmVTdGFnZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlcikge1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcbiAgICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBjb25zdCB0ZXhDb29yZEF0dHJpYnV0ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGV4Q29vcmQnKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0ZXhDb29yZEF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Q29vcmRBdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICByZXR1cm4gcHJvZ3JhbTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBsaW5rIFdlYkdMIHByb2dyYW06ICR7Z2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmFtO1xufVxuZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgc2hhZGVyVHlwZSwgc2hhZGVyU291cmNlKSB7XG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGNvbXBpbGUgc2hhZGVyOiAke2dsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoZ2wsIGludGVybmFsZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBtaW5GaWx0ZXIgPSBnbC5ORUFSRVNULCBtYWdGaWx0ZXIgPSBnbC5ORUFSRVNUKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbWluRmlsdGVyKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbWFnRmlsdGVyKTtcbiAgICBnbC50ZXhTdG9yYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMSwgaW50ZXJuYWxmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZFBpeGVsc0FzeW5jKGdsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIGRlc3QpIHtcbiAgICBjb25zdCBidWYgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWYpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuUElYRUxfUEFDS19CVUZGRVIsIGRlc3QuYnl0ZUxlbmd0aCwgZ2wuU1RSRUFNX1JFQUQpO1xuICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCAwKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBudWxsKTtcbiAgICBhd2FpdCBnZXRCdWZmZXJTdWJEYXRhQXN5bmMoZ2wsIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWYsIDAsIGRlc3QpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcihidWYpO1xuICAgIHJldHVybiBkZXN0O1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QnVmZmVyU3ViRGF0YUFzeW5jKGdsLCB0YXJnZXQsIGJ1ZmZlciwgc3JjQnl0ZU9mZnNldCwgZHN0QnVmZmVyLCBkc3RPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHN5bmMgPSBnbC5mZW5jZVN5bmMoZ2wuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsIDApO1xuICAgIGdsLmZsdXNoKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50V2FpdEFzeW5jKGdsLCBzeW5jKTtcbiAgICBnbC5kZWxldGVTeW5jKHN5bmMpO1xuICAgIGlmIChyZXMgIT09IGdsLldBSVRfRkFJTEVEKSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXIpO1xuICAgICAgICBnbC5nZXRCdWZmZXJTdWJEYXRhKHRhcmdldCwgc3JjQnl0ZU9mZnNldCwgZHN0QnVmZmVyLCBkc3RPZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIodGFyZ2V0LCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGllbnRXYWl0QXN5bmMoZ2wsIHN5bmMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gdGVzdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGdsLmNsaWVudFdhaXRTeW5jKHN5bmMsIDAsIDApO1xuICAgICAgICAgICAgaWYgKHJlcyA9PT0gZ2wuV0FJVF9GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcyA9PT0gZ2wuVElNRU9VVF9FWFBJUkVEKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh0ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dCh0ZXN0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRCYWNrZ3JvdW5kQmx1clN0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGNhbnZhcywgYmx1ckxldmVsKSB7XG4gICAgY29uc3QgYmx1clBhc3MgPSBidWlsZEJsdXJQYXNzKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGNhbnZhcywgYmx1ckxldmVsKTtcbiAgICBjb25zdCBibGVuZFBhc3MgPSBidWlsZEJsZW5kUGFzcyhnbCwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBjYW52YXMpO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgYmx1clBhc3MucmVuZGVyKCk7XG4gICAgICAgIGJsZW5kUGFzcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ292ZXJhZ2UoY292ZXJhZ2UpIHtcbiAgICAgICAgYmxlbmRQYXNzLnVwZGF0ZUNvdmVyYWdlKGNvdmVyYWdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICAgICAgYmxlbmRQYXNzLmNsZWFuVXAoKTtcbiAgICAgICAgYmx1clBhc3MuY2xlYW5VcCgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXIsXG4gICAgICAgIHVwZGF0ZUNvdmVyYWdlLFxuICAgICAgICBjbGVhblVwLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEJsdXJQYXNzKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGNhbnZhcywgYmx1ckxldmVsKSB7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IGJsdXJMZXZlbCA9PT0gJ2xvdydcbiAgICAgICAgPyBbMC4yMjcwMjcwMjcsIDAuMTU0NTk0NTk0NiwgMC4xMDE2MjE2MjE2LCAwLjAzNDA1NDA1NDEsIDAuMDE0MjE2MjE2Ml1cbiAgICAgICAgOiBibHVyTGV2ZWwgPT09ICdtZWRpdW0nXG4gICAgICAgICAgICA/IFswLjMyNzAyNzAyNywgMC4xOTQ1OTQ1OTQ2LCAwLjEyMTYyMTYyMTYsIDAuMDU0MDU0MDU0MSwgMC4wMTYyMTYyMTYyXVxuICAgICAgICAgICAgOiBbMC42MjcwMjcwMjcsIDAuMzQ0NTk0NTk0NiwgMC4yMjE2MjE2MjE2LCAwLjA1NDA1NDA1NDEsIDAuMDE2MjE2MjE2Ml07XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXRGcmFtZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3BlcnNvbk1hc2s7XG4gICAgdW5pZm9ybSB2ZWMyIHVfdGV4ZWxTaXplO1xuXG4gICAgaW4gdmVjMiB2X3RleENvb3JkO1xuICAgIG91dCB2ZWM0IG91dENvbG9yO1xuXG4gICAgY29uc3QgZmxvYXQgb2Zmc2V0WzVdID0gZmxvYXRbXSgwLjAsIDEuMCwgMi4wLCAzLjAsIDQuMCk7XG4gICAgY29uc3QgZmxvYXQgd2VpZ2h0WzVdID0gZmxvYXRbXShcbiAgICAgICR7d2VpZ2h0cy5qb2luKCcsJyl9XG4gICAgKTtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgY2VudGVyQ29sb3IgPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgdl90ZXhDb29yZCk7XG4gICAgICBmbG9hdCBwZXJzb25NYXNrID0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHZfdGV4Q29vcmQpLmE7XG5cbiAgICAgIHZlYzQgZnJhbWVDb2xvciA9IGNlbnRlckNvbG9yICogd2VpZ2h0WzBdICogKDEuMCAtIHBlcnNvbk1hc2spO1xuXG4gICAgICBmb3IgKGludCBpID0gMTsgaSA8IDU7IGkrKykge1xuICAgICAgICB2ZWMyIG9mZnNldCA9IHZlYzIob2Zmc2V0W2ldKSAqIHVfdGV4ZWxTaXplO1xuXG4gICAgICAgIHZlYzIgdGV4Q29vcmQgPSB2X3RleENvb3JkICsgb2Zmc2V0O1xuICAgICAgICBmcmFtZUNvbG9yICs9IHRleHR1cmUodV9pbnB1dEZyYW1lLCB0ZXhDb29yZClcbiAgICAgICAgICAgKiB3ZWlnaHRbaV1cbiAgICAgICAgICAgKiAoMS4wIC0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHRleENvb3JkKS5hKTtcblxuICAgICAgICB0ZXhDb29yZCA9IHZfdGV4Q29vcmQgLSBvZmZzZXQ7XG4gICAgICAgIGZyYW1lQ29sb3IgKz0gdGV4dHVyZSh1X2lucHV0RnJhbWUsIHRleENvb3JkKVxuICAgICAgICAgICogd2VpZ2h0W2ldXG4gICAgICAgICAgKiAoMS4wIC0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHRleENvb3JkKS5hKTtcbiAgICAgIH1cbiAgICAgIG91dENvbG9yID0gdmVjNChmcmFtZUNvbG9yLnJnYiArICgxLjAgLSBmcmFtZUNvbG9yLmEpICogY2VudGVyQ29sb3IucmdiLCAxLjApO1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCBzY2FsZSA9IDAuNTtcbiAgICBjb25zdCBvdXRwdXRXaWR0aCA9IGNhbnZhcy53aWR0aCAqIHNjYWxlO1xuICAgIGNvbnN0IG91dHB1dEhlaWdodCA9IGNhbnZhcy5oZWlnaHQgKiBzY2FsZTtcbiAgICBjb25zdCB0ZXhlbFdpZHRoID0gMSAvIG91dHB1dFdpZHRoO1xuICAgIGNvbnN0IHRleGVsSGVpZ2h0ID0gMSAvIG91dHB1dEhlaWdodDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IHBlcnNvbk1hc2tMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9wZXJzb25NYXNrJyk7XG4gICAgY29uc3QgdGV4ZWxTaXplTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfdGV4ZWxTaXplJyk7XG4gICAgY29uc3QgdGV4dHVyZTEgPSBjcmVhdGVUZXh0dXJlKGdsLCBnbC5SR0JBOCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCwgZ2wuTkVBUkVTVCwgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlcyBhcmUgaW5jb21wbGV0ZVxuICAgIGdsLkxJTkVBUik7XG4gICAgY29uc3QgdGV4dHVyZTIgPSBjcmVhdGVUZXh0dXJlKGdsLCBnbC5SR0JBOCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCwgZ2wuTkVBUkVTVCwgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlcyBhcmUgaW5jb21wbGV0ZVxuICAgIGdsLkxJTkVBUik7XG4gICAgY29uc3QgZnJhbWVCdWZmZXIxID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyMSk7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlMSwgMCk7XG4gICAgY29uc3QgZnJhbWVCdWZmZXIyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyMik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlMiwgMCk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMWkocGVyc29uTWFza0xvY2F0aW9uLCAxKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWkoaW5wdXRGcmFtZUxvY2F0aW9uLCAwKTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHBlcnNvbk1hc2tUZXh0dXJlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZih0ZXhlbFNpemVMb2NhdGlvbiwgMCwgdGV4ZWxIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcjEpO1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUyKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUxKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShpbnB1dEZyYW1lTG9jYXRpb24sIDIpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHRleGVsU2l6ZUxvY2F0aW9uLCB0ZXhlbFdpZHRoLCAwKTtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIyKTtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyMik7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyMSk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZTIpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUxKTtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyLFxuICAgICAgICBjbGVhblVwLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEJsZW5kUGFzcyhnbCwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBjYW52YXMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIGluIHZlYzIgYV9wb3NpdGlvbjtcbiAgICBpbiB2ZWMyIGFfdGV4Q29vcmQ7XG5cbiAgICBvdXQgdmVjMiB2X3RleENvb3JkO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gRmxpcHBpbmcgWSBpcyByZXF1aXJlZCB3aGVuIHJlbmRlcmluZyB0byBjYW52YXNcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uICogdmVjMigxLjAsIC0xLjApLCAwLjAsIDEuMCk7XG4gICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcbiAgICB9XG4gIGA7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW5wdXRGcmFtZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3BlcnNvbk1hc2s7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9ibHVycmVkSW5wdXRGcmFtZTtcbiAgICB1bmlmb3JtIHZlYzIgdV9jb3ZlcmFnZTtcblxuICAgIGluIHZlYzIgdl90ZXhDb29yZDtcblxuICAgIG91dCB2ZWM0IG91dENvbG9yO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMyBjb2xvciA9IHRleHR1cmUodV9pbnB1dEZyYW1lLCB2X3RleENvb3JkKS5yZ2I7XG4gICAgICB2ZWMzIGJsdXJyZWRDb2xvciA9IHRleHR1cmUodV9ibHVycmVkSW5wdXRGcmFtZSwgdl90ZXhDb29yZCkucmdiO1xuICAgICAgZmxvYXQgcGVyc29uTWFzayA9IHRleHR1cmUodV9wZXJzb25NYXNrLCB2X3RleENvb3JkKS5hO1xuICAgICAgcGVyc29uTWFzayA9IHNtb290aHN0ZXAodV9jb3ZlcmFnZS54LCB1X2NvdmVyYWdlLnksIHBlcnNvbk1hc2spO1xuICAgICAgb3V0Q29sb3IgPSB2ZWM0KG1peChibHVycmVkQ29sb3IsIGNvbG9yLCBwZXJzb25NYXNrKSwgMS4wKTtcbiAgICB9XG4gIGA7XG4gICAgY29uc3QgeyB3aWR0aDogb3V0cHV0V2lkdGgsIGhlaWdodDogb3V0cHV0SGVpZ2h0IH0gPSBjYW52YXM7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlKTtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IHBlcnNvbk1hc2tMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9wZXJzb25NYXNrJyk7XG4gICAgY29uc3QgYmx1cnJlZElucHV0RnJhbWUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfYmx1cnJlZElucHV0RnJhbWUnKTtcbiAgICBjb25zdCBjb3ZlcmFnZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2NvdmVyYWdlJyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMWkoaW5wdXRGcmFtZUxvY2F0aW9uLCAwKTtcbiAgICBnbC51bmlmb3JtMWkocGVyc29uTWFza0xvY2F0aW9uLCAxKTtcbiAgICBnbC51bmlmb3JtMWkoYmx1cnJlZElucHV0RnJhbWUsIDIpO1xuICAgIGdsLnVuaWZvcm0yZihjb3ZlcmFnZUxvY2F0aW9uLCAwLCAxKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ292ZXJhZ2UoY292ZXJhZ2UpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKGNvdmVyYWdlTG9jYXRpb24sIGNvdmVyYWdlWzBdLCBjb3ZlcmFnZVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXIsXG4gICAgICAgIHVwZGF0ZUNvdmVyYWdlLFxuICAgICAgICBjbGVhblVwLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQmFja2dyb3VuZEltYWdlU3RhZ2UoZ2wsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGJhY2tncm91bmRJbWFnZSwgY2FudmFzKSB7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gZ2xzbCBgI3ZlcnNpb24gMzAwIGVzXG5cbiAgICB1bmlmb3JtIHZlYzIgdV9iYWNrZ3JvdW5kU2NhbGU7XG4gICAgdW5pZm9ybSB2ZWMyIHVfYmFja2dyb3VuZE9mZnNldDtcblxuICAgIGluIHZlYzIgYV9wb3NpdGlvbjtcbiAgICBpbiB2ZWMyIGFfdGV4Q29vcmQ7XG5cbiAgICBvdXQgdmVjMiB2X3RleENvb3JkO1xuICAgIG91dCB2ZWMyIHZfYmFja2dyb3VuZENvb3JkO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgLy8gRmxpcHBpbmcgWSBpcyByZXF1aXJlZCB3aGVuIHJlbmRlcmluZyB0byBjYW52YXNcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uICogdmVjMigxLjAsIC0xLjApLCAwLjAsIDEuMCk7XG4gICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcbiAgICAgIHZfYmFja2dyb3VuZENvb3JkID0gYV90ZXhDb29yZCAqIHVfYmFja2dyb3VuZFNjYWxlICsgdV9iYWNrZ3JvdW5kT2Zmc2V0O1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dEZyYW1lO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfcGVyc29uTWFzaztcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2JhY2tncm91bmQ7XG4gICAgdW5pZm9ybSB2ZWMyIHVfY292ZXJhZ2U7XG4gICAgdW5pZm9ybSBmbG9hdCB1X2xpZ2h0V3JhcHBpbmc7XG4gICAgdW5pZm9ybSBmbG9hdCB1X2JsZW5kTW9kZTtcblxuICAgIGluIHZlYzIgdl90ZXhDb29yZDtcbiAgICBpbiB2ZWMyIHZfYmFja2dyb3VuZENvb3JkO1xuXG4gICAgb3V0IHZlYzQgb3V0Q29sb3I7XG5cbiAgICB2ZWMzIHNjcmVlbih2ZWMzIGEsIHZlYzMgYikge1xuICAgICAgcmV0dXJuIDEuMCAtICgxLjAgLSBhKSAqICgxLjAgLSBiKTtcbiAgICB9XG5cbiAgICB2ZWMzIGxpbmVhckRvZGdlKHZlYzMgYSwgdmVjMyBiKSB7XG4gICAgICByZXR1cm4gYSArIGI7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMyBmcmFtZUNvbG9yID0gdGV4dHVyZSh1X2lucHV0RnJhbWUsIHZfdGV4Q29vcmQpLnJnYjtcbiAgICAgIHZlYzMgYmFja2dyb3VuZENvbG9yID0gdGV4dHVyZSh1X2JhY2tncm91bmQsIHZfYmFja2dyb3VuZENvb3JkKS5yZ2I7XG4gICAgICBmbG9hdCBwZXJzb25NYXNrID0gdGV4dHVyZSh1X3BlcnNvbk1hc2ssIHZfdGV4Q29vcmQpLmE7XG4gICAgICBmbG9hdCBsaWdodFdyYXBNYXNrID0gMS4wIC0gbWF4KDAuMCwgcGVyc29uTWFzayAtIHVfY292ZXJhZ2UueSkgLyAoMS4wIC0gdV9jb3ZlcmFnZS55KTtcbiAgICAgIHZlYzMgbGlnaHRXcmFwID0gdV9saWdodFdyYXBwaW5nICogbGlnaHRXcmFwTWFzayAqIGJhY2tncm91bmRDb2xvcjtcblxuICAgICAgZnJhbWVDb2xvciA9IHVfYmxlbmRNb2RlICogbGluZWFyRG9kZ2UoZnJhbWVDb2xvciwgbGlnaHRXcmFwKVxuICAgICAgICArICgxLjAgLSB1X2JsZW5kTW9kZSkgKiBzY3JlZW4oZnJhbWVDb2xvciwgbGlnaHRXcmFwKTtcbiAgICAgIHBlcnNvbk1hc2sgPSBzbW9vdGhzdGVwKHVfY292ZXJhZ2UueCwgdV9jb3ZlcmFnZS55LCBwZXJzb25NYXNrKTtcbiAgICAgIG91dENvbG9yID0gdmVjNChmcmFtZUNvbG9yICogcGVyc29uTWFzayArIGJhY2tncm91bmRDb2xvciAqICgxLjAgLSBwZXJzb25NYXNrKSwgMS4wKTtcbiAgICB9XG4gIGA7XG4gICAgY29uc3QgeyB3aWR0aDogb3V0cHV0V2lkdGgsIGhlaWdodDogb3V0cHV0SGVpZ2h0IH0gPSBjYW52YXM7XG4gICAgY29uc3Qgb3V0cHV0UmF0aW8gPSBvdXRwdXRXaWR0aCAvIG91dHB1dEhlaWdodDtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVBpcGVsaW5lU3RhZ2VQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIpO1xuICAgIGNvbnN0IGJhY2tncm91bmRTY2FsZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2JhY2tncm91bmRTY2FsZScpO1xuICAgIGNvbnN0IGJhY2tncm91bmRPZmZzZXRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9iYWNrZ3JvdW5kT2Zmc2V0Jyk7XG4gICAgY29uc3QgaW5wdXRGcmFtZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2lucHV0RnJhbWUnKTtcbiAgICBjb25zdCBwZXJzb25NYXNrTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcGVyc29uTWFzaycpO1xuICAgIGNvbnN0IGJhY2tncm91bmRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9iYWNrZ3JvdW5kJyk7XG4gICAgY29uc3QgY292ZXJhZ2VMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9jb3ZlcmFnZScpO1xuICAgIGNvbnN0IGxpZ2h0V3JhcHBpbmdMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9saWdodFdyYXBwaW5nJyk7XG4gICAgY29uc3QgYmxlbmRNb2RlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfYmxlbmRNb2RlJyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMmYoYmFja2dyb3VuZFNjYWxlTG9jYXRpb24sIDEsIDEpO1xuICAgIGdsLnVuaWZvcm0yZihiYWNrZ3JvdW5kT2Zmc2V0TG9jYXRpb24sIDAsIDApO1xuICAgIGdsLnVuaWZvcm0xaShpbnB1dEZyYW1lTG9jYXRpb24sIDApO1xuICAgIGdsLnVuaWZvcm0xaShwZXJzb25NYXNrTG9jYXRpb24sIDEpO1xuICAgIGdsLnVuaWZvcm0yZihjb3ZlcmFnZUxvY2F0aW9uLCAwLCAxKTtcbiAgICBnbC51bmlmb3JtMWYobGlnaHRXcmFwcGluZ0xvY2F0aW9uLCAwKTtcbiAgICBnbC51bmlmb3JtMWYoYmxlbmRNb2RlTG9jYXRpb24sIDApO1xuICAgIGxldCBiYWNrZ3JvdW5kVGV4dHVyZSA9IG51bGw7XG4gICAgLy8gVE9ETyBGaW5kIGEgYmV0dGVyIHRvIGhhbmRsZSBiYWNrZ3JvdW5kIGJlaW5nIGxvYWRlZFxuICAgIGlmIChiYWNrZ3JvdW5kSW1hZ2U/LmNvbXBsZXRlKSB7XG4gICAgICAgIHVwZGF0ZUJhY2tncm91bmRJbWFnZShiYWNrZ3JvdW5kSW1hZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChiYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZUJhY2tncm91bmRJbWFnZShiYWNrZ3JvdW5kSW1hZ2UpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgcGVyc29uTWFza1RleHR1cmUpO1xuICAgICAgICBpZiAoYmFja2dyb3VuZFRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTIpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYmFja2dyb3VuZFRleHR1cmUpO1xuICAgICAgICAgICAgLy8gVE9ETyBIYW5kbGUgY29ycmVjdGx5IHRoZSBiYWNrZ3JvdW5kIG5vdCBsb2FkZWQgeWV0XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoYmFja2dyb3VuZExvY2F0aW9uLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQmFja2dyb3VuZEltYWdlKGJnSW1hZ2UpIHtcbiAgICAgICAgYmFja2dyb3VuZFRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKGdsLCBnbC5SR0JBOCwgYmdJbWFnZS5uYXR1cmFsV2lkdGgsIGJnSW1hZ2UubmF0dXJhbEhlaWdodCwgXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZXMgYXJlIGluY29tcGxldGVcbiAgICAgICAgZ2wuTElORUFSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGJnSW1hZ2UubmF0dXJhbFdpZHRoLCBiZ0ltYWdlLm5hdHVyYWxIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGJnSW1hZ2UpO1xuICAgICAgICBsZXQgeE9mZnNldCA9IDA7XG4gICAgICAgIGxldCB5T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGJhY2tncm91bmRXaWR0aCA9IGJnSW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICBsZXQgYmFja2dyb3VuZEhlaWdodCA9IGJnSW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZFJhdGlvID0gYmFja2dyb3VuZFdpZHRoIC8gYmFja2dyb3VuZEhlaWdodDtcbiAgICAgICAgaWYgKGJhY2tncm91bmRSYXRpbyA8IG91dHB1dFJhdGlvKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSGVpZ2h0ID0gYmFja2dyb3VuZFdpZHRoIC8gb3V0cHV0UmF0aW87XG4gICAgICAgICAgICB5T2Zmc2V0ID0gKGJnSW1hZ2UubmF0dXJhbEhlaWdodCAtIGJhY2tncm91bmRIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRXaWR0aCA9IGJhY2tncm91bmRIZWlnaHQgKiBvdXRwdXRSYXRpbztcbiAgICAgICAgICAgIHhPZmZzZXQgPSAoYmdJbWFnZS5uYXR1cmFsV2lkdGggLSBiYWNrZ3JvdW5kV2lkdGgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4U2NhbGUgPSBiYWNrZ3JvdW5kV2lkdGggLyBiZ0ltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgY29uc3QgeVNjYWxlID0gYmFja2dyb3VuZEhlaWdodCAvIGJnSW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgeE9mZnNldCAvPSBiZ0ltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgeU9mZnNldCAvPSBiZ0ltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgIGdsLnVuaWZvcm0yZihiYWNrZ3JvdW5kU2NhbGVMb2NhdGlvbiwgeFNjYWxlLCB5U2NhbGUpO1xuICAgICAgICBnbC51bmlmb3JtMmYoYmFja2dyb3VuZE9mZnNldExvY2F0aW9uLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ292ZXJhZ2UoY292ZXJhZ2UpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKGNvdmVyYWdlTG9jYXRpb24sIGNvdmVyYWdlWzBdLCBjb3ZlcmFnZVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxpZ2h0V3JhcHBpbmcobGlnaHRXcmFwcGluZykge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWYobGlnaHRXcmFwcGluZ0xvY2F0aW9uLCBsaWdodFdyYXBwaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQmxlbmRNb2RlKGJsZW5kTW9kZSkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWYoYmxlbmRNb2RlTG9jYXRpb24sIGJsZW5kTW9kZSA9PT0gJ3NjcmVlbicgPyAwIDogMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoYmFja2dyb3VuZFRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyLFxuICAgICAgICB1cGRhdGVDb3ZlcmFnZSxcbiAgICAgICAgdXBkYXRlTGlnaHRXcmFwcGluZyxcbiAgICAgICAgdXBkYXRlQmxlbmRNb2RlLFxuICAgICAgICBjbGVhblVwLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkSm9pbnRCaWxhdGVyYWxGaWx0ZXJTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIGlucHV0VGV4dHVyZSwgb3V0cHV0VGV4dHVyZSwgY2FudmFzLCBzZWdtZW50YXRpb25Db25maWcpIHtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dEZyYW1lO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfc2VnbWVudGF0aW9uTWFzaztcbiAgICB1bmlmb3JtIHZlYzIgdV90ZXhlbFNpemU7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3N0ZXA7XG4gICAgdW5pZm9ybSBmbG9hdCB1X3JhZGl1cztcbiAgICB1bmlmb3JtIGZsb2F0IHVfb2Zmc2V0O1xuICAgIHVuaWZvcm0gZmxvYXQgdV9zaWdtYVRleGVsO1xuICAgIHVuaWZvcm0gZmxvYXQgdV9zaWdtYUNvbG9yO1xuXG4gICAgaW4gdmVjMiB2X3RleENvb3JkO1xuICAgIG91dCB2ZWM0IG91dENvbG9yO1xuXG4gICAgZmxvYXQgZ2F1c3NpYW4oZmxvYXQgeCwgZmxvYXQgc2lnbWEpIHtcbiAgICAgIGZsb2F0IGNvZWZmID0gLTAuNSAvIChzaWdtYSAqIHNpZ21hICogNC4wICsgMS4wZS02KTtcbiAgICAgIHJldHVybiBleHAoKHggKiB4KSAqIGNvZWZmKTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIGNlbnRlckNvb3JkID0gdl90ZXhDb29yZDtcbiAgICAgIHZlYzMgY2VudGVyQ29sb3IgPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgY2VudGVyQ29vcmQpLnJnYjtcbiAgICAgIGZsb2F0IG5ld1ZhbCA9IDAuMDtcblxuICAgICAgZmxvYXQgc3BhY2VXZWlnaHQgPSAwLjA7XG4gICAgICBmbG9hdCBjb2xvcldlaWdodCA9IDAuMDtcbiAgICAgIGZsb2F0IHRvdGFsV2VpZ2h0ID0gMC4wO1xuXG4gICAgICAvLyBTdWJzYW1wbGUga2VybmVsIHNwYWNlLlxuICAgICAgZm9yIChmbG9hdCBpID0gLXVfcmFkaXVzICsgdV9vZmZzZXQ7IGkgPD0gdV9yYWRpdXM7IGkgKz0gdV9zdGVwKSB7XG4gICAgICAgIGZvciAoZmxvYXQgaiA9IC11X3JhZGl1cyArIHVfb2Zmc2V0OyBqIDw9IHVfcmFkaXVzOyBqICs9IHVfc3RlcCkge1xuICAgICAgICAgIHZlYzIgc2hpZnQgPSB2ZWMyKGosIGkpICogdV90ZXhlbFNpemU7XG4gICAgICAgICAgdmVjMiBjb29yZCA9IHZlYzIoY2VudGVyQ29vcmQgKyBzaGlmdCk7XG4gICAgICAgICAgdmVjMyBmcmFtZUNvbG9yID0gdGV4dHVyZSh1X2lucHV0RnJhbWUsIGNvb3JkKS5yZ2I7XG4gICAgICAgICAgZmxvYXQgb3V0VmFsID0gdGV4dHVyZSh1X3NlZ21lbnRhdGlvbk1hc2ssIGNvb3JkKS5hO1xuXG4gICAgICAgICAgc3BhY2VXZWlnaHQgPSBnYXVzc2lhbihkaXN0YW5jZShjZW50ZXJDb29yZCwgY29vcmQpLCB1X3NpZ21hVGV4ZWwpO1xuICAgICAgICAgIGNvbG9yV2VpZ2h0ID0gZ2F1c3NpYW4oZGlzdGFuY2UoY2VudGVyQ29sb3IsIGZyYW1lQ29sb3IpLCB1X3NpZ21hQ29sb3IpO1xuICAgICAgICAgIHRvdGFsV2VpZ2h0ICs9IHNwYWNlV2VpZ2h0ICogY29sb3JXZWlnaHQ7XG5cbiAgICAgICAgICBuZXdWYWwgKz0gc3BhY2VXZWlnaHQgKiBjb2xvcldlaWdodCAqIG91dFZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV3VmFsIC89IHRvdGFsV2VpZ2h0O1xuXG4gICAgICBvdXRDb2xvciA9IHZlYzQodmVjMygwLjApLCBuZXdWYWwpO1xuICAgIH1cbiAgYDtcbiAgICBjb25zdCB7IHdpZHRoOiBzZWdtZW50YXRpb25XaWR0aCwgaGVpZ2h0OiBzZWdtZW50YXRpb25IZWlnaHQgfSA9IHNlZ21lbnRhdGlvbkNvbmZpZztcbiAgICBjb25zdCB7IHdpZHRoOiBvdXRwdXRXaWR0aCwgaGVpZ2h0OiBvdXRwdXRIZWlnaHQgfSA9IGNhbnZhcztcbiAgICBjb25zdCB0ZXhlbFdpZHRoID0gMSAvIG91dHB1dFdpZHRoO1xuICAgIGNvbnN0IHRleGVsSGVpZ2h0ID0gMSAvIG91dHB1dEhlaWdodDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IHNlZ21lbnRhdGlvbk1hc2tMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zZWdtZW50YXRpb25NYXNrJyk7XG4gICAgY29uc3QgdGV4ZWxTaXplTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfdGV4ZWxTaXplJyk7XG4gICAgY29uc3Qgc3RlcExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3N0ZXAnKTtcbiAgICBjb25zdCByYWRpdXNMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYWRpdXMnKTtcbiAgICBjb25zdCBvZmZzZXRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9vZmZzZXQnKTtcbiAgICBjb25zdCBzaWdtYVRleGVsTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2lnbWFUZXhlbCcpO1xuICAgIGNvbnN0IHNpZ21hQ29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zaWdtYUNvbG9yJyk7XG4gICAgY29uc3QgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgb3V0cHV0VGV4dHVyZSwgMCk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC51bmlmb3JtMWkoaW5wdXRGcmFtZUxvY2F0aW9uLCAwKTtcbiAgICBnbC51bmlmb3JtMWkoc2VnbWVudGF0aW9uTWFza0xvY2F0aW9uLCAxKTtcbiAgICBnbC51bmlmb3JtMmYodGV4ZWxTaXplTG9jYXRpb24sIHRleGVsV2lkdGgsIHRleGVsSGVpZ2h0KTtcbiAgICAvLyBFbnN1cmVzIGRlZmF1bHQgdmFsdWVzIGFyZSBjb25maWd1cmVkIHRvIHByZXZlbnQgaW5maW5pdGVcbiAgICAvLyBsb29wIGluIGZyYWdtZW50IHNoYWRlclxuICAgIHVwZGF0ZVNpZ21hU3BhY2UoMCk7XG4gICAgdXBkYXRlU2lnbWFDb2xvcigwKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIG91dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgaW5wdXRUZXh0dXJlKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTaWdtYVNwYWNlKHNpZ21hU3BhY2UpIHtcbiAgICAgICAgc2lnbWFTcGFjZSAqPSBNYXRoLm1heChvdXRwdXRXaWR0aCAvIHNlZ21lbnRhdGlvbldpZHRoLCBvdXRwdXRIZWlnaHQgLyBzZWdtZW50YXRpb25IZWlnaHQpO1xuICAgICAgICBjb25zdCBrU3BhcnNpdHlGYWN0b3IgPSAwLjY2OyAvLyBIaWdoZXIgaXMgc3BhcnNlci5cbiAgICAgICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguc3FydChzaWdtYVNwYWNlKSAqIGtTcGFyc2l0eUZhY3Rvcik7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHNpZ21hU3BhY2U7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0ZXAgPiAxID8gc3RlcCAqIDAuNSA6IDA7XG4gICAgICAgIGNvbnN0IHNpZ21hVGV4ZWwgPSBNYXRoLm1heCh0ZXhlbFdpZHRoLCB0ZXhlbEhlaWdodCkgKiBzaWdtYVNwYWNlO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC51bmlmb3JtMWYoc3RlcExvY2F0aW9uLCBzdGVwKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHJhZGl1c0xvY2F0aW9uLCByYWRpdXMpO1xuICAgICAgICBnbC51bmlmb3JtMWYob2Zmc2V0TG9jYXRpb24sIG9mZnNldCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaWdtYVRleGVsTG9jYXRpb24sIHNpZ21hVGV4ZWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTaWdtYUNvbG9yKHNpZ21hQ29sb3IpIHtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNpZ21hQ29sb3JMb2NhdGlvbiwgc2lnbWFDb2xvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyLCB1cGRhdGVTaWdtYVNwYWNlLCB1cGRhdGVTaWdtYUNvbG9yLCBjbGVhblVwIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVzaXppbmdTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIHRmbGl0ZSwgc2VnbWVudGF0aW9uQ29uZmlnKSB7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBnbHNsIGAjdmVyc2lvbiAzMDAgZXNcblxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2lucHV0RnJhbWU7XG4gICAgaW4gdmVjMiB2X3RleENvb3JkO1xuICAgIG91dCB2ZWM0IG91dENvbG9yO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgb3V0Q29sb3IgPSB0ZXh0dXJlKHVfaW5wdXRGcmFtZSwgdl90ZXhDb29yZCk7XG4gICAgfVxuICBgO1xuICAgIC8vIFRGTGl0ZSBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCBhcyBmbG9hdDMyXG4gICAgY29uc3QgdGZsaXRlSW5wdXRNZW1vcnlPZmZzZXQgPSB0ZmxpdGUuX2dldElucHV0TWVtb3J5T2Zmc2V0KCkgLyA0O1xuICAgIGNvbnN0IHsgd2lkdGg6IG91dHB1dFdpZHRoLCBoZWlnaHQ6IG91dHB1dEhlaWdodCB9ID0gc2VnbWVudGF0aW9uQ29uZmlnO1xuICAgIGNvbnN0IG91dHB1dFBpeGVsQ291bnQgPSBvdXRwdXRXaWR0aCAqIG91dHB1dEhlaWdodDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQaXBlbGluZVN0YWdlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBjb25zdCBpbnB1dEZyYW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfaW5wdXRGcmFtZScpO1xuICAgIGNvbnN0IG91dHB1dFRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKGdsLCBnbC5SR0JBOCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgY29uc3QgZnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgb3V0cHV0VGV4dHVyZSwgMCk7XG4gICAgY29uc3Qgb3V0cHV0UGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkob3V0cHV0UGl4ZWxDb3VudCAqIDQpO1xuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZ2wudW5pZm9ybTFpKGlucHV0RnJhbWVMb2NhdGlvbiwgMCk7XG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgICAvLyBEb3dubG9hZHMgcGl4ZWxzIGFzeW5jaHJvbm91c2x5IGZyb20gR1BVIHdoaWxlIHJlbmRlcmluZyB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgICAgLy8gVGhlIHBpeGVscyB3aWxsIGJlIGF2YWlsYWJsZSBpbiB0aGUgbmV4dCBmcmFtZSByZW5kZXIgd2hpY2ggcmVzdWx0c1xuICAgICAgICAvLyBpbiBvZmZzZXRzIGluIHRoZSBzZWdtZW50YXRpb24gb3V0cHV0IGJ1dCBpbmNyZWFzZXMgdGhlIGZyYW1lIHJhdGUuXG4gICAgICAgIHJlYWRQaXhlbHNBc3luYyhnbCwgMCwgMCwgb3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgb3V0cHV0UGl4ZWxzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRQaXhlbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRmbGl0ZUluZGV4ID0gdGZsaXRlSW5wdXRNZW1vcnlPZmZzZXQgKyBpICogMztcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEluZGV4ID0gaSAqIDQ7XG4gICAgICAgICAgICB0ZmxpdGUuSEVBUEYzMlt0ZmxpdGVJbmRleF0gPSBvdXRwdXRQaXhlbHNbb3V0cHV0SW5kZXhdIC8gMjU1O1xuICAgICAgICAgICAgdGZsaXRlLkhFQVBGMzJbdGZsaXRlSW5kZXggKyAxXSA9IG91dHB1dFBpeGVsc1tvdXRwdXRJbmRleCArIDFdIC8gMjU1O1xuICAgICAgICAgICAgdGZsaXRlLkhFQVBGMzJbdGZsaXRlSW5kZXggKyAyXSA9IG91dHB1dFBpeGVsc1tvdXRwdXRJbmRleCArIDJdIC8gMjU1O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShvdXRwdXRUZXh0dXJlKTtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyLCBjbGVhblVwIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU29mdG1heFN0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgdGZsaXRlLCBvdXRwdXRUZXh0dXJlLCBzZWdtZW50YXRpb25Db25maWcpIHtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGdsc2wgYCN2ZXJzaW9uIDMwMCBlc1xuXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbnB1dFNlZ21lbnRhdGlvbjtcbiAgICBpbiB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgb3V0IHZlYzQgb3V0Q29sb3I7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHNlZ21lbnRhdGlvbiA9IHRleHR1cmUodV9pbnB1dFNlZ21lbnRhdGlvbiwgdl90ZXhDb29yZCkucmc7XG4gICAgICBmbG9hdCBzaGlmdCA9IG1heChzZWdtZW50YXRpb24uciwgc2VnbWVudGF0aW9uLmcpO1xuICAgICAgZmxvYXQgYmFja2dyb3VuZEV4cCA9IGV4cChzZWdtZW50YXRpb24uciAtIHNoaWZ0KTtcbiAgICAgIGZsb2F0IHBlcnNvbkV4cCA9IGV4cChzZWdtZW50YXRpb24uZyAtIHNoaWZ0KTtcbiAgICAgIG91dENvbG9yID0gdmVjNCh2ZWMzKDAuMCksIHBlcnNvbkV4cCAvIChiYWNrZ3JvdW5kRXhwICsgcGVyc29uRXhwKSk7XG4gICAgfVxuICBgO1xuICAgIC8vIFRGTGl0ZSBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCBhcyBmbG9hdDMyXG4gICAgY29uc3QgdGZsaXRlT3V0cHV0TWVtb3J5T2Zmc2V0ID0gdGZsaXRlLl9nZXRPdXRwdXRNZW1vcnlPZmZzZXQoKSAvIDQ7XG4gICAgY29uc3QgeyB3aWR0aDogc2VnbWVudGF0aW9uV2lkdGgsIGhlaWdodDogc2VnbWVudGF0aW9uSGVpZ2h0IH0gPSBzZWdtZW50YXRpb25Db25maWc7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUGlwZWxpbmVTdGFnZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlcik7XG4gICAgY29uc3QgaW5wdXRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9pbnB1dFNlZ21lbnRhdGlvbicpO1xuICAgIGNvbnN0IGlucHV0VGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHMzJGLCBzZWdtZW50YXRpb25XaWR0aCwgc2VnbWVudGF0aW9uSGVpZ2h0KTtcbiAgICBjb25zdCBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBvdXRwdXRUZXh0dXJlLCAwKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIGdsLnVuaWZvcm0xaShpbnB1dExvY2F0aW9uLCAxKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHNlZ21lbnRhdGlvbldpZHRoLCBzZWdtZW50YXRpb25IZWlnaHQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgaW5wdXRUZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBzZWdtZW50YXRpb25XaWR0aCwgc2VnbWVudGF0aW9uSGVpZ2h0LCBnbC5SRywgZ2wuRkxPQVQsIHRmbGl0ZS5IRUFQRjMyLCB0ZmxpdGVPdXRwdXRNZW1vcnlPZmZzZXQpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShpbnB1dFRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIH1cbiAgICByZXR1cm4geyByZW5kZXIsIGNsZWFuVXAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRXZWJHTDJQaXBlbGluZSh2aWRlb1NvdXJjZSwgYmFja2dyb3VuZEltYWdlLCBibHVyTGV2ZWwsIGJhY2tncm91bmRGaWx0ZXIsIGNhbnZhcywgdGZsaXRlLCBzZWdtZW50YXRpb25Db25maWcpIHtcbiAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbiAgICBpZiAoIWdsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMiBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3QgeyB3aWR0aDogZnJhbWVXaWR0aCwgaGVpZ2h0OiBmcmFtZUhlaWdodCB9ID0gdmlkZW9Tb3VyY2U7XG4gICAgY29uc3QgeyB3aWR0aDogc2VnbWVudGF0aW9uV2lkdGgsIGhlaWdodDogc2VnbWVudGF0aW9uSGVpZ2h0IH0gPSBzZWdtZW50YXRpb25Db25maWc7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gZ2xzbCBgI3ZlcnNpb24gMzAwIGVzXG5cbiAgICBpbiB2ZWMyIGFfcG9zaXRpb247XG4gICAgaW4gdmVjMiBhX3RleENvb3JkO1xuICAgIG91dCB2ZWMyIHZfdGV4Q29vcmQ7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XG4gICAgfVxuICBgO1xuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgdmVydGV4QXJyYXkgPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2ZXJ0ZXhBcnJheSk7XG4gICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFstMS4wLCAtMS4wLCAxLjAsIC0xLjAsIC0xLjAsIDEuMCwgMS4wLCAxLjBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGNvbnN0IHRleENvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMS4wLCAxLjBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIC8vIFdlIGRvbid0IHVzZSB0ZXhTdG9yYWdlMkQgaGVyZSBiZWNhdXNlIHRleEltYWdlMkQgc2VlbXMgZmFzdGVyXG4gICAgLy8gdG8gdXBsb2FkIHZpZGVvIHRleHR1cmUgdGhhbiB0ZXhTdWJJbWFnZTJEIGV2ZW4gdGhvdWdoIHRoZSBsYXR0ZXJcbiAgICAvLyBpcyBzdXBwb3NlZCB0byBiZSB0aGUgcmVjb21tZW5kZWQgd2F5OlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTF9BUEkvV2ViR0xfYmVzdF9wcmFjdGljZXMjdXNlX3RleHN0b3JhZ2VfdG9fY3JlYXRlX3RleHR1cmVzXG4gICAgY29uc3QgaW5wdXRGcmFtZVRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgaW5wdXRGcmFtZVRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgLy8gVE9ETyBSZW5hbWUgc2VnbWVudGF0aW9uIGFuZCBwZXJzb24gbWFzayB0byBiZSBtb3JlIHNwZWNpZmljXG4gICAgY29uc3Qgc2VnbWVudGF0aW9uVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHQkE4LCBzZWdtZW50YXRpb25XaWR0aCwgc2VnbWVudGF0aW9uSGVpZ2h0KTtcbiAgICBjb25zdCBwZXJzb25NYXNrVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIGdsLlJHQkE4LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCk7XG4gICAgY29uc3QgcmVzaXppbmdTdGFnZSA9IGJ1aWxkUmVzaXppbmdTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIHRmbGl0ZSwgc2VnbWVudGF0aW9uQ29uZmlnKTtcbiAgICBjb25zdCBsb2FkU2VnbWVudGF0aW9uU3RhZ2UgPSBidWlsZFNvZnRtYXhTdGFnZShnbCwgdmVydGV4U2hhZGVyLCBwb3NpdGlvbkJ1ZmZlciwgdGV4Q29vcmRCdWZmZXIsIHRmbGl0ZSwgc2VnbWVudGF0aW9uVGV4dHVyZSwgc2VnbWVudGF0aW9uQ29uZmlnKTtcbiAgICBjb25zdCBqb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlID0gYnVpbGRKb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlKGdsLCB2ZXJ0ZXhTaGFkZXIsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgc2VnbWVudGF0aW9uVGV4dHVyZSwgcGVyc29uTWFza1RleHR1cmUsIGNhbnZhcywgc2VnbWVudGF0aW9uQ29uZmlnKTtcbiAgICBjb25zdCBiYWNrZ3JvdW5kU3RhZ2UgPSBiYWNrZ3JvdW5kRmlsdGVyID09PSAnYmx1cidcbiAgICAgICAgPyBidWlsZEJhY2tncm91bmRCbHVyU3RhZ2UoZ2wsIHZlcnRleFNoYWRlciwgcG9zaXRpb25CdWZmZXIsIHRleENvb3JkQnVmZmVyLCBwZXJzb25NYXNrVGV4dHVyZSwgY2FudmFzLCBibHVyTGV2ZWwgfHwgJ2hpZ2gnKVxuICAgICAgICA6IGJ1aWxkQmFja2dyb3VuZEltYWdlU3RhZ2UoZ2wsIHBvc2l0aW9uQnVmZmVyLCB0ZXhDb29yZEJ1ZmZlciwgcGVyc29uTWFza1RleHR1cmUsIGJhY2tncm91bmRJbWFnZSwgY2FudmFzKTtcbiAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dEZyYW1lVGV4dHVyZSk7XG4gICAgICAgIC8vIHRleEltYWdlMkQgc2VlbXMgZmFzdGVyIHRoYW4gdGV4U3ViSW1hZ2UyRCB0byB1cGxvYWRcbiAgICAgICAgLy8gdmlkZW8gdGV4dHVyZVxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHZpZGVvU291cmNlKTtcbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KHZlcnRleEFycmF5KTtcbiAgICAgICAgcmVzaXppbmdTdGFnZS5yZW5kZXIoKTtcbiAgICAgICAgdGZsaXRlLl9ydW5JbmZlcmVuY2UoKTtcbiAgICAgICAgbG9hZFNlZ21lbnRhdGlvblN0YWdlLnJlbmRlcigpO1xuICAgICAgICBqb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlLnJlbmRlcigpO1xuICAgICAgICBiYWNrZ3JvdW5kU3RhZ2UucmVuZGVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc3RQcm9jZXNzaW5nQ29uZmlnKCkge1xuICAgICAgICBqb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlLnVwZGF0ZVNpZ21hU3BhY2UoMSk7XG4gICAgICAgIGpvaW50QmlsYXRlcmFsRmlsdGVyU3RhZ2UudXBkYXRlU2lnbWFDb2xvcigwLjEpO1xuICAgICAgICBpZiAoYmFja2dyb3VuZEZpbHRlciA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZEltYWdlU3RhZ2UgPSBiYWNrZ3JvdW5kU3RhZ2U7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VTdGFnZS51cGRhdGVDb3ZlcmFnZShbMC41LCAwLjc1XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VTdGFnZS51cGRhdGVMaWdodFdyYXBwaW5nKDAuMyk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VTdGFnZS51cGRhdGVCbGVuZE1vZGUoJ3NjcmVlbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJhY2tncm91bmRGaWx0ZXIgPT09ICdibHVyJykge1xuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZEJsdXJTdGFnZSA9IGJhY2tncm91bmRTdGFnZTtcbiAgICAgICAgICAgIGJhY2tncm91bmRCbHVyU3RhZ2UudXBkYXRlQ292ZXJhZ2UoWzAuNSwgMC43NV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyBIYW5kbGUgbm8gYmFja2dyb3VuZCBpbiBhIHNlcGFyYXRlIHBpcGVsaW5lIHBhdGhcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmRJbWFnZVN0YWdlID0gYmFja2dyb3VuZFN0YWdlO1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlU3RhZ2UudXBkYXRlQ292ZXJhZ2UoWzAsIDAuOTk5OV0pO1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlU3RhZ2UudXBkYXRlTGlnaHRXcmFwcGluZygwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhblVwKCkge1xuICAgICAgICBiYWNrZ3JvdW5kU3RhZ2UuY2xlYW5VcCgpO1xuICAgICAgICBqb2ludEJpbGF0ZXJhbEZpbHRlclN0YWdlLmNsZWFuVXAoKTtcbiAgICAgICAgbG9hZFNlZ21lbnRhdGlvblN0YWdlLmNsZWFuVXAoKTtcbiAgICAgICAgcmVzaXppbmdTdGFnZS5jbGVhblVwKCk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUocGVyc29uTWFza1RleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHNlZ21lbnRhdGlvblRleHR1cmUpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKGlucHV0RnJhbWVUZXh0dXJlKTtcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHRleENvb3JkQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKHBvc2l0aW9uQnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkodmVydGV4QXJyYXkpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyLCB1cGRhdGVQb3N0UHJvY2Vzc2luZ0NvbmZpZywgY2xlYW5VcCB9O1xufVxuXG52YXIgU2VnbWVudGF0aW9uTGV2ZWw7XG4oZnVuY3Rpb24gKFNlZ21lbnRhdGlvbkxldmVsKSB7XG4gICAgU2VnbWVudGF0aW9uTGV2ZWxbXCJMT1dcIl0gPSBcImxvd1wiO1xuICAgIFNlZ21lbnRhdGlvbkxldmVsW1wiSElHSFwiXSA9IFwiaGlnaFwiO1xufSkoU2VnbWVudGF0aW9uTGV2ZWwgfHwgKFNlZ21lbnRhdGlvbkxldmVsID0ge30pKTtcbmNvbnN0IGdldFNlZ21lbnRhdGlvblBhcmFtcyA9IChsZXZlbCkgPT4ge1xuICAgIGlmIChsZXZlbCA9PT0gU2VnbWVudGF0aW9uTGV2ZWwuSElHSCkge1xuICAgICAgICByZXR1cm4geyB3aWR0aDogMjU2LCBoZWlnaHQ6IDE0NCB9O1xuICAgIH1cbiAgICByZXR1cm4geyB3aWR0aDogMTYwLCBoZWlnaHQ6IDk2IH07XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcih0ZmxpdGUsIHZpZGVvU291cmNlLCB0YXJnZXRDYW52YXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGJhY2tncm91bmRGaWx0ZXIsIGJhY2tncm91bmRJbWFnZSwgYmFja2dyb3VuZEJsdXJMZXZlbCwgc2VnbWVudGF0aW9uTGV2ZWwgPSBTZWdtZW50YXRpb25MZXZlbC5ISUdILCBmcHMgPSAzMCwgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRGaWx0ZXIgPT09ICdpbWFnZScgJiYgIWJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhY2tncm91bmRJbWFnZSBlbGVtZW50IGlzIHJlcXVpcmVkIHdoZW4gYmFja2dyb3VuZEZpbHRlciBpcyBpbWFnZWApO1xuICAgIH1cbiAgICBjb25zdCBwaXBlbGluZSA9IGJ1aWxkV2ViR0wyUGlwZWxpbmUodmlkZW9Tb3VyY2UsIGJhY2tncm91bmRJbWFnZSwgYmFja2dyb3VuZEJsdXJMZXZlbCwgYmFja2dyb3VuZEZpbHRlciwgdGFyZ2V0Q2FudmFzLCB0ZmxpdGUsIGdldFNlZ21lbnRhdGlvblBhcmFtcyhzZWdtZW50YXRpb25MZXZlbCkpO1xuICAgIGNvbnN0IGlkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBwaXBlbGluZS5yZW5kZXIoKTtcbiAgICAgICAgaWYgKGJhY2tncm91bmRGaWx0ZXIgPT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgIHBpcGVsaW5lLnVwZGF0ZVBvc3RQcm9jZXNzaW5nQ29uZmlnKCk7XG4gICAgICAgIH1cbiAgICB9LCAxMDAwIC8gKGZwcyA8PSAwID8gMzAgOiBmcHMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICBwaXBlbGluZS5jbGVhblVwKCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jb25zdCBjcmVhdGVURkxpdGVTSU1ETW9kdWxlID0gKF9fTW9kdWxlKSA9PiB7XG4gIF9fTW9kdWxlID0gX19Nb2R1bGUgfHwge307XG5cbiAgdmFyIF9zY3JpcHREaXIgPVxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdFxuICAgICAgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIE1vZHVsZSA9IHR5cGVvZiBfX01vZHVsZSAhPSAndW5kZWZpbmVkJyA/IF9fTW9kdWxlIDoge307XG4gIHZhciByZWFkeVByb21pc2VSZXNvbHZlLCByZWFkeVByb21pc2VSZWplY3Q7XG4gIE1vZHVsZVsncmVhZHknXSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkeVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICByZWFkeVByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuICB2YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcbiAgdmFyIHRoaXNQcm9ncmFtID0gJy4vdGhpcy5wcm9ncmFtJztcbiAgdmFyIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICAgIHRocm93IHRvVGhyb3c7XG4gIH07XG4gIHZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0cnVlO1xuICB2YXIgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG5cbiAgZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKSB7XG4gICAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgICByZXR1cm4gTW9kdWxlWydsb2NhdGVGaWxlJ10ocGF0aCwgc2NyaXB0RGlyZWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG4gIH1cblxuICB2YXIgcmVhZEJpbmFyeTtcbiAge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgICAgc2NyaXB0RGlyZWN0b3J5ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gICAgfVxuICAgIGlmIChfc2NyaXB0RGlyKSB7XG4gICAgICBzY3JpcHREaXJlY3RvcnkgPSBfc2NyaXB0RGlyO1xuICAgIH1cbiAgICBpZiAoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoXG4gICAgICAgIDAsXG4gICAgICAgIHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCAnJykubGFzdEluZGV4T2YoJy8nKSArIDEsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHREaXJlY3RvcnkgPSAnJztcbiAgICB9XG4gIH1cbiAgdmFyIG91dCA9IE1vZHVsZVsncHJpbnQnXSB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICB2YXIgZXJyID0gTW9kdWxlWydwcmludEVyciddIHx8IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICBPYmplY3QuYXNzaWduKE1vZHVsZSwgbW9kdWxlT3ZlcnJpZGVzKTtcbiAgbW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcbiAgaWYgKE1vZHVsZVsnYXJndW1lbnRzJ10pIE1vZHVsZVsnYXJndW1lbnRzJ107XG4gIGlmIChNb2R1bGVbJ3RoaXNQcm9ncmFtJ10pIHRoaXNQcm9ncmFtID0gTW9kdWxlWyd0aGlzUHJvZ3JhbSddO1xuICBpZiAoTW9kdWxlWydxdWl0J10pIHF1aXRfID0gTW9kdWxlWydxdWl0J107XG4gIHZhciB3YXNtQmluYXJ5O1xuICBpZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHdhc21CaW5hcnkgPSBNb2R1bGVbJ3dhc21CaW5hcnknXTtcbiAgdmFyIG5vRXhpdFJ1bnRpbWUgPSBNb2R1bGVbJ25vRXhpdFJ1bnRpbWUnXSB8fCB0cnVlO1xuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9ICdvYmplY3QnKSB7XG4gICAgYWJvcnQoJ25vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQnKTtcbiAgfVxuICB2YXIgd2FzbU1lbW9yeTtcbiAgdmFyIEFCT1JUID0gZmFsc2U7XG5cbiAgdmFyIFVURjhEZWNvZGVyID1cbiAgICB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCkge1xuICAgIHZhciBlbmRJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcbiAgICB2YXIgZW5kUHRyID0gaWR4O1xuICAgIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LCBlbmRQdHIpKTtcbiAgICB9XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHdoaWxlIChpZHggPCBlbmRQdHIpIHtcbiAgICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgIGlmICghKHUwICYgMTI4KSkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHUxID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMjI0KSA9PSAxOTIpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCh1MCAmIDMxKSA8PCA2KSB8IHUxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdTIgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICAgIGlmICgodTAgJiAyNDApID09IDIyNCkge1xuICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1MCA9XG4gICAgICAgICAgKCh1MCAmIDcpIDw8IDE4KSB8ICh1MSA8PCAxMikgfCAodTIgPDwgNikgfCAoaGVhcE9yQXJyYXlbaWR4KytdICYgNjMpO1xuICAgICAgfVxuICAgICAgaWYgKHUwIDwgNjU1MzYpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoID0gdTAgLSA2NTUzNjtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoY2ggPj4gMTApLCA1NjMyMCB8IChjaCAmIDEwMjMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBidWZmZXIsIEhFQVA4LCBIRUFQVTgsIEhFQVBVMzI7XG5cbiAgZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3MoYnVmKSB7XG4gICAgYnVmZmVyID0gYnVmO1xuICAgIE1vZHVsZVsnSEVBUDgnXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShidWYpO1xuICAgIE1vZHVsZVsnSEVBUDE2J10gPSBuZXcgSW50MTZBcnJheShidWYpO1xuICAgIE1vZHVsZVsnSEVBUDMyJ10gPSBuZXcgSW50MzJBcnJheShidWYpO1xuICAgIE1vZHVsZVsnSEVBUFU4J10gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIE1vZHVsZVsnSEVBUFUxNiddID0gbmV3IFVpbnQxNkFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQVTMyJ10gPSBIRUFQVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQRjMyJ10gPSBuZXcgRmxvYXQzMkFycmF5KGJ1Zik7XG4gICAgTW9kdWxlWydIRUFQRjY0J10gPSBuZXcgRmxvYXQ2NEFycmF5KGJ1Zik7XG4gIH1cblxuICBNb2R1bGVbJ0lOSVRJQUxfTUVNT1JZJ10gfHwgMTY3NzcyMTY7XG4gIHZhciBfX0FUUFJFUlVOX18gPSBbXTtcbiAgdmFyIF9fQVRJTklUX18gPSBbXTtcbiAgdmFyIF9fQVRQT1NUUlVOX18gPSBbXTtcblxuICBmdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCkge1xuICAgIHJldHVybiBub0V4aXRSdW50aW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlUnVuKCkge1xuICAgIGlmIChNb2R1bGVbJ3ByZVJ1biddKSB7XG4gICAgICBpZiAodHlwZW9mIE1vZHVsZVsncHJlUnVuJ10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcbiAgICAgIHdoaWxlIChNb2R1bGVbJ3ByZVJ1biddLmxlbmd0aCkge1xuICAgICAgICBhZGRPblByZVJ1bihNb2R1bGVbJ3ByZVJ1biddLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKSB7XG4gICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7XG4gIH1cblxuICBmdW5jdGlvbiBwb3N0UnVuKCkge1xuICAgIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xuICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3Bvc3RSdW4nXSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBNb2R1bGVbJ3Bvc3RSdW4nXSA9IFtNb2R1bGVbJ3Bvc3RSdW4nXV07XG4gICAgICB3aGlsZSAoTW9kdWxlWydwb3N0UnVuJ10ubGVuZ3RoKSB7XG4gICAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPblByZVJ1bihjYikge1xuICAgIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xuICAgIF9fQVRJTklUX18udW5zaGlmdChjYik7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPblBvc3RSdW4oY2IpIHtcbiAgICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xuICB9XG5cbiAgdmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG4gIHZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgICBydW5EZXBlbmRlbmNpZXMrKztcbiAgICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuICAgIHJ1bkRlcGVuZGVuY2llcy0tO1xuICAgIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGRlcGVuZGVuY2llc0Z1bGZpbGxlZDtcbiAgICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydCh3aGF0KSB7XG4gICAge1xuICAgICAgaWYgKE1vZHVsZVsnb25BYm9ydCddKSB7XG4gICAgICAgIE1vZHVsZVsnb25BYm9ydCddKHdoYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGF0ID0gJ0Fib3J0ZWQoJyArIHdoYXQgKyAnKSc7XG4gICAgZXJyKHdoYXQpO1xuICAgIEFCT1JUID0gdHJ1ZTtcbiAgICB3aGF0ICs9ICcuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uJztcbiAgICB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7XG4gICAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICAgIHRocm93IGU7XG4gIH1cblxuICB2YXIgZGF0YVVSSVByZWZpeCA9ICdkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsJztcblxuICBmdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTtcbiAgfVxuXG4gIHZhciB3YXNtQmluYXJ5RmlsZTtcbiAgd2FzbUJpbmFyeUZpbGUgPSAndGZsaXRlLXNpbWQud2FzbSc7XG4gIGlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuICAgIHdhc21CaW5hcnlGaWxlID0gbG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5hcnkoZmlsZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkQmluYXJ5KSA7XG4gICAgICB0aHJvdyAnYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWQnO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGFib3J0KGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpIHtcbiAgICBpZiAoIXdhc21CaW5hcnkgJiYgKEVOVklST05NRU5UX0lTX1dFQiApKSB7XG4gICAgICBpZiAodHlwZW9mIGZldGNoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydvayddKSB7XG4gICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICBcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiICsgd2FzbUJpbmFyeUZpbGUgKyBcIidcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIGVudjogYXNtTGlicmFyeUFyZyxcbiAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IGFzbUxpYnJhcnlBcmcsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgICB2YXIgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgICBNb2R1bGVbJ2FzbSddID0gZXhwb3J0cztcbiAgICAgIHdhc21NZW1vcnkgPSBNb2R1bGVbJ2FzbSddWydtZW1vcnknXTtcbiAgICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKTtcbiAgICAgIE1vZHVsZVsnYXNtJ11bJ19faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUnXTtcbiAgICAgIGFkZE9uSW5pdChNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKTtcbiAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koKTtcbiAgICB9XG5cbiAgICBhZGRSdW5EZXBlbmRlbmN5KCk7XG5cbiAgICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGluZm8pO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlY2VpdmVyLCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgZXJyKCdmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAnICsgcmVhc29uKTtcbiAgICAgICAgICBhYm9ydChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKCkge1xuICAgICAgaWYgKFxuICAgICAgICAhd2FzbUJpbmFyeSAmJlxuICAgICAgICB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJlxuICAgICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbmZvKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICBlcnIoJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTtcbiAgICAgICAgICAgICAgZXJyKCdmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvbicpO1xuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZXhwb3J0cyA9IE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10oaW5mbywgcmVjZWl2ZUluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycignTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGUpO1xuICAgICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGluc3RhbnRpYXRlQXN5bmMoKS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5uYW1lID0gJ0V4aXRTdGF0dXMnO1xuICAgIHRoaXMubWVzc2FnZSA9ICdQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCcgKyBzdGF0dXMgKyAnKSc7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsUnVudGltZUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19kbGluaXQobWFpbl9kc29faGFuZGxlKSB7fVxuXG4gIHZhciBkbG9wZW5NaXNzaW5nRXJyb3IgPVxuICAgICdUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZyc7XG5cbiAgZnVuY3Rpb24gX19kbG9wZW5fanMoZmlsZW5hbWUsIGZsYWcpIHtcbiAgICBhYm9ydChkbG9wZW5NaXNzaW5nRXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gX19kbHN5bV9qcyhoYW5kbGUsIHN5bWJvbCkge1xuICAgIGFib3J0KGRsb3Blbk1pc3NpbmdFcnJvcik7XG4gIH1cblxuICB2YXIgbm93SXNNb25vdG9uaWMgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYygpIHtcbiAgICByZXR1cm4gbm93SXNNb25vdG9uaWM7XG4gIH1cblxuICBmdW5jdGlvbiBfX21tYXBfanMobGVuLCBwcm90LCBmbGFncywgZmQsIG9mZiwgYWxsb2NhdGVkKSB7XG4gICAgcmV0dXJuIC01MjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9fbXVubWFwX2pzKGFkZHIsIGxlbiwgcHJvdCwgZmxhZ3MsIGZkLCBvZmZzZXQpIHt9XG5cbiAgZnVuY3Rpb24gX2Fib3J0KCkge1xuICAgIGFib3J0KCcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2RhdGVfbm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SGVhcE1heCgpIHtcbiAgICByZXR1cm4gMjE0NzQ4MzY0ODtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCgpIHtcbiAgICByZXR1cm4gZ2V0SGVhcE1heCgpO1xuICB9XG5cbiAgdmFyIF9lbXNjcmlwdGVuX2dldF9ub3c7XG4gIF9lbXNjcmlwdGVuX2dldF9ub3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcblxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3QsIHNyYywgbnVtKSB7XG4gICAgSEVBUFU4LmNvcHlXaXRoaW4oZGVzdCwgc3JjLCBzcmMgKyBudW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihzaXplKSB7XG4gICAgdHJ5IHtcbiAgICAgIHdhc21NZW1vcnkuZ3Jvdygoc2l6ZSAtIGJ1ZmZlci5ieXRlTGVuZ3RoICsgNjU1MzUpID4+PiAxNik7XG4gICAgICB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcik7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSkge1xuICAgIHZhciBvbGRTaXplID0gSEVBUFU4Lmxlbmd0aDtcbiAgICByZXF1ZXN0ZWRTaXplID0gcmVxdWVzdGVkU2l6ZSA+Pj4gMDtcbiAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgaWYgKHJlcXVlc3RlZFNpemUgPiBtYXhIZWFwU2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYWxpZ25VcCA9ICh4LCBtdWx0aXBsZSkgPT4geCArICgobXVsdGlwbGUgLSAoeCAlIG11bHRpcGxlKSkgJSBtdWx0aXBsZSk7XG4gICAgZm9yICh2YXIgY3V0RG93biA9IDE7IGN1dERvd24gPD0gNDsgY3V0RG93biAqPSAyKSB7XG4gICAgICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAwLjIgLyBjdXREb3duKTtcbiAgICAgIG92ZXJHcm93bkhlYXBTaXplID0gTWF0aC5taW4oXG4gICAgICAgIG92ZXJHcm93bkhlYXBTaXplLFxuICAgICAgICByZXF1ZXN0ZWRTaXplICsgMTAwNjYzMjk2LFxuICAgICAgKTtcbiAgICAgIHZhciBuZXdTaXplID0gTWF0aC5taW4oXG4gICAgICAgIG1heEhlYXBTaXplLFxuICAgICAgICBhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpLFxuICAgICAgKTtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIobmV3U2l6ZSk7XG4gICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBFTlYgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRFeGVjdXRhYmxlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpc1Byb2dyYW0gfHwgJy4vdGhpcy5wcm9ncmFtJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKSB7XG4gICAgaWYgKCFnZXRFbnZTdHJpbmdzLnN0cmluZ3MpIHtcbiAgICAgIHZhciBsYW5nID1cbiAgICAgICAgKFxuICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yID09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdKSB8fFxuICAgICAgICAgICdDJ1xuICAgICAgICApLnJlcGxhY2UoJy0nLCAnXycpICsgJy5VVEYtOCc7XG4gICAgICB2YXIgZW52ID0ge1xuICAgICAgICBVU0VSOiAnd2ViX3VzZXInLFxuICAgICAgICBMT0dOQU1FOiAnd2ViX3VzZXInLFxuICAgICAgICBQQVRIOiAnLycsXG4gICAgICAgIFBXRDogJy8nLFxuICAgICAgICBIT01FOiAnL2hvbWUvd2ViX3VzZXInLFxuICAgICAgICBMQU5HOiBsYW5nLFxuICAgICAgICBfOiBnZXRFeGVjdXRhYmxlTmFtZSgpLFxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIHggaW4gRU5WKSB7XG4gICAgICAgIGlmIChFTlZbeF0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIGVudlt4XTtcbiAgICAgICAgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gICAgICB9XG4gICAgICB2YXIgc3RyaW5ncyA9IFtdO1xuICAgICAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKHggKyAnPScgKyBlbnZbeF0pO1xuICAgICAgfVxuICAgICAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICB9XG4gICAgcmV0dXJuIGdldEVudlN0cmluZ3Muc3RyaW5ncztcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gIGZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIGJ1ZmZlciwgZG9udEFkZE51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgSEVBUDhbYnVmZmVyKysgPj4gMF0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgaWYgKCFkb250QWRkTnVsbCkgSEVBUDhbYnVmZmVyID4+IDBdID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnZpcm9uX2dldChfX2Vudmlyb24sIGVudmlyb25fYnVmKSB7XG4gICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgIGdldEVudlN0cmluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBwdHIgPSBlbnZpcm9uX2J1ZiArIGJ1ZlNpemU7XG4gICAgICBIRUFQVTMyWyhfX2Vudmlyb24gKyBpICogNCkgPj4gMl0gPSBwdHI7XG4gICAgICB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyaW5nLCBwdHIpO1xuICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICB9KTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCwgcGVudmlyb25fYnVmX3NpemUpIHtcbiAgICB2YXIgc3RyaW5ncyA9IGdldEVudlN0cmluZ3MoKTtcbiAgICBIRUFQVTMyW3BlbnZpcm9uX2NvdW50ID4+IDJdID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICBidWZTaXplICs9IHN0cmluZy5sZW5ndGggKyAxO1xuICAgIH0pO1xuICAgIEhFQVBVMzJbcGVudmlyb25fYnVmX3NpemUgPj4gMl0gPSBidWZTaXplO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Byb2NfZXhpdChjb2RlKSB7XG4gICAgaWYgKCFrZWVwUnVudGltZUFsaXZlKCkpIHtcbiAgICAgIGlmIChNb2R1bGVbJ29uRXhpdCddKSBNb2R1bGVbJ29uRXhpdCddKGNvZGUpO1xuICAgICAgQUJPUlQgPSB0cnVlO1xuICAgIH1cbiAgICBxdWl0Xyhjb2RlLCBuZXcgRXhpdFN0YXR1cyhjb2RlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBleGl0SlMoc3RhdHVzLCBpbXBsaWNpdCkge1xuICAgIF9wcm9jX2V4aXQoc3RhdHVzKTtcbiAgfVxuXG4gIHZhciBfZXhpdCA9IGV4aXRKUztcblxuICBmdW5jdGlvbiBfZmRfY2xvc2UoZmQpIHtcbiAgICByZXR1cm4gNTI7XG4gIH1cblxuICBmdW5jdGlvbiBfZmRfc2VlayhmZCwgb2Zmc2V0X2xvdywgb2Zmc2V0X2hpZ2gsIHdoZW5jZSwgbmV3T2Zmc2V0KSB7XG4gICAgcmV0dXJuIDcwO1xuICB9XG5cbiAgdmFyIHByaW50Q2hhckJ1ZmZlcnMgPSBbbnVsbCwgW10sIFtdXTtcblxuICBmdW5jdGlvbiBwcmludENoYXIoc3RyZWFtLCBjdXJyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICB2YXIgYnVmZmVyID0gcHJpbnRDaGFyQnVmZmVyc1tzdHJlYW1dO1xuICAgIGlmIChjdXJyID09PSAwIHx8IGN1cnIgPT09IDEwKSB7XG4gICAgICAoc3RyZWFtID09PSAxID8gb3V0IDogZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsIDApKTtcbiAgICAgIGJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjdXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZmRfd3JpdGUoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gICAgdmFyIG51bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgdmFyIHB0ciA9IEhFQVBVMzJbaW92ID4+IDJdO1xuICAgICAgdmFyIGxlbiA9IEhFQVBVMzJbKGlvdiArIDQpID4+IDJdO1xuICAgICAgaW92ICs9IDg7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHByaW50Q2hhcihmZCwgSEVBUFU4W3B0ciArIGpdKTtcbiAgICAgIH1cbiAgICAgIG51bSArPSBsZW47XG4gICAgfVxuICAgIEhFQVBVMzJbcG51bSA+PiAyXSA9IG51bTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhbmRvbURldmljZSgpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgY3J5cHRvID09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgY3J5cHRvWydnZXRSYW5kb21WYWx1ZXMnXSA9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB2YXIgcmFuZG9tQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ1ZmZlcik7XG4gICAgICAgIHJldHVybiByYW5kb21CdWZmZXJbMF07XG4gICAgICB9O1xuICAgIH0gZWxzZSByZXR1cm4gKCkgPT4gYWJvcnQoJ3JhbmRvbURldmljZScpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgZnVuY3Rpb24gX2dldGVudHJvcHkoYnVmZmVyLCBzaXplKSB7XG4gICAgaWYgKCFfZ2V0ZW50cm9weS5yYW5kb21EZXZpY2UpIHtcbiAgICAgIF9nZXRlbnRyb3B5LnJhbmRvbURldmljZSA9IGdldFJhbmRvbURldmljZSgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgSEVBUDhbKGJ1ZmZlciArIGkpID4+IDBdID0gX2dldGVudHJvcHkucmFuZG9tRGV2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGFzbUxpYnJhcnlBcmcgPSB7XG4gICAgX2RsaW5pdDogX19kbGluaXQsXG4gICAgX2Rsb3Blbl9qczogX19kbG9wZW5fanMsXG4gICAgX2Rsc3ltX2pzOiBfX2Rsc3ltX2pzLFxuICAgIF9lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljOiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMsXG4gICAgX21tYXBfanM6IF9fbW1hcF9qcyxcbiAgICBfbXVubWFwX2pzOiBfX211bm1hcF9qcyxcbiAgICBhYm9ydDogX2Fib3J0LFxuICAgIGVtc2NyaXB0ZW5fZGF0ZV9ub3c6IF9lbXNjcmlwdGVuX2RhdGVfbm93LFxuICAgIGVtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4OiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXG4gICAgZW1zY3JpcHRlbl9nZXRfbm93OiBfZW1zY3JpcHRlbl9nZXRfbm93LFxuICAgIGVtc2NyaXB0ZW5fbWVtY3B5X2JpZzogX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyxcbiAgICBlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgICBlbnZpcm9uX2dldDogX2Vudmlyb25fZ2V0LFxuICAgIGVudmlyb25fc2l6ZXNfZ2V0OiBfZW52aXJvbl9zaXplc19nZXQsXG4gICAgZXhpdDogX2V4aXQsXG4gICAgZmRfY2xvc2U6IF9mZF9jbG9zZSxcbiAgICBmZF9zZWVrOiBfZmRfc2VlayxcbiAgICBmZF93cml0ZTogX2ZkX3dyaXRlLFxuICAgIGdldGVudHJvcHk6IF9nZXRlbnRyb3B5LFxuICB9O1xuICBjcmVhdGVXYXNtKCk7XG4gIChNb2R1bGVbJ19fX3dhc21fY2FsbF9jdG9ycyddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfX193YXNtX2NhbGxfY3RvcnMnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldE1vZGVsQnVmZmVyTWVtb3J5T2Zmc2V0J10gPVxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoTW9kdWxlW1xuICAgICAgICAnX2dldE1vZGVsQnVmZmVyTWVtb3J5T2Zmc2V0J1xuICAgICAgXSA9XG4gICAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldE1vZGVsQnVmZmVyTWVtb3J5T2Zmc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gIChNb2R1bGVbJ19nZXRJbnB1dE1lbW9yeU9mZnNldCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0SW5wdXRNZW1vcnlPZmZzZXQnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRJbnB1dE1lbW9yeU9mZnNldCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldElucHV0SGVpZ2h0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRJbnB1dEhlaWdodCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldElucHV0SGVpZ2h0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfZ2V0SW5wdXRXaWR0aCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0SW5wdXRXaWR0aCddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2dldElucHV0V2lkdGgnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19nZXRJbnB1dENoYW5uZWxDb3VudCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0SW5wdXRDaGFubmVsQ291bnQnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRJbnB1dENoYW5uZWxDb3VudCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldE91dHB1dE1lbW9yeU9mZnNldCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0T3V0cHV0TWVtb3J5T2Zmc2V0J10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZ2V0T3V0cHV0TWVtb3J5T2Zmc2V0J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfZ2V0T3V0cHV0SGVpZ2h0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19nZXRPdXRwdXRIZWlnaHQnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRPdXRwdXRIZWlnaHQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19nZXRPdXRwdXRXaWR0aCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0T3V0cHV0V2lkdGgnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydnZXRPdXRwdXRXaWR0aCddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX2dldE91dHB1dENoYW5uZWxDb3VudCddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfZ2V0T3V0cHV0Q2hhbm5lbENvdW50J10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZ2V0T3V0cHV0Q2hhbm5lbENvdW50J10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuICAoTW9kdWxlWydfbG9hZE1vZGVsJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ19sb2FkTW9kZWwnXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydsb2FkTW9kZWwnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19ydW5JbmZlcmVuY2UnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnX3J1bkluZmVyZW5jZSddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ3J1bkluZmVyZW5jZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnX21hbGxvYyddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfbWFsbG9jJ10gPSBNb2R1bGVbJ2FzbSddWydtYWxsb2MnXSkuYXBwbHkoXG4gICAgICBudWxsLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gIH0pO1xuICAoTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ19fZXJybm9fbG9jYXRpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSk7XG4gIChNb2R1bGVbJ19fX2RsX3NldGVyciddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydfX19kbF9zZXRlcnInXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydfX2RsX3NldGVyciddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnc3RhY2tTYXZlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ3N0YWNrU2F2ZSddID0gTW9kdWxlWydhc20nXVsnc3RhY2tTYXZlJ10pLmFwcGx5KFxuICAgICAgbnVsbCxcbiAgICAgIGFyZ3VtZW50cyxcbiAgICApO1xuICB9KTtcbiAgKE1vZHVsZVsnc3RhY2tSZXN0b3JlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ3N0YWNrUmVzdG9yZSddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ3N0YWNrUmVzdG9yZSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnc3RhY2tBbGxvYyddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydzdGFja0FsbG9jJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnc3RhY2tBbGxvYyddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9qamonXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnZHluQ2FsbF9qamonXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2pqaiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9qaWlpJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ2R5bkNhbGxfamlpaSddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfamlpaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9paWlpamonXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKE1vZHVsZVsnZHluQ2FsbF9paWlpamonXSA9XG4gICAgICBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2lpaWlqaiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF92aWlqaiddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydkeW5DYWxsX3ZpaWpqJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWlqaiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF92aWlpampqJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ2R5bkNhbGxfdmlpaWpqaiddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpaWpqaiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9paWpqaWlpaSddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoTW9kdWxlWydkeW5DYWxsX2lpamppaWlpJ10gPVxuICAgICAgTW9kdWxlWydhc20nXVsnZHluQ2FsbF9paWpqaWlpaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgKE1vZHVsZVsnZHluQ2FsbF9qaWppJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChNb2R1bGVbJ2R5bkNhbGxfamlqaSddID1cbiAgICAgIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfamlqaSddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgdmFyIGNhbGxlZFJ1bjtcbiAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xuICAgIGlmICghY2FsbGVkUnVuKSBydW4oKTtcbiAgICBpZiAoIWNhbGxlZFJ1bikgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuQ2FsbGVyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJ1bihhcmdzKSB7XG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlUnVuKCk7XG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb1J1bigpIHtcbiAgICAgIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgICAgIGNhbGxlZFJ1biA9IHRydWU7XG4gICAgICBNb2R1bGVbJ2NhbGxlZFJ1biddID0gdHJ1ZTtcbiAgICAgIGlmIChBQk9SVCkgcmV0dXJuO1xuICAgICAgaW5pdFJ1bnRpbWUoKTtcbiAgICAgIHJlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtcbiAgICAgIGlmIChNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10pIE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSgpO1xuICAgICAgcG9zdFJ1bigpO1xuICAgIH1cblxuICAgIGlmIChNb2R1bGVbJ3NldFN0YXR1cyddKSB7XG4gICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCdSdW5uaW5nLi4uJyk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnJyk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgICBkb1J1bigpO1xuICAgICAgfSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvUnVuKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKE1vZHVsZVsncHJlSW5pdCddKSB7XG4gICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKVxuICAgICAgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3ByZUluaXQnXS5sZW5ndGggPiAwKSB7XG4gICAgICBNb2R1bGVbJ3ByZUluaXQnXS5wb3AoKSgpO1xuICAgIH1cbiAgfVxuICBydW4oKTtcblxuICByZXR1cm4gX19Nb2R1bGUucmVhZHk7XG59O1xuXG5jb25zdCB2ZXJzaW9uID0gXCIwLjEuMFwiIDtcbmNvbnN0IHBhY2thZ2VOYW1lID0gXCJAc3RyZWFtLWlvL3ZpZGVvLWZpbHRlcnMtd2ViXCIgO1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yIC0gbW9kdWxlIGlzIG5vdCBkZWNsYXJlZFxuLy8gVGhpcyBpcyBhIFdlYkFzc2VtYmx5IG1vZHVsZSBjb21waWxlZCBmcm9tIHRoZSBUZW5zb3JGbG93IExpdGUgQysrIGxpYnJhcnkuXG5jb25zdCBjcmVhdGVURkxpdGUgPSBjcmVhdGVURkxpdGVTSU1ETW9kdWxlO1xuY29uc3QgbG9hZFRGTGl0ZSA9IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGJhc2VQYXRoID0gYGh0dHBzOi8vdW5wa2cuY29tLyR7cGFja2FnZU5hbWV9QCR7dmVyc2lvbn0vdGZgLCB0ZkZpbGVQYXRoID0gYCR7YmFzZVBhdGh9L3RmbGl0ZS90ZmxpdGUtc2ltZC53YXNtYCwgbW9kZWxGaWxlUGF0aCA9IGAke2Jhc2VQYXRofS9tb2RlbHMvc2VnbV9mdWxsX3Y2NzkudGZsaXRlYCwgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgW3RmTGl0ZSwgbW9kZWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBjcmVhdGVURkxpdGUoeyBsb2NhdGVGaWxlOiAoKSA9PiB0ZkZpbGVQYXRoIH0pLFxuICAgICAgICBmZXRjaE1vZGVsKG1vZGVsRmlsZVBhdGgpLFxuICAgIF0pO1xuICAgIGNvbnN0IG1vZGVsQnVmZmVyT2Zmc2V0ID0gdGZMaXRlLl9nZXRNb2RlbEJ1ZmZlck1lbW9yeU9mZnNldCgpO1xuICAgIHRmTGl0ZS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KG1vZGVsKSwgbW9kZWxCdWZmZXJPZmZzZXQpO1xuICAgIHRmTGl0ZS5fbG9hZE1vZGVsKG1vZGVsLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB0ZkxpdGU7XG59O1xubGV0IGxhc3RNb2RlbEZpbGVQYXRoID0gJyc7XG5sZXQgbW9kZWxGaWxlQ2FjaGU7XG5jb25zdCBmZXRjaE1vZGVsID0gYXN5bmMgKG1vZGVsRmlsZVBhdGgpID0+IHtcbiAgICBjb25zdCBtb2RlbCA9IG1vZGVsRmlsZVBhdGggPT09IGxhc3RNb2RlbEZpbGVQYXRoICYmIG1vZGVsRmlsZUNhY2hlXG4gICAgICAgID8gbW9kZWxGaWxlQ2FjaGVcbiAgICAgICAgOiBhd2FpdCBmZXRjaChtb2RlbEZpbGVQYXRoKS50aGVuKChyKSA9PiByLmFycmF5QnVmZmVyKCkpO1xuICAgIC8vIENhY2hlIHRoZSBtb2RlbCBmaWxlIGZvciBmdXR1cmUgdXNlLlxuICAgIG1vZGVsRmlsZUNhY2hlID0gbW9kZWw7XG4gICAgbGFzdE1vZGVsRmlsZVBhdGggPSBtb2RlbEZpbGVQYXRoO1xuICAgIHJldHVybiBtb2RlbDtcbn07XG5cbmV4cG9ydCB7IFNlZ21lbnRhdGlvbkxldmVsLCBjcmVhdGVSZW5kZXJlciwgaXNQbGF0Zm9ybVN1cHBvcnRlZCwgbG9hZFRGTGl0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-filters-web/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-bindings/dist/index.es.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_LANGUAGE: () => (/* binding */ DEFAULT_LANGUAGE),\n/* harmony export */   DEFAULT_NAMESPACE: () => (/* binding */ DEFAULT_NAMESPACE),\n/* harmony export */   Restricted: () => (/* binding */ Restricted),\n/* harmony export */   StreamCallProvider: () => (/* binding */ StreamCallProvider),\n/* harmony export */   StreamI18n: () => (/* binding */ StreamI18n),\n/* harmony export */   StreamI18nProvider: () => (/* binding */ StreamI18nProvider),\n/* harmony export */   StreamVideoProvider: () => (/* binding */ StreamVideoProvider),\n/* harmony export */   defaultTranslationFunction: () => (/* binding */ defaultTranslationFunction),\n/* harmony export */   mapToRegistry: () => (/* binding */ mapToRegistry),\n/* harmony export */   useCall: () => (/* binding */ useCall),\n/* harmony export */   useCallStateHooks: () => (/* binding */ useCallStateHooks),\n/* harmony export */   useCalls: () => (/* binding */ useCalls),\n/* harmony export */   useConnectedUser: () => (/* binding */ useConnectedUser),\n/* harmony export */   useCreateI18n: () => (/* binding */ useCreateI18n),\n/* harmony export */   useI18n: () => (/* binding */ useI18n),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStreamVideoClient: () => (/* binding */ useStreamVideoClient)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var i18next__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! i18next */ \"(ssr)/./node_modules/i18next/dist/esm/i18next.js\");\n/* harmony import */ var _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stream-io/video-client */ \"(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\");\n\n\n\n\n\nconst StreamCallContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n/**\n * A provider for the call object.\n */\nconst StreamCallProvider = (props) => {\n    const { call, children } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamCallContext.Provider, { value: call, children: children }));\n};\n/**\n * A hook to get the call object from the closest provider.\n */\nconst useCall = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamCallContext);\n};\n\nconst mapToRegistry = (translationsMap, namespace) => Object.entries(translationsMap).reduce((acc, [lng, translations]) => {\n    acc[lng] = { [namespace]: translations };\n    return acc;\n}, {});\n\nconst DEFAULT_LANGUAGE = 'en';\nconst DEFAULT_NAMESPACE = 'stream-video';\nconst DEFAULT_CONFIG = {\n    debug: false,\n    currentLanguage: DEFAULT_LANGUAGE,\n    fallbackLanguage: false,\n};\nconst DEFAULT_TRANSLATIONS_REGISTRY = mapToRegistry({}, DEFAULT_NAMESPACE);\nconst defaultTranslationFunction = (key) => key;\nclass StreamI18n {\n    /** Simple logger function */\n    constructor(options = {}) {\n        /** Translator function that converts the provided string into its equivalent in the current language. */\n        this.t = defaultTranslationFunction;\n        this.init = async () => {\n            try {\n                this.t = await this.i18nInstance.init();\n            }\n            catch (e) {\n                console.error(`Failed to initialize translations: ${JSON.stringify(e)}`);\n            }\n            return this;\n        };\n        this.changeLanguage = async (language, onChange) => {\n            if (!this._checkIsInitialized())\n                return;\n            // i18next detects the language, if none provided, but it is better\n            // to show this detection here explicitly\n            const browserLanguage = typeof window !== 'undefined' && window.navigator\n                ? window.navigator.language\n                : undefined;\n            await this.i18nInstance.changeLanguage(language || browserLanguage);\n            onChange?.(this.currentLanguage);\n        };\n        this.registerTranslationsForLanguage = ({ lng, translations, }) => {\n            if (!this._checkIsInitialized())\n                return;\n            this.i18nInstance.addResourceBundle(lng, DEFAULT_NAMESPACE, translations, true, true);\n        };\n        this._checkIsInitialized = () => {\n            if (!this.i18nInstance.isInitialized) {\n                console.warn('I18n instance is not initialized. Call yourStreamI18nInstance.init().');\n            }\n            return this.i18nInstance.isInitialized;\n        };\n        const { debug = DEFAULT_CONFIG.debug, currentLanguage = DEFAULT_CONFIG.currentLanguage, fallbackLanguage = DEFAULT_CONFIG.fallbackLanguage, translationsOverrides, } = options;\n        this.i18nInstance = i18next__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createInstance({\n            debug,\n            defaultNS: DEFAULT_NAMESPACE,\n            fallbackLng: fallbackLanguage,\n            interpolation: { escapeValue: false },\n            keySeparator: false,\n            lng: currentLanguage,\n            nsSeparator: false,\n            parseMissingKeyHandler: (key) => {\n                return key;\n            },\n            resources: DEFAULT_TRANSLATIONS_REGISTRY,\n        });\n        if (translationsOverrides) {\n            this.i18nInstance.on('initialized', () => {\n                Object.entries(translationsOverrides).forEach(([lng, translations]) => {\n                    this.registerTranslationsForLanguage({ lng, translations });\n                });\n            });\n        }\n    }\n    get currentLanguage() {\n        this._checkIsInitialized();\n        return this.i18nInstance.language;\n    }\n    get isInitialized() {\n        return this.i18nInstance.isInitialized;\n    }\n}\n\nconst StreamI18nContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    t: defaultTranslationFunction,\n});\nconst StreamI18nProvider = ({ children, ...createI18nParams }) => {\n    const { i18n, t } = useCreateI18n(createI18nParams);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamI18nContext.Provider, { value: { t, i18n }, children: children }));\n};\nconst useCreateI18n = ({ i18nInstance, language, fallbackLanguage, translationsOverrides, }) => {\n    const [i18n] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => i18nInstance ||\n        new StreamI18n({\n            currentLanguage: language,\n            fallbackLanguage,\n            translationsOverrides,\n        }));\n    const [t, setTranslationFn] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => defaultTranslationFunction);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const { isInitialized } = i18n;\n        if (!isInitialized) {\n            i18n.init().then((_i18n) => setTranslationFn(() => _i18n.i18nInstance.t));\n            return;\n        }\n        if (language && i18n?.currentLanguage !== language) {\n            i18n.changeLanguage(language).catch((err) => {\n                console.log('Error while changing language', err);\n            });\n        }\n    }, [i18n, i18nInstance, language, translationsOverrides]);\n    return { i18n, t };\n};\nconst useI18n = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamI18nContext);\n\nconst StreamVideoContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n/**\n * StreamVideo is a provider component which should be used to wrap the entire application.\n * It provides the client object to all children components and initializes the i18n instance.\n *  @param PropsWithChildren<StreamVideoProps>\n *  @category Client State\n */\nconst StreamVideoProvider = ({ children, client, i18nInstance, language, translationsOverrides, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamVideoContext.Provider, { value: client, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamI18nProvider, { i18nInstance: i18nInstance, language: language, translationsOverrides: translationsOverrides, children: children }) }));\n};\n/**\n *\n * @returns\n *\n * @category Client State\n */\nconst useStreamVideoClient = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamVideoContext);\n};\n\n/**\n * Utility hook which provides the current value of the given observable.\n * @internal\n */\nconst useObservableValue = (observable$) => {\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__.RxUtils.getCurrentValue(observable$));\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const subscription = observable$.subscribe(setValue);\n        return () => {\n            subscription.unsubscribe();\n        };\n    }, [observable$]);\n    return value;\n};\n\n/**\n * Checks whether we are using React Native\n */\nconst isReactNative = () => {\n    if (typeof navigator === 'undefined')\n        return false;\n    return navigator.product?.toLowerCase() === 'reactnative';\n};\n\n/**\n * Utility hook, which provides the current call's state.\n *\n * @category Call State\n */\nconst useCallState = () => {\n    const call = useCall();\n    // return an empty and unlinked CallState object if there is no call in the provider\n    // this ensures that the hooks always return a value and many null checks can be avoided\n    if (!call) {\n        const message = 'You are using useCallState() outside a Call context. ' +\n            'Please wrap your component in <StreamCall /> and provide a \"call\" instance.';\n        console.warn(message);\n        return new _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__.CallState();\n    }\n    return call.state;\n};\n/**\n * Utility hook which provides information whether the current call is being recorded. It will return `true` if the call is being recorded.\n *\n * @category Call State\n */\nconst useIsCallRecordingInProgress = () => {\n    const { recording$ } = useCallState();\n    return useObservableValue(recording$);\n};\n/**\n * Utility hook which provides information whether the current call is broadcasting.\n *\n * @category Call State\n */\nconst useIsCallHLSBroadcastingInProgress = () => {\n    const { egress$ } = useCallState();\n    const egress = useObservableValue(egress$);\n    if (!egress)\n        return false;\n    return egress.broadcasting;\n};\n/**\n * Utility hook which provides information whether the current call is live.\n *\n * @category Call State\n */\nconst useIsCallLive = () => {\n    const { backstage$ } = useCallState();\n    const isBackstageOn = useObservableValue(backstage$);\n    return !isBackstageOn;\n};\n/**\n * Returns the list of blocked users in the current call.\n */\nconst useCallBlockedUserIds = () => {\n    const { blockedUserIds$ } = useCallState();\n    return useObservableValue(blockedUserIds$);\n};\n/**\n * Returns the timestamp when this call was created.\n */\nconst useCallCreatedAt = () => {\n    const { createdAt$ } = useCallState();\n    return useObservableValue(createdAt$);\n};\n/**\n * Returns the timestamp when this call was ended.\n */\nconst useCallEndedAt = () => {\n    const { endedAt$ } = useCallState();\n    return useObservableValue(endedAt$);\n};\n/**\n * Returns the timestamp telling when the call is scheduled to start.\n */\nconst useCallStartsAt = () => {\n    const { startsAt$ } = useCallState();\n    return useObservableValue(startsAt$);\n};\n/**\n * Returns the timestamp when this call was updated.\n */\nconst useCallUpdatedAt = () => {\n    const { updatedAt$ } = useCallState();\n    return useObservableValue(updatedAt$);\n};\n/**\n * Returns the information about the call's creator.\n */\nconst useCallCreatedBy = () => {\n    const { createdBy$ } = useCallState();\n    return useObservableValue(createdBy$);\n};\n/**\n * Returns the call's custom data.\n */\nconst useCallCustomData = () => {\n    const { custom$ } = useCallState();\n    return useObservableValue(custom$);\n};\n/**\n * Returns the call's Egress information.\n */\nconst useCallEgress = () => {\n    const { egress$ } = useCallState();\n    return useObservableValue(egress$);\n};\n/**\n * Returns the call's Ingress information.\n */\nconst useCallIngress = () => {\n    const { ingress$ } = useCallState();\n    return useObservableValue(ingress$);\n};\n/**\n * Returns the data for the current call session.\n */\nconst useCallSession = () => {\n    const { session$ } = useCallState();\n    return useObservableValue(session$);\n};\n/**\n * Returns the call's settings.\n */\nconst useCallSettings = () => {\n    const { settings$ } = useCallState();\n    return useObservableValue(settings$);\n};\n/**\n * Returns whether the call has transcribing enabled.\n */\nconst useIsCallTranscribingInProgress = () => {\n    const { transcribing$ } = useCallState();\n    return useObservableValue(transcribing$);\n};\n/**\n * Returns information about the user who has marked this call as ended.\n */\nconst useCallEndedBy = () => {\n    const { endedBy$ } = useCallState();\n    return useObservableValue(endedBy$);\n};\n/**\n * Utility hook which provides a boolean indicating whether there is\n * a participant in the current call which shares their screen.\n *\n * @category Call State\n */\nconst useHasOngoingScreenShare = () => {\n    const { hasOngoingScreenShare$ } = useCallState();\n    return useObservableValue(hasOngoingScreenShare$);\n};\n/**\n * Utility hook which provides the latest stats report of the current call.\n *\n * The latest stats report of the current call.\n * When stats gathering is enabled, this observable will emit a new value\n * at a regular (configurable) interval.\n *\n * Consumers of this observable can implement their own batching logic\n * in case they want to show historical stats data.\n *\n * @category Call State\n */\nconst useCallStatsReport = () => {\n    const { callStatsReport$ } = useCallState();\n    return useObservableValue(callStatsReport$);\n};\n/**\n * Utility hook which provides the dominant speaker of the current call.\n *\n * @category Call State\n */\nconst useDominantSpeaker = () => {\n    const { dominantSpeaker$ } = useCallState();\n    return useObservableValue(dominantSpeaker$);\n};\n/**\n * Utility hook which provides a list of call members.\n *\n * @category Call State\n */\nconst useCallMembers = () => {\n    const { members$ } = useCallState();\n    return useObservableValue(members$);\n};\n/**\n * Utility hook providing the current calling state of the call. For example, `RINGING` or `JOINED`.\n *\n * @category Call State\n */\nconst useCallCallingState = () => {\n    const { callingState$ } = useCallState();\n    return useObservableValue(callingState$);\n};\n/**\n * Utility hook providing the actual start time of the current session.\n * Useful for calculating the call duration.\n *\n * @category Call State\n */\nconst useCallStartedAt = () => {\n    const { startedAt$ } = useCallState();\n    return useObservableValue(startedAt$);\n};\n/**\n * A hook which provides a list of all participants that have joined an active call.\n *\n * @category Call State\n *\n * @param options.sortBy - A comparator function to sort the participants by.\n * Make sure to memoize output of the `combineComparators` function\n * (or keep it out of component's scope if possible) before passing it down to this property.\n */\nconst useParticipants = ({ sortBy, } = {}) => {\n    const { participants$ } = useCallState();\n    const participants = useObservableValue(participants$);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        if (sortBy) {\n            return [...participants].sort(sortBy);\n        }\n        return participants;\n    }, [participants, sortBy]);\n};\n/**\n * A hook which provides a StreamVideoLocalParticipant object.\n * It signals that I have joined a call.\n *\n * @category Call State\n */\nconst useLocalParticipant = () => {\n    const { localParticipant$ } = useCallState();\n    return useObservableValue(localParticipant$);\n};\n/**\n * A hook which provides a list of all other participants than me that have joined an active call.\n *\n * @category Call State\n */\nconst useRemoteParticipants = () => {\n    const { remoteParticipants$ } = useCallState();\n    return useObservableValue(remoteParticipants$);\n};\n/**\n * Returns the approximate participant count of the active call.\n * This includes the anonymous users as well, and it is computed on the server.\n *\n * @category Call State\n */\nconst useParticipantCount = () => {\n    const { participantCount$ } = useCallState();\n    return useObservableValue(participantCount$);\n};\n/**\n * Returns the approximate anonymous participant count of the active call.\n * The regular participants are not included in this count. It is computed on the server.\n *\n * @category Call State\n */\nconst useAnonymousParticipantCount = () => {\n    const { anonymousParticipantCount$ } = useCallState();\n    return useObservableValue(anonymousParticipantCount$);\n};\n/**\n * Returns the generated thumbnail of the current call, if enabled in settings.\n */\nconst useCallThumbnail = () => {\n    const { thumbnails$ } = useCallState();\n    return useObservableValue(thumbnails$);\n};\n/**\n * A hook which returns the local participant's own capabilities.\n */\nconst useOwnCapabilities = () => {\n    const { ownCapabilities$ } = useCallState();\n    return useObservableValue(ownCapabilities$);\n};\n/**\n * Hook that returns true if the local participant has all the given permissions.\n *\n * @param permissions the permissions to check.\n */\nconst useHasPermissions = (...permissions) => {\n    const capabilities = useOwnCapabilities();\n    return permissions.every((permission) => capabilities?.includes(permission));\n};\n/**\n * Returns the camera state of the current call.\n *\n * @category Camera Manager State\n *\n */\nconst useCameraState = () => {\n    const call = useCall();\n    const { camera } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => camera.listDevices(), [camera]);\n    const { state } = camera;\n    const status = useObservableValue(state.status$);\n    const direction = useObservableValue(state.direction$);\n    const mediaStream = useObservableValue(state.mediaStream$);\n    const selectedDevice = useObservableValue(state.selectedDevice$);\n    const devices = useObservableValue(devices$);\n    const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);\n    const isMute = status !== 'enabled';\n    return {\n        camera,\n        status,\n        isEnabled: status === 'enabled',\n        direction,\n        mediaStream,\n        devices,\n        hasBrowserPermission,\n        selectedDevice,\n        isMute,\n    };\n};\n/**\n * Returns the microphone state of the current call.\n *\n * @category Microphone Manager State\n */\nconst useMicrophoneState = () => {\n    const call = useCall();\n    const { microphone } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => microphone.listDevices(), [microphone]);\n    const { state } = microphone;\n    const status = useObservableValue(state.status$);\n    const mediaStream = useObservableValue(state.mediaStream$);\n    const selectedDevice = useObservableValue(state.selectedDevice$);\n    const devices = useObservableValue(devices$);\n    const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);\n    const isSpeakingWhileMuted = useObservableValue(state.speakingWhileMuted$);\n    const isMute = status !== 'enabled';\n    return {\n        microphone,\n        status,\n        isEnabled: status === 'enabled',\n        mediaStream,\n        devices,\n        selectedDevice,\n        hasBrowserPermission,\n        isSpeakingWhileMuted,\n        isMute,\n    };\n};\n/**\n * Returns the speaker state of the current call.\n *\n * Note: This hook is not supported in React Native\n */\nconst useSpeakerState = () => {\n    if (isReactNative()) {\n        throw new Error('This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details');\n    }\n    const call = useCall();\n    const { speaker } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => speaker.listDevices(), [speaker]);\n    const devices = useObservableValue(devices$);\n    const selectedDevice = useObservableValue(speaker.state.selectedDevice$);\n    return {\n        speaker,\n        devices,\n        selectedDevice,\n        isDeviceSelectionSupported: speaker.state.isDeviceSelectionSupported,\n    };\n};\n/**\n * Returns the Screen Share state of the current call.\n */\nconst useScreenShareState = () => {\n    const call = useCall();\n    const { screenShare } = call;\n    const status = useObservableValue(screenShare.state.status$);\n    const mediaStream = useObservableValue(screenShare.state.mediaStream$);\n    const isMute = status !== 'enabled';\n    return {\n        screenShare,\n        mediaStream,\n        status,\n        isMute,\n    };\n};\n\nvar CallStateHooks = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    useAnonymousParticipantCount: useAnonymousParticipantCount,\n    useCallBlockedUserIds: useCallBlockedUserIds,\n    useCallCallingState: useCallCallingState,\n    useCallCreatedAt: useCallCreatedAt,\n    useCallCreatedBy: useCallCreatedBy,\n    useCallCustomData: useCallCustomData,\n    useCallEgress: useCallEgress,\n    useCallEndedAt: useCallEndedAt,\n    useCallEndedBy: useCallEndedBy,\n    useCallIngress: useCallIngress,\n    useCallMembers: useCallMembers,\n    useCallSession: useCallSession,\n    useCallSettings: useCallSettings,\n    useCallStartedAt: useCallStartedAt,\n    useCallStartsAt: useCallStartsAt,\n    useCallState: useCallState,\n    useCallStatsReport: useCallStatsReport,\n    useCallThumbnail: useCallThumbnail,\n    useCallUpdatedAt: useCallUpdatedAt,\n    useCameraState: useCameraState,\n    useDominantSpeaker: useDominantSpeaker,\n    useHasOngoingScreenShare: useHasOngoingScreenShare,\n    useHasPermissions: useHasPermissions,\n    useIsCallHLSBroadcastingInProgress: useIsCallHLSBroadcastingInProgress,\n    useIsCallLive: useIsCallLive,\n    useIsCallRecordingInProgress: useIsCallRecordingInProgress,\n    useIsCallTranscribingInProgress: useIsCallTranscribingInProgress,\n    useLocalParticipant: useLocalParticipant,\n    useMicrophoneState: useMicrophoneState,\n    useOwnCapabilities: useOwnCapabilities,\n    useParticipantCount: useParticipantCount,\n    useParticipants: useParticipants,\n    useRemoteParticipants: useRemoteParticipants,\n    useScreenShareState: useScreenShareState,\n    useSpeakerState: useSpeakerState\n});\n\n/**\n * Utility hook which provides access to client's state store.\n */\nconst useStore = () => {\n    const client = useStreamVideoClient();\n    if (!client) {\n        throw new Error(`StreamVideoClient isn't initialized or this hook is called outside of <StreamVideo> context.`);\n    }\n    return client.readOnlyStateStore;\n};\n/**\n * Utility hook which provides a list of all notifications about created calls.\n * In the ring call settings, these calls can be outgoing (I have called somebody)\n * or incoming (somebody has called me).\n *\n * @category Client State\n */\nconst useCalls = () => {\n    const { calls$ } = useStore();\n    return useObservableValue(calls$);\n};\n/**\n * Returns the current connected user.\n *\n * @category Client State\n */\nconst useConnectedUser = () => {\n    const { connectedUser$ } = useStore();\n    return useObservableValue(connectedUser$);\n};\n\n/**\n * A hook-alike function that exposes all call state hooks.\n *\n * @category Call State\n */\nconst useCallStateHooks = () => CallStateHooks;\n\nconst Restricted = ({ canRequestOnly, hasPermissionsOnly, requiredGrants, requireAll = true, children, }) => {\n    const call = useCall();\n    const { useCallSettings, useOwnCapabilities } = useCallStateHooks();\n    const ownCapabilities = useOwnCapabilities();\n    const settings = useCallSettings();\n    const hasPermissions = requiredGrants[requireAll ? 'every' : 'some']((capability) => ownCapabilities?.includes(capability));\n    if (hasPermissionsOnly)\n        return hasPermissions ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children }) : null;\n    const canRequest = requiredGrants.some((capability) => call?.permissionsContext.canRequest(capability, settings));\n    if (canRequestOnly)\n        return canRequest ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children }) : null;\n    if (hasPermissions || canRequest)\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children });\n    return null;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1iaW5kaW5ncy9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtEO0FBQzhCO0FBQ2xEO0FBQytCOztBQUU3RCwwQkFBMEIsb0RBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLHNEQUFHLCtCQUErQixpQ0FBaUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQVU7QUFDckI7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2SkFBNko7QUFDN0ssNEJBQTRCLDhEQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1CQUFtQjtBQUM5RSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixvREFBYTtBQUN2QztBQUNBLENBQUM7QUFDRCw4QkFBOEIsK0JBQStCO0FBQzdELFlBQVks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QUFJLG9CQUFvQjtBQUNuRDtBQUNBOztBQUUrUjtBQUMvUiIsInNvdXJjZXMiOlsid2VicGFjazovL3lvb20vLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1iaW5kaW5ncy9kaXN0L2luZGV4LmVzLmpzPzNjOTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4LCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaTE4bmV4dCBmcm9tICdpMThuZXh0JztcbmltcG9ydCB7IFJ4VXRpbHMsIENhbGxTdGF0ZSB9IGZyb20gJ0BzdHJlYW0taW8vdmlkZW8tY2xpZW50JztcblxuY29uc3QgU3RyZWFtQ2FsbENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKipcbiAqIEEgcHJvdmlkZXIgZm9yIHRoZSBjYWxsIG9iamVjdC5cbiAqL1xuY29uc3QgU3RyZWFtQ2FsbFByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjYWxsLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChqc3goU3RyZWFtQ2FsbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNhbGwsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuLyoqXG4gKiBBIGhvb2sgdG8gZ2V0IHRoZSBjYWxsIG9iamVjdCBmcm9tIHRoZSBjbG9zZXN0IHByb3ZpZGVyLlxuICovXG5jb25zdCB1c2VDYWxsID0gKCkgPT4ge1xuICAgIHJldHVybiB1c2VDb250ZXh0KFN0cmVhbUNhbGxDb250ZXh0KTtcbn07XG5cbmNvbnN0IG1hcFRvUmVnaXN0cnkgPSAodHJhbnNsYXRpb25zTWFwLCBuYW1lc3BhY2UpID0+IE9iamVjdC5lbnRyaWVzKHRyYW5zbGF0aW9uc01hcCkucmVkdWNlKChhY2MsIFtsbmcsIHRyYW5zbGF0aW9uc10pID0+IHtcbiAgICBhY2NbbG5nXSA9IHsgW25hbWVzcGFjZV06IHRyYW5zbGF0aW9ucyB9O1xuICAgIHJldHVybiBhY2M7XG59LCB7fSk7XG5cbmNvbnN0IERFRkFVTFRfTEFOR1VBR0UgPSAnZW4nO1xuY29uc3QgREVGQVVMVF9OQU1FU1BBQ0UgPSAnc3RyZWFtLXZpZGVvJztcbmNvbnN0IERFRkFVTFRfQ09ORklHID0ge1xuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBjdXJyZW50TGFuZ3VhZ2U6IERFRkFVTFRfTEFOR1VBR0UsXG4gICAgZmFsbGJhY2tMYW5ndWFnZTogZmFsc2UsXG59O1xuY29uc3QgREVGQVVMVF9UUkFOU0xBVElPTlNfUkVHSVNUUlkgPSBtYXBUb1JlZ2lzdHJ5KHt9LCBERUZBVUxUX05BTUVTUEFDRSk7XG5jb25zdCBkZWZhdWx0VHJhbnNsYXRpb25GdW5jdGlvbiA9IChrZXkpID0+IGtleTtcbmNsYXNzIFN0cmVhbUkxOG4ge1xuICAgIC8qKiBTaW1wbGUgbG9nZ2VyIGZ1bmN0aW9uICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qKiBUcmFuc2xhdG9yIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgdGhlIHByb3ZpZGVkIHN0cmluZyBpbnRvIGl0cyBlcXVpdmFsZW50IGluIHRoZSBjdXJyZW50IGxhbmd1YWdlLiAqL1xuICAgICAgICB0aGlzLnQgPSBkZWZhdWx0VHJhbnNsYXRpb25GdW5jdGlvbjtcbiAgICAgICAgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnQgPSBhd2FpdCB0aGlzLmkxOG5JbnN0YW5jZS5pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIHRyYW5zbGF0aW9uczogJHtKU09OLnN0cmluZ2lmeShlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5nZUxhbmd1YWdlID0gYXN5bmMgKGxhbmd1YWdlLCBvbkNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGVja0lzSW5pdGlhbGl6ZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBpMThuZXh0IGRldGVjdHMgdGhlIGxhbmd1YWdlLCBpZiBub25lIHByb3ZpZGVkLCBidXQgaXQgaXMgYmV0dGVyXG4gICAgICAgICAgICAvLyB0byBzaG93IHRoaXMgZGV0ZWN0aW9uIGhlcmUgZXhwbGljaXRseVxuICAgICAgICAgICAgY29uc3QgYnJvd3Nlckxhbmd1YWdlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvclxuICAgICAgICAgICAgICAgID8gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pMThuSW5zdGFuY2UuY2hhbmdlTGFuZ3VhZ2UobGFuZ3VhZ2UgfHwgYnJvd3Nlckxhbmd1YWdlKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlPy4odGhpcy5jdXJyZW50TGFuZ3VhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVHJhbnNsYXRpb25zRm9yTGFuZ3VhZ2UgPSAoeyBsbmcsIHRyYW5zbGF0aW9ucywgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGVja0lzSW5pdGlhbGl6ZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmkxOG5JbnN0YW5jZS5hZGRSZXNvdXJjZUJ1bmRsZShsbmcsIERFRkFVTFRfTkFNRVNQQUNFLCB0cmFuc2xhdGlvbnMsIHRydWUsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaGVja0lzSW5pdGlhbGl6ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaTE4bkluc3RhbmNlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0kxOG4gaW5zdGFuY2UgaXMgbm90IGluaXRpYWxpemVkLiBDYWxsIHlvdXJTdHJlYW1JMThuSW5zdGFuY2UuaW5pdCgpLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaTE4bkluc3RhbmNlLmlzSW5pdGlhbGl6ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgZGVidWcgPSBERUZBVUxUX0NPTkZJRy5kZWJ1ZywgY3VycmVudExhbmd1YWdlID0gREVGQVVMVF9DT05GSUcuY3VycmVudExhbmd1YWdlLCBmYWxsYmFja0xhbmd1YWdlID0gREVGQVVMVF9DT05GSUcuZmFsbGJhY2tMYW5ndWFnZSwgdHJhbnNsYXRpb25zT3ZlcnJpZGVzLCB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pMThuSW5zdGFuY2UgPSBpMThuZXh0LmNyZWF0ZUluc3RhbmNlKHtcbiAgICAgICAgICAgIGRlYnVnLFxuICAgICAgICAgICAgZGVmYXVsdE5TOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGZhbGxiYWNrTG5nOiBmYWxsYmFja0xhbmd1YWdlLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogeyBlc2NhcGVWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgIGtleVNlcGFyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICBsbmc6IGN1cnJlbnRMYW5ndWFnZSxcbiAgICAgICAgICAgIG5zU2VwYXJhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlTWlzc2luZ0tleUhhbmRsZXI6IChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc291cmNlczogREVGQVVMVF9UUkFOU0xBVElPTlNfUkVHSVNUUlksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHJhbnNsYXRpb25zT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5JbnN0YW5jZS5vbignaW5pdGlhbGl6ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModHJhbnNsYXRpb25zT3ZlcnJpZGVzKS5mb3JFYWNoKChbbG5nLCB0cmFuc2xhdGlvbnNdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJUcmFuc2xhdGlvbnNGb3JMYW5ndWFnZSh7IGxuZywgdHJhbnNsYXRpb25zIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRMYW5ndWFnZSgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJc0luaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmkxOG5JbnN0YW5jZS5sYW5ndWFnZTtcbiAgICB9XG4gICAgZ2V0IGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmkxOG5JbnN0YW5jZS5pc0luaXRpYWxpemVkO1xuICAgIH1cbn1cblxuY29uc3QgU3RyZWFtSTE4bkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgICB0OiBkZWZhdWx0VHJhbnNsYXRpb25GdW5jdGlvbixcbn0pO1xuY29uc3QgU3RyZWFtSTE4blByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIC4uLmNyZWF0ZUkxOG5QYXJhbXMgfSkgPT4ge1xuICAgIGNvbnN0IHsgaTE4biwgdCB9ID0gdXNlQ3JlYXRlSTE4bihjcmVhdGVJMThuUGFyYW1zKTtcbiAgICByZXR1cm4gKGpzeChTdHJlYW1JMThuQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyB0LCBpMThuIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuY29uc3QgdXNlQ3JlYXRlSTE4biA9ICh7IGkxOG5JbnN0YW5jZSwgbGFuZ3VhZ2UsIGZhbGxiYWNrTGFuZ3VhZ2UsIHRyYW5zbGF0aW9uc092ZXJyaWRlcywgfSkgPT4ge1xuICAgIGNvbnN0IFtpMThuXSA9IHVzZVN0YXRlKCgpID0+IGkxOG5JbnN0YW5jZSB8fFxuICAgICAgICBuZXcgU3RyZWFtSTE4bih7XG4gICAgICAgICAgICBjdXJyZW50TGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICAgICAgZmFsbGJhY2tMYW5ndWFnZSxcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uc092ZXJyaWRlcyxcbiAgICAgICAgfSkpO1xuICAgIGNvbnN0IFt0LCBzZXRUcmFuc2xhdGlvbkZuXSA9IHVzZVN0YXRlKCgpID0+IGRlZmF1bHRUcmFuc2xhdGlvbkZ1bmN0aW9uKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGlzSW5pdGlhbGl6ZWQgfSA9IGkxOG47XG4gICAgICAgIGlmICghaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgaTE4bi5pbml0KCkudGhlbigoX2kxOG4pID0+IHNldFRyYW5zbGF0aW9uRm4oKCkgPT4gX2kxOG4uaTE4bkluc3RhbmNlLnQpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ3VhZ2UgJiYgaTE4bj8uY3VycmVudExhbmd1YWdlICE9PSBsYW5ndWFnZSkge1xuICAgICAgICAgICAgaTE4bi5jaGFuZ2VMYW5ndWFnZShsYW5ndWFnZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciB3aGlsZSBjaGFuZ2luZyBsYW5ndWFnZScsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtpMThuLCBpMThuSW5zdGFuY2UsIGxhbmd1YWdlLCB0cmFuc2xhdGlvbnNPdmVycmlkZXNdKTtcbiAgICByZXR1cm4geyBpMThuLCB0IH07XG59O1xuY29uc3QgdXNlSTE4biA9ICgpID0+IHVzZUNvbnRleHQoU3RyZWFtSTE4bkNvbnRleHQpO1xuXG5jb25zdCBTdHJlYW1WaWRlb0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG4vKipcbiAqIFN0cmVhbVZpZGVvIGlzIGEgcHJvdmlkZXIgY29tcG9uZW50IHdoaWNoIHNob3VsZCBiZSB1c2VkIHRvIHdyYXAgdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cbiAqIEl0IHByb3ZpZGVzIHRoZSBjbGllbnQgb2JqZWN0IHRvIGFsbCBjaGlsZHJlbiBjb21wb25lbnRzIGFuZCBpbml0aWFsaXplcyB0aGUgaTE4biBpbnN0YW5jZS5cbiAqICBAcGFyYW0gUHJvcHNXaXRoQ2hpbGRyZW48U3RyZWFtVmlkZW9Qcm9wcz5cbiAqICBAY2F0ZWdvcnkgQ2xpZW50IFN0YXRlXG4gKi9cbmNvbnN0IFN0cmVhbVZpZGVvUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgY2xpZW50LCBpMThuSW5zdGFuY2UsIGxhbmd1YWdlLCB0cmFuc2xhdGlvbnNPdmVycmlkZXMsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChTdHJlYW1WaWRlb0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNsaWVudCwgY2hpbGRyZW46IGpzeChTdHJlYW1JMThuUHJvdmlkZXIsIHsgaTE4bkluc3RhbmNlOiBpMThuSW5zdGFuY2UsIGxhbmd1YWdlOiBsYW5ndWFnZSwgdHJhbnNsYXRpb25zT3ZlcnJpZGVzOiB0cmFuc2xhdGlvbnNPdmVycmlkZXMsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59O1xuLyoqXG4gKlxuICogQHJldHVybnNcbiAqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50IFN0YXRlXG4gKi9cbmNvbnN0IHVzZVN0cmVhbVZpZGVvQ2xpZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiB1c2VDb250ZXh0KFN0cmVhbVZpZGVvQ29udGV4dCk7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb2JzZXJ2YWJsZS5cbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCB1c2VPYnNlcnZhYmxlVmFsdWUgPSAob2JzZXJ2YWJsZSQpID0+IHtcbiAgICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVN0YXRlKCgpID0+IFJ4VXRpbHMuZ2V0Q3VycmVudFZhbHVlKG9ic2VydmFibGUkKSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZSQuc3Vic2NyaWJlKHNldFZhbHVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtvYnNlcnZhYmxlJF0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgd2UgYXJlIHVzaW5nIFJlYWN0IE5hdGl2ZVxuICovXG5jb25zdCBpc1JlYWN0TmF0aXZlID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdD8udG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBob29rLCB3aGljaCBwcm92aWRlcyB0aGUgY3VycmVudCBjYWxsJ3Mgc3RhdGUuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlQ2FsbFN0YXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgLy8gcmV0dXJuIGFuIGVtcHR5IGFuZCB1bmxpbmtlZCBDYWxsU3RhdGUgb2JqZWN0IGlmIHRoZXJlIGlzIG5vIGNhbGwgaW4gdGhlIHByb3ZpZGVyXG4gICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGhvb2tzIGFsd2F5cyByZXR1cm4gYSB2YWx1ZSBhbmQgbWFueSBudWxsIGNoZWNrcyBjYW4gYmUgYXZvaWRlZFxuICAgIGlmICghY2FsbCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1lvdSBhcmUgdXNpbmcgdXNlQ2FsbFN0YXRlKCkgb3V0c2lkZSBhIENhbGwgY29udGV4dC4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHdyYXAgeW91ciBjb21wb25lbnQgaW4gPFN0cmVhbUNhbGwgLz4gYW5kIHByb3ZpZGUgYSBcImNhbGxcIiBpbnN0YW5jZS4nO1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbFN0YXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsLnN0YXRlO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHdoaWNoIHByb3ZpZGVzIGluZm9ybWF0aW9uIHdoZXRoZXIgdGhlIGN1cnJlbnQgY2FsbCBpcyBiZWluZyByZWNvcmRlZC4gSXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBjYWxsIGlzIGJlaW5nIHJlY29yZGVkLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MgPSAoKSA9PiB7XG4gICAgY29uc3QgeyByZWNvcmRpbmckIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHJlY29yZGluZyQpO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHdoaWNoIHByb3ZpZGVzIGluZm9ybWF0aW9uIHdoZXRoZXIgdGhlIGN1cnJlbnQgY2FsbCBpcyBicm9hZGNhc3RpbmcuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlSXNDYWxsSExTQnJvYWRjYXN0aW5nSW5Qcm9ncmVzcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGVncmVzcyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIGNvbnN0IGVncmVzcyA9IHVzZU9ic2VydmFibGVWYWx1ZShlZ3Jlc3MkKTtcbiAgICBpZiAoIWVncmVzcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBlZ3Jlc3MuYnJvYWRjYXN0aW5nO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHdoaWNoIHByb3ZpZGVzIGluZm9ybWF0aW9uIHdoZXRoZXIgdGhlIGN1cnJlbnQgY2FsbCBpcyBsaXZlLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUlzQ2FsbExpdmUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBiYWNrc3RhZ2UkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICBjb25zdCBpc0JhY2tzdGFnZU9uID0gdXNlT2JzZXJ2YWJsZVZhbHVlKGJhY2tzdGFnZSQpO1xuICAgIHJldHVybiAhaXNCYWNrc3RhZ2VPbjtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYmxvY2tlZCB1c2VycyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICovXG5jb25zdCB1c2VDYWxsQmxvY2tlZFVzZXJJZHMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBibG9ja2VkVXNlcklkcyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoYmxvY2tlZFVzZXJJZHMkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHRpbWVzdGFtcCB3aGVuIHRoaXMgY2FsbCB3YXMgY3JlYXRlZC5cbiAqL1xuY29uc3QgdXNlQ2FsbENyZWF0ZWRBdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNyZWF0ZWRBdCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoY3JlYXRlZEF0JCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgd2hlbiB0aGlzIGNhbGwgd2FzIGVuZGVkLlxuICovXG5jb25zdCB1c2VDYWxsRW5kZWRBdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGVuZGVkQXQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGVuZGVkQXQkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHRpbWVzdGFtcCB0ZWxsaW5nIHdoZW4gdGhlIGNhbGwgaXMgc2NoZWR1bGVkIHRvIHN0YXJ0LlxuICovXG5jb25zdCB1c2VDYWxsU3RhcnRzQXQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdGFydHNBdCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhcnRzQXQkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHRpbWVzdGFtcCB3aGVuIHRoaXMgY2FsbCB3YXMgdXBkYXRlZC5cbiAqL1xuY29uc3QgdXNlQ2FsbFVwZGF0ZWRBdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHVwZGF0ZWRBdCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUodXBkYXRlZEF0JCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2FsbCdzIGNyZWF0b3IuXG4gKi9cbmNvbnN0IHVzZUNhbGxDcmVhdGVkQnkgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjcmVhdGVkQnkkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGNyZWF0ZWRCeSQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY2FsbCdzIGN1c3RvbSBkYXRhLlxuICovXG5jb25zdCB1c2VDYWxsQ3VzdG9tRGF0YSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGN1c3RvbSQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoY3VzdG9tJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWxsJ3MgRWdyZXNzIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCB1c2VDYWxsRWdyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZWdyZXNzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShlZ3Jlc3MkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGNhbGwncyBJbmdyZXNzIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCB1c2VDYWxsSW5ncmVzcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGluZ3Jlc3MkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGluZ3Jlc3MkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgZm9yIHRoZSBjdXJyZW50IGNhbGwgc2Vzc2lvbi5cbiAqL1xuY29uc3QgdXNlQ2FsbFNlc3Npb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzZXNzaW9uJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShzZXNzaW9uJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWxsJ3Mgc2V0dGluZ3MuXG4gKi9cbmNvbnN0IHVzZUNhbGxTZXR0aW5ncyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHNldHRpbmdzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShzZXR0aW5ncyQpO1xufTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBjYWxsIGhhcyB0cmFuc2NyaWJpbmcgZW5hYmxlZC5cbiAqL1xuY29uc3QgdXNlSXNDYWxsVHJhbnNjcmliaW5nSW5Qcm9ncmVzcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHRyYW5zY3JpYmluZyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUodHJhbnNjcmliaW5nJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIHdobyBoYXMgbWFya2VkIHRoaXMgY2FsbCBhcyBlbmRlZC5cbiAqL1xuY29uc3QgdXNlQ2FsbEVuZGVkQnkgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBlbmRlZEJ5JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShlbmRlZEJ5JCk7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSBpc1xuICogYSBwYXJ0aWNpcGFudCBpbiB0aGUgY3VycmVudCBjYWxsIHdoaWNoIHNoYXJlcyB0aGVpciBzY3JlZW4uXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgaGFzT25nb2luZ1NjcmVlblNoYXJlJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShoYXNPbmdvaW5nU2NyZWVuU2hhcmUkKTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyB0aGUgbGF0ZXN0IHN0YXRzIHJlcG9ydCBvZiB0aGUgY3VycmVudCBjYWxsLlxuICpcbiAqIFRoZSBsYXRlc3Qgc3RhdHMgcmVwb3J0IG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKiBXaGVuIHN0YXRzIGdhdGhlcmluZyBpcyBlbmFibGVkLCB0aGlzIG9ic2VydmFibGUgd2lsbCBlbWl0IGEgbmV3IHZhbHVlXG4gKiBhdCBhIHJlZ3VsYXIgKGNvbmZpZ3VyYWJsZSkgaW50ZXJ2YWwuXG4gKlxuICogQ29uc3VtZXJzIG9mIHRoaXMgb2JzZXJ2YWJsZSBjYW4gaW1wbGVtZW50IHRoZWlyIG93biBiYXRjaGluZyBsb2dpY1xuICogaW4gY2FzZSB0aGV5IHdhbnQgdG8gc2hvdyBoaXN0b3JpY2FsIHN0YXRzIGRhdGEuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlQ2FsbFN0YXRzUmVwb3J0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2FsbFN0YXRzUmVwb3J0JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShjYWxsU3RhdHNSZXBvcnQkKTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyB0aGUgZG9taW5hbnQgc3BlYWtlciBvZiB0aGUgY3VycmVudCBjYWxsLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZURvbWluYW50U3BlYWtlciA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRvbWluYW50U3BlYWtlciQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoZG9taW5hbnRTcGVha2VyJCk7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgYSBsaXN0IG9mIGNhbGwgbWVtYmVycy5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VDYWxsTWVtYmVycyA9ICgpID0+IHtcbiAgICBjb25zdCB7IG1lbWJlcnMkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKG1lbWJlcnMkKTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayBwcm92aWRpbmcgdGhlIGN1cnJlbnQgY2FsbGluZyBzdGF0ZSBvZiB0aGUgY2FsbC4gRm9yIGV4YW1wbGUsIGBSSU5HSU5HYCBvciBgSk9JTkVEYC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VDYWxsQ2FsbGluZ1N0YXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2FsbGluZ1N0YXRlJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShjYWxsaW5nU3RhdGUkKTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayBwcm92aWRpbmcgdGhlIGFjdHVhbCBzdGFydCB0aW1lIG9mIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gKiBVc2VmdWwgZm9yIGNhbGN1bGF0aW5nIHRoZSBjYWxsIGR1cmF0aW9uLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUNhbGxTdGFydGVkQXQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdGFydGVkQXQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXJ0ZWRBdCQpO1xufTtcbi8qKlxuICogQSBob29rIHdoaWNoIHByb3ZpZGVzIGEgbGlzdCBvZiBhbGwgcGFydGljaXBhbnRzIHRoYXQgaGF2ZSBqb2luZWQgYW4gYWN0aXZlIGNhbGwuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucy5zb3J0QnkgLSBBIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gc29ydCB0aGUgcGFydGljaXBhbnRzIGJ5LlxuICogTWFrZSBzdXJlIHRvIG1lbW9pemUgb3V0cHV0IG9mIHRoZSBgY29tYmluZUNvbXBhcmF0b3JzYCBmdW5jdGlvblxuICogKG9yIGtlZXAgaXQgb3V0IG9mIGNvbXBvbmVudCdzIHNjb3BlIGlmIHBvc3NpYmxlKSBiZWZvcmUgcGFzc2luZyBpdCBkb3duIHRvIHRoaXMgcHJvcGVydHkuXG4gKi9cbmNvbnN0IHVzZVBhcnRpY2lwYW50cyA9ICh7IHNvcnRCeSwgfSA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBwYXJ0aWNpcGFudHMkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSB1c2VPYnNlcnZhYmxlVmFsdWUocGFydGljaXBhbnRzJCk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc29ydEJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnBhcnRpY2lwYW50c10uc29ydChzb3J0QnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0aWNpcGFudHM7XG4gICAgfSwgW3BhcnRpY2lwYW50cywgc29ydEJ5XSk7XG59O1xuLyoqXG4gKiBBIGhvb2sgd2hpY2ggcHJvdmlkZXMgYSBTdHJlYW1WaWRlb0xvY2FsUGFydGljaXBhbnQgb2JqZWN0LlxuICogSXQgc2lnbmFscyB0aGF0IEkgaGF2ZSBqb2luZWQgYSBjYWxsLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUxvY2FsUGFydGljaXBhbnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBsb2NhbFBhcnRpY2lwYW50JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShsb2NhbFBhcnRpY2lwYW50JCk7XG59O1xuLyoqXG4gKiBBIGhvb2sgd2hpY2ggcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBvdGhlciBwYXJ0aWNpcGFudHMgdGhhbiBtZSB0aGF0IGhhdmUgam9pbmVkIGFuIGFjdGl2ZSBjYWxsLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZVJlbW90ZVBhcnRpY2lwYW50cyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHJlbW90ZVBhcnRpY2lwYW50cyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUocmVtb3RlUGFydGljaXBhbnRzJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcHByb3hpbWF0ZSBwYXJ0aWNpcGFudCBjb3VudCBvZiB0aGUgYWN0aXZlIGNhbGwuXG4gKiBUaGlzIGluY2x1ZGVzIHRoZSBhbm9ueW1vdXMgdXNlcnMgYXMgd2VsbCwgYW5kIGl0IGlzIGNvbXB1dGVkIG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlUGFydGljaXBhbnRDb3VudCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50Q291bnQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHBhcnRpY2lwYW50Q291bnQkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGFwcHJveGltYXRlIGFub255bW91cyBwYXJ0aWNpcGFudCBjb3VudCBvZiB0aGUgYWN0aXZlIGNhbGwuXG4gKiBUaGUgcmVndWxhciBwYXJ0aWNpcGFudHMgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGNvdW50LiBJdCBpcyBjb21wdXRlZCBvbiB0aGUgc2VydmVyLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUFub255bW91c1BhcnRpY2lwYW50Q291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBhbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShhbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50JCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgdGh1bWJuYWlsIG9mIHRoZSBjdXJyZW50IGNhbGwsIGlmIGVuYWJsZWQgaW4gc2V0dGluZ3MuXG4gKi9cbmNvbnN0IHVzZUNhbGxUaHVtYm5haWwgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0aHVtYm5haWxzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZSh0aHVtYm5haWxzJCk7XG59O1xuLyoqXG4gKiBBIGhvb2sgd2hpY2ggcmV0dXJucyB0aGUgbG9jYWwgcGFydGljaXBhbnQncyBvd24gY2FwYWJpbGl0aWVzLlxuICovXG5jb25zdCB1c2VPd25DYXBhYmlsaXRpZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBvd25DYXBhYmlsaXRpZXMkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKG93bkNhcGFiaWxpdGllcyQpO1xufTtcbi8qKlxuICogSG9vayB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgbG9jYWwgcGFydGljaXBhbnQgaGFzIGFsbCB0aGUgZ2l2ZW4gcGVybWlzc2lvbnMuXG4gKlxuICogQHBhcmFtIHBlcm1pc3Npb25zIHRoZSBwZXJtaXNzaW9ucyB0byBjaGVjay5cbiAqL1xuY29uc3QgdXNlSGFzUGVybWlzc2lvbnMgPSAoLi4ucGVybWlzc2lvbnMpID0+IHtcbiAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSB1c2VPd25DYXBhYmlsaXRpZXMoKTtcbiAgICByZXR1cm4gcGVybWlzc2lvbnMuZXZlcnkoKHBlcm1pc3Npb24pID0+IGNhcGFiaWxpdGllcz8uaW5jbHVkZXMocGVybWlzc2lvbikpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY2FtZXJhIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKlxuICogQGNhdGVnb3J5IENhbWVyYSBNYW5hZ2VyIFN0YXRlXG4gKlxuICovXG5jb25zdCB1c2VDYW1lcmFTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgY2FtZXJhIH0gPSBjYWxsO1xuICAgIGNvbnN0IGRldmljZXMkID0gdXNlTWVtbygoKSA9PiBjYW1lcmEubGlzdERldmljZXMoKSwgW2NhbWVyYV0pO1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNhbWVyYTtcbiAgICBjb25zdCBzdGF0dXMgPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUuc3RhdHVzJCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLmRpcmVjdGlvbiQpO1xuICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLm1lZGlhU3RyZWFtJCk7XG4gICAgY29uc3Qgc2VsZWN0ZWREZXZpY2UgPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUuc2VsZWN0ZWREZXZpY2UkKTtcbiAgICBjb25zdCBkZXZpY2VzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKGRldmljZXMkKTtcbiAgICBjb25zdCBoYXNCcm93c2VyUGVybWlzc2lvbiA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5oYXNCcm93c2VyUGVybWlzc2lvbiQpO1xuICAgIGNvbnN0IGlzTXV0ZSA9IHN0YXR1cyAhPT0gJ2VuYWJsZWQnO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhbWVyYSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBpc0VuYWJsZWQ6IHN0YXR1cyA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIG1lZGlhU3RyZWFtLFxuICAgICAgICBkZXZpY2VzLFxuICAgICAgICBoYXNCcm93c2VyUGVybWlzc2lvbixcbiAgICAgICAgc2VsZWN0ZWREZXZpY2UsXG4gICAgICAgIGlzTXV0ZSxcbiAgICB9O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbWljcm9waG9uZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBjYWxsLlxuICpcbiAqIEBjYXRlZ29yeSBNaWNyb3Bob25lIE1hbmFnZXIgU3RhdGVcbiAqL1xuY29uc3QgdXNlTWljcm9waG9uZVN0YXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyBtaWNyb3Bob25lIH0gPSBjYWxsO1xuICAgIGNvbnN0IGRldmljZXMkID0gdXNlTWVtbygoKSA9PiBtaWNyb3Bob25lLmxpc3REZXZpY2VzKCksIFttaWNyb3Bob25lXSk7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gbWljcm9waG9uZTtcbiAgICBjb25zdCBzdGF0dXMgPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUuc3RhdHVzJCk7XG4gICAgY29uc3QgbWVkaWFTdHJlYW0gPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUubWVkaWFTdHJlYW0kKTtcbiAgICBjb25zdCBzZWxlY3RlZERldmljZSA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5zZWxlY3RlZERldmljZSQpO1xuICAgIGNvbnN0IGRldmljZXMgPSB1c2VPYnNlcnZhYmxlVmFsdWUoZGV2aWNlcyQpO1xuICAgIGNvbnN0IGhhc0Jyb3dzZXJQZXJtaXNzaW9uID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLmhhc0Jyb3dzZXJQZXJtaXNzaW9uJCk7XG4gICAgY29uc3QgaXNTcGVha2luZ1doaWxlTXV0ZWQgPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUuc3BlYWtpbmdXaGlsZU11dGVkJCk7XG4gICAgY29uc3QgaXNNdXRlID0gc3RhdHVzICE9PSAnZW5hYmxlZCc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWljcm9waG9uZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBpc0VuYWJsZWQ6IHN0YXR1cyA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICBtZWRpYVN0cmVhbSxcbiAgICAgICAgZGV2aWNlcyxcbiAgICAgICAgc2VsZWN0ZWREZXZpY2UsXG4gICAgICAgIGhhc0Jyb3dzZXJQZXJtaXNzaW9uLFxuICAgICAgICBpc1NwZWFraW5nV2hpbGVNdXRlZCxcbiAgICAgICAgaXNNdXRlLFxuICAgIH07XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcGVha2VyIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKlxuICogTm90ZTogVGhpcyBob29rIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gKi9cbmNvbnN0IHVzZVNwZWFrZXJTdGF0ZSA9ICgpID0+IHtcbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9nZXRzdHJlYW0uaW8vdmlkZW8vZG9jcy9yZWFjdG5hdGl2ZS9jb3JlL2NhbWVyYS1hbmQtbWljcm9waG9uZS8jc3BlYWtlci1tYW5hZ2VtZW50IGZvciBtb3JlIGRldGFpbHMnKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHNwZWFrZXIgfSA9IGNhbGw7XG4gICAgY29uc3QgZGV2aWNlcyQgPSB1c2VNZW1vKCgpID0+IHNwZWFrZXIubGlzdERldmljZXMoKSwgW3NwZWFrZXJdKTtcbiAgICBjb25zdCBkZXZpY2VzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKGRldmljZXMkKTtcbiAgICBjb25zdCBzZWxlY3RlZERldmljZSA9IHVzZU9ic2VydmFibGVWYWx1ZShzcGVha2VyLnN0YXRlLnNlbGVjdGVkRGV2aWNlJCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3BlYWtlcixcbiAgICAgICAgZGV2aWNlcyxcbiAgICAgICAgc2VsZWN0ZWREZXZpY2UsXG4gICAgICAgIGlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkOiBzcGVha2VyLnN0YXRlLmlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkLFxuICAgIH07XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBTY3JlZW4gU2hhcmUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqL1xuY29uc3QgdXNlU2NyZWVuU2hhcmVTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgc2NyZWVuU2hhcmUgfSA9IGNhbGw7XG4gICAgY29uc3Qgc3RhdHVzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHNjcmVlblNoYXJlLnN0YXRlLnN0YXR1cyQpO1xuICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHNjcmVlblNoYXJlLnN0YXRlLm1lZGlhU3RyZWFtJCk7XG4gICAgY29uc3QgaXNNdXRlID0gc3RhdHVzICE9PSAnZW5hYmxlZCc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuU2hhcmUsXG4gICAgICAgIG1lZGlhU3RyZWFtLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGlzTXV0ZSxcbiAgICB9O1xufTtcblxudmFyIENhbGxTdGF0ZUhvb2tzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50OiB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50LFxuICAgIHVzZUNhbGxCbG9ja2VkVXNlcklkczogdXNlQ2FsbEJsb2NrZWRVc2VySWRzLFxuICAgIHVzZUNhbGxDYWxsaW5nU3RhdGU6IHVzZUNhbGxDYWxsaW5nU3RhdGUsXG4gICAgdXNlQ2FsbENyZWF0ZWRBdDogdXNlQ2FsbENyZWF0ZWRBdCxcbiAgICB1c2VDYWxsQ3JlYXRlZEJ5OiB1c2VDYWxsQ3JlYXRlZEJ5LFxuICAgIHVzZUNhbGxDdXN0b21EYXRhOiB1c2VDYWxsQ3VzdG9tRGF0YSxcbiAgICB1c2VDYWxsRWdyZXNzOiB1c2VDYWxsRWdyZXNzLFxuICAgIHVzZUNhbGxFbmRlZEF0OiB1c2VDYWxsRW5kZWRBdCxcbiAgICB1c2VDYWxsRW5kZWRCeTogdXNlQ2FsbEVuZGVkQnksXG4gICAgdXNlQ2FsbEluZ3Jlc3M6IHVzZUNhbGxJbmdyZXNzLFxuICAgIHVzZUNhbGxNZW1iZXJzOiB1c2VDYWxsTWVtYmVycyxcbiAgICB1c2VDYWxsU2Vzc2lvbjogdXNlQ2FsbFNlc3Npb24sXG4gICAgdXNlQ2FsbFNldHRpbmdzOiB1c2VDYWxsU2V0dGluZ3MsXG4gICAgdXNlQ2FsbFN0YXJ0ZWRBdDogdXNlQ2FsbFN0YXJ0ZWRBdCxcbiAgICB1c2VDYWxsU3RhcnRzQXQ6IHVzZUNhbGxTdGFydHNBdCxcbiAgICB1c2VDYWxsU3RhdGU6IHVzZUNhbGxTdGF0ZSxcbiAgICB1c2VDYWxsU3RhdHNSZXBvcnQ6IHVzZUNhbGxTdGF0c1JlcG9ydCxcbiAgICB1c2VDYWxsVGh1bWJuYWlsOiB1c2VDYWxsVGh1bWJuYWlsLFxuICAgIHVzZUNhbGxVcGRhdGVkQXQ6IHVzZUNhbGxVcGRhdGVkQXQsXG4gICAgdXNlQ2FtZXJhU3RhdGU6IHVzZUNhbWVyYVN0YXRlLFxuICAgIHVzZURvbWluYW50U3BlYWtlcjogdXNlRG9taW5hbnRTcGVha2VyLFxuICAgIHVzZUhhc09uZ29pbmdTY3JlZW5TaGFyZTogdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlLFxuICAgIHVzZUhhc1Blcm1pc3Npb25zOiB1c2VIYXNQZXJtaXNzaW9ucyxcbiAgICB1c2VJc0NhbGxITFNCcm9hZGNhc3RpbmdJblByb2dyZXNzOiB1c2VJc0NhbGxITFNCcm9hZGNhc3RpbmdJblByb2dyZXNzLFxuICAgIHVzZUlzQ2FsbExpdmU6IHVzZUlzQ2FsbExpdmUsXG4gICAgdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzczogdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyxcbiAgICB1c2VJc0NhbGxUcmFuc2NyaWJpbmdJblByb2dyZXNzOiB1c2VJc0NhbGxUcmFuc2NyaWJpbmdJblByb2dyZXNzLFxuICAgIHVzZUxvY2FsUGFydGljaXBhbnQ6IHVzZUxvY2FsUGFydGljaXBhbnQsXG4gICAgdXNlTWljcm9waG9uZVN0YXRlOiB1c2VNaWNyb3Bob25lU3RhdGUsXG4gICAgdXNlT3duQ2FwYWJpbGl0aWVzOiB1c2VPd25DYXBhYmlsaXRpZXMsXG4gICAgdXNlUGFydGljaXBhbnRDb3VudDogdXNlUGFydGljaXBhbnRDb3VudCxcbiAgICB1c2VQYXJ0aWNpcGFudHM6IHVzZVBhcnRpY2lwYW50cyxcbiAgICB1c2VSZW1vdGVQYXJ0aWNpcGFudHM6IHVzZVJlbW90ZVBhcnRpY2lwYW50cyxcbiAgICB1c2VTY3JlZW5TaGFyZVN0YXRlOiB1c2VTY3JlZW5TaGFyZVN0YXRlLFxuICAgIHVzZVNwZWFrZXJTdGF0ZTogdXNlU3BlYWtlclN0YXRlXG59KTtcblxuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIGNsaWVudCdzIHN0YXRlIHN0b3JlLlxuICovXG5jb25zdCB1c2VTdG9yZSA9ICgpID0+IHtcbiAgICBjb25zdCBjbGllbnQgPSB1c2VTdHJlYW1WaWRlb0NsaWVudCgpO1xuICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyZWFtVmlkZW9DbGllbnQgaXNuJ3QgaW5pdGlhbGl6ZWQgb3IgdGhpcyBob29rIGlzIGNhbGxlZCBvdXRzaWRlIG9mIDxTdHJlYW1WaWRlbz4gY29udGV4dC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudC5yZWFkT25seVN0YXRlU3RvcmU7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBub3RpZmljYXRpb25zIGFib3V0IGNyZWF0ZWQgY2FsbHMuXG4gKiBJbiB0aGUgcmluZyBjYWxsIHNldHRpbmdzLCB0aGVzZSBjYWxscyBjYW4gYmUgb3V0Z29pbmcgKEkgaGF2ZSBjYWxsZWQgc29tZWJvZHkpXG4gKiBvciBpbmNvbWluZyAoc29tZWJvZHkgaGFzIGNhbGxlZCBtZSkuXG4gKlxuICogQGNhdGVnb3J5IENsaWVudCBTdGF0ZVxuICovXG5jb25zdCB1c2VDYWxscyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNhbGxzJCB9ID0gdXNlU3RvcmUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGNhbGxzJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3RlZCB1c2VyLlxuICpcbiAqIEBjYXRlZ29yeSBDbGllbnQgU3RhdGVcbiAqL1xuY29uc3QgdXNlQ29ubmVjdGVkVXNlciA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbm5lY3RlZFVzZXIkIH0gPSB1c2VTdG9yZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoY29ubmVjdGVkVXNlciQpO1xufTtcblxuLyoqXG4gKiBBIGhvb2stYWxpa2UgZnVuY3Rpb24gdGhhdCBleHBvc2VzIGFsbCBjYWxsIHN0YXRlIGhvb2tzLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUNhbGxTdGF0ZUhvb2tzID0gKCkgPT4gQ2FsbFN0YXRlSG9va3M7XG5cbmNvbnN0IFJlc3RyaWN0ZWQgPSAoeyBjYW5SZXF1ZXN0T25seSwgaGFzUGVybWlzc2lvbnNPbmx5LCByZXF1aXJlZEdyYW50cywgcmVxdWlyZUFsbCA9IHRydWUsIGNoaWxkcmVuLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUNhbGxTZXR0aW5ncywgdXNlT3duQ2FwYWJpbGl0aWVzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IG93bkNhcGFiaWxpdGllcyA9IHVzZU93bkNhcGFiaWxpdGllcygpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gdXNlQ2FsbFNldHRpbmdzKCk7XG4gICAgY29uc3QgaGFzUGVybWlzc2lvbnMgPSByZXF1aXJlZEdyYW50c1tyZXF1aXJlQWxsID8gJ2V2ZXJ5JyA6ICdzb21lJ10oKGNhcGFiaWxpdHkpID0+IG93bkNhcGFiaWxpdGllcz8uaW5jbHVkZXMoY2FwYWJpbGl0eSkpO1xuICAgIGlmIChoYXNQZXJtaXNzaW9uc09ubHkpXG4gICAgICAgIHJldHVybiBoYXNQZXJtaXNzaW9ucyA/IGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkgOiBudWxsO1xuICAgIGNvbnN0IGNhblJlcXVlc3QgPSByZXF1aXJlZEdyYW50cy5zb21lKChjYXBhYmlsaXR5KSA9PiBjYWxsPy5wZXJtaXNzaW9uc0NvbnRleHQuY2FuUmVxdWVzdChjYXBhYmlsaXR5LCBzZXR0aW5ncykpO1xuICAgIGlmIChjYW5SZXF1ZXN0T25seSlcbiAgICAgICAgcmV0dXJuIGNhblJlcXVlc3QgPyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIDogbnVsbDtcbiAgICBpZiAoaGFzUGVybWlzc2lvbnMgfHwgY2FuUmVxdWVzdClcbiAgICAgICAgcmV0dXJuIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgeyBERUZBVUxUX0xBTkdVQUdFLCBERUZBVUxUX05BTUVTUEFDRSwgUmVzdHJpY3RlZCwgU3RyZWFtQ2FsbFByb3ZpZGVyLCBTdHJlYW1JMThuLCBTdHJlYW1JMThuUHJvdmlkZXIsIFN0cmVhbVZpZGVvUHJvdmlkZXIsIGRlZmF1bHRUcmFuc2xhdGlvbkZ1bmN0aW9uLCBtYXBUb1JlZ2lzdHJ5LCB1c2VDYWxsLCB1c2VDYWxsU3RhdGVIb29rcywgdXNlQ2FsbHMsIHVzZUNvbm5lY3RlZFVzZXIsIHVzZUNyZWF0ZUkxOG4sIHVzZUkxOG4sIHVzZVN0b3JlLCB1c2VTdHJlYW1WaWRlb0NsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stream-io/video-react-sdk/dist/index.es.js":
/*!******************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-sdk/dist/index.es.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AcceptCallButton: () => (/* binding */ AcceptCallButton),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AudioSettingsDefaultDeviceEnum),\n/* harmony export */   AudioSettingsRequestDefaultDeviceEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   Avatar: () => (/* binding */ Avatar),\n/* harmony export */   AvatarFallback: () => (/* binding */ AvatarFallback),\n/* harmony export */   AxiosError: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AxiosError),\n/* harmony export */   BackgroundFiltersProvider: () => (/* binding */ BackgroundFiltersProvider),\n/* harmony export */   BaseVideo: () => (/* binding */ BaseVideo),\n/* harmony export */   Browsers: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers),\n/* harmony export */   Call: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Call),\n/* harmony export */   CallControls: () => (/* binding */ CallControls),\n/* harmony export */   CallParticipantListing: () => (/* binding */ CallParticipantListing),\n/* harmony export */   CallParticipantListingItem: () => (/* binding */ CallParticipantListingItem),\n/* harmony export */   CallParticipantsList: () => (/* binding */ CallParticipantsList),\n/* harmony export */   CallPreview: () => (/* binding */ CallPreview),\n/* harmony export */   CallRecordingList: () => (/* binding */ CallRecordingList),\n/* harmony export */   CallRecordingListHeader: () => (/* binding */ CallRecordingListHeader),\n/* harmony export */   CallRecordingListItem: () => (/* binding */ CallRecordingListItem),\n/* harmony export */   CallState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallState),\n/* harmony export */   CallStats: () => (/* binding */ CallStats),\n/* harmony export */   CallStatsButton: () => (/* binding */ CallStatsButton),\n/* harmony export */   CallStatsLatencyChart: () => (/* binding */ CallStatsLatencyChart),\n/* harmony export */   CallType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallType),\n/* harmony export */   CallTypes: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallTypes),\n/* harmony export */   CallingState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState),\n/* harmony export */   CameraManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CameraManager),\n/* harmony export */   CameraManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CameraManagerState),\n/* harmony export */   CancelCallButton: () => (/* binding */ CancelCallButton),\n/* harmony export */   CancelCallConfirmButton: () => (/* binding */ CancelCallConfirmButton),\n/* harmony export */   CompositeButton: () => (/* binding */ CompositeButton),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CreateDeviceRequestPushProviderEnum),\n/* harmony export */   DEFAULT_LANGUAGE: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LANGUAGE),\n/* harmony export */   DEFAULT_NAMESPACE: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_NAMESPACE),\n/* harmony export */   DebounceType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.DebounceType),\n/* harmony export */   DefaultParticipantViewUI: () => (/* binding */ DefaultParticipantViewUI),\n/* harmony export */   DefaultReactionsMenu: () => (/* binding */ DefaultReactionsMenu),\n/* harmony export */   DefaultScreenShareOverlay: () => (/* binding */ DefaultScreenShareOverlay),\n/* harmony export */   DefaultVideoPlaceholder: () => (/* binding */ DefaultVideoPlaceholder),\n/* harmony export */   DeviceSelector: () => (/* binding */ DeviceSelector),\n/* harmony export */   DeviceSelectorAudioInput: () => (/* binding */ DeviceSelectorAudioInput),\n/* harmony export */   DeviceSelectorAudioOutput: () => (/* binding */ DeviceSelectorAudioOutput),\n/* harmony export */   DeviceSelectorVideo: () => (/* binding */ DeviceSelectorVideo),\n/* harmony export */   DeviceSettings: () => (/* binding */ DeviceSettings),\n/* harmony export */   DropDownSelect: () => (/* binding */ DropDownSelect),\n/* harmony export */   DropDownSelectOption: () => (/* binding */ DropDownSelectOption),\n/* harmony export */   DynascaleManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.DynascaleManager),\n/* harmony export */   EmptyCallRecordingListing: () => (/* binding */ EmptyCallRecordingListing),\n/* harmony export */   ErrorFromResponse: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ErrorFromResponse),\n/* harmony export */   GenericMenu: () => (/* binding */ GenericMenu),\n/* harmony export */   GenericMenuButtonItem: () => (/* binding */ GenericMenuButtonItem),\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   IconButton: () => (/* binding */ IconButton),\n/* harmony export */   InputMediaDeviceManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.InputMediaDeviceManager),\n/* harmony export */   InputMediaDeviceManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.InputMediaDeviceManagerState),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.LayoutSettingsNameEnum),\n/* harmony export */   LayoutSettingsRequestNameEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.LayoutSettingsRequestNameEnum),\n/* harmony export */   LivestreamLayout: () => (/* binding */ LivestreamLayout),\n/* harmony export */   LoadingCallRecordingListing: () => (/* binding */ LoadingCallRecordingListing),\n/* harmony export */   LoadingIndicator: () => (/* binding */ LoadingIndicator),\n/* harmony export */   MenuToggle: () => (/* binding */ MenuToggle),\n/* harmony export */   MenuVisualType: () => (/* binding */ MenuVisualType),\n/* harmony export */   MicrophoneManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.MicrophoneManager),\n/* harmony export */   MicrophoneManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.MicrophoneManagerState),\n/* harmony export */   Notification: () => (/* binding */ Notification),\n/* harmony export */   OwnCapability: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability),\n/* harmony export */   PaginatedGridLayout: () => (/* binding */ PaginatedGridLayout),\n/* harmony export */   ParticipantActionsContextMenu: () => (/* binding */ ParticipantActionsContextMenu),\n/* harmony export */   ParticipantDetails: () => (/* binding */ ParticipantDetails),\n/* harmony export */   ParticipantView: () => (/* binding */ ParticipantView),\n/* harmony export */   ParticipantViewContext: () => (/* binding */ ParticipantViewContext),\n/* harmony export */   ParticipantsAudio: () => (/* binding */ ParticipantsAudio),\n/* harmony export */   PermissionNotification: () => (/* binding */ PermissionNotification),\n/* harmony export */   PermissionRequestList: () => (/* binding */ PermissionRequestList),\n/* harmony export */   PermissionRequests: () => (/* binding */ PermissionRequests),\n/* harmony export */   ReactionsButton: () => (/* binding */ ReactionsButton),\n/* harmony export */   RecordCallButton: () => (/* binding */ RecordCallButton),\n/* harmony export */   RecordCallConfirmationButton: () => (/* binding */ RecordCallConfirmationButton),\n/* harmony export */   RecordSettingsRequestModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RecordSettingsRequestModeEnum),\n/* harmony export */   RecordSettingsRequestQualityEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RecordSettingsRequestQualityEnum),\n/* harmony export */   RecordingInProgressNotification: () => (/* binding */ RecordingInProgressNotification),\n/* harmony export */   Restricted: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted),\n/* harmony export */   RingingCall: () => (/* binding */ RingingCall),\n/* harmony export */   RingingCallControls: () => (/* binding */ RingingCallControls),\n/* harmony export */   RxUtils: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RxUtils),\n/* harmony export */   ScreenShareButton: () => (/* binding */ ScreenShareButton),\n/* harmony export */   ScreenShareManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ScreenShareManager),\n/* harmony export */   ScreenShareState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ScreenShareState),\n/* harmony export */   SearchInput: () => (/* binding */ SearchInput),\n/* harmony export */   SearchResults: () => (/* binding */ SearchResults),\n/* harmony export */   SfuEvents: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuEvents),\n/* harmony export */   SfuModels: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels),\n/* harmony export */   SpeakerLayout: () => (/* binding */ SpeakerLayout),\n/* harmony export */   SpeakerManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SpeakerManager),\n/* harmony export */   SpeakerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SpeakerState),\n/* harmony export */   SpeakingWhileMutedNotification: () => (/* binding */ SpeakingWhileMutedNotification),\n/* harmony export */   SpeechIndicator: () => (/* binding */ SpeechIndicator),\n/* harmony export */   StatCard: () => (/* binding */ StatCard),\n/* harmony export */   StatCardExplanation: () => (/* binding */ StatCardExplanation),\n/* harmony export */   StatsTag: () => (/* binding */ StatsTag),\n/* harmony export */   Statuses: () => (/* binding */ Statuses),\n/* harmony export */   StreamCall: () => (/* binding */ StreamCall),\n/* harmony export */   StreamCallProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamCallProvider),\n/* harmony export */   StreamI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamI18n),\n/* harmony export */   StreamI18nProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamI18nProvider),\n/* harmony export */   StreamSfuClient: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamSfuClient),\n/* harmony export */   StreamTheme: () => (/* binding */ StreamTheme),\n/* harmony export */   StreamVideo: () => (/* binding */ StreamVideo),\n/* harmony export */   StreamVideoClient: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoClient),\n/* harmony export */   StreamVideoProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamVideoProvider),\n/* harmony export */   StreamVideoReadOnlyStateStore: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoReadOnlyStateStore),\n/* harmony export */   StreamVideoServerClient: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoServerClient),\n/* harmony export */   StreamVideoWriteableStateStore: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoWriteableStateStore),\n/* harmony export */   TextButton: () => (/* binding */ TextButton),\n/* harmony export */   ToggleAudioOutputButton: () => (/* binding */ ToggleAudioOutputButton),\n/* harmony export */   ToggleAudioPreviewButton: () => (/* binding */ ToggleAudioPreviewButton),\n/* harmony export */   ToggleAudioPublishingButton: () => (/* binding */ ToggleAudioPublishingButton),\n/* harmony export */   ToggleVideoPreviewButton: () => (/* binding */ ToggleVideoPreviewButton),\n/* harmony export */   ToggleVideoPublishingButton: () => (/* binding */ ToggleVideoPublishingButton),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.TranscriptionSettingsModeEnum),\n/* harmony export */   TranscriptionSettingsRequestModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.TranscriptionSettingsRequestModeEnum),\n/* harmony export */   Video: () => (/* binding */ Video$1),\n/* harmony export */   VideoPreview: () => (/* binding */ VideoPreview),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoSettingsRequestCameraFacingEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VideoSettingsRequestCameraFacingEnum),\n/* harmony export */   ViewportTracker: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ViewportTracker),\n/* harmony export */   VisibilityState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VisibilityState),\n/* harmony export */   WithTooltip: () => (/* binding */ WithTooltip),\n/* harmony export */   checkIfAudioOutputChangeSupported: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.checkIfAudioOutputChangeSupported),\n/* harmony export */   combineComparators: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.combineComparators),\n/* harmony export */   conditional: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.conditional),\n/* harmony export */   createSoundDetector: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.createSoundDetector),\n/* harmony export */   defaultReactions: () => (/* binding */ defaultReactions),\n/* harmony export */   defaultSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.defaultSortPreset),\n/* harmony export */   defaultTranslationFunction: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.defaultTranslationFunction),\n/* harmony export */   descending: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.descending),\n/* harmony export */   deviceIds$: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.deviceIds$),\n/* harmony export */   disposeOfMediaStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.disposeOfMediaStream),\n/* harmony export */   dominantSpeaker: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.dominantSpeaker),\n/* harmony export */   getAudioDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioDevices),\n/* harmony export */   getAudioOutputDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioOutputDevices),\n/* harmony export */   getAudioStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioStream),\n/* harmony export */   getClientDetails: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getClientDetails),\n/* harmony export */   getDeviceInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getDeviceInfo),\n/* harmony export */   getLogger: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getLogger),\n/* harmony export */   getOSInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getOSInfo),\n/* harmony export */   getScreenShareStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getScreenShareStream),\n/* harmony export */   getSdkInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getSdkInfo),\n/* harmony export */   getVideoDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getVideoDevices),\n/* harmony export */   getVideoStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getVideoStream),\n/* harmony export */   getWebRTCInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getWebRTCInfo),\n/* harmony export */   livestreamOrAudioRoomSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.livestreamOrAudioRoomSortPreset),\n/* harmony export */   logLevels: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.logLevels),\n/* harmony export */   logToConsole: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.logToConsole),\n/* harmony export */   mapToRegistry: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.mapToRegistry),\n/* harmony export */   name: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.name),\n/* harmony export */   noopComparator: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.noopComparator),\n/* harmony export */   paginatedLayoutSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.paginatedLayoutSortPreset),\n/* harmony export */   pinned: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.pinned),\n/* harmony export */   publishingAudio: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.publishingAudio),\n/* harmony export */   publishingVideo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.publishingVideo),\n/* harmony export */   reactionType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.reactionType),\n/* harmony export */   role: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.role),\n/* harmony export */   screenSharing: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.screenSharing),\n/* harmony export */   setDeviceInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setDeviceInfo),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setLogLevel),\n/* harmony export */   setLogger: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setLogger),\n/* harmony export */   setOSInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setOSInfo),\n/* harmony export */   setSdkInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setSdkInfo),\n/* harmony export */   setWebRTCInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setWebRTCInfo),\n/* harmony export */   speakerLayoutSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speakerLayoutSortPreset),\n/* harmony export */   speaking: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speaking),\n/* harmony export */   translations: () => (/* binding */ translations),\n/* harmony export */   useBackgroundFilters: () => (/* binding */ useBackgroundFilters),\n/* harmony export */   useCall: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall),\n/* harmony export */   useCallStateHooks: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks),\n/* harmony export */   useCalls: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCalls),\n/* harmony export */   useConnectedUser: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser),\n/* harmony export */   useCreateI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCreateI18n),\n/* harmony export */   useHorizontalScrollPosition: () => (/* binding */ useHorizontalScrollPosition),\n/* harmony export */   useI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n),\n/* harmony export */   useMenuContext: () => (/* binding */ useMenuContext),\n/* harmony export */   useParticipantViewContext: () => (/* binding */ useParticipantViewContext),\n/* harmony export */   usePersistedDevicePreferences: () => (/* binding */ usePersistedDevicePreferences),\n/* harmony export */   useRequestPermission: () => (/* binding */ useRequestPermission),\n/* harmony export */   useStore: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useStore),\n/* harmony export */   useStreamVideoClient: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useStreamVideoClient),\n/* harmony export */   useTrackElementVisibility: () => (/* binding */ useTrackElementVisibility),\n/* harmony export */   useVerticalScrollPosition: () => (/* binding */ useVerticalScrollPosition)\n/* harmony export */ });\n/* harmony import */ var _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stream-io/video-client */ \"(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\");\n/* harmony import */ var _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stream-io/video-react-bindings */ \"(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _stream_io_video_filters_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @stream-io/video-filters-web */ \"(ssr)/./node_modules/@stream-io/video-filters-web/dist/index.es.js\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! chart.js */ \"(ssr)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var react_chartjs_2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-chartjs-2 */ \"(ssr)/./node_modules/react-chartjs-2/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst Audio = ({ participant, trackType = 'audioTrack', ...rest }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [audioElement, setAudioElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const { userId, sessionId } = participant;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !audioElement)\n            return;\n        const cleanup = call.bindAudioElement(audioElement, sessionId, trackType);\n        return () => {\n            cleanup?.();\n        };\n    }, [call, sessionId, audioElement, trackType]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"audio\", { autoPlay: true, ...rest, ref: setAudioElement, \"data-user-id\": userId, \"data-session-id\": sessionId, \"data-track-type\": trackType }));\n};\n\nconst ParticipantsAudio = (props) => {\n    const { participants, audioProps } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: participants.map((participant) => {\n            if (participant.isLocalParticipant)\n                return null;\n            const { publishedTracks, audioStream, screenShareAudioStream, sessionId, } = participant;\n            const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n            const audioTrackElement = hasAudio && audioStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { ...audioProps, trackType: \"audioTrack\", participant: participant }));\n            const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n            const screenShareAudioTrackElement = hasScreenShareAudio &&\n                screenShareAudioStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { ...audioProps, trackType: \"screenShareAudioTrack\", participant: participant }));\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [audioTrackElement, screenShareAudioTrackElement] }, sessionId));\n        }) }));\n};\n\nconst ParticipantViewContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(undefined);\nconst useParticipantViewContext = () => (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ParticipantViewContext);\n\nconst Avatar = ({ imageSrc, name, style, className, ...rest }) => {\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(!imageSrc || error) && name && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(AvatarFallback, { className: className, style: style, names: [name] })), imageSrc && !error && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { onError: () => setError(true), alt: \"avatar\", className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__avatar', className), src: imageSrc, style: style, ...rest }))] }));\n};\nconst AvatarFallback = ({ className, names, style, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__avatar--initials-fallback', className), style: style, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { children: [names[0][0], names[1]?.[0]] }) }));\n};\n\n/**\n * The context for the background filters.\n */\nconst BackgroundFiltersContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(undefined);\n/**\n * A hook to access the background filters context API.\n */\nconst useBackgroundFilters = () => {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(BackgroundFiltersContext);\n    if (!context) {\n        throw new Error('useBackgroundFilters must be used within a BackgroundFiltersProvider');\n    }\n    return context;\n};\n/**\n * A provider component that enables the use of background filters in your app.\n *\n * Please make sure you have the `@stream-io/video-filters-web` package installed\n * in your project before using this component.\n */\nconst BackgroundFiltersProvider = (props) => {\n    const { children, isBlurringEnabled = true, backgroundImages = [], backgroundFilter: bgFilterFromProps = undefined, backgroundImage: bgImageFromProps = undefined, backgroundBlurLevel: bgBlurLevelFromProps = 'high', tfFilePath, modelFilePath, basePath, } = props;\n    const [backgroundFilter, setBackgroundFilter] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(bgFilterFromProps);\n    const [backgroundImage, setBackgroundImage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(bgImageFromProps);\n    const [backgroundBlurLevel, setBackgroundBlurLevel] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(bgBlurLevelFromProps);\n    const applyBackgroundImageFilter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((imageUrl) => {\n        setBackgroundFilter('image');\n        setBackgroundImage(imageUrl);\n    }, []);\n    const applyBackgroundBlurFilter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((blurLevel = 'high') => {\n        setBackgroundFilter('blur');\n        setBackgroundBlurLevel(blurLevel);\n    }, []);\n    const disableBackgroundFilter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n        setBackgroundFilter(undefined);\n        setBackgroundImage(undefined);\n        setBackgroundBlurLevel('high');\n    }, []);\n    const [isSupported, setIsSupported] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        (0,_stream_io_video_filters_web__WEBPACK_IMPORTED_MODULE_5__.isPlatformSupported)().then(setIsSupported);\n    }, []);\n    const [tfLite, setTfLite] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        // don't try to load TFLite if the platform is not supported\n        if (!isSupported)\n            return;\n        (0,_stream_io_video_filters_web__WEBPACK_IMPORTED_MODULE_5__.loadTFLite)({ basePath, modelFilePath, tfFilePath })\n            .then(setTfLite)\n            .catch((err) => console.error('Failed to load TFLite', err));\n    }, [basePath, isSupported, modelFilePath, tfFilePath]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(BackgroundFiltersContext.Provider, { value: {\n            isSupported,\n            isReady: !!tfLite,\n            backgroundImage,\n            backgroundBlurLevel,\n            backgroundFilter,\n            disableBackgroundFilter,\n            applyBackgroundBlurFilter,\n            applyBackgroundImageFilter,\n            backgroundImages,\n            isBlurringEnabled,\n            tfFilePath,\n            modelFilePath,\n            basePath,\n        }, children: [children, tfLite && backgroundFilter && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BackgroundFilters, { tfLite: tfLite })] }));\n};\nconst BackgroundFilters = (props) => {\n    const { tfLite } = props;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { backgroundImage, backgroundFilter } = useBackgroundFilters();\n    const [videoRef, setVideoRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [bgImageRef, setBgImageRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [canvasRef, setCanvasRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [width, setWidth] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(1920);\n    const [height, setHeight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(1080);\n    const resolveFilterRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    const [mediaStream, setMediaStream] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    const registerFilterRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(Promise.resolve(async () => { }));\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !backgroundFilter)\n            return;\n        registerFilterRef.current = registerFilterRef.current.then(() => call.camera.registerFilter(async (ms) => {\n            return new Promise((resolve) => {\n                setMediaStream(ms);\n                resolveFilterRef.current = resolve;\n            });\n        }));\n        return () => {\n            registerFilterRef.current\n                .then((unregister) => unregister())\n                .then(() => setMediaStream(undefined))\n                .catch((err) => console.error('Failed to unregister filter', err));\n        };\n    }, [backgroundFilter, call]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!mediaStream || !videoRef || !canvasRef)\n            return;\n        const handleOnPlay = () => {\n            const [track] = mediaStream.getVideoTracks();\n            if (track) {\n                const { width: w = 0, height: h = 0 } = track.getSettings();\n                setWidth(w);\n                setHeight(h);\n            }\n            const resolveFilter = resolveFilterRef.current;\n            if (!resolveFilter)\n                return;\n            const filter = canvasRef.captureStream();\n            resolveFilter(filter);\n        };\n        videoRef.addEventListener('play', handleOnPlay);\n        videoRef.srcObject = mediaStream;\n        videoRef.play().catch((err) => console.error('Failed to play video', err));\n        return () => {\n            videoRef.removeEventListener('play', handleOnPlay);\n            videoRef.srcObject = null;\n        };\n    }, [canvasRef, mediaStream, videoRef]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__background-filters\", style: {\n            width: `${width}px`,\n            height: `${height}px`,\n        }, children: [mediaStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RenderPipeline, { tfLite: tfLite, videoRef: videoRef, canvasRef: canvasRef, backgroundImageRef: bgImageRef })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"video\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__background-filters__video', height > width && 'str-video__background-filters__video--tall'), ref: setVideoRef, autoPlay: true, playsInline: true, controls: false, width: width, height: height, muted: true, loop: true }), backgroundImage && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { className: \"str-video__background-filters__background-image\", alt: \"Background\", ref: setBgImageRef, src: backgroundImage, width: width, height: height }, backgroundImage)), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", { className: \"str-video__background-filters__target-canvas\", width: width, height: height, ref: setCanvasRef }, `key-${width}${height}`)] }));\n};\nconst RenderPipeline = (props) => {\n    const { tfLite, videoRef, canvasRef, backgroundImageRef } = props;\n    const { backgroundFilter, backgroundBlurLevel } = useBackgroundFilters();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!videoRef || !canvasRef || !backgroundFilter)\n            return;\n        if (backgroundFilter === 'image' && !backgroundImageRef)\n            return;\n        const renderer = (0,_stream_io_video_filters_web__WEBPACK_IMPORTED_MODULE_5__.createRenderer)(tfLite, videoRef, canvasRef, {\n            backgroundFilter,\n            backgroundImage: backgroundImageRef ?? undefined,\n            backgroundBlurLevel,\n        });\n        return () => {\n            renderer.dispose();\n        };\n    }, [\n        backgroundBlurLevel,\n        backgroundFilter,\n        backgroundImageRef,\n        canvasRef,\n        tfLite,\n        videoRef,\n    ]);\n    return null;\n};\n\nconst useFloatingUIPreset = ({ placement, strategy, offset: offsetInPx = 10, }) => {\n    const { refs, x, y, update, elements: { domReference, floating }, } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useFloating)({\n        placement,\n        strategy,\n        middleware: [\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.offset)(offsetInPx),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.shift)(),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.flip)(),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.size)({\n                padding: 10,\n                apply: ({ availableHeight, elements }) => {\n                    Object.assign(elements.floating.style, {\n                        maxHeight: `${availableHeight}px`,\n                    });\n                },\n            }),\n        ],\n    });\n    // handle window resizing\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!domReference || !floating)\n            return;\n        const cleanup = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.autoUpdate)(domReference, floating, update);\n        return () => cleanup();\n    }, [domReference, floating, update]);\n    return { refs, x, y, domReference, floating, strategy };\n};\n\n/**\n * This hook will persist the device settings to local storage.\n *\n * @param key the key to use for local storage.\n */\nconst usePersistDevicePreferences = (key) => {\n    const { useMicrophoneState, useCameraState, useSpeakerState, useCallSettings, } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const mic = useMicrophoneState();\n    const camera = useCameraState();\n    const speaker = useSpeakerState();\n    const settings = useCallSettings();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !settings)\n            return;\n        if (call.state.callingState === _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.LEFT)\n            return;\n        try {\n            const hasPreferences = !!window.localStorage.getItem(key);\n            const { audio, video } = settings;\n            const defaultDevice = 'default';\n            const preferences = {\n                mic: {\n                    selectedDeviceId: mic.selectedDevice || defaultDevice,\n                    muted: hasPreferences ? mic.isMute : !audio.mic_default_on,\n                },\n                camera: {\n                    selectedDeviceId: camera.selectedDevice || defaultDevice,\n                    muted: hasPreferences ? camera.isMute : !video.camera_default_on,\n                },\n                speaker: {\n                    selectedDeviceId: speaker.selectedDevice || defaultDevice,\n                    muted: false,\n                },\n            };\n            window.localStorage.setItem(key, JSON.stringify(preferences));\n        }\n        catch (err) {\n            console.warn('Failed to save device preferences', err);\n        }\n    }, [\n        call,\n        camera.isMute,\n        camera.selectedDevice,\n        key,\n        mic.isMute,\n        mic.selectedDevice,\n        settings,\n        speaker.selectedDevice,\n    ]);\n};\n/**\n * This hook will apply the device settings from local storage.\n *\n * @param key the key to use for local storage.\n */\nconst useApplyDevicePreferences = (key) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const settings = useCallSettings();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !settings)\n            return;\n        const apply = async () => {\n            const initMic = async (setting) => {\n                await call.microphone.select(setting.selectedDeviceId);\n                if (setting.muted) {\n                    await call.microphone.disable();\n                }\n                else {\n                    await call.microphone.enable();\n                }\n            };\n            const initCamera = async (setting) => {\n                await call.camera.select(setting.selectedDeviceId);\n                if (setting.muted) {\n                    await call.camera.disable();\n                }\n                else {\n                    await call.camera.enable();\n                }\n            };\n            const initSpeaker = (setting) => {\n                call.speaker.select(setting.selectedDeviceId);\n            };\n            let preferences = null;\n            try {\n                preferences = JSON.parse(window.localStorage.getItem(key));\n            }\n            catch (err) {\n                console.warn('Failed to load device preferences', err);\n            }\n            if (preferences) {\n                await initMic(preferences.mic);\n                await initCamera(preferences.camera);\n                initSpeaker(preferences.speaker);\n            }\n            else {\n                const { audio, video } = settings;\n                if (audio.mic_default_on)\n                    await call.microphone.enable();\n                if (video.camera_default_on)\n                    await call.camera.enable();\n            }\n        };\n        apply().catch((err) => {\n            console.warn('Failed to apply device preferences', err);\n        });\n    }, [call, key, settings]);\n};\n/**\n * This hook will apply and persist the device preferences from local storage.\n *\n * @param key the key to use for local storage.\n */\nconst usePersistedDevicePreferences = (key = '@stream-io/device-preferences') => {\n    useApplyDevicePreferences(key);\n    usePersistDevicePreferences(key);\n};\n\nconst SCROLL_THRESHOLD = 10;\n/**\n * Hook which observes element's scroll position and returns text value based on the\n * position of the scrollbar (`top`, `bottom`, `between` and `null` if no scrollbar is available)\n */\nconst useVerticalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {\n    const [scrollPosition, setScrollPosition] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!scrollElement)\n            return;\n        const scrollHandler = () => {\n            const element = scrollElement;\n            const hasVerticalScrollbar = element.scrollHeight > element.clientHeight;\n            if (!hasVerticalScrollbar)\n                return setScrollPosition(null);\n            const isAtTheTop = element.scrollTop <= threshold;\n            if (isAtTheTop)\n                return setScrollPosition('top');\n            const isAtTheBottom = Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) <= threshold;\n            if (isAtTheBottom)\n                return setScrollPosition('bottom');\n            setScrollPosition('between');\n        };\n        const resizeObserver = new ResizeObserver(scrollHandler);\n        resizeObserver.observe(scrollElement);\n        scrollElement.addEventListener('scroll', scrollHandler);\n        return () => {\n            scrollElement.removeEventListener('scroll', scrollHandler);\n            resizeObserver.disconnect();\n        };\n    }, [scrollElement, threshold]);\n    return scrollPosition;\n};\nconst useHorizontalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {\n    const [scrollPosition, setScrollPosition] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!scrollElement)\n            return;\n        const scrollHandler = () => {\n            const element = scrollElement;\n            const hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;\n            if (!hasHorizontalScrollbar)\n                return setScrollPosition(null);\n            const isAtTheStart = element.scrollLeft <= threshold;\n            if (isAtTheStart)\n                return setScrollPosition('start');\n            const isAtTheEnd = Math.abs(element.scrollWidth - element.scrollLeft - element.clientWidth) <= threshold;\n            if (isAtTheEnd)\n                return setScrollPosition('end');\n            setScrollPosition('between');\n        };\n        const resizeObserver = new ResizeObserver(scrollHandler);\n        resizeObserver.observe(scrollElement);\n        scrollElement.addEventListener('scroll', scrollHandler);\n        return () => {\n            scrollElement.removeEventListener('scroll', scrollHandler);\n            resizeObserver.disconnect();\n        };\n    }, [scrollElement, threshold]);\n    return scrollPosition;\n};\n\nconst useToggleCallRecording = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useIsCallRecordingInProgress } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isCallRecordingInProgress = useIsCallRecordingInProgress();\n    const [isAwaitingResponse, setIsAwaitingResponse] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    // TODO: add permissions\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        // we wait until call.recording_started/stopped event to flips the\n        // `isCallRecordingInProgress` state variable.\n        // Once the flip happens, we remove the loading indicator\n        setIsAwaitingResponse((isAwaiting) => {\n            if (isAwaiting)\n                return false;\n            return isAwaiting;\n        });\n    }, [isCallRecordingInProgress]);\n    const toggleCallRecording = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async () => {\n        try {\n            setIsAwaitingResponse(true);\n            if (isCallRecordingInProgress) {\n                await call?.stopRecording();\n            }\n            else {\n                await call?.startRecording();\n            }\n        }\n        catch (e) {\n            console.error(`Failed start recording`, e);\n        }\n    }, [call, isCallRecordingInProgress]);\n    return { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress };\n};\n\nconst useRequestPermission = (permission) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const hasPermission = useHasPermissions(permission);\n    const [isAwaitingPermission, setIsAwaitingPermission] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false); // TODO: load with possibly pending state\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        const reset = () => setIsAwaitingPermission(false);\n        if (hasPermission)\n            reset();\n    }, [hasPermission]);\n    const requestPermission = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async () => {\n        if (hasPermission)\n            return true;\n        const canRequestPermission = !!call?.permissionsContext.canRequest(permission);\n        if (isAwaitingPermission || !canRequestPermission)\n            return false;\n        setIsAwaitingPermission(true);\n        try {\n            await call?.requestPermissions({\n                permissions: [permission],\n            });\n        }\n        catch (error) {\n            setIsAwaitingPermission(false);\n            throw new Error(`requestPermission failed: ${error}`);\n        }\n        return false;\n    }, [call, hasPermission, isAwaitingPermission, permission]);\n    return {\n        requestPermission,\n        hasPermission,\n        canRequestPermission: !!call?.permissionsContext.canRequest(permission),\n        isAwaitingPermission,\n    };\n};\n\nvar MenuVisualType;\n(function (MenuVisualType) {\n    MenuVisualType[\"PORTAL\"] = \"portal\";\n    MenuVisualType[\"MENU\"] = \"menu\";\n})(MenuVisualType || (MenuVisualType = {}));\n/**\n * Used to provide utility APIs to the components rendered inside the portal.\n */\nconst MenuContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\n/**\n * Access to the closes MenuContext.\n */\nconst useMenuContext = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(MenuContext);\n};\nconst MenuPortal = ({ children, refs, }) => {\n    const portalId = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => `str-video-portal-${Math.random().toString(36).substring(2, 9)}`, []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { id: portalId, className: \"str-video__portal\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.FloatingOverlay, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.FloatingPortal, { id: portalId, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__portal-content\", ref: refs.setFloating, children: children }) }) })] }));\n};\nconst MenuToggle = ({ ToggleButton, placement = 'top-start', strategy = 'absolute', offset, visualType = MenuVisualType.MENU, children, }) => {\n    const [menuShown, setMenuShown] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const { floating, domReference, refs, x, y } = useFloatingUIPreset({\n        placement,\n        strategy,\n        offset,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        const handleClick = (event) => {\n            if (!floating && domReference?.contains(event.target)) {\n                setMenuShown(true);\n            }\n            else if (floating && !floating?.contains(event.target)) {\n                setMenuShown(false);\n            }\n        };\n        const handleKeyDown = (event) => {\n            if (event.key.toLowerCase() === 'escape' &&\n                !event.altKey &&\n                !event.ctrlKey) {\n                setMenuShown(false);\n            }\n        };\n        document?.addEventListener('click', handleClick, { capture: true });\n        document?.addEventListener('keydown', handleKeyDown);\n        return () => {\n            document?.removeEventListener('click', handleClick, { capture: true });\n            document?.removeEventListener('keydown', handleKeyDown);\n        };\n    }, [floating, domReference]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [menuShown && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuContext.Provider, { value: { close: () => setMenuShown(false) }, children: visualType === MenuVisualType.PORTAL ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuPortal, { refs: refs, children: children })) : visualType === MenuVisualType.MENU ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__menu-container\", ref: refs.setFloating, style: {\n                        position: strategy,\n                        top: y ?? 0,\n                        left: x ?? 0,\n                        overflowY: 'auto',\n                    }, children: children })) : null })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleButton, { menuShown: menuShown, ref: refs.setReference })] }));\n};\n\nconst GenericMenu = ({ children, onItemClick, }) => {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__generic-menu\", ref: ref, onClick: (e) => {\n            if (onItemClick &&\n                e.target !== ref.current &&\n                ref.current?.contains(e.target)) {\n                onItemClick(e);\n            }\n        }, children: children }));\n};\nconst GenericMenuButtonItem = ({ children, ...rest }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"li\", { className: \"str-video__generic-menu--item\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { ...rest, children: children }) }));\n};\n\nconst Icon = ({ className, icon }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__icon', icon && `str-video__icon--${icon}`, className) }));\n\nconst IconButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function IconButton(props, ref) {\n    const { icon, enabled, variant, onClick, className, ...rest } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-controls__button', className, {\n            [`str-video__call-controls__button--variant-${variant}`]: variant,\n            'str-video__call-controls__button--enabled': enabled,\n        }), onClick: (e) => {\n            e.preventDefault();\n            onClick?.(e);\n        }, ref: ref, ...rest, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: icon }) }));\n});\n\nconst isComponentType = (elementOrComponent) => {\n    return elementOrComponent === null\n        ? false\n        : !(0,react__WEBPACK_IMPORTED_MODULE_3__.isValidElement)(elementOrComponent);\n};\n\nconst chunk = (array, size) => {\n    const chunkCount = Math.ceil(array.length / size);\n    return Array.from({ length: chunkCount }, (_, index) => array.slice(size * index, size * index + size));\n};\n\nconst applyElementToRef = (ref, element) => {\n    if (!ref)\n        return;\n    if (typeof ref === 'function')\n        return ref(element);\n    ref.current = element;\n};\n\nconst CompositeButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function CompositeButton({ caption, children, className, active, Menu, menuPlacement, menuOffset, title, ToggleMenuButton = DefaultToggleMenuButton, variant, onClick, ...restButtonProps }, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__composite-button', className, {\n            'str-video__composite-button--caption': caption,\n            'str-video__composite-button--menu': Menu,\n        }), title: title, ref: ref, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__composite-button__button-group', {\n                    'str-video__composite-button__button-group--active': active,\n                    'str-video__composite-button__button-group--active-primary': active && variant === 'primary',\n                    'str-video__composite-button__button-group--active-secondary': active && variant === 'secondary',\n                }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { type: \"button\", className: \"str-video__composite-button__button\", onClick: (e) => {\n                            e.preventDefault();\n                            onClick?.(e);\n                        }, ...restButtonProps, children: children }), Menu && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { offset: menuOffset, placement: menuPlacement, ToggleButton: ToggleMenuButton, children: isComponentType(Menu) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Menu, {}) : Menu }))] }), caption && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__composite-button__caption\", children: caption }))] }));\n});\nconst DefaultToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function DefaultToggleMenuButton({ menuShown }, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__menu-toggle-button', {\n            'str-video__menu-toggle-button--active': menuShown,\n        }), icon: menuShown ? 'caret-down' : 'caret-up', ref: ref }));\n});\n\nconst TextButton = ({ children, ...rest }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { ...rest, className: \"str-video__text-button\", children: children }));\n};\n\nconst AcceptCallButton = ({ disabled, onAccept, onClick, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.join();\n            onAccept?.();\n        }\n    }, [onClick, onAccept, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: disabled, icon: \"call-accept\", variant: \"success\", \"data-testid\": \"accept-call-button\", onClick: handleClick }));\n};\n\nconst Notification = (props) => {\n    const { isVisible, message, children, visibilityTimeout, resetIsVisible, placement = 'top', iconClassName = 'str-video__notification__icon', close, } = props;\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement,\n        strategy: 'absolute',\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!isVisible || !visibilityTimeout || !resetIsVisible)\n            return;\n        const timeout = setTimeout(() => {\n            resetIsVisible();\n        }, visibilityTimeout);\n        return () => clearTimeout(timeout);\n    }, [isVisible, resetIsVisible, visibilityTimeout]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: refs.setReference, children: [isVisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__notification\", ref: refs.setFloating, style: {\n                    position: strategy,\n                    top: y ?? 0,\n                    left: x ?? 0,\n                    overflowY: 'auto',\n                }, children: [iconClassName && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"i\", { className: iconClassName }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__notification__message\", children: message }), close ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"i\", { className: \"str-video__icon str-video__icon--close str-video__notification__close\", onClick: close })) : null] })), children] }));\n};\n\nconst PermissionNotification = (props) => {\n    const { permission, isAwaitingApproval, messageApproved, messageAwaitingApproval, messageRevoked, visibilityTimeout = 3500, children, } = props;\n    const { useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const hasPermission = useHasPermissions(permission);\n    const prevHasPermission = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(hasPermission);\n    const [showNotification, setShowNotification] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (hasPermission && !prevHasPermission.current) {\n            setShowNotification('granted');\n            prevHasPermission.current = true;\n        }\n        else if (!hasPermission && prevHasPermission.current) {\n            setShowNotification('revoked');\n            prevHasPermission.current = false;\n        }\n    }, [hasPermission]);\n    const resetIsVisible = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => setShowNotification(undefined), []);\n    if (isAwaitingApproval) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: isAwaitingApproval && !hasPermission, message: messageAwaitingApproval, children: children }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: !!showNotification, visibilityTimeout: visibilityTimeout, resetIsVisible: resetIsVisible, message: showNotification === 'granted' ? messageApproved : messageRevoked, children: children }));\n};\n\nconst SpeakingWhileMutedNotification = ({ children, text, placement, }) => {\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { isSpeakingWhileMuted } = useMicrophoneState();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const message = text ?? t('You are muted. Unmute to speak.');\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { message: message, isVisible: isSpeakingWhileMuted, placement: placement || 'top-start', children: children }));\n};\n\nconst RecordingInProgressNotification = ({ children, text, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { isCallRecordingInProgress } = useToggleCallRecording();\n    const [isVisible, setVisible] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const message = text ?? t('Recording in progress...');\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (isCallRecordingInProgress) {\n            setVisible(true);\n        }\n        else {\n            setVisible(false);\n        }\n    }, [isCallRecordingInProgress]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { message: message, iconClassName: \"str-video__icon str-video__icon--recording-on\", isVisible: isVisible, placement: \"top-start\", close: () => setVisible(false), children: children }));\n};\n\nconst LoadingIndicator = ({ className, type = 'spinner', text, tooltip, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__loading-indicator', className), title: tooltip, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__loading-indicator__icon', type) }), text && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__loading-indicator-text\", children: text })] }));\n};\n\nconst RecordEndConfirmation = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse } = useToggleCallRecording();\n    const { close } = useMenuContext();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__confirmation\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-on\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"h2\", { className: \"str-video__end-recording__heading\", children: t('End recording') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__end-recording__description\", children: t('Are you sure you want end the recording?') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__actions\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { variant: \"secondary\", onClick: close, children: t('Cancel') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { variant: \"primary\", onClick: toggleCallRecording, children: isAwaitingResponse ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, {}) : t('End recording') })] })] }));\n};\nconst ToggleEndRecordingMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleEndRecordingMenuButton(props, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: true, variant: \"secondary\", \"data-testid\": \"recording-stop-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-off\" }) }));\n});\nconst RecordCallConfirmationButton = ({ caption, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();\n    if (isCallRecordingInProgress) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n                _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n                _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n            ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { ToggleButton: ToggleEndRecordingMenuButton, visualType: MenuVisualType.PORTAL, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RecordEndConfirmation, {}) }) }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n        ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption: caption, title: caption || t('Record call'), variant: \"secondary\", \"data-testid\": \"recording-start-button\", onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, { tooltip: t('Waiting for recording to start...') })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-off\" })) }) }));\n};\nconst RecordCallButton = ({ caption }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();\n    let title = caption || t('Record call');\n    if (isAwaitingResponse) {\n        title = isCallRecordingInProgress\n            ? t('Waiting for recording to stop...')\n            : t('Waiting for recording to start...');\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n        ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption: caption, variant: \"secondary\", \"data-testid\": isCallRecordingInProgress\n                ? 'recording-stop-button'\n                : 'recording-start-button', title: title, onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, {})) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isCallRecordingInProgress ? 'recording-on' : 'recording-off' })) }) }));\n};\n\nconst defaultEmojiReactionMap = {\n    ':like:': '👍',\n    ':raise-hand:': '✋',\n    ':fireworks:': '🎉',\n    ':dislike:': '👎',\n    ':heart:': '❤️',\n    ':smile:': '😀',\n};\nconst Reaction = ({ participant: { reaction, sessionId }, hideAfterTimeoutInMs = 5500, emojiReactionMap = defaultEmojiReactionMap, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !reaction)\n            return;\n        const timeoutId = setTimeout(() => {\n            call.resetReaction(sessionId);\n        }, hideAfterTimeoutInMs);\n        return () => {\n            clearTimeout(timeoutId);\n        };\n    }, [call, hideAfterTimeoutInMs, reaction, sessionId]);\n    if (!reaction)\n        return null;\n    const { emoji_code: emojiCode } = reaction;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__reaction\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__reaction__emoji\", children: emojiCode && emojiReactionMap[emojiCode] }) }));\n};\n\nconst defaultReactions = [\n    {\n        type: 'reaction',\n        emoji_code: ':like:',\n    },\n    {\n        // TODO OL: use `prompt` type?\n        type: 'raised-hand',\n        emoji_code: ':raise-hand:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':fireworks:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':dislike:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':heart:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':smile:',\n    },\n];\nconst ReactionsButton = ({ reactions = defaultReactions, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.CREATE_REACTION], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top\", ToggleButton: ToggleReactionsMenuButton, visualType: MenuVisualType.MENU, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultReactionsMenu, { reactions: reactions }) }) }));\n};\nconst ToggleReactionsMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleReactionsMenuButton({ menuShown }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: menuShown, variant: \"primary\", title: t('Reactions'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"reactions\" }) }));\n});\nconst DefaultReactionsMenu = ({ reactions, layout = 'horizontal', }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__reactions-menu', {\n            'str-video__reactions-menu--horizontal': layout === 'horizontal',\n            'str-video__reactions-menu--vertical': layout === 'vertical',\n        }), children: reactions.map((reaction) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { type: \"button\", className: \"str-video__reactions-menu__button\", onClick: () => {\n                call?.sendReaction(reaction);\n            }, children: reaction.emoji_code && defaultEmojiReactionMap[reaction.emoji_code] }, reaction.emoji_code))) }));\n};\n\nconst ScreenShareButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption } = props;\n    const { useHasOngoingScreenShare, useScreenShareState, useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isSomeoneScreenSharing = useHasOngoingScreenShare();\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE);\n    const callSettings = useCallSettings();\n    const isScreenSharingAllowed = callSettings?.screensharing.enabled;\n    const { screenShare, isMute: amIScreenSharing } = useScreenShareState();\n    const disableScreenShareButton = amIScreenSharing\n        ? isSomeoneScreenSharing || isScreenSharingAllowed === false\n        : false;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your screen.'), messageAwaitingApproval: t('Awaiting for an approval to share screen.'), messageRevoked: t('You can no longer share your screen.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isSomeoneScreenSharing, caption: caption, title: caption || t('Share screen'), variant: \"primary\", \"data-testid\": isSomeoneScreenSharing\n                    ? 'screen-share-stop-button'\n                    : 'screen-share-start-button', disabled: disableScreenShareButton, onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await screenShare.toggle();\n                    }\n                }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isSomeoneScreenSharing ? 'screen-share-on' : 'screen-share-off' }) }) }) }));\n};\n\nconst SelectContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nconst Select = (props) => {\n    const { children, icon, defaultSelectedLabel, defaultSelectedIndex, handleSelect: handleSelectProp, } = props;\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [activeIndex, setActiveIndex] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [selectedIndex, setSelectedIndex] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(defaultSelectedIndex);\n    const [selectedLabel, setSelectedLabel] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(defaultSelectedLabel);\n    const { refs, context } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useFloating)({\n        placement: 'bottom-start',\n        open: isOpen,\n        onOpenChange: setIsOpen,\n        whileElementsMounted: _floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.autoUpdate,\n        middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_8__.flip)()],\n    });\n    const elementsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    const labelsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    const handleSelect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((index) => {\n        setSelectedIndex(index);\n        handleSelectProp(index || 0);\n        setIsOpen(false);\n        if (index !== null) {\n            setSelectedLabel(labelsRef.current[index]);\n        }\n    }, [handleSelectProp]);\n    const handleTypeaheadMatch = (index) => {\n        if (isOpen) {\n            setActiveIndex(index);\n        }\n        else {\n            handleSelect(index);\n        }\n    };\n    const listNav = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useListNavigation)(context, {\n        listRef: elementsRef,\n        activeIndex,\n        selectedIndex,\n        onNavigate: setActiveIndex,\n    });\n    const typeahead = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useTypeahead)(context, {\n        listRef: labelsRef,\n        activeIndex,\n        selectedIndex,\n        onMatch: handleTypeaheadMatch,\n    });\n    const click = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useClick)(context);\n    const dismiss = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useDismiss)(context);\n    const role = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useRole)(context, { role: 'listbox' });\n    const { getReferenceProps, getFloatingProps, getItemProps } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useInteractions)([listNav, typeahead, click, dismiss, role]);\n    const selectContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        activeIndex,\n        selectedIndex,\n        getItemProps,\n        handleSelect,\n    }), [activeIndex, selectedIndex, getItemProps, handleSelect]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__dropdown\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__dropdown-selected\", ref: refs.setReference, tabIndex: 0, ...getReferenceProps(), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"label\", { className: \"str-video__dropdown-selected__label\", children: [icon && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-selected__icon\", icon: icon })), selectedLabel] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-selected__chevron\", icon: isOpen ? 'chevron-up' : 'chevron-down' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SelectContext.Provider, { value: selectContext, children: isOpen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.FloatingFocusManager, { context: context, modal: false, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__dropdown-list\", ref: refs.setFloating, ...getFloatingProps(), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.FloatingList, { elementsRef: elementsRef, labelsRef: labelsRef, children: children }) }) })) })] }));\n};\nconst DropDownSelectOption = (props) => {\n    const { selected, label, icon } = props;\n    const { getItemProps, handleSelect } = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectContext);\n    const { ref, index } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useListItem)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__dropdown-option', {\n            'str-video__dropdown-option--selected': selected,\n        }), ref: ref, ...getItemProps({\n            onClick: () => handleSelect(index),\n        }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-icon\", icon: icon }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__dropdown-label\", children: label })] }));\n};\nconst DropDownSelect = (props) => {\n    const { children, icon, handleSelect, defaultSelectedLabel, defaultSelectedIndex, } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Select, { icon: icon, handleSelect: handleSelect, defaultSelectedIndex: defaultSelectedIndex, defaultSelectedLabel: defaultSelectedLabel, children: children }));\n};\n\nconst DeviceSelectorOption = ({ disabled, id, label, onChange, name, selected, defaultChecked, value, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"label\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__device-settings__option', {\n            'str-video__device-settings__option--selected': selected,\n            'str-video__device-settings__option--disabled': disabled,\n        }), htmlFor: id, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", { type: \"radio\", name: name, onChange: onChange, value: value, id: id, checked: selected, defaultChecked: defaultChecked, disabled: disabled }), label] }));\n};\nconst DeviceSelectorList = (props) => {\n    const { devices = [], selectedDeviceId: selectedDeviceFromProps, title, type, onChange, } = props;\n    // sometimes the browser (Chrome) will report the system-default device\n    // with an id of 'default'. In case when it doesn't, we'll select the first\n    // available device.\n    let selectedDeviceId = selectedDeviceFromProps;\n    if (devices.length > 0 &&\n        !devices.find((d) => d.deviceId === selectedDeviceId)) {\n        selectedDeviceId = devices[0].deviceId;\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings__device-kind\", children: [title && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__device-settings__device-selector-title\", children: title })), !devices.length ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorOption, { id: `${type}--default`, label: \"Default\", name: type, defaultChecked: true, value: \"default\" })) : (devices.map((device) => {\n                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorOption, { id: `${type}--${device.deviceId}`, value: device.deviceId, label: device.label, onChange: (e) => {\n                        onChange?.(e.target.value);\n                    }, name: type, selected: device.deviceId === selectedDeviceId || devices.length === 1 }, device.deviceId));\n            }))] }));\n};\nconst DeviceSelectorDropdown = (props) => {\n    const { devices = [], selectedDeviceId: selectedDeviceFromProps, title, onChange, icon, } = props;\n    // sometimes the browser (Chrome) will report the system-default device\n    // with an id of 'default'. In case when it doesn't, we'll select the first\n    // available device.\n    let selectedDeviceId = selectedDeviceFromProps;\n    if (devices.length > 0 &&\n        !devices.find((d) => d.deviceId === selectedDeviceId)) {\n        selectedDeviceId = devices[0].deviceId;\n    }\n    const selectedIndex = devices.findIndex((d) => d.deviceId === selectedDeviceId);\n    const handleSelect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((index) => {\n        onChange?.(devices[index].deviceId);\n    }, [devices, onChange]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings__device-kind\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__device-settings__device-selector-title\", children: title }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropDownSelect, { icon: icon, defaultSelectedIndex: selectedIndex, defaultSelectedLabel: devices[selectedIndex]?.label, handleSelect: handleSelect, children: devices.map((device) => {\n                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropDownSelectOption, { icon: icon, label: device.label, selected: device.deviceId === selectedDeviceId || devices.length === 1 }, device.deviceId));\n                }) })] }));\n};\nconst DeviceSelector = (props) => {\n    const { visualType = 'list', icon, placeholder, ...rest } = props;\n    if (visualType === 'list') {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorList, { ...rest });\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorDropdown, { ...rest, icon: icon, placeholder: placeholder }));\n};\n\nconst DeviceSelectorAudioInput = ({ title, visualType, }) => {\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, selectedDevice, devices } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices || [], selectedDeviceId: selectedDevice, type: \"audioinput\", onChange: async (deviceId) => {\n            await microphone.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"mic\" }));\n};\nconst DeviceSelectorAudioOutput = ({ title, visualType, }) => {\n    const { useSpeakerState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { speaker, selectedDevice, devices, isDeviceSelectionSupported } = useSpeakerState();\n    if (!isDeviceSelectionSupported)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices, type: \"audiooutput\", selectedDeviceId: selectedDevice, onChange: (deviceId) => {\n            speaker.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"speaker\" }));\n};\n\nconst DeviceSelectorVideo = ({ title, visualType, }) => {\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, devices, selectedDevice } = useCameraState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices || [], type: \"videoinput\", selectedDeviceId: selectedDevice, onChange: async (deviceId) => {\n            await camera.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"camera\" }));\n};\n\nconst DeviceSettings = ({ visualType = MenuVisualType.MENU, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleDeviceSettingsMenuButton, visualType: visualType, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Menu, {}) }));\n};\nconst Menu = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorVideo, { title: t('Select a Camera') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioInput, { title: t('Select a Mic') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioOutput, { title: t('Select Speakers') })] }));\n};\nconst ToggleDeviceSettingsMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleDeviceSettingsMenuButton({ menuShown }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__device-settings__button', {\n            'str-video__device-settings__button--active': menuShown,\n        }), title: t('Toggle device menu'), icon: \"device-settings\", ref: ref }));\n});\n\nconst ToggleAudioPreviewButton = (props) => {\n    const { caption, Menu, menuPlacement, ...restCompositeButtonProps } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, isMute, hasBrowserPermission } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!hasBrowserPermission && 'str-video__device-unavailable'), variant: \"secondary\", title: !hasBrowserPermission\n            ? t('Check your browser audio permissions')\n            : caption || t('Mic'), disabled: !hasBrowserPermission, \"data-testid\": isMute ? 'preview-audio-unmute-button' : 'preview-audio-mute-button', onClick: () => microphone.toggle(), Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: !isMute ? 'mic' : 'mic-off' }), !hasBrowserPermission && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", title: t('Check your browser audio permissions'), children: \"!\" }))] }));\n};\nconst ToggleAudioPublishingButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioInput, { visualType: \"list\" }), menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO);\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, isMute, hasBrowserPermission } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now speak.'), messageAwaitingApproval: t('Awaiting for an approval to speak.'), messageRevoked: t('You can no longer speak.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, title: !hasPermission\n                    ? t('You have no permission to share your audio')\n                    : !hasBrowserPermission\n                        ? t('Check your browser mic permissions')\n                        : caption || t('Mic'), variant: \"secondary\", disabled: !hasBrowserPermission || !hasPermission, \"data-testid\": isMute ? 'audio-unmute-button' : 'audio-mute-button', onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await microphone.toggle();\n                    }\n                }, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isMute ? 'mic-off' : 'mic' }), (!hasBrowserPermission || !hasPermission) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", children: \"!\" }))] }) }) }));\n};\n\nconst ToggleVideoPreviewButton = (props) => {\n    const { caption, Menu = DeviceSelectorVideo, menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, isMute, hasBrowserPermission } = useCameraState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!hasBrowserPermission && 'str-video__device-unavailable'), title: !hasBrowserPermission\n            ? t('Check your browser video permissions')\n            : caption || t('Video'), variant: \"secondary\", \"data-testid\": isMute ? 'preview-video-unmute-button' : 'preview-video-mute-button', onClick: () => camera.toggle(), disabled: !hasBrowserPermission, Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: !isMute ? 'camera' : 'camera-off' }), !hasBrowserPermission && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", title: t('Check your browser video permissions'), children: \"!\" }))] }));\n};\nconst ToggleVideoPublishingButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorVideo, { visualType: \"list\" }), menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO);\n    const { useCameraState, useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, isMute, hasBrowserPermission } = useCameraState();\n    const callSettings = useCallSettings();\n    const isPublishingVideoAllowed = callSettings?.video.enabled;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your video.'), messageAwaitingApproval: t('Awaiting for an approval to share your video.'), messageRevoked: t('You can no longer share your video.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, variant: \"secondary\", title: !hasPermission\n                    ? t('You have no permission to share your video')\n                    : !hasBrowserPermission\n                        ? t('Check your browser video permissions')\n                        : !isPublishingVideoAllowed\n                            ? t('Video publishing is disabled by the system')\n                            : caption || t('Video'), disabled: !hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed, \"data-testid\": isMute ? 'video-unmute-button' : 'video-mute-button', onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await camera.toggle();\n                    }\n                }, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isMute ? 'camera-off' : 'camera' }), (!hasBrowserPermission ||\n                        !hasPermission ||\n                        !isPublishingVideoAllowed) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", children: \"!\" }))] }) }) }));\n};\n\nconst EndCallMenu = (props) => {\n    const { onLeave, onEnd } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-call__confirmation\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { className: \"str-video__button str-video__end-call__leave\", type: \"button\", \"data-testid\": \"leave-call-button\", onClick: onLeave, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__button__icon str-video__end-call__leave-icon\", icon: \"logout\" }), t('Leave call')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.END_CALL], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { className: \"str-video__button str-video__end-call__end\", type: \"button\", \"data-testid\": \"end-call-for-all-button\", onClick: onEnd, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__button__icon str-video__end-call__end-icon\", icon: \"call-end\" }), t('End call for all')] }) })] }));\n};\nconst CancelCallToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function CancelCallToggleMenuButton(props, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"call-end\", variant: \"danger\", title: t('Leave call'), \"data-testid\": \"leave-call-button\", ref: ref }));\n});\nconst CancelCallConfirmButton = ({ onClick, onLeave, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const handleLeave = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.leave();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    const handleEndCall = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.endCall();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top-start\", ToggleButton: CancelCallToggleMenuButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EndCallMenu, { onEnd: handleEndCall, onLeave: handleLeave }) }));\n};\nconst CancelCallButton = ({ disabled, onClick, onLeave, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.leave();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: disabled, icon: \"call-end\", variant: \"danger\", title: t('Leave call'), \"data-testid\": \"cancel-call-button\", onClick: handleClick }));\n};\n\nconst CallControls = ({ onLeave }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-controls\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RecordCallButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ReactionsButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ScreenShareButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SpeakingWhileMutedNotification, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleAudioPublishingButton, {}) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleVideoPublishingButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { onLeave: onLeave })] }));\n\nchart_js__WEBPACK_IMPORTED_MODULE_9__.Chart.register(chart_js__WEBPACK_IMPORTED_MODULE_9__.CategoryScale, chart_js__WEBPACK_IMPORTED_MODULE_9__.LinearScale, chart_js__WEBPACK_IMPORTED_MODULE_9__.LineElement, chart_js__WEBPACK_IMPORTED_MODULE_9__.PointElement);\nconst CallStatsLatencyChart = (props) => {\n    const { values } = props;\n    let max = 0;\n    const data = {\n        labels: values.map((point) => {\n            const date = new Date(point.x * 1000);\n            return `${date.getHours()}:${date.getMinutes()}`;\n        }),\n        datasets: [\n            {\n                data: values.map((point) => {\n                    const { y } = point;\n                    max = Math.max(max, y);\n                    return point;\n                }),\n                borderColor: '#00e2a1',\n                backgroundColor: '#00e2a1',\n            },\n        ],\n    };\n    const options = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n        return {\n            maintainAspectRatio: false,\n            animation: {\n                duration: 0,\n            },\n            elements: {\n                line: {\n                    borderWidth: 1,\n                },\n                point: {\n                    radius: 2,\n                },\n            },\n            scales: {\n                y: {\n                    position: 'right',\n                    stacked: true,\n                    min: 0,\n                    max: Math.max(180, Math.ceil((max + 10) / 10) * 10),\n                    grid: {\n                        display: true,\n                        color: '#979ca0',\n                    },\n                    ticks: {\n                        stepSize: 30,\n                    },\n                },\n                x: {\n                    grid: {\n                        display: false,\n                    },\n                    ticks: {\n                        display: false,\n                    },\n                },\n            },\n        };\n    }, [max]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats-line-chart-container\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_chartjs_2__WEBPACK_IMPORTED_MODULE_10__.Line, { options: options, data: data, className: \"str-video__call-stats__latencychart\" }) }));\n};\n\nvar Statuses;\n(function (Statuses) {\n    Statuses[\"GOOD\"] = \"Good\";\n    Statuses[\"OK\"] = \"Ok\";\n    Statuses[\"BAD\"] = \"Bad\";\n})(Statuses || (Statuses = {}));\nconst statsStatus = ({ value, lowBound, highBound, }) => {\n    if (value <= lowBound) {\n        return Statuses.GOOD;\n    }\n    if (value >= lowBound && value <= highBound) {\n        return Statuses.OK;\n    }\n    if (value >= highBound) {\n        return Statuses.BAD;\n    }\n    return Statuses.GOOD;\n};\nconst CallStats = (props) => {\n    const { latencyLowBound = 75, latencyHighBound = 400 } = props;\n    const [latencyBuffer, setLatencyBuffer] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => {\n        const now = Date.now();\n        return Array.from({ length: 20 }, (_, i) => ({ x: now + i, y: 0 }));\n    });\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const [publishBitrate, setPublishBitrate] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('-');\n    const [subscribeBitrate, setSubscribeBitrate] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('-');\n    const previousStats = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    const { useCallStatsReport } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callStatsReport = useCallStatsReport();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!callStatsReport)\n            return;\n        if (!previousStats.current) {\n            previousStats.current = callStatsReport;\n            return;\n        }\n        const previousCallStatsReport = previousStats.current;\n        setPublishBitrate(() => {\n            return calculatePublishBitrate(previousCallStatsReport, callStatsReport);\n        });\n        setSubscribeBitrate(() => {\n            return calculateSubscribeBitrate(previousCallStatsReport, callStatsReport);\n        });\n        setLatencyBuffer((latencyBuf) => {\n            const newLatencyBuffer = latencyBuf.slice(-19);\n            newLatencyBuffer.push({\n                x: callStatsReport.timestamp,\n                y: callStatsReport.publisherStats.averageRoundTripTimeInMs,\n            });\n            return newLatencyBuffer;\n        });\n        previousStats.current = callStatsReport;\n    }, [callStatsReport]);\n    const latencyComparison = {\n        lowBound: latencyLowBound,\n        highBound: latencyHighBound,\n        value: callStatsReport?.publisherStats.averageRoundTripTimeInMs || 0,\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats\", children: callStatsReport && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"h3\", { className: \"str-video__call-stats__heading\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-stats__icon\", icon: \"call-latency\" }), t('Call Latency')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-stats__description\", children: t('Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__latencychart\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallStatsLatencyChart, { values: latencyBuffer }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"h3\", { className: \"str-video__call-stats__heading\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-stats__icon\", icon: \"network-quality\" }), t('Call performance')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-stats__description\", children: t('Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-container\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Region\", value: callStatsReport.datacenter }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Latency\", value: `${callStatsReport.publisherStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receive jitter\", value: `${callStatsReport.subscriberStats.averageJitterInMs} ms.`, comparison: {\n                                ...latencyComparison,\n                                value: callStatsReport.subscriberStats.averageJitterInMs,\n                            } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish jitter\", value: `${callStatsReport.publisherStats.averageJitterInMs} ms.`, comparison: {\n                                ...latencyComparison,\n                                value: callStatsReport.publisherStats.averageJitterInMs,\n                            } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish resolution\", value: toFrameSize(callStatsReport.publisherStats) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish quality drop reason\", value: callStatsReport.publisherStats.qualityLimitationReasons }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receiving resolution\", value: toFrameSize(callStatsReport.subscriberStats) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receive quality drop reason\", value: callStatsReport.subscriberStats.qualityLimitationReasons }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish bitrate\", value: publishBitrate }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receiving bitrate\", value: subscribeBitrate })] })] })) }));\n};\nconst StatCardExplanation = (props) => {\n    const { description } = props;\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const { refs, floatingStyles, context } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useFloating)({\n        open: isOpen,\n        onOpenChange: setIsOpen,\n    });\n    const hover = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useHover)(context);\n    const { getReferenceProps, getFloatingProps } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.useInteractions)([hover]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-explanation\", ref: refs.setReference, ...getReferenceProps(), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-explanation__icon\", icon: \"info\" }) }), isOpen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-explanation__description\", ref: refs.setFloating, style: floatingStyles, ...getFloatingProps(), children: description }))] }));\n};\nconst StatsTag = ({ children, status = Statuses.GOOD, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-stats__tag', {\n            'str-video__call-stats__tag--good': status === Statuses.GOOD,\n            'str-video__call-stats__tag--ok': status === Statuses.OK,\n            'str-video__call-stats__tag--bad': status === Statuses.BAD,\n        }), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__tag__text\", children: children }) }));\n};\nconst StatCard = (props) => {\n    const { label, value, description, comparison } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const status = comparison ? statsStatus(comparison) : undefined;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-content\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-label\", children: [label, description && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCardExplanation, { description: description })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__card-value\", children: value })] }), comparison && status && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatsTag, { status: status, children: t(status) })] }));\n};\nconst toFrameSize = (stats) => {\n    const { highestFrameWidth: w, highestFrameHeight: h, highestFramesPerSecond: fps, } = stats;\n    let size = `-`;\n    if (w && h) {\n        size = `${w}x${h}`;\n        if (fps) {\n            size += `@${fps}fps.`;\n        }\n    }\n    return size;\n};\nconst calculatePublishBitrate = (previousCallStatsReport, callStatsReport) => {\n    const { publisherStats: { totalBytesSent: previousTotalBytesSent, timestamp: previousTimestamp, }, } = previousCallStatsReport;\n    const { publisherStats: { totalBytesSent, timestamp }, } = callStatsReport;\n    const bytesSent = totalBytesSent - previousTotalBytesSent;\n    const timeElapsed = timestamp - previousTimestamp;\n    return `${((bytesSent * 8) / timeElapsed).toFixed(2)} kbps`;\n};\nconst calculateSubscribeBitrate = (previousCallStatsReport, callStatsReport) => {\n    const { subscriberStats: { totalBytesReceived: previousTotalBytesReceived, timestamp: previousTimestamp, }, } = previousCallStatsReport;\n    const { subscriberStats: { totalBytesReceived, timestamp }, } = callStatsReport;\n    const bytesReceived = totalBytesReceived - previousTotalBytesReceived;\n    const timeElapsed = timestamp - previousTimestamp;\n    return `${((bytesReceived * 8) / timeElapsed).toFixed(2)} kbps`;\n};\n\nconst CallStatsButton = () => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top-end\", ToggleButton: ToggleMenuButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallStats, {}) }));\nconst ToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleMenuButton(props, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, menuShown } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: menuShown, caption: caption, title: caption || t('Statistics'), \"data-testid\": \"stats-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"stats\" }) }));\n});\n\nconst ToggleAudioOutputButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = DeviceSelectorAudioOutput, menuPlacement = 'top', } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { Menu: Menu, menuPlacement: menuPlacement, caption: caption, title: caption || t('Speakers'), \"data-testid\": \"audio-output-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"speaker\" }) }));\n};\n\nconst BlockedUserListing = ({ data }) => {\n    if (!data.length)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing\", children: data.map((userId) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlockedUserListingItem, { userId: userId }, userId))) }) }));\n};\nconst BlockedUserListingItem = ({ userId }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const unblockUserClickHandler = () => {\n        if (userId)\n            call?.unblockUser(userId);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing-item__display-name\", children: userId }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.BLOCK_USERS], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(TextButton, { onClick: unblockUserClickHandler, children: \"Unblock\" }) })] }));\n};\n\nconst CallParticipantListHeader = ({ onClose, }) => {\n    const { useParticipants, useAnonymousParticipantCount } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants();\n    const anonymousParticipantCount = useAnonymousParticipantCount();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list-header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list-header__title\", children: [t('Participants'), ' ', (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__participant-list-header__title-count\", children: [\"[\", participants.length, \"]\"] }), anonymousParticipantCount > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-list-header__title-anonymous\", children: t('Anonymous', { count: anonymousParticipantCount }) }))] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: onClose, className: \"str-video__participant-list-header__close-button\", icon: \"close\" })] }));\n};\n\nconst Tooltip = ({ children, referenceElement, tooltipClassName, tooltipPlacement = 'top', visible = false, }) => {\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement: tooltipPlacement,\n        strategy: 'absolute',\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        refs.setReference(referenceElement);\n    }, [referenceElement, refs]);\n    if (!visible)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__tooltip', tooltipClassName), ref: refs.setFloating, style: {\n            position: strategy,\n            top: y ?? 0,\n            left: x ?? 0,\n            overflowY: 'auto',\n        }, children: children }));\n};\n\nconst useEnterLeaveHandlers = ({ onMouseEnter, onMouseLeave, } = {}) => {\n    const [tooltipVisible, setTooltipVisible] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const handleMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((e) => {\n        setTooltipVisible(true);\n        onMouseEnter?.(e);\n    }, [onMouseEnter]);\n    const handleMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((e) => {\n        setTooltipVisible(false);\n        onMouseLeave?.(e);\n    }, [onMouseLeave]);\n    return { handleMouseEnter, handleMouseLeave, tooltipVisible };\n};\n\n// todo: duplicate of CallParticipantList.tsx#MediaIndicator - refactor to a single component\nconst WithTooltip = ({ title, tooltipClassName, tooltipPlacement, ...props }) => {\n    const { handleMouseEnter, handleMouseLeave, tooltipVisible } = useEnterLeaveHandlers();\n    const [tooltipAnchor, setTooltipAnchor] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Tooltip, { referenceElement: tooltipAnchor, visible: tooltipVisible, tooltipClassName: tooltipClassName, tooltipPlacement: tooltipPlacement, children: title || '' }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: setTooltipAnchor, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...props })] }));\n};\n\nconst CallParticipantListingItem = ({ participant, DisplayName = DefaultDisplayName, }) => {\n    const isAudioOn = participant.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const isVideoOn = participant.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const isPinned = !!participant.pin;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Avatar, { name: participant.name, imageSrc: participant.image }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DisplayName, { participant: participant }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item__media-indicator-group\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: isAudioOn ? t('Microphone on') : t('Microphone off'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isAudioOn ? 'mic' : 'mic-off'}`) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: isVideoOn ? t('Camera on') : t('Camera off'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isVideoOn ? 'camera' : 'camera-off'}`) }), isPinned && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: t('Pinned'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', 'str-video__participant-listing-item__icon-pinned') })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleButton$2, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantViewContext.Provider, { value: { participant, trackType: 'none' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantActionsContextMenu, {}) }) })] })] }));\n};\nconst MediaIndicator = (props) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(WithTooltip, { ...props }));\nconst DefaultDisplayName = ({ participant }) => {\n    const connectedUser = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const meFlag = participant.userId === connectedUser?.id ? t('Me') : '';\n    const nameOrId = participant.name || participant.userId || t('Unknown');\n    let displayName;\n    if (!participant.name) {\n        displayName = meFlag || nameOrId || t('Unknown');\n    }\n    else if (meFlag) {\n        displayName = `${nameOrId} (${meFlag})`;\n    }\n    else {\n        displayName = nameOrId;\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(WithTooltip, { className: \"str-video__participant-listing-item__display-name\", title: displayName, children: displayName }));\n};\nconst ToggleButton$2 = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"ellipsis\", ref: ref });\n});\n\nconst CallParticipantListing = ({ data, }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing\", children: data.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListingItem, { participant: participant }, participant.sessionId))) }));\n\nconst EmptyParticipantSearchList = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-list--empty\", children: t('No participants found') }));\n};\n\nconst SearchInput = ({ exitSearch, isActive, ...rest }) => {\n    const [inputElement, setInputElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!inputElement)\n            return;\n        const handleKeyDown = (e) => {\n            if (e.key.toLowerCase() === 'escape')\n                exitSearch();\n        };\n        inputElement.addEventListener('keydown', handleKeyDown);\n        return () => {\n            inputElement.removeEventListener('keydown', handleKeyDown);\n        };\n    }, [exitSearch, inputElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__search-input__container', {\n            'str-video__search-input__container--active': isActive,\n        }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", { placeholder: \"Search\", ...rest, ref: setInputElement }), isActive ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: \"str-video__search-input__clear-btn\", onClick: exitSearch, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__search-input__icon--active\" }) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__search-input__icon\" }))] }));\n};\n\nconst SearchResults = ({ EmptySearchResultComponent, LoadingIndicator: LoadingIndicator$1 = LoadingIndicator, searchQueryInProgress, searchResults, SearchResultList, }) => {\n    if (searchQueryInProgress) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__search-results--loading\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator$1, {}) }));\n    }\n    if (!searchResults.length) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EmptySearchResultComponent, {});\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResultList, { data: searchResults });\n};\n\nconst useSearch = ({ debounceInterval, searchFn, searchQuery = '', }) => {\n    const [searchResults, setSearchResults] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [searchQueryInProgress, setSearchQueryInProgress] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!searchQuery.length) {\n            setSearchQueryInProgress(false);\n            setSearchResults([]);\n            return;\n        }\n        setSearchQueryInProgress(true);\n        const timeout = setTimeout(async () => {\n            try {\n                const results = await searchFn(searchQuery);\n                setSearchResults(results);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            finally {\n                setSearchQueryInProgress(false);\n            }\n        }, debounceInterval);\n        return () => {\n            clearTimeout(timeout);\n        };\n    }, [debounceInterval, searchFn, searchQuery]);\n    return {\n        searchQueryInProgress,\n        searchResults,\n    };\n};\n\nconst UserListTypes = {\n    active: 'Active users',\n    blocked: 'Blocked users',\n};\nconst DEFAULT_DEBOUNCE_SEARCH_INTERVAL = 200;\nconst CallParticipantsList = ({ onClose, activeUsersSearchFn, blockedUsersSearchFn, debounceSearchInterval, }) => {\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('');\n    const [userListType, setUserListType] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('active');\n    const exitSearch = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => setSearchQuery(''), []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListHeader, { onClose: onClose }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchInput, { value: searchQuery, onChange: ({ currentTarget }) => setSearchQuery(currentTarget.value), exitSearch: exitSearch, isActive: !!searchQuery }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListContentHeader, { userListType: userListType, setUserListType: setUserListType }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list__content\", children: [userListType === 'active' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ActiveUsersSearchResults, { searchQuery: searchQuery, activeUsersSearchFn: activeUsersSearchFn, debounceSearchInterval: debounceSearchInterval })), userListType === 'blocked' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlockedUsersSearchResults, { searchQuery: searchQuery, blockedUsersSearchFn: blockedUsersSearchFn, debounceSearchInterval: debounceSearchInterval }))] })] }));\n};\nconst CallParticipantListContentHeader = ({ userListType, setUserListType, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const muteAll = () => {\n        call?.muteAllUsers('audio');\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list__content-header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-list__content-header-title\", children: userListType === 'active' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.MUTE_USERS], hasPermissionsOnly: true, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(TextButton, { onClick: muteAll, children: \"Mute all\" }) })) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleButton$1, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenu, { children: Object.keys(UserListTypes).map((lt) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { \"aria-selected\": lt === userListType, onClick: () => setUserListType(lt), children: UserListTypes[lt] }, lt))) }) })] }));\n};\nconst ActiveUsersSearchResults = ({ searchQuery, activeUsersSearchFn: activeUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, }) => {\n    const { useParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants({ sortBy: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.name });\n    const activeUsersSearchFn = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((queryString) => {\n        const queryRegExp = new RegExp(queryString, 'i');\n        return Promise.resolve(participants.filter((participant) => {\n            return participant.name.match(queryRegExp);\n        }));\n    }, [participants]);\n    const { searchQueryInProgress, searchResults } = useSearch({\n        searchFn: activeUsersSearchFnFromProps ?? activeUsersSearchFn,\n        debounceInterval: debounceSearchInterval,\n        searchQuery,\n    });\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : participants, SearchResultList: CallParticipantListing }));\n};\nconst BlockedUsersSearchResults = ({ blockedUsersSearchFn: blockedUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, searchQuery, }) => {\n    const { useCallBlockedUserIds } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const blockedUsers = useCallBlockedUserIds();\n    const blockedUsersSearchFn = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((queryString) => {\n        const queryRegExp = new RegExp(queryString, 'i');\n        return Promise.resolve(blockedUsers.filter((blockedUser) => {\n            return blockedUser.match(queryRegExp);\n        }));\n    }, [blockedUsers]);\n    const { searchQueryInProgress, searchResults } = useSearch({\n        searchFn: blockedUsersSearchFnFromProps ?? blockedUsersSearchFn,\n        debounceInterval: debounceSearchInterval,\n        searchQuery,\n    });\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : blockedUsers, SearchResultList: BlockedUserListing }));\n};\nconst ToggleButton$1 = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"filter\", ref: ref });\n});\n\nconst CallPreview = (props) => {\n    const { className, style } = props;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallThumbnail } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const thumbnail = useCallThumbnail();\n    const [imageRef, setImageRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!imageRef || !call)\n            return;\n        const cleanup = call.bindCallThumbnailElement(imageRef);\n        return () => cleanup();\n    }, [imageRef, call]);\n    if (!thumbnail)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-preview', className), style: style, alt: \"Call Preview Thumbnail\", ref: setImageRef }));\n};\n\nconst CallRecordingListHeader = ({ callRecordings, onRefresh, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__title\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { children: t('Call Recordings') }), callRecordings.length ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { children: [\"(\", callRecordings.length, \")\"] }) : null] }), onRefresh && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"refresh\", title: t('Refresh'), onClick: onRefresh }))] }));\n};\n\nconst dateFormat = (date) => {\n    const format = new Date(date);\n    return format.toTimeString().split(' ')[0];\n};\nconst CallRecordingListItem = ({ recording, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"li\", { className: \"str-video__call-recording-list__item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__filename\", children: recording.filename }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__time\", children: dateFormat(recording.start_time) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__time\", children: dateFormat(recording.end_time) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__download\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"a\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-recording-list-item__action-button', 'str-video__call-recording-list-item__action-button--download'), role: \"button\", href: recording.url, download: recording.filename, title: \"Download the recording\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"download\" }) }) })] }));\n};\n\nconst EmptyCallRecordingListing = () => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__listing str-video__call-recording-list__listing--empty\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__listing--icon-empty\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-recording-list__listing--text-empty\", children: \"No recordings available\" })] }));\n};\n\nconst LoadingCallRecordingListing = ({ callRecordings, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [callRecordings.map((recording) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListItem, { recording: recording }, recording.filename))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, { text: \"Recording getting ready\" })] }));\n};\n\nconst CallRecordingList = ({ callRecordings, CallRecordingListHeader: CallRecordingListHeader$1 = CallRecordingListHeader, CallRecordingListItem: CallRecordingListItem$1 = CallRecordingListItem, EmptyCallRecordingList = EmptyCallRecordingListing, loading, LoadingCallRecordingList = LoadingCallRecordingListing, onRefresh, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListHeader$1, { callRecordings: callRecordings, onRefresh: onRefresh }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__listing\", children: loading ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingCallRecordingList, { callRecordings: callRecordings })) : callRecordings.length ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__call-recording-list__list\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"li\", { className: \"str-video__call-recording-list__item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__filename\", children: \"Name\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__time\", children: \"Start time\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__time\", children: \"End time\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__download\" })] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__call-recording-list__list\", children: callRecordings.map((recording) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListItem$1, { recording: recording }, recording.filename))) })] })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EmptyCallRecordingList, {})) })] }));\n};\n\nconst RingingCallControls = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallCallingState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callCallingState = useCallCallingState();\n    if (!call)\n        return null;\n    const buttonsDisabled = callCallingState !== _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__pending-call-controls\", children: call.isCreatedByMe ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { disabled: buttonsDisabled })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(AcceptCallButton, { disabled: buttonsDisabled }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { onClick: () => call.leave({ reject: true }), disabled: buttonsDisabled })] })) }));\n};\n\nconst CALLING_STATE_TO_LABEL = {\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINING]: 'Joining',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING]: 'Ringing',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.MIGRATING]: 'Migrating',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RECONNECTING]: 'Re-connecting',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RECONNECTING_FAILED]: 'Failed',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.OFFLINE]: 'No internet connection',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.IDLE]: '',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.UNKNOWN]: '',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINED]: 'Joined',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.LEFT]: 'Left call',\n};\nconst RingingCall = (props) => {\n    const { includeSelf = false, totalMembersToShow = 3 } = props;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useCallCallingState, useCallMembers } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callingState = useCallCallingState();\n    const members = useCallMembers();\n    const connectedUser = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser)();\n    if (!call)\n        return null;\n    // take the first N members to show their avatars\n    const membersToShow = (members || [])\n        .slice(0, totalMembersToShow)\n        .map(({ user }) => user)\n        .filter((user) => user.id !== connectedUser?.id || includeSelf);\n    if (includeSelf &&\n        !membersToShow.find((user) => user.id === connectedUser?.id)) {\n        // if the current user is not in the initial batch of members,\n        // replace the first item in membersToShow array with the current user\n        const self = members.find(({ user }) => user.id === connectedUser?.id);\n        if (self) {\n            membersToShow.splice(0, 1, self.user);\n        }\n    }\n    const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-panel str-video__call-panel--ringing\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-panel__members-list\", children: membersToShow.map((user) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-panel__member-box\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Avatar, { name: user.name, imageSrc: user.image }), user.name && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__member_details\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__member_name\", children: user.name }) }))] }, user.id))) }), callingStateLabel && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-panel__calling-state-label\", children: t(callingStateLabel) })), [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING, _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINING].includes(callingState) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RingingCallControls, {}))] }));\n};\n\nconst byNameOrId = (a, b) => {\n    if (a.name && b.name && a.name < b.name)\n        return -1;\n    if (a.name && b.name && a.name > b.name)\n        return 1;\n    if (a.id < b.id)\n        return -1;\n    if (a.id > b.id)\n        return 1;\n    return 0;\n};\nconst PermissionRequests = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useLocalParticipant, useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const localParticipant = useLocalParticipant();\n    const [expanded, setExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [permissionRequests, setPermissionRequests] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const canUpdateCallPermissions = useHasPermissions(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.UPDATE_CALL_PERMISSIONS);\n    const localUserId = localParticipant?.userId;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !canUpdateCallPermissions)\n            return;\n        return call.on('call.permission_request', (event) => {\n            if (event.user.id !== localUserId) {\n                setPermissionRequests((requests) => [...requests, event].sort((a, b) => byNameOrId(a.user, b.user)));\n            }\n        });\n    }, [call, canUpdateCallPermissions, localUserId]);\n    const handleUpdatePermission = (request, type) => {\n        return async () => {\n            const { user, permissions } = request;\n            switch (type) {\n                case 'grant':\n                    await call?.grantPermissions(user.id, permissions);\n                    break;\n                case 'revoke':\n                    await call?.revokePermissions(user.id, permissions);\n                    break;\n            }\n            setPermissionRequests((requests) => requests.filter((r) => r !== request));\n        };\n    };\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement: 'bottom',\n        strategy: 'absolute',\n    });\n    // don't render anything if there are no permission requests\n    if (permissionRequests.length === 0)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-requests\", ref: refs.setReference, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-requests__notification\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__permission-requests__notification__message\", children: [permissionRequests.length, \" pending permission requests\"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { type: \"button\", onClick: () => {\n                            setExpanded((e) => !e);\n                        }, children: expanded ? 'Hide requests' : 'Show requests' })] }), expanded && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionRequestList, { ref: refs.setFloating, style: {\n                    position: strategy,\n                    top: y ?? 0,\n                    left: x ?? 0,\n                    overflowY: 'auto',\n                }, permissionRequests: permissionRequests, handleUpdatePermission: handleUpdatePermission }))] }));\n};\nconst PermissionRequestList = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function PermissionRequestList(props, ref) {\n    const { permissionRequests, handleUpdatePermission, ...rest } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__permission-requests-list\", ref: ref, ...rest, children: permissionRequests.map((request, reqIndex) => {\n            const { user, permissions } = request;\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: permissions.map((permission) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-request\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__permission-request__message\", children: messageForPermission(user.name || user.id, permission, t) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--allow\", type: \"button\", onClick: handleUpdatePermission(request, 'grant'), children: t('Allow') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--reject\", type: \"button\", onClick: handleUpdatePermission(request, 'revoke'), children: t('Revoke') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--reject\", type: \"button\", onClick: handleUpdatePermission(request, 'dismiss'), children: t('Dismiss') })] }, permission))) }, `${user.id}/${reqIndex}`));\n        }) }));\n});\nconst Button = (props) => {\n    const { className, ...rest } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__permission-request__button', className), ...rest }));\n};\nconst messageForPermission = (userName, permission, t) => {\n    switch (permission) {\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO:\n            return t('{{ userName }} is requesting to speak', { userName });\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO:\n            return t('{{ userName }} is requesting to share their camera', {\n                userName,\n            });\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE:\n            return t('{{ userName }} is requesting to present their screen', {\n                userName,\n            });\n        default:\n            return t('{{ userName }} is requesting permission: {{ permission }}', {\n                userName,\n                permission,\n            });\n    }\n};\n\nconst StreamTheme = ({ as: Component = 'div', className, children, ...props }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Component, { ...props, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video', className), children: children }));\n};\n\nconst DefaultVideoPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function DefaultVideoPlaceholder({ participant, style }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const name = participant.name || participant.userId;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__video-placeholder\", style: style, ref: ref, children: [(!participant.image || error) &&\n                (name ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(InitialsFallback, { name: name })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__video-placeholder__no-video-label\", children: t('Video is disabled') }))), participant.image && !error && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { onError: () => setError(true), alt: \"video-placeholder\", className: \"str-video__video-placeholder__avatar\", src: participant.image }))] }));\n});\nconst InitialsFallback = (props) => {\n    const { name } = props;\n    const initials = name\n        .split(' ')\n        .slice(0, 2)\n        .map((n) => n[0])\n        .join('');\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__video-placeholder__initials-fallback\", children: initials }));\n};\n\nconst Video$1 = ({ trackType, participant, className, VideoPlaceholder = DefaultVideoPlaceholder, refs, ...rest }) => {\n    const { sessionId, videoStream, screenShareStream, publishedTracks, viewportVisibilityState, isLocalParticipant, userId, } = participant;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [videoElement, setVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    // start with true, will flip once the video starts playing\n    const [isVideoPaused, setIsVideoPaused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);\n    const [isWideMode, setIsWideMode] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);\n    const stream = trackType === 'videoTrack'\n        ? videoStream\n        : trackType === 'screenShareTrack'\n            ? screenShareStream\n            : undefined;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(() => {\n        if (!call || !videoElement || trackType === 'none')\n            return;\n        const cleanup = call.bindVideoElement(videoElement, sessionId, trackType);\n        return () => {\n            cleanup?.();\n        };\n    }, [call, trackType, sessionId, videoElement]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!stream || !videoElement)\n            return;\n        const [track] = stream.getVideoTracks();\n        if (!track)\n            return;\n        const handlePlayPause = () => {\n            setIsVideoPaused(videoElement.paused);\n            const { width = 0, height = 0 } = track.getSettings();\n            setIsWideMode(width >= height);\n        };\n        // playback may have started before we had a chance to\n        // attach the 'play/pause' event listener, so we set the state\n        // here to make sure it's in sync\n        setIsVideoPaused(videoElement.paused);\n        videoElement.addEventListener('play', handlePlayPause);\n        videoElement.addEventListener('pause', handlePlayPause);\n        track.addEventListener('unmute', handlePlayPause);\n        return () => {\n            videoElement.removeEventListener('play', handlePlayPause);\n            videoElement.removeEventListener('pause', handlePlayPause);\n            track.removeEventListener('unmute', handlePlayPause);\n            // reset the 'pause' state once we unmount the video element\n            setIsVideoPaused(true);\n        };\n    }, [stream, videoElement]);\n    if (!call)\n        return null;\n    const isPublishingTrack = trackType === 'videoTrack'\n        ? publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO)\n        : trackType === 'screenShareTrack'\n            ? publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE)\n            : false;\n    const isInvisible = trackType === 'none' ||\n        viewportVisibilityState?.[trackType] === _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VisibilityState.INVISIBLE;\n    const hasNoVideoOrInvisible = !isPublishingTrack || isInvisible;\n    const mirrorVideo = isLocalParticipant && trackType === 'videoTrack';\n    const isScreenShareTrack = trackType === 'screenShareTrack';\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [!hasNoVideoOrInvisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"video\", { ...rest, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video', className, {\n                    'str-video__video--not-playing': isVideoPaused,\n                    'str-video__video--tall': !isWideMode,\n                    'str-video__video--mirror': mirrorVideo,\n                    'str-video__video--screen-share': isScreenShareTrack,\n                }), \"data-user-id\": userId, \"data-session-id\": sessionId, ref: (element) => {\n                    setVideoElement(element);\n                    refs?.setVideoElement?.(element);\n                } })), (hasNoVideoOrInvisible || isVideoPaused) && VideoPlaceholder && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VideoPlaceholder, { style: { position: 'absolute' }, participant: participant, ref: refs?.setVideoPlaceholderElement }))] }));\n};\n\n/**\n * @description Extends video element with `stream` property\n * (`srcObject`) to reactively handle stream changes\n */\nconst BaseVideo = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function BaseVideo({ stream, ...rest }, ref) {\n    const [videoElement, setVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!videoElement || !stream)\n            return;\n        if (stream === videoElement.srcObject)\n            return;\n        videoElement.srcObject = stream;\n        if (_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers.isSafari() || _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers.isFirefox()) {\n            // Firefox and Safari have some timing issue\n            setTimeout(() => {\n                videoElement.srcObject = stream;\n                videoElement.play().catch((e) => {\n                    console.error(`Failed to play stream`, e);\n                });\n            }, 0);\n        }\n        return () => {\n            videoElement.pause();\n            videoElement.srcObject = null;\n        };\n    }, [stream, videoElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"video\", { autoPlay: true, playsInline: true, ...rest, ref: (element) => {\n            applyElementToRef(ref, element);\n            setVideoElement(element);\n        } }));\n});\n\nconst DefaultDisabledVideoPreview = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str_video__video-preview__disabled-video-preview\", children: t('Video is disabled') }));\n};\nconst DefaultNoCameraPreview = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str_video__video-preview__no-camera-preview\", children: t('No camera found') }));\n};\nconst VideoPreview = ({ className, mirror = true, DisabledVideoPreview = DefaultDisabledVideoPreview, NoCameraPreview = DefaultNoCameraPreview, StartingCameraPreview = LoadingIndicator, }) => {\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { devices, status, isMute, mediaStream } = useCameraState();\n    let contents;\n    if (isMute && devices?.length === 0) {\n        contents = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(NoCameraPreview, {});\n    }\n    else if (status === 'enabled') {\n        const loading = !mediaStream;\n        contents = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [mediaStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BaseVideo, { stream: mediaStream, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video-preview', {\n                        'str-video__video-preview--mirror': mirror,\n                        'str-video__video-preview--loading': loading,\n                    }) })), loading && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StartingCameraPreview, {})] }));\n    }\n    else {\n        contents = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DisabledVideoPreview, {});\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video-preview-container', className), children: contents }));\n};\n\nconst ParticipantActionsContextMenu = () => {\n    const { participant, participantViewElement, videoElement } = useParticipantViewContext();\n    const [fullscreenModeOn, setFullscreenModeOn] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!!document.fullscreenElement);\n    const [pictureInPictureElement, setPictureInPictureElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(document.pictureInPictureElement);\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { pin, publishedTracks, sessionId, userId } = participant;\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const hasScreenShare = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n    const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n    const blockUser = () => call?.blockUser(userId);\n    const muteAudio = () => call?.muteUser(userId, 'audio');\n    const muteVideo = () => call?.muteUser(userId, 'video');\n    const muteScreenShare = () => call?.muteUser(userId, 'screenshare');\n    const muteScreenShareAudio = () => call?.muteUser(userId, 'screenshare_audio');\n    const grantPermission = (permission) => () => {\n        call?.updateUserPermissions({\n            user_id: userId,\n            grant_permissions: [permission],\n        });\n    };\n    const revokePermission = (permission) => () => {\n        call?.updateUserPermissions({\n            user_id: userId,\n            revoke_permissions: [permission],\n        });\n    };\n    const toggleParticipantPin = () => {\n        if (pin) {\n            call?.unpin(sessionId);\n        }\n        else {\n            call?.pin(sessionId);\n        }\n    };\n    const pinForEveryone = () => {\n        call\n            ?.pinForEveryone({\n            user_id: userId,\n            session_id: sessionId,\n        })\n            .catch((err) => {\n            console.error(`Failed to pin participant ${userId}`, err);\n        });\n    };\n    const unpinForEveryone = () => {\n        call\n            ?.unpinForEveryone({\n            user_id: userId,\n            session_id: sessionId,\n        })\n            .catch((err) => {\n            console.error(`Failed to unpin participant ${userId}`, err);\n        });\n    };\n    const toggleFullscreenMode = () => {\n        if (!fullscreenModeOn) {\n            return participantViewElement?.requestFullscreen().catch(console.error);\n        }\n        return document.exitFullscreen().catch(console.error);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        // handles the case when fullscreen mode is toggled externally,\n        // e.g., by pressing ESC key or some other keyboard shortcut\n        const handleFullscreenChange = () => {\n            setFullscreenModeOn(!!document.fullscreenElement);\n        };\n        document.addEventListener('fullscreenchange', handleFullscreenChange);\n        return () => {\n            document.removeEventListener('fullscreenchange', handleFullscreenChange);\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!videoElement)\n            return;\n        const handlePiP = () => {\n            setPictureInPictureElement(document.pictureInPictureElement);\n        };\n        videoElement.addEventListener('enterpictureinpicture', handlePiP);\n        videoElement.addEventListener('leavepictureinpicture', handlePiP);\n        return () => {\n            videoElement.removeEventListener('enterpictureinpicture', handlePiP);\n            videoElement.removeEventListener('leavepictureinpicture', handlePiP);\n        };\n    }, [videoElement]);\n    const togglePictureInPicture = () => {\n        if (videoElement && pictureInPictureElement !== videoElement) {\n            return videoElement\n                .requestPictureInPicture()\n                .catch(console.error);\n        }\n        return document.exitPictureInPicture().catch(console.error);\n    };\n    const { close } = useMenuContext() || {};\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenu, { onItemClick: close, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: toggleParticipantPin, disabled: pin && !pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), pin ? t('Unpin') : t('Pin')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.PIN_FOR_EVERYONE], children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: pinForEveryone, disabled: pin && !pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), t('Pin for everyone')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: unpinForEveryone, disabled: !pin || pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), t('Unpin for everyone')] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.BLOCK_USERS], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: blockUser, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"not-allowed\" }), t('Block')] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.MUTE_USERS], children: [hasVideo && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteVideo, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"camera-off-outline\" }), t('Turn off video')] })), hasScreenShare && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShare, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"screen-share-off\" }), t('Turn off screen share')] })), hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteAudio, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"no-audio\" }), t('Mute audio')] })), hasScreenShareAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShareAudio, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"no-audio\" }), t('Mute screen share audio')] }))] }), participantViewElement && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: toggleFullscreenMode, children: t('{{ direction }} fullscreen', {\n                    direction: fullscreenModeOn ? t('Leave') : t('Enter'),\n                }) })), videoElement && document.pictureInPictureEnabled && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: togglePictureInPicture, children: t('{{ direction }} picture-in-picture', {\n                    direction: pictureInPictureElement === videoElement\n                        ? t('Leave')\n                        : t('Enter'),\n                }) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.UPDATE_CALL_PERMISSIONS], children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO), children: t('Allow audio') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO), children: t('Allow video') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE), children: t('Allow screen sharing') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO), children: t('Disable audio') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO), children: t('Disable video') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE), children: t('Disable screen sharing') })] })] }));\n};\n\nconst useTrackElementVisibility = ({ trackedElement, dynascaleManager: propsDynascaleManager, sessionId, trackType, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const manager = propsDynascaleManager ?? call?.dynascaleManager;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!trackedElement || !manager || !call || trackType === 'none')\n            return;\n        const unobserve = manager.trackElementVisibility(trackedElement, sessionId, trackType);\n        return () => {\n            unobserve();\n        };\n    }, [trackedElement, manager, call, sessionId, trackType]);\n};\n\nconst ToggleButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"ellipsis\", ref: ref });\n});\nconst DefaultScreenShareOverlay = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const stopScreenShare = () => {\n        call?.screenShare.disable();\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__screen-share-overlay\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"screen-share-off\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__screen-share-overlay__title\", children: t('You are presenting your screen') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { onClick: stopScreenShare, className: \"str-video__screen-share-overlay__button\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"close\" }), \" \", t('Stop Screen Sharing')] })] }));\n};\nconst DefaultParticipantViewUI = ({ indicatorsVisible = true, menuPlacement = 'bottom-start', showMenuButton = true, ParticipantActionsContextMenu: ParticipantActionsContextMenu$1 = ParticipantActionsContextMenu, }) => {\n    const { participant, trackType } = useParticipantViewContext();\n    const { publishedTracks } = participant;\n    const hasScreenShare = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n    if (participant.isLocalParticipant &&\n        hasScreenShare &&\n        trackType === 'screenShareTrack') {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultScreenShareOverlay, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [showMenuButton && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { strategy: \"fixed\", placement: menuPlacement, ToggleButton: ToggleButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantActionsContextMenu$1, {}) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Reaction, { participant: participant }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));\n};\nconst ParticipantDetails = ({ indicatorsVisible = true, }) => {\n    const { participant } = useParticipantViewContext();\n    const { isLocalParticipant, connectionQuality, publishedTracks, pin, sessionId, name, userId, } = participant;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const connectionQualityAsString = !!connectionQuality &&\n        _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.ConnectionQuality[connectionQuality].toLowerCase();\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const canUnpin = !!pin && pin.isLocalPin;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-details\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__participant-details__name\", children: [name || userId, indicatorsVisible && !hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-details__name--audio-muted\" })), indicatorsVisible && !hasVideo && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-details__name--video-muted\" })), indicatorsVisible && canUnpin && (\n                        // TODO: remove this monstrosity once we have a proper design\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { title: t('Unpin'), onClick: () => call?.unpin(sessionId), className: \"str-video__participant-details__name--pinned\" })), indicatorsVisible && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SpeechIndicator, {})] }) }), indicatorsVisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: isLocalParticipant &&\n                    connectionQuality === _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.ConnectionQuality.POOR, message: t('Poor connection quality'), children: connectionQualityAsString && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-details__connection-quality', `str-video__participant-details__connection-quality--${connectionQualityAsString}`), title: connectionQualityAsString })) }))] }));\n};\nconst SpeechIndicator = () => {\n    const { participant } = useParticipantViewContext();\n    const { isSpeaking, isDominantSpeaker } = participant;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__speech-indicator', isSpeaking && 'str-video__speech-indicator--speaking', isDominantSpeaker && 'str-video__speech-indicator--dominant'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" })] }));\n};\n\nconst ParticipantView = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ParticipantView({ participant, trackType = 'videoTrack', muteAudio, refs: { setVideoElement, setVideoPlaceholderElement } = {}, className, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, }, ref) {\n    const { isLocalParticipant, isSpeaking, isDominantSpeaker, publishedTracks, sessionId, } = participant;\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n    const [trackedElement, setTrackedElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [contextVideoElement, setContextVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [contextVideoPlaceholderElement, setContextVideoPlaceholderElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    // TODO: allow to pass custom ViewportTracker instance from props\n    useTrackElementVisibility({\n        sessionId,\n        trackedElement,\n        trackType,\n    });\n    const participantViewContextValue = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        participant,\n        participantViewElement: trackedElement,\n        videoElement: contextVideoElement,\n        videoPlaceholderElement: contextVideoPlaceholderElement,\n        trackType,\n    }), [\n        contextVideoElement,\n        contextVideoPlaceholderElement,\n        participant,\n        trackedElement,\n        trackType,\n    ]);\n    const videoRefs = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        setVideoElement: (element) => {\n            setVideoElement?.(element);\n            setContextVideoElement(element);\n        },\n        setVideoPlaceholderElement: (element) => {\n            setVideoPlaceholderElement?.(element);\n            setContextVideoPlaceholderElement(element);\n        },\n    }), [setVideoElement, setVideoPlaceholderElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { \"data-testid\": \"participant-view\", ref: (element) => {\n            applyElementToRef(ref, element);\n            setTrackedElement(element);\n        }, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-view', isDominantSpeaker && 'str-video__participant-view--dominant-speaker', isSpeaking && 'str-video__participant-view--speaking', !hasVideo && 'str-video__participant-view--no-video', !hasAudio && 'str-video__participant-view--no-audio', className), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(ParticipantViewContext.Provider, { value: participantViewContextValue, children: [!isLocalParticipant && !muteAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { participant: participant, trackType: \"audioTrack\" })), hasScreenShareAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { participant: participant, trackType: \"screenShareAudioTrack\" }))] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Video$1, { VideoPlaceholder: VideoPlaceholder, participant: participant, trackType: trackType, refs: videoRefs, autoPlay: true }), isComponentType(ParticipantViewUI) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantViewUI, {})) : (ParticipantViewUI)] }) }));\n});\n\n// re-exporting the StreamCallProvider as StreamCall\nconst StreamCall = _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamCallProvider;\n\nvar Joining = \"Joining\";\nvar Mic = \"Mic\";\nvar Ringing = \"Ringing\";\nvar Speakers = \"Speakers\";\nvar Video = \"Video\";\nvar Live = \"Live\";\nvar Reactions = \"Reactions\";\nvar Statistics = \"Statistics\";\nvar Invite = \"Invite\";\nvar Join = \"Join\";\nvar You = \"You\";\nvar Me = \"Me\";\nvar Unknown = \"Unknown\";\nvar Refresh = \"Refresh\";\nvar Allow = \"Allow\";\nvar Revoke = \"Revoke\";\nvar Dismiss = \"Dismiss\";\nvar Pinned = \"Pinned\";\nvar Unpin = \"Unpin\";\nvar Pin = \"Pin\";\nvar Block = \"Block\";\nvar Enter = \"Enter\";\nvar Leave = \"Leave\";\nvar Participants = \"Participants\";\nvar Anonymous = \", and ({{ count }}) anonymous\";\nvar en = {\n\tJoining: Joining,\n\tMic: Mic,\n\t\"No internet connection\": \"No internet connection\",\n\t\"Re-connecting\": \"Re-connecting\",\n\tRinging: Ringing,\n\t\"Screen Share\": \"Screen Share\",\n\t\"Select a Camera\": \"Select a Camera\",\n\t\"Select a Mic\": \"Select a Mic\",\n\t\"Select Speakers\": \"Select Speakers\",\n\tSpeakers: Speakers,\n\tVideo: Video,\n\t\"You are muted. Unmute to speak.\": \"You are muted. Unmute to speak.\",\n\tLive: Live,\n\t\"You can now speak.\": \"You can now speak.\",\n\t\"Awaiting for an approval to speak.\": \"Awaiting for an approval to speak.\",\n\t\"You can no longer speak.\": \"You can no longer speak.\",\n\t\"You can now share your video.\": \"You can now share your video.\",\n\t\"Awaiting for an approval to share your video.\": \"Awaiting for an approval to share your video.\",\n\t\"You can no longer share your video.\": \"You can no longer share your video.\",\n\t\"Waiting for recording to stop...\": \"Waiting for recording to stop...\",\n\t\"Waiting for recording to start...\": \"Waiting for recording to start...\",\n\t\"Record call\": \"Record call\",\n\tReactions: Reactions,\n\tStatistics: Statistics,\n\t\"You can now share your screen.\": \"You can now share your screen.\",\n\t\"Awaiting for an approval to share screen.\": \"Awaiting for an approval to share screen.\",\n\t\"You can no longer share your screen.\": \"You can no longer share your screen.\",\n\t\"Share screen\": \"Share screen\",\n\t\"Incoming Call...\": \"Incoming Call...\",\n\t\"Calling...\": \"Calling...\",\n\t\"Mute All\": \"Mute All\",\n\tInvite: Invite,\n\tJoin: Join,\n\tYou: You,\n\tMe: Me,\n\tUnknown: Unknown,\n\t\"Toggle device menu\": \"Toggle device menu\",\n\t\"Call Recordings\": \"Call Recordings\",\n\tRefresh: Refresh,\n\t\"Check your browser video permissions\": \"Check your browser video permissions\",\n\t\"Video publishing is disabled by the system\": \"Video publishing is disabled by the system\",\n\t\"You have no permission to share your video\": \"You have no permission to share your video\",\n\t\"You have no permission to share your audio\": \"You have no permission to share your audio\",\n\t\"You are presenting your screen\": \"You are presenting your screen\",\n\t\"Stop Screen Sharing\": \"Stop Screen Sharing\",\n\tAllow: Allow,\n\tRevoke: Revoke,\n\tDismiss: Dismiss,\n\t\"Microphone on\": \"Microphone on\",\n\t\"Microphone off\": \"Microphone off\",\n\t\"Camera on\": \"Camera on\",\n\t\"Camera off\": \"Camera off\",\n\t\"No camera found\": \"No camera found\",\n\t\"Video is disabled\": \"Video is disabled\",\n\tPinned: Pinned,\n\tUnpin: Unpin,\n\tPin: Pin,\n\t\"Pin for everyone\": \"Pin for everyone\",\n\t\"Unpin for everyone\": \"Unpin for everyone\",\n\tBlock: Block,\n\t\"Turn off video\": \"Turn off video\",\n\t\"Turn off screen share\": \"Turn off screen share\",\n\t\"Mute audio\": \"Mute audio\",\n\t\"Mute screen share audio\": \"Mute screen share audio\",\n\t\"Allow audio\": \"Allow audio\",\n\t\"Allow video\": \"Allow video\",\n\t\"Allow screen sharing\": \"Allow screen sharing\",\n\t\"Disable audio\": \"Disable audio\",\n\t\"Disable video\": \"Disable video\",\n\t\"Disable screen sharing\": \"Disable screen sharing\",\n\tEnter: Enter,\n\tLeave: Leave,\n\t\"Leave call\": \"Leave call\",\n\t\"End call for all\": \"End call for all\",\n\t\"{{ direction }} fullscreen\": \"{{ direction }} fullscreen\",\n\t\"{{ direction }} picture-in-picture\": \"{{ direction }} picture-in-picture\",\n\t\"Dominant Speaker\": \"Dominant Speaker\",\n\t\"Poor connection quality\": \"Poor connection quality. Please check your internet connection.\",\n\tParticipants: Participants,\n\tAnonymous: Anonymous,\n\t\"No participants found\": \"No participants found\",\n\t\"Participants ({{ numberOfParticipants }})\": \"Participants ({{ numberOfParticipants }})\",\n\t\"{{ userName }} is sharing their screen\": \"{{ userName }} is sharing their screen\",\n\t\"{{ userName }} is requesting to speak\": \"{{ userName }} is requesting to speak\",\n\t\"{{ userName }} is requesting to share their camera\": \"{{ userName }} is requesting to share their camera\",\n\t\"{{ userName }} is requesting to present their screen\": \"{{ userName }} is requesting to present their screen\",\n\t\"{{ userName }} is requesting permission: {{ permission }}\": \"{{ userName }} is requesting permission: {{ permission }}\"\n};\n\nconst translations = { en };\n\nconst StreamVideo = (props) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamVideoProvider, { translationsOverrides: translations, ...props }));\n};\n\nconst usePaginatedLayoutSortPreset = (call) => {\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call)\n            return;\n        call.setSortParticipantsBy(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.paginatedLayoutSortPreset);\n        return () => {\n            resetSortPreset(call);\n        };\n    }, [call]);\n};\nconst useSpeakerLayoutSortPreset = (call, isOneOnOneCall) => {\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call)\n            return;\n        // always show the remote participant in the spotlight\n        if (isOneOnOneCall) {\n            call.setSortParticipantsBy((0,_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.combineComparators)(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.screenSharing, loggedIn));\n        }\n        else {\n            call.setSortParticipantsBy(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speakerLayoutSortPreset);\n        }\n        return () => {\n            resetSortPreset(call);\n        };\n    }, [call, isOneOnOneCall]);\n};\nconst resetSortPreset = (call) => {\n    // reset the sorting to the default for the call type\n    const callConfig = _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallTypes.get(call.type);\n    call.setSortParticipantsBy(callConfig.options.sortParticipantsBy || _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.defaultSortPreset);\n};\nconst loggedIn = (a, b) => {\n    if (a.isLocalParticipant)\n        return 1;\n    if (b.isLocalParticipant)\n        return -1;\n    return 0;\n};\n\nconst LivestreamLayout = (props) => {\n    const { useParticipants, useRemoteParticipants, useHasOngoingScreenShare } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [currentSpeaker, ...otherParticipants] = useParticipants();\n    const remoteParticipants = useRemoteParticipants();\n    const hasOngoingScreenShare = useHasOngoingScreenShare();\n    const presenter = hasOngoingScreenShare\n        ? hasScreenShare$1(currentSpeaker) && currentSpeaker\n        : otherParticipants.find(hasScreenShare$1);\n    usePaginatedLayoutSortPreset(call);\n    const Overlay = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantOverlay, { showParticipantCount: props.showParticipantCount, showDuration: props.showDuration, showLiveBadge: props.showLiveBadge, showSpeakerName: props.showSpeakerName }));\n    const { floatingParticipantProps } = props;\n    const FloatingParticipantOverlay = hasOngoingScreenShare && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantOverlay\n    // these elements aren't needed for the video feed\n    , { \n        // these elements aren't needed for the video feed\n        showParticipantCount: floatingParticipantProps?.showParticipantCount ?? false, showDuration: floatingParticipantProps?.showDuration ?? false, showLiveBadge: floatingParticipantProps?.showLiveBadge ?? false, showSpeakerName: floatingParticipantProps?.showSpeakerName ?? true }));\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__livestream-layout__wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), hasOngoingScreenShare && presenter && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { className: \"str-video__livestream-layout__screen-share\", participant: presenter, ParticipantViewUI: Overlay, trackType: \"screenShareTrack\", muteAudio // audio is rendered by ParticipantsAudio\n                : true })), currentSpeaker && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(hasOngoingScreenShare &&\n                    (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__livestream-layout__floating-participant', `str-video__livestream-layout__floating-participant--${floatingParticipantProps?.position ?? 'top-right'}`)), participant: currentSpeaker, ParticipantViewUI: FloatingParticipantOverlay || Overlay, muteAudio // audio is rendered by ParticipantsAudio\n                : true }))] }));\n};\nconst hasScreenShare$1 = (p) => !!p?.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\nconst ParticipantOverlay = (props) => {\n    const { enableFullScreen = true, showParticipantCount = true, showDuration = true, showLiveBadge = true, showSpeakerName = false, } = props;\n    const { participant } = useParticipantViewContext();\n    const { useParticipantCount } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participantCount = useParticipantCount();\n    const duration = useUpdateCallDuration();\n    const toggleFullScreen = useToggleFullScreen();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__livestream-layout__overlay\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__livestream-layout__overlay__bar\", children: [showLiveBadge && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__live-badge\", children: t('Live') })), showParticipantCount && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__viewers-count\", children: participantCount })), showSpeakerName && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__speaker-name\", title: participant.name || participant.userId || '', children: participant.name || participant.userId || '' })), showDuration && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__duration\", children: formatDuration(duration) })), enableFullScreen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__go-fullscreen\", onClick: toggleFullScreen }))] }) }));\n};\nconst useUpdateCallDuration = () => {\n    const { useIsCallLive, useCallSession } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isCallLive = useIsCallLive();\n    const session = useCallSession();\n    const [duration, setDuration] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => {\n        if (!session || !session.live_started_at)\n            return 0;\n        const liveStartTime = new Date(session.live_started_at);\n        const now = new Date();\n        return Math.floor((now.getTime() - liveStartTime.getTime()) / 1000);\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!isCallLive)\n            return;\n        const interval = setInterval(() => {\n            setDuration((d) => d + 1);\n        }, 1000);\n        return () => {\n            clearInterval(interval);\n        };\n    }, [isCallLive]);\n    return duration;\n};\nconst useToggleFullScreen = () => {\n    const { participantViewElement } = useParticipantViewContext();\n    const [isFullscreen, setIsFullscreen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n        if (isFullscreen) {\n            document.exitFullscreen().then(() => {\n                setIsFullscreen(false);\n            });\n        }\n        else {\n            participantViewElement?.requestFullscreen().then(() => {\n                setIsFullscreen(true);\n            });\n        }\n    }, [isFullscreen, participantViewElement]);\n};\nconst formatDuration = (durationInMs) => {\n    const days = Math.floor(durationInMs / 86400);\n    const hours = Math.floor(durationInMs / 3600);\n    const minutes = Math.floor((durationInMs % 3600) / 60);\n    const seconds = durationInMs % 60;\n    return `${days ? days + ' ' : ''}${hours ? hours + ':' : ''}${minutes < 10 ? '0' : ''}${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\n\nconst GROUP_SIZE = 16;\nconst PaginatedGridLayoutGroup = ({ group, VideoPlaceholder, ParticipantViewUI, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__paginated-grid-layout__group', {\n            'str-video__paginated-grid-layout--one': group.length === 1,\n            'str-video__paginated-grid-layout--two-four': group.length >= 2 && group.length <= 4,\n            'str-video__paginated-grid-layout--five-nine': group.length >= 5 && group.length <= 9,\n        }), children: group.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participant, muteAudio: true, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }, participant.sessionId))) }));\n};\nconst PaginatedGridLayout = ({ groupSize = GROUP_SIZE, excludeLocalParticipant = false, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, }) => {\n    const [page, setPage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(0);\n    const [paginatedGridLayoutWrapperElement, setPaginatedGridLayoutWrapperElement,] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useParticipants, useRemoteParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants();\n    // used to render audio elements\n    const remoteParticipants = useRemoteParticipants();\n    usePaginatedLayoutSortPreset(call);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!paginatedGridLayoutWrapperElement || !call)\n            return;\n        const cleanup = call.setViewport(paginatedGridLayoutWrapperElement);\n        return () => cleanup();\n    }, [paginatedGridLayoutWrapperElement, call]);\n    // only used to render video elements\n    const participantGroups = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => chunk(excludeLocalParticipant ? remoteParticipants : participants, groupSize), [excludeLocalParticipant, remoteParticipants, participants, groupSize]);\n    const pageCount = participantGroups.length;\n    // update page when page count is reduced and selected page no longer exists\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (page > pageCount - 1) {\n            setPage(Math.max(0, pageCount - 1));\n        }\n    }, [page, pageCount]);\n    const selectedGroup = participantGroups[page];\n    if (!call)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__paginated-grid-layout__wrapper\", ref: setPaginatedGridLayoutWrapperElement, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__paginated-grid-layout\", children: [pageArrowsVisible && pageCount > 1 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"caret-left\", disabled: page === 0, onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)) })), selectedGroup && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PaginatedGridLayoutGroup, { group: participantGroups[page], VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI })), pageArrowsVisible && pageCount > 1 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: page === pageCount - 1, icon: \"caret-right\", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)) }))] })] }));\n};\n\nconst useCalculateHardLimit = (\n/**\n * Element that stretches to 100% of the whole layout component\n */\nwrapperElement, \n/**\n * Element that directly hosts individual `ParticipantView` (or wrapper) elements\n */\nhostElement, limit) => {\n    const [calculatedLimit, setCalculatedLimit] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        vertical: typeof limit === 'number' ? limit : null,\n        horizontal: typeof limit === 'number' ? limit : null,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!hostElement ||\n            !wrapperElement ||\n            typeof limit === 'number' ||\n            typeof limit === 'undefined')\n            return;\n        let childWidth = null;\n        let childHeight = null;\n        const resizeObserver = new ResizeObserver((entries, observer) => {\n            // this part should ideally run as little times as possible\n            // get child measurements and disconnect\n            // does not consider dynamically sized children\n            // this hook is for SpeakerLayout use only, where children in the bar are fixed size\n            if (entries.length > 1) {\n                const child = hostElement.firstChild;\n                if (child) {\n                    childHeight = child.clientHeight;\n                    childWidth = child.clientWidth;\n                    observer.unobserve(hostElement);\n                }\n            }\n            // keep the state at { vertical: 1, horizontal: 1 }\n            // until we get the proper child measurements\n            if (childHeight === null || childWidth === null)\n                return;\n            const vertical = Math.floor(wrapperElement.clientHeight / childHeight);\n            const horizontal = Math.floor(wrapperElement.clientWidth / childWidth);\n            setCalculatedLimit((pv) => {\n                if (pv.vertical !== vertical || pv.horizontal !== horizontal)\n                    return { vertical, horizontal };\n                return pv;\n            });\n        });\n        resizeObserver.observe(wrapperElement);\n        resizeObserver.observe(hostElement);\n        return () => {\n            resizeObserver.disconnect();\n        };\n    }, [hostElement, limit, wrapperElement]);\n    return calculatedLimit;\n};\n\nconst DefaultParticipantViewUIBar = () => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultParticipantViewUI, { menuPlacement: \"top-end\" }));\nconst DefaultParticipantViewUISpotlight = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultParticipantViewUI, {});\nconst SpeakerLayout = ({ ParticipantViewUIBar = DefaultParticipantViewUIBar, ParticipantViewUISpotlight = DefaultParticipantViewUISpotlight, VideoPlaceholder, participantsBarPosition = 'bottom', participantsBarLimit, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useParticipants, useRemoteParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const [participantInSpotlight, ...otherParticipants] = useParticipants();\n    const remoteParticipants = useRemoteParticipants();\n    const [participantsBarWrapperElement, setParticipantsBarWrapperElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [participantsBarElement, setParticipantsBarElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [buttonsWrapperElement, setButtonsWrapperElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const isSpeakerScreenSharing = hasScreenShare(participantInSpotlight);\n    const hardLimit = useCalculateHardLimit(buttonsWrapperElement, participantsBarElement, participantsBarLimit);\n    const isVertical = participantsBarPosition === 'left' || participantsBarPosition === 'right';\n    const isHorizontal = participantsBarPosition === 'top' || participantsBarPosition === 'bottom';\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!participantsBarWrapperElement || !call)\n            return;\n        const cleanup = call.setViewport(participantsBarWrapperElement);\n        return () => cleanup();\n    }, [participantsBarWrapperElement, call]);\n    const isOneOnOneCall = otherParticipants.length === 1;\n    useSpeakerLayoutSortPreset(call, isOneOnOneCall);\n    let participantsWithAppliedLimit = otherParticipants;\n    const hardLimitToApply = isVertical\n        ? hardLimit.vertical\n        : hardLimit.horizontal;\n    if (typeof participantsBarLimit !== 'undefined' &&\n        hardLimitToApply !== null) {\n        participantsWithAppliedLimit = otherParticipants.slice(0, \n        // subtract 1 if speaker is sharing screen as\n        // that one is rendered independently from otherParticipants array\n        hardLimitToApply - (isSpeakerScreenSharing ? 1 : 0));\n    }\n    if (!call)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__speaker-layout__wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__speaker-layout', participantsBarPosition &&\n                    `str-video__speaker-layout--variant-${participantsBarPosition}`), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__spotlight\", children: participantInSpotlight && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participantInSpotlight, muteAudio: true, trackType: isSpeakerScreenSharing ? 'screenShareTrack' : 'videoTrack', ParticipantViewUI: ParticipantViewUISpotlight, VideoPlaceholder: VideoPlaceholder })) }), participantsWithAppliedLimit.length > 0 && participantsBarPosition && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: setButtonsWrapperElement, className: \"str-video__speaker-layout__participants-bar-buttons-wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participants-bar-wrapper\", ref: setParticipantsBarWrapperElement, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: setParticipantsBarElement, className: \"str-video__speaker-layout__participants-bar\", children: [isSpeakerScreenSharing && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participant-tile\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participantInSpotlight, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, muteAudio: true }) }, participantInSpotlight.sessionId)), participantsWithAppliedLimit.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participant-tile\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participant, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, muteAudio: true }) }, participant.sessionId)))] }) }), isVertical && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VerticalScrollButtons, { scrollWrapper: participantsBarWrapperElement })), isHorizontal && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(HorizontalScrollButtons, { scrollWrapper: participantsBarWrapperElement }))] }))] })] }));\n};\nconst HorizontalScrollButtons = ({ scrollWrapper, }) => {\n    const scrollPosition = useHorizontalScrollPosition(scrollWrapper);\n    const scrollStartClickHandler = () => {\n        scrollWrapper?.scrollBy({ left: -150, behavior: 'smooth' });\n    };\n    const scrollEndClickHandler = () => {\n        scrollWrapper?.scrollBy({ left: 150, behavior: 'smooth' });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [scrollPosition && scrollPosition !== 'start' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollStartClickHandler, icon: \"caret-left\", className: \"str-video__speaker-layout__participants-bar--button-left\" })), scrollPosition && scrollPosition !== 'end' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollEndClickHandler, icon: \"caret-right\", className: \"str-video__speaker-layout__participants-bar--button-right\" }))] }));\n};\nconst VerticalScrollButtons = ({ scrollWrapper, }) => {\n    const scrollPosition = useVerticalScrollPosition(scrollWrapper);\n    const scrollTopClickHandler = () => {\n        scrollWrapper?.scrollBy({ top: -150, behavior: 'smooth' });\n    };\n    const scrollBottomClickHandler = () => {\n        scrollWrapper?.scrollBy({ top: 150, behavior: 'smooth' });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [scrollPosition && scrollPosition !== 'top' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollTopClickHandler, icon: \"caret-up\", className: \"str-video__speaker-layout__participants-bar--button-top\" })), scrollPosition && scrollPosition !== 'bottom' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollBottomClickHandler, icon: \"caret-down\", className: \"str-video__speaker-layout__participants-bar--button-bottom\" }))] }));\n};\nconst hasScreenShare = (p) => !!p?.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n\nconst [major, minor, patch] = (\"0.5.12\" ).split('.');\n(0,_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setSdkInfo)({\n    type: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.SdkType.REACT,\n    major,\n    minor,\n    patch,\n});\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtUDtBQUMzTTtBQUNxSDtBQUM3RztBQUNRO0FBQ2tIO0FBQ2xKO0FBQ3VFO0FBQ3NLO0FBQzdLO0FBQ2pEOztBQUV2QyxpQkFBaUIsZ0RBQWdEO0FBQ2pFLGlCQUFpQix3RUFBTztBQUN4Qiw0Q0FBNEMsK0NBQVE7QUFDcEQsWUFBWSxvQkFBb0I7QUFDaEMsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHNEQUFHLFlBQVksbUlBQW1JO0FBQzlKOztBQUVBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkMsWUFBWSxzREFBRyxDQUFDLHVEQUFRLElBQUk7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixtRUFBbUU7QUFDdkYsc0RBQXNELDhEQUFTO0FBQy9ELGtFQUFrRSxzREFBRyxVQUFVLGtFQUFrRTtBQUNqSixpRUFBaUUsOERBQVM7QUFDMUU7QUFDQSwyQ0FBMkMsc0RBQUcsVUFBVSw2RUFBNkU7QUFDckksb0JBQW9CLHVEQUFJLENBQUMsMkNBQVUsSUFBSSw2REFBNkQ7QUFDcEcsU0FBUyxHQUFHO0FBQ1o7O0FBRUEsK0JBQStCLG9EQUFhO0FBQzVDLHdDQUF3QyxpREFBVTs7QUFFbEQsa0JBQWtCLDJDQUEyQztBQUM3RCw4QkFBOEIsK0NBQVE7QUFDdEMsWUFBWSx1REFBSSxDQUFDLHVEQUFRLElB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QTtBQUNBLENBQUM7O0FBRTR1RDtBQUM3dUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95b29tLy4vbm9kZV9tb2R1bGVzL0BzdHJlYW0taW8vdmlkZW8tcmVhY3Qtc2RrL2Rpc3QvaW5kZXguZXMuanM/Mjk2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZnVNb2RlbHMsIENhbGxpbmdTdGF0ZSwgT3duQ2FwYWJpbGl0eSwgbmFtZSwgVmlzaWJpbGl0eVN0YXRlLCBCcm93c2VycywgcGFnaW5hdGVkTGF5b3V0U29ydFByZXNldCwgY29tYmluZUNvbXBhcmF0b3JzLCBzY3JlZW5TaGFyaW5nLCBzcGVha2VyTGF5b3V0U29ydFByZXNldCwgQ2FsbFR5cGVzLCBkZWZhdWx0U29ydFByZXNldCwgc2V0U2RrSW5mbyB9IGZyb20gJ0BzdHJlYW0taW8vdmlkZW8tY2xpZW50JztcbmV4cG9ydCAqIGZyb20gJ0BzdHJlYW0taW8vdmlkZW8tY2xpZW50JztcbmltcG9ydCB7IHVzZUNhbGwsIHVzZUNhbGxTdGF0ZUhvb2tzLCB1c2VJMThuLCBSZXN0cmljdGVkLCB1c2VDb25uZWN0ZWRVc2VyLCBTdHJlYW1DYWxsUHJvdmlkZXIsIFN0cmVhbVZpZGVvUHJvdmlkZXIgfSBmcm9tICdAc3RyZWFtLWlvL3ZpZGVvLXJlYWN0LWJpbmRpbmdzJztcbmV4cG9ydCAqIGZyb20gJ0BzdHJlYW0taW8vdmlkZW8tcmVhY3QtYmluZGluZ3MnO1xuaW1wb3J0IHsganN4LCBGcmFnbWVudCwganN4cyB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIEZyYWdtZW50IGFzIEZyYWdtZW50JDEsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZU1lbW8sIGZvcndhcmRSZWYsIGlzVmFsaWRFbGVtZW50LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IGlzUGxhdGZvcm1TdXBwb3J0ZWQsIGxvYWRURkxpdGUsIGNyZWF0ZVJlbmRlcmVyIH0gZnJvbSAnQHN0cmVhbS1pby92aWRlby1maWx0ZXJzLXdlYic7XG5pbXBvcnQgeyB1c2VGbG9hdGluZywgb2Zmc2V0LCBzaGlmdCwgZmxpcCwgc2l6ZSwgYXV0b1VwZGF0ZSwgRmxvYXRpbmdPdmVybGF5LCBGbG9hdGluZ1BvcnRhbCwgdXNlTGlzdEl0ZW0sIHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VUeXBlYWhlYWQsIHVzZUNsaWNrLCB1c2VEaXNtaXNzLCB1c2VSb2xlLCB1c2VJbnRlcmFjdGlvbnMsIEZsb2F0aW5nRm9jdXNNYW5hZ2VyLCBGbG9hdGluZ0xpc3QsIHVzZUhvdmVyIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0JztcbmltcG9ydCB7IENoYXJ0LCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCB9IGZyb20gJ2NoYXJ0LmpzJztcbmltcG9ydCB7IExpbmUgfSBmcm9tICdyZWFjdC1jaGFydGpzLTInO1xuXG5jb25zdCBBdWRpbyA9ICh7IHBhcnRpY2lwYW50LCB0cmFja1R5cGUgPSAnYXVkaW9UcmFjaycsIC4uLnJlc3QgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgW2F1ZGlvRWxlbWVudCwgc2V0QXVkaW9FbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgdXNlcklkLCBzZXNzaW9uSWQgfSA9IHBhcnRpY2lwYW50O1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FsbCB8fCAhYXVkaW9FbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gY2FsbC5iaW5kQXVkaW9FbGVtZW50KGF1ZGlvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW51cD8uKCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbGwsIHNlc3Npb25JZCwgYXVkaW9FbGVtZW50LCB0cmFja1R5cGVdKTtcbiAgICByZXR1cm4gKGpzeChcImF1ZGlvXCIsIHsgYXV0b1BsYXk6IHRydWUsIC4uLnJlc3QsIHJlZjogc2V0QXVkaW9FbGVtZW50LCBcImRhdGEtdXNlci1pZFwiOiB1c2VySWQsIFwiZGF0YS1zZXNzaW9uLWlkXCI6IHNlc3Npb25JZCwgXCJkYXRhLXRyYWNrLXR5cGVcIjogdHJhY2tUeXBlIH0pKTtcbn07XG5cbmNvbnN0IFBhcnRpY2lwYW50c0F1ZGlvID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBwYXJ0aWNpcGFudHMsIGF1ZGlvUHJvcHMgfSA9IHByb3BzO1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBwYXJ0aWNpcGFudHMubWFwKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcnRpY2lwYW50LmlzTG9jYWxQYXJ0aWNpcGFudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsgcHVibGlzaGVkVHJhY2tzLCBhdWRpb1N0cmVhbSwgc2NyZWVuU2hhcmVBdWRpb1N0cmVhbSwgc2Vzc2lvbklkLCB9ID0gcGFydGljaXBhbnQ7XG4gICAgICAgICAgICBjb25zdCBoYXNBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLkFVRElPKTtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tFbGVtZW50ID0gaGFzQXVkaW8gJiYgYXVkaW9TdHJlYW0gJiYgKGpzeChBdWRpbywgeyAuLi5hdWRpb1Byb3BzLCB0cmFja1R5cGU6IFwiYXVkaW9UcmFja1wiLCBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQgfSkpO1xuICAgICAgICAgICAgY29uc3QgaGFzU2NyZWVuU2hhcmVBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTyk7XG4gICAgICAgICAgICBjb25zdCBzY3JlZW5TaGFyZUF1ZGlvVHJhY2tFbGVtZW50ID0gaGFzU2NyZWVuU2hhcmVBdWRpbyAmJlxuICAgICAgICAgICAgICAgIHNjcmVlblNoYXJlQXVkaW9TdHJlYW0gJiYgKGpzeChBdWRpbywgeyAuLi5hdWRpb1Byb3BzLCB0cmFja1R5cGU6IFwic2NyZWVuU2hhcmVBdWRpb1RyYWNrXCIsIHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCB9KSk7XG4gICAgICAgICAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQkMSwgeyBjaGlsZHJlbjogW2F1ZGlvVHJhY2tFbGVtZW50LCBzY3JlZW5TaGFyZUF1ZGlvVHJhY2tFbGVtZW50XSB9LCBzZXNzaW9uSWQpKTtcbiAgICAgICAgfSkgfSkpO1xufTtcblxuY29uc3QgUGFydGljaXBhbnRWaWV3Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbmNvbnN0IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQgPSAoKSA9PiB1c2VDb250ZXh0KFBhcnRpY2lwYW50Vmlld0NvbnRleHQpO1xuXG5jb25zdCBBdmF0YXIgPSAoeyBpbWFnZVNyYywgbmFtZSwgc3R5bGUsIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSA9PiB7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKCFpbWFnZVNyYyB8fCBlcnJvcikgJiYgbmFtZSAmJiAoanN4KEF2YXRhckZhbGxiYWNrLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZTogc3R5bGUsIG5hbWVzOiBbbmFtZV0gfSkpLCBpbWFnZVNyYyAmJiAhZXJyb3IgJiYgKGpzeChcImltZ1wiLCB7IG9uRXJyb3I6ICgpID0+IHNldEVycm9yKHRydWUpLCBhbHQ6IFwiYXZhdGFyXCIsIGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19hdmF0YXInLCBjbGFzc05hbWUpLCBzcmM6IGltYWdlU3JjLCBzdHlsZTogc3R5bGUsIC4uLnJlc3QgfSkpXSB9KSk7XG59O1xuY29uc3QgQXZhdGFyRmFsbGJhY2sgPSAoeyBjbGFzc05hbWUsIG5hbWVzLCBzdHlsZSwgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2F2YXRhci0taW5pdGlhbHMtZmFsbGJhY2snLCBjbGFzc05hbWUpLCBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIHsgY2hpbGRyZW46IFtuYW1lc1swXVswXSwgbmFtZXNbMV0/LlswXV0gfSkgfSkpO1xufTtcblxuLyoqXG4gKiBUaGUgY29udGV4dCBmb3IgdGhlIGJhY2tncm91bmQgZmlsdGVycy5cbiAqL1xuY29uc3QgQmFja2dyb3VuZEZpbHRlcnNDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuLyoqXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSBiYWNrZ3JvdW5kIGZpbHRlcnMgY29udGV4dCBBUEkuXG4gKi9cbmNvbnN0IHVzZUJhY2tncm91bmRGaWx0ZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEJhY2tncm91bmRGaWx0ZXJzQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlQmFja2dyb3VuZEZpbHRlcnMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJhY2tncm91bmRGaWx0ZXJzUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59O1xuLyoqXG4gKiBBIHByb3ZpZGVyIGNvbXBvbmVudCB0aGF0IGVuYWJsZXMgdGhlIHVzZSBvZiBiYWNrZ3JvdW5kIGZpbHRlcnMgaW4geW91ciBhcHAuXG4gKlxuICogUGxlYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgYEBzdHJlYW0taW8vdmlkZW8tZmlsdGVycy13ZWJgIHBhY2thZ2UgaW5zdGFsbGVkXG4gKiBpbiB5b3VyIHByb2plY3QgYmVmb3JlIHVzaW5nIHRoaXMgY29tcG9uZW50LlxuICovXG5jb25zdCBCYWNrZ3JvdW5kRmlsdGVyc1Byb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaXNCbHVycmluZ0VuYWJsZWQgPSB0cnVlLCBiYWNrZ3JvdW5kSW1hZ2VzID0gW10sIGJhY2tncm91bmRGaWx0ZXI6IGJnRmlsdGVyRnJvbVByb3BzID0gdW5kZWZpbmVkLCBiYWNrZ3JvdW5kSW1hZ2U6IGJnSW1hZ2VGcm9tUHJvcHMgPSB1bmRlZmluZWQsIGJhY2tncm91bmRCbHVyTGV2ZWw6IGJnQmx1ckxldmVsRnJvbVByb3BzID0gJ2hpZ2gnLCB0ZkZpbGVQYXRoLCBtb2RlbEZpbGVQYXRoLCBiYXNlUGF0aCwgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtiYWNrZ3JvdW5kRmlsdGVyLCBzZXRCYWNrZ3JvdW5kRmlsdGVyXSA9IHVzZVN0YXRlKGJnRmlsdGVyRnJvbVByb3BzKTtcbiAgICBjb25zdCBbYmFja2dyb3VuZEltYWdlLCBzZXRCYWNrZ3JvdW5kSW1hZ2VdID0gdXNlU3RhdGUoYmdJbWFnZUZyb21Qcm9wcyk7XG4gICAgY29uc3QgW2JhY2tncm91bmRCbHVyTGV2ZWwsIHNldEJhY2tncm91bmRCbHVyTGV2ZWxdID0gdXNlU3RhdGUoYmdCbHVyTGV2ZWxGcm9tUHJvcHMpO1xuICAgIGNvbnN0IGFwcGx5QmFja2dyb3VuZEltYWdlRmlsdGVyID0gdXNlQ2FsbGJhY2soKGltYWdlVXJsKSA9PiB7XG4gICAgICAgIHNldEJhY2tncm91bmRGaWx0ZXIoJ2ltYWdlJyk7XG4gICAgICAgIHNldEJhY2tncm91bmRJbWFnZShpbWFnZVVybCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGFwcGx5QmFja2dyb3VuZEJsdXJGaWx0ZXIgPSB1c2VDYWxsYmFjaygoYmx1ckxldmVsID0gJ2hpZ2gnKSA9PiB7XG4gICAgICAgIHNldEJhY2tncm91bmRGaWx0ZXIoJ2JsdXInKTtcbiAgICAgICAgc2V0QmFja2dyb3VuZEJsdXJMZXZlbChibHVyTGV2ZWwpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBkaXNhYmxlQmFja2dyb3VuZEZpbHRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0QmFja2dyb3VuZEZpbHRlcih1bmRlZmluZWQpO1xuICAgICAgICBzZXRCYWNrZ3JvdW5kSW1hZ2UodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0QmFja2dyb3VuZEJsdXJMZXZlbCgnaGlnaCcpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBbaXNTdXBwb3J0ZWQsIHNldElzU3VwcG9ydGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc1BsYXRmb3JtU3VwcG9ydGVkKCkudGhlbihzZXRJc1N1cHBvcnRlZCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IFt0ZkxpdGUsIHNldFRmTGl0ZV0gPSB1c2VTdGF0ZSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIGRvbid0IHRyeSB0byBsb2FkIFRGTGl0ZSBpZiB0aGUgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICBpZiAoIWlzU3VwcG9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2FkVEZMaXRlKHsgYmFzZVBhdGgsIG1vZGVsRmlsZVBhdGgsIHRmRmlsZVBhdGggfSlcbiAgICAgICAgICAgIC50aGVuKHNldFRmTGl0ZSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBURkxpdGUnLCBlcnIpKTtcbiAgICB9LCBbYmFzZVBhdGgsIGlzU3VwcG9ydGVkLCBtb2RlbEZpbGVQYXRoLCB0ZkZpbGVQYXRoXSk7XG4gICAgcmV0dXJuIChqc3hzKEJhY2tncm91bmRGaWx0ZXJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZToge1xuICAgICAgICAgICAgaXNTdXBwb3J0ZWQsXG4gICAgICAgICAgICBpc1JlYWR5OiAhIXRmTGl0ZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRCbHVyTGV2ZWwsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmlsdGVyLFxuICAgICAgICAgICAgZGlzYWJsZUJhY2tncm91bmRGaWx0ZXIsXG4gICAgICAgICAgICBhcHBseUJhY2tncm91bmRCbHVyRmlsdGVyLFxuICAgICAgICAgICAgYXBwbHlCYWNrZ3JvdW5kSW1hZ2VGaWx0ZXIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VzLFxuICAgICAgICAgICAgaXNCbHVycmluZ0VuYWJsZWQsXG4gICAgICAgICAgICB0ZkZpbGVQYXRoLFxuICAgICAgICAgICAgbW9kZWxGaWxlUGF0aCxcbiAgICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICB9LCBjaGlsZHJlbjogW2NoaWxkcmVuLCB0ZkxpdGUgJiYgYmFja2dyb3VuZEZpbHRlciAmJiBqc3goQmFja2dyb3VuZEZpbHRlcnMsIHsgdGZMaXRlOiB0ZkxpdGUgfSldIH0pKTtcbn07XG5jb25zdCBCYWNrZ3JvdW5kRmlsdGVycyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdGZMaXRlIH0gPSBwcm9wcztcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgYmFja2dyb3VuZEltYWdlLCBiYWNrZ3JvdW5kRmlsdGVyIH0gPSB1c2VCYWNrZ3JvdW5kRmlsdGVycygpO1xuICAgIGNvbnN0IFt2aWRlb1JlZiwgc2V0VmlkZW9SZWZdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2JnSW1hZ2VSZWYsIHNldEJnSW1hZ2VSZWZdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2NhbnZhc1JlZiwgc2V0Q2FudmFzUmVmXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFt3aWR0aCwgc2V0V2lkdGhdID0gdXNlU3RhdGUoMTkyMCk7XG4gICAgY29uc3QgW2hlaWdodCwgc2V0SGVpZ2h0XSA9IHVzZVN0YXRlKDEwODApO1xuICAgIGNvbnN0IHJlc29sdmVGaWx0ZXJSZWYgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBbbWVkaWFTdHJlYW0sIHNldE1lZGlhU3RyZWFtXSA9IHVzZVN0YXRlKCk7XG4gICAgY29uc3QgcmVnaXN0ZXJGaWx0ZXJSZWYgPSB1c2VSZWYoUHJvbWlzZS5yZXNvbHZlKGFzeW5jICgpID0+IHsgfSkpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FsbCB8fCAhYmFja2dyb3VuZEZpbHRlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVnaXN0ZXJGaWx0ZXJSZWYuY3VycmVudCA9IHJlZ2lzdGVyRmlsdGVyUmVmLmN1cnJlbnQudGhlbigoKSA9PiBjYWxsLmNhbWVyYS5yZWdpc3RlckZpbHRlcihhc3luYyAobXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNldE1lZGlhU3RyZWFtKG1zKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlRmlsdGVyUmVmLmN1cnJlbnQgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyRmlsdGVyUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAudGhlbigodW5yZWdpc3RlcikgPT4gdW5yZWdpc3RlcigpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHNldE1lZGlhU3RyZWFtKHVuZGVmaW5lZCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1bnJlZ2lzdGVyIGZpbHRlcicsIGVycikpO1xuICAgICAgICB9O1xuICAgIH0sIFtiYWNrZ3JvdW5kRmlsdGVyLCBjYWxsXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtZWRpYVN0cmVhbSB8fCAhdmlkZW9SZWYgfHwgIWNhbnZhc1JlZilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlT25QbGF5ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3RyYWNrXSA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoOiB3ID0gMCwgaGVpZ2h0OiBoID0gMCB9ID0gdHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBzZXRXaWR0aCh3KTtcbiAgICAgICAgICAgICAgICBzZXRIZWlnaHQoaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlRmlsdGVyID0gcmVzb2x2ZUZpbHRlclJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlRmlsdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGNhbnZhc1JlZi5jYXB0dXJlU3RyZWFtKCk7XG4gICAgICAgICAgICByZXNvbHZlRmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH07XG4gICAgICAgIHZpZGVvUmVmLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBoYW5kbGVPblBsYXkpO1xuICAgICAgICB2aWRlb1JlZi5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICAgICAgdmlkZW9SZWYucGxheSgpLmNhdGNoKChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwbGF5IHZpZGVvJywgZXJyKSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlb1JlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5JywgaGFuZGxlT25QbGF5KTtcbiAgICAgICAgICAgIHZpZGVvUmVmLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbnZhc1JlZiwgbWVkaWFTdHJlYW0sIHZpZGVvUmVmXSk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fYmFja2dyb3VuZC1maWx0ZXJzXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxuICAgICAgICB9LCBjaGlsZHJlbjogW21lZGlhU3RyZWFtICYmIChqc3goUmVuZGVyUGlwZWxpbmUsIHsgdGZMaXRlOiB0ZkxpdGUsIHZpZGVvUmVmOiB2aWRlb1JlZiwgY2FudmFzUmVmOiBjYW52YXNSZWYsIGJhY2tncm91bmRJbWFnZVJlZjogYmdJbWFnZVJlZiB9KSksIGpzeChcInZpZGVvXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2JhY2tncm91bmQtZmlsdGVyc19fdmlkZW8nLCBoZWlnaHQgPiB3aWR0aCAmJiAnc3RyLXZpZGVvX19iYWNrZ3JvdW5kLWZpbHRlcnNfX3ZpZGVvLS10YWxsJyksIHJlZjogc2V0VmlkZW9SZWYsIGF1dG9QbGF5OiB0cnVlLCBwbGF5c0lubGluZTogdHJ1ZSwgY29udHJvbHM6IGZhbHNlLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBtdXRlZDogdHJ1ZSwgbG9vcDogdHJ1ZSB9KSwgYmFja2dyb3VuZEltYWdlICYmIChqc3goXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19iYWNrZ3JvdW5kLWZpbHRlcnNfX2JhY2tncm91bmQtaW1hZ2VcIiwgYWx0OiBcIkJhY2tncm91bmRcIiwgcmVmOiBzZXRCZ0ltYWdlUmVmLCBzcmM6IGJhY2tncm91bmRJbWFnZSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9LCBiYWNrZ3JvdW5kSW1hZ2UpKSwganN4KFwiY2FudmFzXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fYmFja2dyb3VuZC1maWx0ZXJzX190YXJnZXQtY2FudmFzXCIsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHJlZjogc2V0Q2FudmFzUmVmIH0sIGBrZXktJHt3aWR0aH0ke2hlaWdodH1gKV0gfSkpO1xufTtcbmNvbnN0IFJlbmRlclBpcGVsaW5lID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB0ZkxpdGUsIHZpZGVvUmVmLCBjYW52YXNSZWYsIGJhY2tncm91bmRJbWFnZVJlZiB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBiYWNrZ3JvdW5kRmlsdGVyLCBiYWNrZ3JvdW5kQmx1ckxldmVsIH0gPSB1c2VCYWNrZ3JvdW5kRmlsdGVycygpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdmlkZW9SZWYgfHwgIWNhbnZhc1JlZiB8fCAhYmFja2dyb3VuZEZpbHRlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGJhY2tncm91bmRGaWx0ZXIgPT09ICdpbWFnZScgJiYgIWJhY2tncm91bmRJbWFnZVJlZilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlcih0ZkxpdGUsIHZpZGVvUmVmLCBjYW52YXNSZWYsIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRGaWx0ZXIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGJhY2tncm91bmRJbWFnZVJlZiA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQmx1ckxldmVsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGJhY2tncm91bmRCbHVyTGV2ZWwsXG4gICAgICAgIGJhY2tncm91bmRGaWx0ZXIsXG4gICAgICAgIGJhY2tncm91bmRJbWFnZVJlZixcbiAgICAgICAgY2FudmFzUmVmLFxuICAgICAgICB0ZkxpdGUsXG4gICAgICAgIHZpZGVvUmVmLFxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgdXNlRmxvYXRpbmdVSVByZXNldCA9ICh7IHBsYWNlbWVudCwgc3RyYXRlZ3ksIG9mZnNldDogb2Zmc2V0SW5QeCA9IDEwLCB9KSA9PiB7XG4gICAgY29uc3QgeyByZWZzLCB4LCB5LCB1cGRhdGUsIGVsZW1lbnRzOiB7IGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcgfSwgfSA9IHVzZUZsb2F0aW5nKHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgbWlkZGxld2FyZTogW1xuICAgICAgICAgICAgb2Zmc2V0KG9mZnNldEluUHgpLFxuICAgICAgICAgICAgc2hpZnQoKSxcbiAgICAgICAgICAgIGZsaXAoKSxcbiAgICAgICAgICAgIHNpemUoe1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgICAgICAgICAgIGFwcGx5OiAoeyBhdmFpbGFibGVIZWlnaHQsIGVsZW1lbnRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50cy5mbG9hdGluZy5zdHlsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBgJHthdmFpbGFibGVIZWlnaHR9cHhgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgfSk7XG4gICAgLy8gaGFuZGxlIHdpbmRvdyByZXNpemluZ1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZG9tUmVmZXJlbmNlIHx8ICFmbG9hdGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGF1dG9VcGRhdGUoZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFudXAoKTtcbiAgICB9LCBbZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlXSk7XG4gICAgcmV0dXJuIHsgcmVmcywgeCwgeSwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgc3RyYXRlZ3kgfTtcbn07XG5cbi8qKlxuICogVGhpcyBob29rIHdpbGwgcGVyc2lzdCB0aGUgZGV2aWNlIHNldHRpbmdzIHRvIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZSBmb3IgbG9jYWwgc3RvcmFnZS5cbiAqL1xuY29uc3QgdXNlUGVyc2lzdERldmljZVByZWZlcmVuY2VzID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlTWljcm9waG9uZVN0YXRlLCB1c2VDYW1lcmFTdGF0ZSwgdXNlU3BlYWtlclN0YXRlLCB1c2VDYWxsU2V0dGluZ3MsIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgbWljID0gdXNlTWljcm9waG9uZVN0YXRlKCk7XG4gICAgY29uc3QgY2FtZXJhID0gdXNlQ2FtZXJhU3RhdGUoKTtcbiAgICBjb25zdCBzcGVha2VyID0gdXNlU3BlYWtlclN0YXRlKCk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB1c2VDYWxsU2V0dGluZ3MoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbGwgfHwgIXNldHRpbmdzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoY2FsbC5zdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5MRUZUKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGFzUHJlZmVyZW5jZXMgPSAhIXdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgY29uc3QgeyBhdWRpbywgdmlkZW8gfSA9IHNldHRpbmdzO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdERldmljZSA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIGNvbnN0IHByZWZlcmVuY2VzID0ge1xuICAgICAgICAgICAgICAgIG1pYzoge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZERldmljZUlkOiBtaWMuc2VsZWN0ZWREZXZpY2UgfHwgZGVmYXVsdERldmljZSxcbiAgICAgICAgICAgICAgICAgICAgbXV0ZWQ6IGhhc1ByZWZlcmVuY2VzID8gbWljLmlzTXV0ZSA6ICFhdWRpby5taWNfZGVmYXVsdF9vbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbWVyYToge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZERldmljZUlkOiBjYW1lcmEuc2VsZWN0ZWREZXZpY2UgfHwgZGVmYXVsdERldmljZSxcbiAgICAgICAgICAgICAgICAgICAgbXV0ZWQ6IGhhc1ByZWZlcmVuY2VzID8gY2FtZXJhLmlzTXV0ZSA6ICF2aWRlby5jYW1lcmFfZGVmYXVsdF9vbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNwZWFrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWREZXZpY2VJZDogc3BlYWtlci5zZWxlY3RlZERldmljZSB8fCBkZWZhdWx0RGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICBtdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShwcmVmZXJlbmNlcykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgZGV2aWNlIHByZWZlcmVuY2VzJywgZXJyKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgY2FsbCxcbiAgICAgICAgY2FtZXJhLmlzTXV0ZSxcbiAgICAgICAgY2FtZXJhLnNlbGVjdGVkRGV2aWNlLFxuICAgICAgICBrZXksXG4gICAgICAgIG1pYy5pc011dGUsXG4gICAgICAgIG1pYy5zZWxlY3RlZERldmljZSxcbiAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgIHNwZWFrZXIuc2VsZWN0ZWREZXZpY2UsXG4gICAgXSk7XG59O1xuLyoqXG4gKiBUaGlzIGhvb2sgd2lsbCBhcHBseSB0aGUgZGV2aWNlIHNldHRpbmdzIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGZvciBsb2NhbCBzdG9yYWdlLlxuICovXG5jb25zdCB1c2VBcHBseURldmljZVByZWZlcmVuY2VzID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyB1c2VDYWxsU2V0dGluZ3MgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB1c2VDYWxsU2V0dGluZ3MoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbGwgfHwgIXNldHRpbmdzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhcHBseSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRNaWMgPSBhc3luYyAoc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubWljcm9waG9uZS5zZWxlY3Qoc2V0dGluZy5zZWxlY3RlZERldmljZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy5tdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLm1pY3JvcGhvbmUuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FsbC5taWNyb3Bob25lLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBpbml0Q2FtZXJhID0gYXN5bmMgKHNldHRpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLmNhbWVyYS5zZWxlY3Qoc2V0dGluZy5zZWxlY3RlZERldmljZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZy5tdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLmNhbWVyYS5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLmNhbWVyYS5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaW5pdFNwZWFrZXIgPSAoc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGwuc3BlYWtlci5zZWxlY3Qoc2V0dGluZy5zZWxlY3RlZERldmljZUlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcHJlZmVyZW5jZXMgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcmVmZXJlbmNlcyA9IEpTT04ucGFyc2Uod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgZGV2aWNlIHByZWZlcmVuY2VzJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGluaXRNaWMocHJlZmVyZW5jZXMubWljKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBpbml0Q2FtZXJhKHByZWZlcmVuY2VzLmNhbWVyYSk7XG4gICAgICAgICAgICAgICAgaW5pdFNwZWFrZXIocHJlZmVyZW5jZXMuc3BlYWtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1ZGlvLCB2aWRlbyB9ID0gc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvLm1pY19kZWZhdWx0X29uKVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLm1pY3JvcGhvbmUuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvLmNhbWVyYV9kZWZhdWx0X29uKVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLmNhbWVyYS5lbmFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYXBwbHkoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBhcHBseSBkZXZpY2UgcHJlZmVyZW5jZXMnLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBbY2FsbCwga2V5LCBzZXR0aW5nc10pO1xufTtcbi8qKlxuICogVGhpcyBob29rIHdpbGwgYXBwbHkgYW5kIHBlcnNpc3QgdGhlIGRldmljZSBwcmVmZXJlbmNlcyBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHVzZSBmb3IgbG9jYWwgc3RvcmFnZS5cbiAqL1xuY29uc3QgdXNlUGVyc2lzdGVkRGV2aWNlUHJlZmVyZW5jZXMgPSAoa2V5ID0gJ0BzdHJlYW0taW8vZGV2aWNlLXByZWZlcmVuY2VzJykgPT4ge1xuICAgIHVzZUFwcGx5RGV2aWNlUHJlZmVyZW5jZXMoa2V5KTtcbiAgICB1c2VQZXJzaXN0RGV2aWNlUHJlZmVyZW5jZXMoa2V5KTtcbn07XG5cbmNvbnN0IFNDUk9MTF9USFJFU0hPTEQgPSAxMDtcbi8qKlxuICogSG9vayB3aGljaCBvYnNlcnZlcyBlbGVtZW50J3Mgc2Nyb2xsIHBvc2l0aW9uIGFuZCByZXR1cm5zIHRleHQgdmFsdWUgYmFzZWQgb24gdGhlXG4gKiBwb3NpdGlvbiBvZiB0aGUgc2Nyb2xsYmFyIChgdG9wYCwgYGJvdHRvbWAsIGBiZXR3ZWVuYCBhbmQgYG51bGxgIGlmIG5vIHNjcm9sbGJhciBpcyBhdmFpbGFibGUpXG4gKi9cbmNvbnN0IHVzZVZlcnRpY2FsU2Nyb2xsUG9zaXRpb24gPSAoc2Nyb2xsRWxlbWVudCwgdGhyZXNob2xkID0gU0NST0xMX1RIUkVTSE9MRCkgPT4ge1xuICAgIGNvbnN0IFtzY3JvbGxQb3NpdGlvbiwgc2V0U2Nyb2xsUG9zaXRpb25dID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFzY3JvbGxFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY3JvbGxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBoYXNWZXJ0aWNhbFNjcm9sbGJhciA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIWhhc1ZlcnRpY2FsU2Nyb2xsYmFyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRTY3JvbGxQb3NpdGlvbihudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQXRUaGVUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCA8PSB0aHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAoaXNBdFRoZVRvcClcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0U2Nyb2xsUG9zaXRpb24oJ3RvcCcpO1xuICAgICAgICAgICAgY29uc3QgaXNBdFRoZUJvdHRvbSA9IE1hdGguYWJzKGVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gZWxlbWVudC5zY3JvbGxUb3AgLSBlbGVtZW50LmNsaWVudEhlaWdodCkgPD0gdGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKGlzQXRUaGVCb3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFNjcm9sbFBvc2l0aW9uKCdib3R0b20nKTtcbiAgICAgICAgICAgIHNldFNjcm9sbFBvc2l0aW9uKCdiZXR3ZWVuJyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHNjcm9sbEVsZW1lbnQpO1xuICAgICAgICBzY3JvbGxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbc2Nyb2xsRWxlbWVudCwgdGhyZXNob2xkXSk7XG4gICAgcmV0dXJuIHNjcm9sbFBvc2l0aW9uO1xufTtcbmNvbnN0IHVzZUhvcml6b250YWxTY3JvbGxQb3NpdGlvbiA9IChzY3JvbGxFbGVtZW50LCB0aHJlc2hvbGQgPSBTQ1JPTExfVEhSRVNIT0xEKSA9PiB7XG4gICAgY29uc3QgW3Njcm9sbFBvc2l0aW9uLCBzZXRTY3JvbGxQb3NpdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXNjcm9sbEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjcm9sbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGhhc0hvcml6b250YWxTY3JvbGxiYXIgPSBlbGVtZW50LnNjcm9sbFdpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGlmICghaGFzSG9yaXpvbnRhbFNjcm9sbGJhcilcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0U2Nyb2xsUG9zaXRpb24obnVsbCk7XG4gICAgICAgICAgICBjb25zdCBpc0F0VGhlU3RhcnQgPSBlbGVtZW50LnNjcm9sbExlZnQgPD0gdGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKGlzQXRUaGVTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0U2Nyb2xsUG9zaXRpb24oJ3N0YXJ0Jyk7XG4gICAgICAgICAgICBjb25zdCBpc0F0VGhlRW5kID0gTWF0aC5hYnMoZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuc2Nyb2xsTGVmdCAtIGVsZW1lbnQuY2xpZW50V2lkdGgpIDw9IHRocmVzaG9sZDtcbiAgICAgICAgICAgIGlmIChpc0F0VGhlRW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRTY3JvbGxQb3NpdGlvbignZW5kJyk7XG4gICAgICAgICAgICBzZXRTY3JvbGxQb3NpdGlvbignYmV0d2VlbicpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihzY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShzY3JvbGxFbGVtZW50KTtcbiAgICAgICAgc2Nyb2xsRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHNjcm9sbEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsSGFuZGxlcik7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW3Njcm9sbEVsZW1lbnQsIHRocmVzaG9sZF0pO1xuICAgIHJldHVybiBzY3JvbGxQb3NpdGlvbjtcbn07XG5cbmNvbnN0IHVzZVRvZ2dsZUNhbGxSZWNvcmRpbmcgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyA9IHVzZUlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MoKTtcbiAgICBjb25zdCBbaXNBd2FpdGluZ1Jlc3BvbnNlLCBzZXRJc0F3YWl0aW5nUmVzcG9uc2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIFRPRE86IGFkZCBwZXJtaXNzaW9uc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIHdlIHdhaXQgdW50aWwgY2FsbC5yZWNvcmRpbmdfc3RhcnRlZC9zdG9wcGVkIGV2ZW50IHRvIGZsaXBzIHRoZVxuICAgICAgICAvLyBgaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzc2Agc3RhdGUgdmFyaWFibGUuXG4gICAgICAgIC8vIE9uY2UgdGhlIGZsaXAgaGFwcGVucywgd2UgcmVtb3ZlIHRoZSBsb2FkaW5nIGluZGljYXRvclxuICAgICAgICBzZXRJc0F3YWl0aW5nUmVzcG9uc2UoKGlzQXdhaXRpbmcpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0F3YWl0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBpc0F3YWl0aW5nO1xuICAgICAgICB9KTtcbiAgICB9LCBbaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzc10pO1xuICAgIGNvbnN0IHRvZ2dsZUNhbGxSZWNvcmRpbmcgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXRJc0F3YWl0aW5nUmVzcG9uc2UodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGw/LnN0b3BSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGw/LnN0YXJ0UmVjb3JkaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCBzdGFydCByZWNvcmRpbmdgLCBlKTtcbiAgICAgICAgfVxuICAgIH0sIFtjYWxsLCBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXSk7XG4gICAgcmV0dXJuIHsgdG9nZ2xlQ2FsbFJlY29yZGluZywgaXNBd2FpdGluZ1Jlc3BvbnNlLCBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzIH07XG59O1xuXG5jb25zdCB1c2VSZXF1ZXN0UGVybWlzc2lvbiA9IChwZXJtaXNzaW9uKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUhhc1Blcm1pc3Npb25zIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSB1c2VIYXNQZXJtaXNzaW9ucyhwZXJtaXNzaW9uKTtcbiAgICBjb25zdCBbaXNBd2FpdGluZ1Blcm1pc3Npb24sIHNldElzQXdhaXRpbmdQZXJtaXNzaW9uXSA9IHVzZVN0YXRlKGZhbHNlKTsgLy8gVE9ETzogbG9hZCB3aXRoIHBvc3NpYmx5IHBlbmRpbmcgc3RhdGVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCByZXNldCA9ICgpID0+IHNldElzQXdhaXRpbmdQZXJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgaWYgKGhhc1Blcm1pc3Npb24pXG4gICAgICAgICAgICByZXNldCgpO1xuICAgIH0sIFtoYXNQZXJtaXNzaW9uXSk7XG4gICAgY29uc3QgcmVxdWVzdFBlcm1pc3Npb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChoYXNQZXJtaXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IGNhblJlcXVlc3RQZXJtaXNzaW9uID0gISFjYWxsPy5wZXJtaXNzaW9uc0NvbnRleHQuY2FuUmVxdWVzdChwZXJtaXNzaW9uKTtcbiAgICAgICAgaWYgKGlzQXdhaXRpbmdQZXJtaXNzaW9uIHx8ICFjYW5SZXF1ZXN0UGVybWlzc2lvbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgc2V0SXNBd2FpdGluZ1Blcm1pc3Npb24odHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjYWxsPy5yZXF1ZXN0UGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbcGVybWlzc2lvbl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNldElzQXdhaXRpbmdQZXJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWVzdFBlcm1pc3Npb24gZmFpbGVkOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbY2FsbCwgaGFzUGVybWlzc2lvbiwgaXNBd2FpdGluZ1Blcm1pc3Npb24sIHBlcm1pc3Npb25dKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXF1ZXN0UGVybWlzc2lvbixcbiAgICAgICAgaGFzUGVybWlzc2lvbixcbiAgICAgICAgY2FuUmVxdWVzdFBlcm1pc3Npb246ICEhY2FsbD8ucGVybWlzc2lvbnNDb250ZXh0LmNhblJlcXVlc3QocGVybWlzc2lvbiksXG4gICAgICAgIGlzQXdhaXRpbmdQZXJtaXNzaW9uLFxuICAgIH07XG59O1xuXG52YXIgTWVudVZpc3VhbFR5cGU7XG4oZnVuY3Rpb24gKE1lbnVWaXN1YWxUeXBlKSB7XG4gICAgTWVudVZpc3VhbFR5cGVbXCJQT1JUQUxcIl0gPSBcInBvcnRhbFwiO1xuICAgIE1lbnVWaXN1YWxUeXBlW1wiTUVOVVwiXSA9IFwibWVudVwiO1xufSkoTWVudVZpc3VhbFR5cGUgfHwgKE1lbnVWaXN1YWxUeXBlID0ge30pKTtcbi8qKlxuICogVXNlZCB0byBwcm92aWRlIHV0aWxpdHkgQVBJcyB0byB0aGUgY29tcG9uZW50cyByZW5kZXJlZCBpbnNpZGUgdGhlIHBvcnRhbC5cbiAqL1xuY29uc3QgTWVudUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbi8qKlxuICogQWNjZXNzIHRvIHRoZSBjbG9zZXMgTWVudUNvbnRleHQuXG4gKi9cbmNvbnN0IHVzZU1lbnVDb250ZXh0ID0gKCkgPT4ge1xuICAgIHJldHVybiB1c2VDb250ZXh0KE1lbnVDb250ZXh0KTtcbn07XG5jb25zdCBNZW51UG9ydGFsID0gKHsgY2hpbGRyZW4sIHJlZnMsIH0pID0+IHtcbiAgICBjb25zdCBwb3J0YWxJZCA9IHVzZU1lbW8oKCkgPT4gYHN0ci12aWRlby1wb3J0YWwtJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSl9YCwgW10pO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGlkOiBwb3J0YWxJZCwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcG9ydGFsXCIgfSksIGpzeChGbG9hdGluZ092ZXJsYXksIHsgY2hpbGRyZW46IGpzeChGbG9hdGluZ1BvcnRhbCwgeyBpZDogcG9ydGFsSWQsIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wb3J0YWwtY29udGVudFwiLCByZWY6IHJlZnMuc2V0RmxvYXRpbmcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSB9KV0gfSkpO1xufTtcbmNvbnN0IE1lbnVUb2dnbGUgPSAoeyBUb2dnbGVCdXR0b24sIHBsYWNlbWVudCA9ICd0b3Atc3RhcnQnLCBzdHJhdGVneSA9ICdhYnNvbHV0ZScsIG9mZnNldCwgdmlzdWFsVHlwZSA9IE1lbnVWaXN1YWxUeXBlLk1FTlUsIGNoaWxkcmVuLCB9KSA9PiB7XG4gICAgY29uc3QgW21lbnVTaG93biwgc2V0TWVudVNob3duXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB7IGZsb2F0aW5nLCBkb21SZWZlcmVuY2UsIHJlZnMsIHgsIHkgfSA9IHVzZUZsb2F0aW5nVUlQcmVzZXQoe1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHN0cmF0ZWd5LFxuICAgICAgICBvZmZzZXQsXG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZmxvYXRpbmcgJiYgZG9tUmVmZXJlbmNlPy5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgc2V0TWVudVNob3duKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmxvYXRpbmcgJiYgIWZsb2F0aW5nPy5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgc2V0TWVudVNob3duKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpID09PSAnZXNjYXBlJyAmJlxuICAgICAgICAgICAgICAgICFldmVudC5hbHRLZXkgJiZcbiAgICAgICAgICAgICAgICAhZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgICAgICAgIHNldE1lbnVTaG93bihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljaywgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZmxvYXRpbmcsIGRvbVJlZmVyZW5jZV0pO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW21lbnVTaG93biAmJiAoanN4KE1lbnVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGNsb3NlOiAoKSA9PiBzZXRNZW51U2hvd24oZmFsc2UpIH0sIGNoaWxkcmVuOiB2aXN1YWxUeXBlID09PSBNZW51VmlzdWFsVHlwZS5QT1JUQUwgPyAoanN4KE1lbnVQb3J0YWwsIHsgcmVmczogcmVmcywgY2hpbGRyZW46IGNoaWxkcmVuIH0pKSA6IHZpc3VhbFR5cGUgPT09IE1lbnVWaXN1YWxUeXBlLk1FTlUgPyAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbWVudS1jb250YWluZXJcIiwgcmVmOiByZWZzLnNldEZsb2F0aW5nLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB5ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKSA6IG51bGwgfSkpLCBqc3goVG9nZ2xlQnV0dG9uLCB7IG1lbnVTaG93bjogbWVudVNob3duLCByZWY6IHJlZnMuc2V0UmVmZXJlbmNlIH0pXSB9KSk7XG59O1xuXG5jb25zdCBHZW5lcmljTWVudSA9ICh7IGNoaWxkcmVuLCBvbkl0ZW1DbGljaywgfSkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICByZXR1cm4gKGpzeChcInVsXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZ2VuZXJpYy1tZW51XCIsIHJlZjogcmVmLCBvbkNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG9uSXRlbUNsaWNrICYmXG4gICAgICAgICAgICAgICAgZS50YXJnZXQgIT09IHJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQ/LmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIG9uSXRlbUNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbmNvbnN0IEdlbmVyaWNNZW51QnV0dG9uSXRlbSA9ICh7IGNoaWxkcmVuLCAuLi5yZXN0IH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcImxpXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZ2VuZXJpYy1tZW51LS1pdGVtXCIsIGNoaWxkcmVuOiBqc3goXCJidXR0b25cIiwgeyAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufTtcblxuY29uc3QgSWNvbiA9ICh7IGNsYXNzTmFtZSwgaWNvbiB9KSA9PiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19pY29uJywgaWNvbiAmJiBgc3RyLXZpZGVvX19pY29uLS0ke2ljb259YCwgY2xhc3NOYW1lKSB9KSk7XG5cbmNvbnN0IEljb25CdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIEljb25CdXR0b24ocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IHsgaWNvbiwgZW5hYmxlZCwgdmFyaWFudCwgb25DbGljaywgY2xhc3NOYW1lLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGpzeChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19jYWxsLWNvbnRyb2xzX19idXR0b24nLCBjbGFzc05hbWUsIHtcbiAgICAgICAgICAgIFtgc3RyLXZpZGVvX19jYWxsLWNvbnRyb2xzX19idXR0b24tLXZhcmlhbnQtJHt2YXJpYW50fWBdOiB2YXJpYW50LFxuICAgICAgICAgICAgJ3N0ci12aWRlb19fY2FsbC1jb250cm9sc19fYnV0dG9uLS1lbmFibGVkJzogZW5hYmxlZCxcbiAgICAgICAgfSksIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZSk7XG4gICAgICAgIH0sIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjoganN4KEljb24sIHsgaWNvbjogaWNvbiB9KSB9KSk7XG59KTtcblxuY29uc3QgaXNDb21wb25lbnRUeXBlID0gKGVsZW1lbnRPckNvbXBvbmVudCkgPT4ge1xuICAgIHJldHVybiBlbGVtZW50T3JDb21wb25lbnQgPT09IG51bGxcbiAgICAgICAgPyBmYWxzZVxuICAgICAgICA6ICFpc1ZhbGlkRWxlbWVudChlbGVtZW50T3JDb21wb25lbnQpO1xufTtcblxuY29uc3QgY2h1bmsgPSAoYXJyYXksIHNpemUpID0+IHtcbiAgICBjb25zdCBjaHVua0NvdW50ID0gTWF0aC5jZWlsKGFycmF5Lmxlbmd0aCAvIHNpemUpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjaHVua0NvdW50IH0sIChfLCBpbmRleCkgPT4gYXJyYXkuc2xpY2Uoc2l6ZSAqIGluZGV4LCBzaXplICogaW5kZXggKyBzaXplKSk7XG59O1xuXG5jb25zdCBhcHBseUVsZW1lbnRUb1JlZiA9IChyZWYsIGVsZW1lbnQpID0+IHtcbiAgICBpZiAoIXJlZilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gcmVmKGVsZW1lbnQpO1xuICAgIHJlZi5jdXJyZW50ID0gZWxlbWVudDtcbn07XG5cbmNvbnN0IENvbXBvc2l0ZUJ1dHRvbiA9IGZvcndhcmRSZWYoZnVuY3Rpb24gQ29tcG9zaXRlQnV0dG9uKHsgY2FwdGlvbiwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgYWN0aXZlLCBNZW51LCBtZW51UGxhY2VtZW50LCBtZW51T2Zmc2V0LCB0aXRsZSwgVG9nZ2xlTWVudUJ1dHRvbiA9IERlZmF1bHRUb2dnbGVNZW51QnV0dG9uLCB2YXJpYW50LCBvbkNsaWNrLCAuLi5yZXN0QnV0dG9uUHJvcHMgfSwgcmVmKSB7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b24nLCBjbGFzc05hbWUsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b24tLWNhcHRpb24nOiBjYXB0aW9uLFxuICAgICAgICAgICAgJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbi0tbWVudSc6IE1lbnUsXG4gICAgICAgIH0pLCB0aXRsZTogdGl0bGUsIHJlZjogcmVmLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbl9fYnV0dG9uLWdyb3VwJywge1xuICAgICAgICAgICAgICAgICAgICAnc3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uX19idXR0b24tZ3JvdXAtLWFjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbl9fYnV0dG9uLWdyb3VwLS1hY3RpdmUtcHJpbWFyeSc6IGFjdGl2ZSAmJiB2YXJpYW50ID09PSAncHJpbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b25fX2J1dHRvbi1ncm91cC0tYWN0aXZlLXNlY29uZGFyeSc6IGFjdGl2ZSAmJiB2YXJpYW50ID09PSAnc2Vjb25kYXJ5JyxcbiAgICAgICAgICAgICAgICB9KSwgY2hpbGRyZW46IFtqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uX19idXR0b25cIiwgb25DbGljazogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz8uKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgLi4ucmVzdEJ1dHRvblByb3BzLCBjaGlsZHJlbjogY2hpbGRyZW4gfSksIE1lbnUgJiYgKGpzeChNZW51VG9nZ2xlLCB7IG9mZnNldDogbWVudU9mZnNldCwgcGxhY2VtZW50OiBtZW51UGxhY2VtZW50LCBUb2dnbGVCdXR0b246IFRvZ2dsZU1lbnVCdXR0b24sIGNoaWxkcmVuOiBpc0NvbXBvbmVudFR5cGUoTWVudSkgPyBqc3goTWVudSwge30pIDogTWVudSB9KSldIH0pLCBjYXB0aW9uICYmIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uX19jYXB0aW9uXCIsIGNoaWxkcmVuOiBjYXB0aW9uIH0pKV0gfSkpO1xufSk7XG5jb25zdCBEZWZhdWx0VG9nZ2xlTWVudUJ1dHRvbiA9IGZvcndhcmRSZWYoZnVuY3Rpb24gRGVmYXVsdFRvZ2dsZU1lbnVCdXR0b24oeyBtZW51U2hvd24gfSwgcmVmKSB7XG4gICAgcmV0dXJuIChqc3goSWNvbkJ1dHRvbiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fbWVudS10b2dnbGUtYnV0dG9uJywge1xuICAgICAgICAgICAgJ3N0ci12aWRlb19fbWVudS10b2dnbGUtYnV0dG9uLS1hY3RpdmUnOiBtZW51U2hvd24sXG4gICAgICAgIH0pLCBpY29uOiBtZW51U2hvd24gPyAnY2FyZXQtZG93bicgOiAnY2FyZXQtdXAnLCByZWY6IHJlZiB9KSk7XG59KTtcblxuY29uc3QgVGV4dEJ1dHRvbiA9ICh7IGNoaWxkcmVuLCAuLi5yZXN0IH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcImJ1dHRvblwiLCB7IC4uLnJlc3QsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3RleHQtYnV0dG9uXCIsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCBBY2NlcHRDYWxsQnV0dG9uID0gKHsgZGlzYWJsZWQsIG9uQWNjZXB0LCBvbkNsaWNrLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGwpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGwuam9pbigpO1xuICAgICAgICAgICAgb25BY2NlcHQ/LigpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2ssIG9uQWNjZXB0LCBjYWxsXSk7XG4gICAgcmV0dXJuIChqc3goSWNvbkJ1dHRvbiwgeyBkaXNhYmxlZDogZGlzYWJsZWQsIGljb246IFwiY2FsbC1hY2NlcHRcIiwgdmFyaWFudDogXCJzdWNjZXNzXCIsIFwiZGF0YS10ZXN0aWRcIjogXCJhY2NlcHQtY2FsbC1idXR0b25cIiwgb25DbGljazogaGFuZGxlQ2xpY2sgfSkpO1xufTtcblxuY29uc3QgTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBpc1Zpc2libGUsIG1lc3NhZ2UsIGNoaWxkcmVuLCB2aXNpYmlsaXR5VGltZW91dCwgcmVzZXRJc1Zpc2libGUsIHBsYWNlbWVudCA9ICd0b3AnLCBpY29uQ2xhc3NOYW1lID0gJ3N0ci12aWRlb19fbm90aWZpY2F0aW9uX19pY29uJywgY2xvc2UsIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHJlZnMsIHgsIHksIHN0cmF0ZWd5IH0gPSB1c2VGbG9hdGluZ1VJUHJlc2V0KHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzVmlzaWJsZSB8fCAhdmlzaWJpbGl0eVRpbWVvdXQgfHwgIXJlc2V0SXNWaXNpYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNldElzVmlzaWJsZSgpO1xuICAgICAgICB9LCB2aXNpYmlsaXR5VGltZW91dCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfSwgW2lzVmlzaWJsZSwgcmVzZXRJc1Zpc2libGUsIHZpc2liaWxpdHlUaW1lb3V0XSk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgcmVmOiByZWZzLnNldFJlZmVyZW5jZSwgY2hpbGRyZW46IFtpc1Zpc2libGUgJiYgKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19ub3RpZmljYXRpb25cIiwgcmVmOiByZWZzLnNldEZsb2F0aW5nLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogeSA/PyAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbaWNvbkNsYXNzTmFtZSAmJiBqc3goXCJpXCIsIHsgY2xhc3NOYW1lOiBpY29uQ2xhc3NOYW1lIH0pLCBqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbm90aWZpY2F0aW9uX19tZXNzYWdlXCIsIGNoaWxkcmVuOiBtZXNzYWdlIH0pLCBjbG9zZSA/IChqc3goXCJpXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19faWNvbiBzdHItdmlkZW9fX2ljb24tLWNsb3NlIHN0ci12aWRlb19fbm90aWZpY2F0aW9uX19jbG9zZVwiLCBvbkNsaWNrOiBjbG9zZSB9KSkgOiBudWxsXSB9KSksIGNoaWxkcmVuXSB9KSk7XG59O1xuXG5jb25zdCBQZXJtaXNzaW9uTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9uLCBpc0F3YWl0aW5nQXBwcm92YWwsIG1lc3NhZ2VBcHByb3ZlZCwgbWVzc2FnZUF3YWl0aW5nQXBwcm92YWwsIG1lc3NhZ2VSZXZva2VkLCB2aXNpYmlsaXR5VGltZW91dCA9IDM1MDAsIGNoaWxkcmVuLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB1c2VIYXNQZXJtaXNzaW9ucyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBoYXNQZXJtaXNzaW9uID0gdXNlSGFzUGVybWlzc2lvbnMocGVybWlzc2lvbik7XG4gICAgY29uc3QgcHJldkhhc1Blcm1pc3Npb24gPSB1c2VSZWYoaGFzUGVybWlzc2lvbik7XG4gICAgY29uc3QgW3Nob3dOb3RpZmljYXRpb24sIHNldFNob3dOb3RpZmljYXRpb25dID0gdXNlU3RhdGUoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaGFzUGVybWlzc2lvbiAmJiAhcHJldkhhc1Blcm1pc3Npb24uY3VycmVudCkge1xuICAgICAgICAgICAgc2V0U2hvd05vdGlmaWNhdGlvbignZ3JhbnRlZCcpO1xuICAgICAgICAgICAgcHJldkhhc1Blcm1pc3Npb24uY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWhhc1Blcm1pc3Npb24gJiYgcHJldkhhc1Blcm1pc3Npb24uY3VycmVudCkge1xuICAgICAgICAgICAgc2V0U2hvd05vdGlmaWNhdGlvbigncmV2b2tlZCcpO1xuICAgICAgICAgICAgcHJldkhhc1Blcm1pc3Npb24uY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgW2hhc1Blcm1pc3Npb25dKTtcbiAgICBjb25zdCByZXNldElzVmlzaWJsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHNldFNob3dOb3RpZmljYXRpb24odW5kZWZpbmVkKSwgW10pO1xuICAgIGlmIChpc0F3YWl0aW5nQXBwcm92YWwpIHtcbiAgICAgICAgcmV0dXJuIChqc3goTm90aWZpY2F0aW9uLCB7IGlzVmlzaWJsZTogaXNBd2FpdGluZ0FwcHJvdmFsICYmICFoYXNQZXJtaXNzaW9uLCBtZXNzYWdlOiBtZXNzYWdlQXdhaXRpbmdBcHByb3ZhbCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goTm90aWZpY2F0aW9uLCB7IGlzVmlzaWJsZTogISFzaG93Tm90aWZpY2F0aW9uLCB2aXNpYmlsaXR5VGltZW91dDogdmlzaWJpbGl0eVRpbWVvdXQsIHJlc2V0SXNWaXNpYmxlOiByZXNldElzVmlzaWJsZSwgbWVzc2FnZTogc2hvd05vdGlmaWNhdGlvbiA9PT0gJ2dyYW50ZWQnID8gbWVzc2FnZUFwcHJvdmVkIDogbWVzc2FnZVJldm9rZWQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCBTcGVha2luZ1doaWxlTXV0ZWROb3RpZmljYXRpb24gPSAoeyBjaGlsZHJlbiwgdGV4dCwgcGxhY2VtZW50LCB9KSA9PiB7XG4gICAgY29uc3QgeyB1c2VNaWNyb3Bob25lU3RhdGUgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgeyBpc1NwZWFraW5nV2hpbGVNdXRlZCB9ID0gdXNlTWljcm9waG9uZVN0YXRlKCk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRleHQgPz8gdCgnWW91IGFyZSBtdXRlZC4gVW5tdXRlIHRvIHNwZWFrLicpO1xuICAgIHJldHVybiAoanN4KE5vdGlmaWNhdGlvbiwgeyBtZXNzYWdlOiBtZXNzYWdlLCBpc1Zpc2libGU6IGlzU3BlYWtpbmdXaGlsZU11dGVkLCBwbGFjZW1lbnQ6IHBsYWNlbWVudCB8fCAndG9wLXN0YXJ0JywgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IFJlY29yZGluZ0luUHJvZ3Jlc3NOb3RpZmljYXRpb24gPSAoeyBjaGlsZHJlbiwgdGV4dCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyB9ID0gdXNlVG9nZ2xlQ2FsbFJlY29yZGluZygpO1xuICAgIGNvbnN0IFtpc1Zpc2libGUsIHNldFZpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0ZXh0ID8/IHQoJ1JlY29yZGluZyBpbiBwcm9ncmVzcy4uLicpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzKSB7XG4gICAgICAgICAgICBzZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzc10pO1xuICAgIHJldHVybiAoanN4KE5vdGlmaWNhdGlvbiwgeyBtZXNzYWdlOiBtZXNzYWdlLCBpY29uQ2xhc3NOYW1lOiBcInN0ci12aWRlb19faWNvbiBzdHItdmlkZW9fX2ljb24tLXJlY29yZGluZy1vblwiLCBpc1Zpc2libGU6IGlzVmlzaWJsZSwgcGxhY2VtZW50OiBcInRvcC1zdGFydFwiLCBjbG9zZTogKCkgPT4gc2V0VmlzaWJsZShmYWxzZSksIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gKHsgY2xhc3NOYW1lLCB0eXBlID0gJ3NwaW5uZXInLCB0ZXh0LCB0b29sdGlwLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2xvYWRpbmctaW5kaWNhdG9yJywgY2xhc3NOYW1lKSwgdGl0bGU6IHRvb2x0aXAsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2xvYWRpbmctaW5kaWNhdG9yX19pY29uJywgdHlwZSkgfSksIHRleHQgJiYganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2xvYWRpbmctaW5kaWNhdG9yLXRleHRcIiwgY2hpbGRyZW46IHRleHQgfSldIH0pKTtcbn07XG5cbmNvbnN0IFJlY29yZEVuZENvbmZpcm1hdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IHRvZ2dsZUNhbGxSZWNvcmRpbmcsIGlzQXdhaXRpbmdSZXNwb25zZSB9ID0gdXNlVG9nZ2xlQ2FsbFJlY29yZGluZygpO1xuICAgIGNvbnN0IHsgY2xvc2UgfSA9IHVzZU1lbnVDb250ZXh0KCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZW5kLXJlY29yZGluZ19fY29uZmlybWF0aW9uXCIsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2VuZC1yZWNvcmRpbmdfX2hlYWRlclwiLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IFwicmVjb3JkaW5nLW9uXCIgfSksIGpzeChcImgyXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZW5kLXJlY29yZGluZ19faGVhZGluZ1wiLCBjaGlsZHJlbjogdCgnRW5kIHJlY29yZGluZycpIH0pXSB9KSwganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2VuZC1yZWNvcmRpbmdfX2Rlc2NyaXB0aW9uXCIsIGNoaWxkcmVuOiB0KCdBcmUgeW91IHN1cmUgeW91IHdhbnQgZW5kIHRoZSByZWNvcmRpbmc/JykgfSksIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19lbmQtcmVjb3JkaW5nX19hY3Rpb25zXCIsIGNoaWxkcmVuOiBbanN4KENvbXBvc2l0ZUJ1dHRvbiwgeyB2YXJpYW50OiBcInNlY29uZGFyeVwiLCBvbkNsaWNrOiBjbG9zZSwgY2hpbGRyZW46IHQoJ0NhbmNlbCcpIH0pLCBqc3goQ29tcG9zaXRlQnV0dG9uLCB7IHZhcmlhbnQ6IFwicHJpbWFyeVwiLCBvbkNsaWNrOiB0b2dnbGVDYWxsUmVjb3JkaW5nLCBjaGlsZHJlbjogaXNBd2FpdGluZ1Jlc3BvbnNlID8ganN4KExvYWRpbmdJbmRpY2F0b3IsIHt9KSA6IHQoJ0VuZCByZWNvcmRpbmcnKSB9KV0gfSldIH0pKTtcbn07XG5jb25zdCBUb2dnbGVFbmRSZWNvcmRpbmdNZW51QnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBUb2dnbGVFbmRSZWNvcmRpbmdNZW51QnV0dG9uKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gKGpzeChDb21wb3NpdGVCdXR0b24sIHsgcmVmOiByZWYsIGFjdGl2ZTogdHJ1ZSwgdmFyaWFudDogXCJzZWNvbmRhcnlcIiwgXCJkYXRhLXRlc3RpZFwiOiBcInJlY29yZGluZy1zdG9wLWJ1dHRvblwiLCBjaGlsZHJlbjoganN4KEljb24sIHsgaWNvbjogXCJyZWNvcmRpbmctb2ZmXCIgfSkgfSkpO1xufSk7XG5jb25zdCBSZWNvcmRDYWxsQ29uZmlybWF0aW9uQnV0dG9uID0gKHsgY2FwdGlvbiwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdG9nZ2xlQ2FsbFJlY29yZGluZywgaXNBd2FpdGluZ1Jlc3BvbnNlLCBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzIH0gPSB1c2VUb2dnbGVDYWxsUmVjb3JkaW5nKCk7XG4gICAgaWYgKGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW1xuICAgICAgICAgICAgICAgIE93bkNhcGFiaWxpdHkuU1RBUlRfUkVDT1JEX0NBTEwsXG4gICAgICAgICAgICAgICAgT3duQ2FwYWJpbGl0eS5TVE9QX1JFQ09SRF9DQUxMLFxuICAgICAgICAgICAgXSwgY2hpbGRyZW46IGpzeChNZW51VG9nZ2xlLCB7IFRvZ2dsZUJ1dHRvbjogVG9nZ2xlRW5kUmVjb3JkaW5nTWVudUJ1dHRvbiwgdmlzdWFsVHlwZTogTWVudVZpc3VhbFR5cGUuUE9SVEFMLCBjaGlsZHJlbjoganN4KFJlY29yZEVuZENvbmZpcm1hdGlvbiwge30pIH0pIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW1xuICAgICAgICAgICAgT3duQ2FwYWJpbGl0eS5TVEFSVF9SRUNPUkRfQ0FMTCxcbiAgICAgICAgICAgIE93bkNhcGFiaWxpdHkuU1RPUF9SRUNPUkRfQ0FMTCxcbiAgICAgICAgXSwgY2hpbGRyZW46IGpzeChDb21wb3NpdGVCdXR0b24sIHsgYWN0aXZlOiBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzLCBjYXB0aW9uOiBjYXB0aW9uLCB0aXRsZTogY2FwdGlvbiB8fCB0KCdSZWNvcmQgY2FsbCcpLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCBcImRhdGEtdGVzdGlkXCI6IFwicmVjb3JkaW5nLXN0YXJ0LWJ1dHRvblwiLCBvbkNsaWNrOiBpc0F3YWl0aW5nUmVzcG9uc2UgPyB1bmRlZmluZWQgOiB0b2dnbGVDYWxsUmVjb3JkaW5nLCBjaGlsZHJlbjogaXNBd2FpdGluZ1Jlc3BvbnNlID8gKGpzeChMb2FkaW5nSW5kaWNhdG9yLCB7IHRvb2x0aXA6IHQoJ1dhaXRpbmcgZm9yIHJlY29yZGluZyB0byBzdGFydC4uLicpIH0pKSA6IChqc3goSWNvbiwgeyBpY29uOiBcInJlY29yZGluZy1vZmZcIiB9KSkgfSkgfSkpO1xufTtcbmNvbnN0IFJlY29yZENhbGxCdXR0b24gPSAoeyBjYXB0aW9uIH0pID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IHRvZ2dsZUNhbGxSZWNvcmRpbmcsIGlzQXdhaXRpbmdSZXNwb25zZSwgaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyB9ID0gdXNlVG9nZ2xlQ2FsbFJlY29yZGluZygpO1xuICAgIGxldCB0aXRsZSA9IGNhcHRpb24gfHwgdCgnUmVjb3JkIGNhbGwnKTtcbiAgICBpZiAoaXNBd2FpdGluZ1Jlc3BvbnNlKSB7XG4gICAgICAgIHRpdGxlID0gaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzc1xuICAgICAgICAgICAgPyB0KCdXYWl0aW5nIGZvciByZWNvcmRpbmcgdG8gc3RvcC4uLicpXG4gICAgICAgICAgICA6IHQoJ1dhaXRpbmcgZm9yIHJlY29yZGluZyB0byBzdGFydC4uLicpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbXG4gICAgICAgICAgICBPd25DYXBhYmlsaXR5LlNUQVJUX1JFQ09SRF9DQUxMLFxuICAgICAgICAgICAgT3duQ2FwYWJpbGl0eS5TVE9QX1JFQ09SRF9DQUxMLFxuICAgICAgICBdLCBjaGlsZHJlbjoganN4KENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MsIGNhcHRpb246IGNhcHRpb24sIHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIFwiZGF0YS10ZXN0aWRcIjogaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgID8gJ3JlY29yZGluZy1zdG9wLWJ1dHRvbidcbiAgICAgICAgICAgICAgICA6ICdyZWNvcmRpbmctc3RhcnQtYnV0dG9uJywgdGl0bGU6IHRpdGxlLCBvbkNsaWNrOiBpc0F3YWl0aW5nUmVzcG9uc2UgPyB1bmRlZmluZWQgOiB0b2dnbGVDYWxsUmVjb3JkaW5nLCBjaGlsZHJlbjogaXNBd2FpdGluZ1Jlc3BvbnNlID8gKGpzeChMb2FkaW5nSW5kaWNhdG9yLCB7fSkpIDogKGpzeChJY29uLCB7IGljb246IGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MgPyAncmVjb3JkaW5nLW9uJyA6ICdyZWNvcmRpbmctb2ZmJyB9KSkgfSkgfSkpO1xufTtcblxuY29uc3QgZGVmYXVsdEVtb2ppUmVhY3Rpb25NYXAgPSB7XG4gICAgJzpsaWtlOic6ICfwn5GNJyxcbiAgICAnOnJhaXNlLWhhbmQ6JzogJ+KciycsXG4gICAgJzpmaXJld29ya3M6JzogJ/CfjoknLFxuICAgICc6ZGlzbGlrZTonOiAn8J+RjicsXG4gICAgJzpoZWFydDonOiAn4p2k77iPJyxcbiAgICAnOnNtaWxlOic6ICfwn5iAJyxcbn07XG5jb25zdCBSZWFjdGlvbiA9ICh7IHBhcnRpY2lwYW50OiB7IHJlYWN0aW9uLCBzZXNzaW9uSWQgfSwgaGlkZUFmdGVyVGltZW91dEluTXMgPSA1NTAwLCBlbW9qaVJlYWN0aW9uTWFwID0gZGVmYXVsdEVtb2ppUmVhY3Rpb25NYXAsIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FsbCB8fCAhcmVhY3Rpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2FsbC5yZXNldFJlYWN0aW9uKHNlc3Npb25JZCk7XG4gICAgICAgIH0sIGhpZGVBZnRlclRpbWVvdXRJbk1zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9O1xuICAgIH0sIFtjYWxsLCBoaWRlQWZ0ZXJUaW1lb3V0SW5NcywgcmVhY3Rpb24sIHNlc3Npb25JZF0pO1xuICAgIGlmICghcmVhY3Rpb24pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHsgZW1vamlfY29kZTogZW1vamlDb2RlIH0gPSByZWFjdGlvbjtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3JlYWN0aW9uXCIsIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcmVhY3Rpb25fX2Vtb2ppXCIsIGNoaWxkcmVuOiBlbW9qaUNvZGUgJiYgZW1vamlSZWFjdGlvbk1hcFtlbW9qaUNvZGVdIH0pIH0pKTtcbn07XG5cbmNvbnN0IGRlZmF1bHRSZWFjdGlvbnMgPSBbXG4gICAge1xuICAgICAgICB0eXBlOiAncmVhY3Rpb24nLFxuICAgICAgICBlbW9qaV9jb2RlOiAnOmxpa2U6JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgLy8gVE9ETyBPTDogdXNlIGBwcm9tcHRgIHR5cGU/XG4gICAgICAgIHR5cGU6ICdyYWlzZWQtaGFuZCcsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6cmFpc2UtaGFuZDonLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiAncmVhY3Rpb24nLFxuICAgICAgICBlbW9qaV9jb2RlOiAnOmZpcmV3b3JrczonLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiAncmVhY3Rpb24nLFxuICAgICAgICBlbW9qaV9jb2RlOiAnOmRpc2xpa2U6JyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogJ3JlYWN0aW9uJyxcbiAgICAgICAgZW1vamlfY29kZTogJzpoZWFydDonLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiAncmVhY3Rpb24nLFxuICAgICAgICBlbW9qaV9jb2RlOiAnOnNtaWxlOicsXG4gICAgfSxcbl07XG5jb25zdCBSZWFjdGlvbnNCdXR0b24gPSAoeyByZWFjdGlvbnMgPSBkZWZhdWx0UmVhY3Rpb25zLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuQ1JFQVRFX1JFQUNUSU9OXSwgY2hpbGRyZW46IGpzeChNZW51VG9nZ2xlLCB7IHBsYWNlbWVudDogXCJ0b3BcIiwgVG9nZ2xlQnV0dG9uOiBUb2dnbGVSZWFjdGlvbnNNZW51QnV0dG9uLCB2aXN1YWxUeXBlOiBNZW51VmlzdWFsVHlwZS5NRU5VLCBjaGlsZHJlbjoganN4KERlZmF1bHRSZWFjdGlvbnNNZW51LCB7IHJlYWN0aW9uczogcmVhY3Rpb25zIH0pIH0pIH0pKTtcbn07XG5jb25zdCBUb2dnbGVSZWFjdGlvbnNNZW51QnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBUb2dnbGVSZWFjdGlvbnNNZW51QnV0dG9uKHsgbWVudVNob3duIH0sIHJlZikge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4KENvbXBvc2l0ZUJ1dHRvbiwgeyByZWY6IHJlZiwgYWN0aXZlOiBtZW51U2hvd24sIHZhcmlhbnQ6IFwicHJpbWFyeVwiLCB0aXRsZTogdCgnUmVhY3Rpb25zJyksIGNoaWxkcmVuOiBqc3goSWNvbiwgeyBpY29uOiBcInJlYWN0aW9uc1wiIH0pIH0pKTtcbn0pO1xuY29uc3QgRGVmYXVsdFJlYWN0aW9uc01lbnUgPSAoeyByZWFjdGlvbnMsIGxheW91dCA9ICdob3Jpem9udGFsJywgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fcmVhY3Rpb25zLW1lbnUnLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19yZWFjdGlvbnMtbWVudS0taG9yaXpvbnRhbCc6IGxheW91dCA9PT0gJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgJ3N0ci12aWRlb19fcmVhY3Rpb25zLW1lbnUtLXZlcnRpY2FsJzogbGF5b3V0ID09PSAndmVydGljYWwnLFxuICAgICAgICB9KSwgY2hpbGRyZW46IHJlYWN0aW9ucy5tYXAoKHJlYWN0aW9uKSA9PiAoanN4KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcmVhY3Rpb25zLW1lbnVfX2J1dHRvblwiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbD8uc2VuZFJlYWN0aW9uKHJlYWN0aW9uKTtcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiByZWFjdGlvbi5lbW9qaV9jb2RlICYmIGRlZmF1bHRFbW9qaVJlYWN0aW9uTWFwW3JlYWN0aW9uLmVtb2ppX2NvZGVdIH0sIHJlYWN0aW9uLmVtb2ppX2NvZGUpKSkgfSkpO1xufTtcblxuY29uc3QgU2NyZWVuU2hhcmVCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IGNhcHRpb24gfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlLCB1c2VTY3JlZW5TaGFyZVN0YXRlLCB1c2VDYWxsU2V0dGluZ3MgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgaXNTb21lb25lU2NyZWVuU2hhcmluZyA9IHVzZUhhc09uZ29pbmdTY3JlZW5TaGFyZSgpO1xuICAgIGNvbnN0IHsgaGFzUGVybWlzc2lvbiwgcmVxdWVzdFBlcm1pc3Npb24sIGlzQXdhaXRpbmdQZXJtaXNzaW9uIH0gPSB1c2VSZXF1ZXN0UGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFKTtcbiAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSB1c2VDYWxsU2V0dGluZ3MoKTtcbiAgICBjb25zdCBpc1NjcmVlblNoYXJpbmdBbGxvd2VkID0gY2FsbFNldHRpbmdzPy5zY3JlZW5zaGFyaW5nLmVuYWJsZWQ7XG4gICAgY29uc3QgeyBzY3JlZW5TaGFyZSwgaXNNdXRlOiBhbUlTY3JlZW5TaGFyaW5nIH0gPSB1c2VTY3JlZW5TaGFyZVN0YXRlKCk7XG4gICAgY29uc3QgZGlzYWJsZVNjcmVlblNoYXJlQnV0dG9uID0gYW1JU2NyZWVuU2hhcmluZ1xuICAgICAgICA/IGlzU29tZW9uZVNjcmVlblNoYXJpbmcgfHwgaXNTY3JlZW5TaGFyaW5nQWxsb3dlZCA9PT0gZmFsc2VcbiAgICAgICAgOiBmYWxzZTtcbiAgICByZXR1cm4gKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5TQ1JFRU5TSEFSRV0sIGNoaWxkcmVuOiBqc3goUGVybWlzc2lvbk5vdGlmaWNhdGlvbiwgeyBwZXJtaXNzaW9uOiBPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFLCBpc0F3YWl0aW5nQXBwcm92YWw6IGlzQXdhaXRpbmdQZXJtaXNzaW9uLCBtZXNzYWdlQXBwcm92ZWQ6IHQoJ1lvdSBjYW4gbm93IHNoYXJlIHlvdXIgc2NyZWVuLicpLCBtZXNzYWdlQXdhaXRpbmdBcHByb3ZhbDogdCgnQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNoYXJlIHNjcmVlbi4nKSwgbWVzc2FnZVJldm9rZWQ6IHQoJ1lvdSBjYW4gbm8gbG9uZ2VyIHNoYXJlIHlvdXIgc2NyZWVuLicpLCBjaGlsZHJlbjoganN4KENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzU29tZW9uZVNjcmVlblNoYXJpbmcsIGNhcHRpb246IGNhcHRpb24sIHRpdGxlOiBjYXB0aW9uIHx8IHQoJ1NoYXJlIHNjcmVlbicpLCB2YXJpYW50OiBcInByaW1hcnlcIiwgXCJkYXRhLXRlc3RpZFwiOiBpc1NvbWVvbmVTY3JlZW5TaGFyaW5nXG4gICAgICAgICAgICAgICAgICAgID8gJ3NjcmVlbi1zaGFyZS1zdG9wLWJ1dHRvbidcbiAgICAgICAgICAgICAgICAgICAgOiAnc2NyZWVuLXNoYXJlLXN0YXJ0LWJ1dHRvbicsIGRpc2FibGVkOiBkaXNhYmxlU2NyZWVuU2hhcmVCdXR0b24sIG9uQ2xpY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXF1ZXN0UGVybWlzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2NyZWVuU2hhcmUudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjoganN4KEljb24sIHsgaWNvbjogaXNTb21lb25lU2NyZWVuU2hhcmluZyA/ICdzY3JlZW4tc2hhcmUtb24nIDogJ3NjcmVlbi1zaGFyZS1vZmYnIH0pIH0pIH0pIH0pKTtcbn07XG5cbmNvbnN0IFNlbGVjdENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbmNvbnN0IFNlbGVjdCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGljb24sIGRlZmF1bHRTZWxlY3RlZExhYmVsLCBkZWZhdWx0U2VsZWN0ZWRJbmRleCwgaGFuZGxlU2VsZWN0OiBoYW5kbGVTZWxlY3RQcm9wLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbYWN0aXZlSW5kZXgsIHNldEFjdGl2ZUluZGV4XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlKGRlZmF1bHRTZWxlY3RlZEluZGV4KTtcbiAgICBjb25zdCBbc2VsZWN0ZWRMYWJlbCwgc2V0U2VsZWN0ZWRMYWJlbF0gPSB1c2VTdGF0ZShkZWZhdWx0U2VsZWN0ZWRMYWJlbCk7XG4gICAgY29uc3QgeyByZWZzLCBjb250ZXh0IH0gPSB1c2VGbG9hdGluZyh7XG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbS1zdGFydCcsXG4gICAgICAgIG9wZW46IGlzT3BlbixcbiAgICAgICAgb25PcGVuQ2hhbmdlOiBzZXRJc09wZW4sXG4gICAgICAgIHdoaWxlRWxlbWVudHNNb3VudGVkOiBhdXRvVXBkYXRlLFxuICAgICAgICBtaWRkbGV3YXJlOiBbZmxpcCgpXSxcbiAgICB9KTtcbiAgICBjb25zdCBlbGVtZW50c1JlZiA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgbGFiZWxzUmVmID0gdXNlUmVmKFtdKTtcbiAgICBjb25zdCBoYW5kbGVTZWxlY3QgPSB1c2VDYWxsYmFjaygoaW5kZXgpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0ZWRJbmRleChpbmRleCk7XG4gICAgICAgIGhhbmRsZVNlbGVjdFByb3AoaW5kZXggfHwgMCk7XG4gICAgICAgIHNldElzT3BlbihmYWxzZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRMYWJlbChsYWJlbHNSZWYuY3VycmVudFtpbmRleF0pO1xuICAgICAgICB9XG4gICAgfSwgW2hhbmRsZVNlbGVjdFByb3BdKTtcbiAgICBjb25zdCBoYW5kbGVUeXBlYWhlYWRNYXRjaCA9IChpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICBzZXRBY3RpdmVJbmRleChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVTZWxlY3QoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsaXN0TmF2ID0gdXNlTGlzdE5hdmlnYXRpb24oY29udGV4dCwge1xuICAgICAgICBsaXN0UmVmOiBlbGVtZW50c1JlZixcbiAgICAgICAgYWN0aXZlSW5kZXgsXG4gICAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICAgIG9uTmF2aWdhdGU6IHNldEFjdGl2ZUluZGV4LFxuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVhaGVhZCA9IHVzZVR5cGVhaGVhZChjb250ZXh0LCB7XG4gICAgICAgIGxpc3RSZWY6IGxhYmVsc1JlZixcbiAgICAgICAgYWN0aXZlSW5kZXgsXG4gICAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICAgIG9uTWF0Y2g6IGhhbmRsZVR5cGVhaGVhZE1hdGNoLFxuICAgIH0pO1xuICAgIGNvbnN0IGNsaWNrID0gdXNlQ2xpY2soY29udGV4dCk7XG4gICAgY29uc3QgZGlzbWlzcyA9IHVzZURpc21pc3MoY29udGV4dCk7XG4gICAgY29uc3Qgcm9sZSA9IHVzZVJvbGUoY29udGV4dCwgeyByb2xlOiAnbGlzdGJveCcgfSk7XG4gICAgY29uc3QgeyBnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzIH0gPSB1c2VJbnRlcmFjdGlvbnMoW2xpc3ROYXYsIHR5cGVhaGVhZCwgY2xpY2ssIGRpc21pc3MsIHJvbGVdKTtcbiAgICBjb25zdCBzZWxlY3RDb250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgZ2V0SXRlbVByb3BzLFxuICAgICAgICBoYW5kbGVTZWxlY3QsXG4gICAgfSksIFthY3RpdmVJbmRleCwgc2VsZWN0ZWRJbmRleCwgZ2V0SXRlbVByb3BzLCBoYW5kbGVTZWxlY3RdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93blwiLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93bi1zZWxlY3RlZFwiLCByZWY6IHJlZnMuc2V0UmVmZXJlbmNlLCB0YWJJbmRleDogMCwgLi4uZ2V0UmVmZXJlbmNlUHJvcHMoKSwgY2hpbGRyZW46IFtqc3hzKFwibGFiZWxcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93bi1zZWxlY3RlZF9fbGFiZWxcIiwgY2hpbGRyZW46IFtpY29uICYmIChqc3goSWNvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93bi1zZWxlY3RlZF9faWNvblwiLCBpY29uOiBpY29uIH0pKSwgc2VsZWN0ZWRMYWJlbF0gfSksIGpzeChJY29uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLXNlbGVjdGVkX19jaGV2cm9uXCIsIGljb246IGlzT3BlbiA/ICdjaGV2cm9uLXVwJyA6ICdjaGV2cm9uLWRvd24nIH0pXSB9KSwganN4KFNlbGVjdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNlbGVjdENvbnRleHQsIGNoaWxkcmVuOiBpc09wZW4gJiYgKGpzeChGbG9hdGluZ0ZvY3VzTWFuYWdlciwgeyBjb250ZXh0OiBjb250ZXh0LCBtb2RhbDogZmFsc2UsIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93bi1saXN0XCIsIHJlZjogcmVmcy5zZXRGbG9hdGluZywgLi4uZ2V0RmxvYXRpbmdQcm9wcygpLCBjaGlsZHJlbjoganN4KEZsb2F0aW5nTGlzdCwgeyBlbGVtZW50c1JlZjogZWxlbWVudHNSZWYsIGxhYmVsc1JlZjogbGFiZWxzUmVmLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkgfSkpIH0pXSB9KSk7XG59O1xuY29uc3QgRHJvcERvd25TZWxlY3RPcHRpb24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGVkLCBsYWJlbCwgaWNvbiB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBnZXRJdGVtUHJvcHMsIGhhbmRsZVNlbGVjdCB9ID0gdXNlQ29udGV4dChTZWxlY3RDb250ZXh0KTtcbiAgICBjb25zdCB7IHJlZiwgaW5kZXggfSA9IHVzZUxpc3RJdGVtKCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2Ryb3Bkb3duLW9wdGlvbicsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2Ryb3Bkb3duLW9wdGlvbi0tc2VsZWN0ZWQnOiBzZWxlY3RlZCxcbiAgICAgICAgfSksIHJlZjogcmVmLCAuLi5nZXRJdGVtUHJvcHMoe1xuICAgICAgICAgICAgb25DbGljazogKCkgPT4gaGFuZGxlU2VsZWN0KGluZGV4KSxcbiAgICAgICAgfSksIGNoaWxkcmVuOiBbanN4KEljb24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZHJvcGRvd24taWNvblwiLCBpY29uOiBpY29uIH0pLCBqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZHJvcGRvd24tbGFiZWxcIiwgY2hpbGRyZW46IGxhYmVsIH0pXSB9KSk7XG59O1xuY29uc3QgRHJvcERvd25TZWxlY3QgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBpY29uLCBoYW5kbGVTZWxlY3QsIGRlZmF1bHRTZWxlY3RlZExhYmVsLCBkZWZhdWx0U2VsZWN0ZWRJbmRleCwgfSA9IHByb3BzO1xuICAgIHJldHVybiAoanN4KFNlbGVjdCwgeyBpY29uOiBpY29uLCBoYW5kbGVTZWxlY3Q6IGhhbmRsZVNlbGVjdCwgZGVmYXVsdFNlbGVjdGVkSW5kZXg6IGRlZmF1bHRTZWxlY3RlZEluZGV4LCBkZWZhdWx0U2VsZWN0ZWRMYWJlbDogZGVmYXVsdFNlbGVjdGVkTGFiZWwsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCBEZXZpY2VTZWxlY3Rvck9wdGlvbiA9ICh7IGRpc2FibGVkLCBpZCwgbGFiZWwsIG9uQ2hhbmdlLCBuYW1lLCBzZWxlY3RlZCwgZGVmYXVsdENoZWNrZWQsIHZhbHVlLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3hzKFwibGFiZWxcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzX19vcHRpb24nLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX29wdGlvbi0tc2VsZWN0ZWQnOiBzZWxlY3RlZCxcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2RldmljZS1zZXR0aW5nc19fb3B0aW9uLS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICB9KSwgaHRtbEZvcjogaWQsIGNoaWxkcmVuOiBbanN4KFwiaW5wdXRcIiwgeyB0eXBlOiBcInJhZGlvXCIsIG5hbWU6IG5hbWUsIG9uQ2hhbmdlOiBvbkNoYW5nZSwgdmFsdWU6IHZhbHVlLCBpZDogaWQsIGNoZWNrZWQ6IHNlbGVjdGVkLCBkZWZhdWx0Q2hlY2tlZDogZGVmYXVsdENoZWNrZWQsIGRpc2FibGVkOiBkaXNhYmxlZCB9KSwgbGFiZWxdIH0pKTtcbn07XG5jb25zdCBEZXZpY2VTZWxlY3Rvckxpc3QgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGRldmljZXMgPSBbXSwgc2VsZWN0ZWREZXZpY2VJZDogc2VsZWN0ZWREZXZpY2VGcm9tUHJvcHMsIHRpdGxlLCB0eXBlLCBvbkNoYW5nZSwgfSA9IHByb3BzO1xuICAgIC8vIHNvbWV0aW1lcyB0aGUgYnJvd3NlciAoQ2hyb21lKSB3aWxsIHJlcG9ydCB0aGUgc3lzdGVtLWRlZmF1bHQgZGV2aWNlXG4gICAgLy8gd2l0aCBhbiBpZCBvZiAnZGVmYXVsdCcuIEluIGNhc2Ugd2hlbiBpdCBkb2Vzbid0LCB3ZSdsbCBzZWxlY3QgdGhlIGZpcnN0XG4gICAgLy8gYXZhaWxhYmxlIGRldmljZS5cbiAgICBsZXQgc2VsZWN0ZWREZXZpY2VJZCA9IHNlbGVjdGVkRGV2aWNlRnJvbVByb3BzO1xuICAgIGlmIChkZXZpY2VzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIWRldmljZXMuZmluZCgoZCkgPT4gZC5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCkpIHtcbiAgICAgICAgc2VsZWN0ZWREZXZpY2VJZCA9IGRldmljZXNbMF0uZGV2aWNlSWQ7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2RldmljZS1zZXR0aW5nc19fZGV2aWNlLWtpbmRcIiwgY2hpbGRyZW46IFt0aXRsZSAmJiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzX19kZXZpY2Utc2VsZWN0b3ItdGl0bGVcIiwgY2hpbGRyZW46IHRpdGxlIH0pKSwgIWRldmljZXMubGVuZ3RoID8gKGpzeChEZXZpY2VTZWxlY3Rvck9wdGlvbiwgeyBpZDogYCR7dHlwZX0tLWRlZmF1bHRgLCBsYWJlbDogXCJEZWZhdWx0XCIsIG5hbWU6IHR5cGUsIGRlZmF1bHRDaGVja2VkOiB0cnVlLCB2YWx1ZTogXCJkZWZhdWx0XCIgfSkpIDogKGRldmljZXMubWFwKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGpzeChEZXZpY2VTZWxlY3Rvck9wdGlvbiwgeyBpZDogYCR7dHlwZX0tLSR7ZGV2aWNlLmRldmljZUlkfWAsIHZhbHVlOiBkZXZpY2UuZGV2aWNlSWQsIGxhYmVsOiBkZXZpY2UubGFiZWwsIG9uQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U/LihlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG5hbWU6IHR5cGUsIHNlbGVjdGVkOiBkZXZpY2UuZGV2aWNlSWQgPT09IHNlbGVjdGVkRGV2aWNlSWQgfHwgZGV2aWNlcy5sZW5ndGggPT09IDEgfSwgZGV2aWNlLmRldmljZUlkKSk7XG4gICAgICAgICAgICB9KSldIH0pKTtcbn07XG5jb25zdCBEZXZpY2VTZWxlY3RvckRyb3Bkb3duID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBkZXZpY2VzID0gW10sIHNlbGVjdGVkRGV2aWNlSWQ6IHNlbGVjdGVkRGV2aWNlRnJvbVByb3BzLCB0aXRsZSwgb25DaGFuZ2UsIGljb24sIH0gPSBwcm9wcztcbiAgICAvLyBzb21ldGltZXMgdGhlIGJyb3dzZXIgKENocm9tZSkgd2lsbCByZXBvcnQgdGhlIHN5c3RlbS1kZWZhdWx0IGRldmljZVxuICAgIC8vIHdpdGggYW4gaWQgb2YgJ2RlZmF1bHQnLiBJbiBjYXNlIHdoZW4gaXQgZG9lc24ndCwgd2UnbGwgc2VsZWN0IHRoZSBmaXJzdFxuICAgIC8vIGF2YWlsYWJsZSBkZXZpY2UuXG4gICAgbGV0IHNlbGVjdGVkRGV2aWNlSWQgPSBzZWxlY3RlZERldmljZUZyb21Qcm9wcztcbiAgICBpZiAoZGV2aWNlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICFkZXZpY2VzLmZpbmQoKGQpID0+IGQuZGV2aWNlSWQgPT09IHNlbGVjdGVkRGV2aWNlSWQpKSB7XG4gICAgICAgIHNlbGVjdGVkRGV2aWNlSWQgPSBkZXZpY2VzWzBdLmRldmljZUlkO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gZGV2aWNlcy5maW5kSW5kZXgoKGQpID0+IGQuZGV2aWNlSWQgPT09IHNlbGVjdGVkRGV2aWNlSWQpO1xuICAgIGNvbnN0IGhhbmRsZVNlbGVjdCA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4ge1xuICAgICAgICBvbkNoYW5nZT8uKGRldmljZXNbaW5kZXhdLmRldmljZUlkKTtcbiAgICB9LCBbZGV2aWNlcywgb25DaGFuZ2VdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX2RldmljZS1raW5kXCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzX19kZXZpY2Utc2VsZWN0b3ItdGl0bGVcIiwgY2hpbGRyZW46IHRpdGxlIH0pLCBqc3goRHJvcERvd25TZWxlY3QsIHsgaWNvbjogaWNvbiwgZGVmYXVsdFNlbGVjdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXgsIGRlZmF1bHRTZWxlY3RlZExhYmVsOiBkZXZpY2VzW3NlbGVjdGVkSW5kZXhdPy5sYWJlbCwgaGFuZGxlU2VsZWN0OiBoYW5kbGVTZWxlY3QsIGNoaWxkcmVuOiBkZXZpY2VzLm1hcCgoZGV2aWNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoanN4KERyb3BEb3duU2VsZWN0T3B0aW9uLCB7IGljb246IGljb24sIGxhYmVsOiBkZXZpY2UubGFiZWwsIHNlbGVjdGVkOiBkZXZpY2UuZGV2aWNlSWQgPT09IHNlbGVjdGVkRGV2aWNlSWQgfHwgZGV2aWNlcy5sZW5ndGggPT09IDEgfSwgZGV2aWNlLmRldmljZUlkKSk7XG4gICAgICAgICAgICAgICAgfSkgfSldIH0pKTtcbn07XG5jb25zdCBEZXZpY2VTZWxlY3RvciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdmlzdWFsVHlwZSA9ICdsaXN0JywgaWNvbiwgcGxhY2Vob2xkZXIsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGlmICh2aXN1YWxUeXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgcmV0dXJuIGpzeChEZXZpY2VTZWxlY3Rvckxpc3QsIHsgLi4ucmVzdCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goRGV2aWNlU2VsZWN0b3JEcm9wZG93biwgeyAuLi5yZXN0LCBpY29uOiBpY29uLCBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIgfSkpO1xufTtcblxuY29uc3QgRGV2aWNlU2VsZWN0b3JBdWRpb0lucHV0ID0gKHsgdGl0bGUsIHZpc3VhbFR5cGUsIH0pID0+IHtcbiAgICBjb25zdCB7IHVzZU1pY3JvcGhvbmVTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IG1pY3JvcGhvbmUsIHNlbGVjdGVkRGV2aWNlLCBkZXZpY2VzIH0gPSB1c2VNaWNyb3Bob25lU3RhdGUoKTtcbiAgICByZXR1cm4gKGpzeChEZXZpY2VTZWxlY3RvciwgeyBkZXZpY2VzOiBkZXZpY2VzIHx8IFtdLCBzZWxlY3RlZERldmljZUlkOiBzZWxlY3RlZERldmljZSwgdHlwZTogXCJhdWRpb2lucHV0XCIsIG9uQ2hhbmdlOiBhc3luYyAoZGV2aWNlSWQpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IG1pY3JvcGhvbmUuc2VsZWN0KGRldmljZUlkKTtcbiAgICAgICAgfSwgdGl0bGU6IHRpdGxlLCB2aXN1YWxUeXBlOiB2aXN1YWxUeXBlLCBpY29uOiBcIm1pY1wiIH0pKTtcbn07XG5jb25zdCBEZXZpY2VTZWxlY3RvckF1ZGlvT3V0cHV0ID0gKHsgdGl0bGUsIHZpc3VhbFR5cGUsIH0pID0+IHtcbiAgICBjb25zdCB7IHVzZVNwZWFrZXJTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IHNwZWFrZXIsIHNlbGVjdGVkRGV2aWNlLCBkZXZpY2VzLCBpc0RldmljZVNlbGVjdGlvblN1cHBvcnRlZCB9ID0gdXNlU3BlYWtlclN0YXRlKCk7XG4gICAgaWYgKCFpc0RldmljZVNlbGVjdGlvblN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3goRGV2aWNlU2VsZWN0b3IsIHsgZGV2aWNlczogZGV2aWNlcywgdHlwZTogXCJhdWRpb291dHB1dFwiLCBzZWxlY3RlZERldmljZUlkOiBzZWxlY3RlZERldmljZSwgb25DaGFuZ2U6IChkZXZpY2VJZCkgPT4ge1xuICAgICAgICAgICAgc3BlYWtlci5zZWxlY3QoZGV2aWNlSWQpO1xuICAgICAgICB9LCB0aXRsZTogdGl0bGUsIHZpc3VhbFR5cGU6IHZpc3VhbFR5cGUsIGljb246IFwic3BlYWtlclwiIH0pKTtcbn07XG5cbmNvbnN0IERldmljZVNlbGVjdG9yVmlkZW8gPSAoeyB0aXRsZSwgdmlzdWFsVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlQ2FtZXJhU3RhdGUgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgeyBjYW1lcmEsIGRldmljZXMsIHNlbGVjdGVkRGV2aWNlIH0gPSB1c2VDYW1lcmFTdGF0ZSgpO1xuICAgIHJldHVybiAoanN4KERldmljZVNlbGVjdG9yLCB7IGRldmljZXM6IGRldmljZXMgfHwgW10sIHR5cGU6IFwidmlkZW9pbnB1dFwiLCBzZWxlY3RlZERldmljZUlkOiBzZWxlY3RlZERldmljZSwgb25DaGFuZ2U6IGFzeW5jIChkZXZpY2VJZCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgY2FtZXJhLnNlbGVjdChkZXZpY2VJZCk7XG4gICAgICAgIH0sIHRpdGxlOiB0aXRsZSwgdmlzdWFsVHlwZTogdmlzdWFsVHlwZSwgaWNvbjogXCJjYW1lcmFcIiB9KSk7XG59O1xuXG5jb25zdCBEZXZpY2VTZXR0aW5ncyA9ICh7IHZpc3VhbFR5cGUgPSBNZW51VmlzdWFsVHlwZS5NRU5VLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goTWVudVRvZ2dsZSwgeyBwbGFjZW1lbnQ6IFwiYm90dG9tLWVuZFwiLCBUb2dnbGVCdXR0b246IFRvZ2dsZURldmljZVNldHRpbmdzTWVudUJ1dHRvbiwgdmlzdWFsVHlwZTogdmlzdWFsVHlwZSwgY2hpbGRyZW46IGpzeChNZW51LCB7fSkgfSkpO1xufTtcbmNvbnN0IE1lbnUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzXCIsIGNoaWxkcmVuOiBbanN4KERldmljZVNlbGVjdG9yVmlkZW8sIHsgdGl0bGU6IHQoJ1NlbGVjdCBhIENhbWVyYScpIH0pLCBqc3goRGV2aWNlU2VsZWN0b3JBdWRpb0lucHV0LCB7IHRpdGxlOiB0KCdTZWxlY3QgYSBNaWMnKSB9KSwganN4KERldmljZVNlbGVjdG9yQXVkaW9PdXRwdXQsIHsgdGl0bGU6IHQoJ1NlbGVjdCBTcGVha2VycycpIH0pXSB9KSk7XG59O1xuY29uc3QgVG9nZ2xlRGV2aWNlU2V0dGluZ3NNZW51QnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBUb2dnbGVEZXZpY2VTZXR0aW5nc01lbnVCdXR0b24oeyBtZW51U2hvd24gfSwgcmVmKSB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goSWNvbkJ1dHRvbiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzX19idXR0b24nLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX2J1dHRvbi0tYWN0aXZlJzogbWVudVNob3duLFxuICAgICAgICB9KSwgdGl0bGU6IHQoJ1RvZ2dsZSBkZXZpY2UgbWVudScpLCBpY29uOiBcImRldmljZS1zZXR0aW5nc1wiLCByZWY6IHJlZiB9KSk7XG59KTtcblxuY29uc3QgVG9nZ2xlQXVkaW9QcmV2aWV3QnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjYXB0aW9uLCBNZW51LCBtZW51UGxhY2VtZW50LCAuLi5yZXN0Q29tcG9zaXRlQnV0dG9uUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdXNlTWljcm9waG9uZVN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgbWljcm9waG9uZSwgaXNNdXRlLCBoYXNCcm93c2VyUGVybWlzc2lvbiB9ID0gdXNlTWljcm9waG9uZVN0YXRlKCk7XG4gICAgcmV0dXJuIChqc3hzKENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzTXV0ZSwgY2FwdGlvbjogY2FwdGlvbiwgY2xhc3NOYW1lOiBjbHN4KCFoYXNCcm93c2VyUGVybWlzc2lvbiAmJiAnc3RyLXZpZGVvX19kZXZpY2UtdW5hdmFpbGFibGUnKSwgdmFyaWFudDogXCJzZWNvbmRhcnlcIiwgdGl0bGU6ICFoYXNCcm93c2VyUGVybWlzc2lvblxuICAgICAgICAgICAgPyB0KCdDaGVjayB5b3VyIGJyb3dzZXIgYXVkaW8gcGVybWlzc2lvbnMnKVxuICAgICAgICAgICAgOiBjYXB0aW9uIHx8IHQoJ01pYycpLCBkaXNhYmxlZDogIWhhc0Jyb3dzZXJQZXJtaXNzaW9uLCBcImRhdGEtdGVzdGlkXCI6IGlzTXV0ZSA/ICdwcmV2aWV3LWF1ZGlvLXVubXV0ZS1idXR0b24nIDogJ3ByZXZpZXctYXVkaW8tbXV0ZS1idXR0b24nLCBvbkNsaWNrOiAoKSA9PiBtaWNyb3Bob25lLnRvZ2dsZSgpLCBNZW51OiBNZW51LCBtZW51UGxhY2VtZW50OiBtZW51UGxhY2VtZW50LCAuLi5yZXN0Q29tcG9zaXRlQnV0dG9uUHJvcHMsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogIWlzTXV0ZSA/ICdtaWMnIDogJ21pYy1vZmYnIH0pLCAhaGFzQnJvd3NlclBlcm1pc3Npb24gJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19uby1tZWRpYS1wZXJtaXNzaW9uXCIsIHRpdGxlOiB0KCdDaGVjayB5b3VyIGJyb3dzZXIgYXVkaW8gcGVybWlzc2lvbnMnKSwgY2hpbGRyZW46IFwiIVwiIH0pKV0gfSkpO1xufTtcbmNvbnN0IFRvZ2dsZUF1ZGlvUHVibGlzaGluZ0J1dHRvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgY2FwdGlvbiwgTWVudSA9IGpzeChEZXZpY2VTZWxlY3RvckF1ZGlvSW5wdXQsIHsgdmlzdWFsVHlwZTogXCJsaXN0XCIgfSksIG1lbnVQbGFjZW1lbnQgPSAndG9wJywgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGhhc1Blcm1pc3Npb24sIHJlcXVlc3RQZXJtaXNzaW9uLCBpc0F3YWl0aW5nUGVybWlzc2lvbiB9ID0gdXNlUmVxdWVzdFBlcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPKTtcbiAgICBjb25zdCB7IHVzZU1pY3JvcGhvbmVTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IG1pY3JvcGhvbmUsIGlzTXV0ZSwgaGFzQnJvd3NlclBlcm1pc3Npb24gfSA9IHVzZU1pY3JvcGhvbmVTdGF0ZSgpO1xuICAgIHJldHVybiAoanN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LlNFTkRfQVVESU9dLCBjaGlsZHJlbjoganN4KFBlcm1pc3Npb25Ob3RpZmljYXRpb24sIHsgcGVybWlzc2lvbjogT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPLCBpc0F3YWl0aW5nQXBwcm92YWw6IGlzQXdhaXRpbmdQZXJtaXNzaW9uLCBtZXNzYWdlQXBwcm92ZWQ6IHQoJ1lvdSBjYW4gbm93IHNwZWFrLicpLCBtZXNzYWdlQXdhaXRpbmdBcHByb3ZhbDogdCgnQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNwZWFrLicpLCBtZXNzYWdlUmV2b2tlZDogdCgnWW91IGNhbiBubyBsb25nZXIgc3BlYWsuJyksIGNoaWxkcmVuOiBqc3hzKENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzTXV0ZSwgY2FwdGlvbjogY2FwdGlvbiwgdGl0bGU6ICFoYXNQZXJtaXNzaW9uXG4gICAgICAgICAgICAgICAgICAgID8gdCgnWW91IGhhdmUgbm8gcGVybWlzc2lvbiB0byBzaGFyZSB5b3VyIGF1ZGlvJylcbiAgICAgICAgICAgICAgICAgICAgOiAhaGFzQnJvd3NlclBlcm1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgID8gdCgnQ2hlY2sgeW91ciBicm93c2VyIG1pYyBwZXJtaXNzaW9ucycpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNhcHRpb24gfHwgdCgnTWljJyksIHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIGRpc2FibGVkOiAhaGFzQnJvd3NlclBlcm1pc3Npb24gfHwgIWhhc1Blcm1pc3Npb24sIFwiZGF0YS10ZXN0aWRcIjogaXNNdXRlID8gJ2F1ZGlvLXVubXV0ZS1idXR0b24nIDogJ2F1ZGlvLW11dGUtYnV0dG9uJywgb25DbGljazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBtaWNyb3Bob25lLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgTWVudTogTWVudSwgbWVudVBsYWNlbWVudDogbWVudVBsYWNlbWVudCwgbWVudU9mZnNldDogMTYsIC4uLnJlc3RDb21wb3NpdGVCdXR0b25Qcm9wcywgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBpc011dGUgPyAnbWljLW9mZicgOiAnbWljJyB9KSwgKCFoYXNCcm93c2VyUGVybWlzc2lvbiB8fCAhaGFzUGVybWlzc2lvbikgJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19uby1tZWRpYS1wZXJtaXNzaW9uXCIsIGNoaWxkcmVuOiBcIiFcIiB9KSldIH0pIH0pIH0pKTtcbn07XG5cbmNvbnN0IFRvZ2dsZVZpZGVvUHJldmlld0J1dHRvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2FwdGlvbiwgTWVudSA9IERldmljZVNlbGVjdG9yVmlkZW8sIG1lbnVQbGFjZW1lbnQgPSAndG9wJywgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IHVzZUNhbWVyYVN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgY2FtZXJhLCBpc011dGUsIGhhc0Jyb3dzZXJQZXJtaXNzaW9uIH0gPSB1c2VDYW1lcmFTdGF0ZSgpO1xuICAgIHJldHVybiAoanN4cyhDb21wb3NpdGVCdXR0b24sIHsgYWN0aXZlOiBpc011dGUsIGNhcHRpb246IGNhcHRpb24sIGNsYXNzTmFtZTogY2xzeCghaGFzQnJvd3NlclBlcm1pc3Npb24gJiYgJ3N0ci12aWRlb19fZGV2aWNlLXVuYXZhaWxhYmxlJyksIHRpdGxlOiAhaGFzQnJvd3NlclBlcm1pc3Npb25cbiAgICAgICAgICAgID8gdCgnQ2hlY2sgeW91ciBicm93c2VyIHZpZGVvIHBlcm1pc3Npb25zJylcbiAgICAgICAgICAgIDogY2FwdGlvbiB8fCB0KCdWaWRlbycpLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCBcImRhdGEtdGVzdGlkXCI6IGlzTXV0ZSA/ICdwcmV2aWV3LXZpZGVvLXVubXV0ZS1idXR0b24nIDogJ3ByZXZpZXctdmlkZW8tbXV0ZS1idXR0b24nLCBvbkNsaWNrOiAoKSA9PiBjYW1lcmEudG9nZ2xlKCksIGRpc2FibGVkOiAhaGFzQnJvd3NlclBlcm1pc3Npb24sIE1lbnU6IE1lbnUsIG1lbnVQbGFjZW1lbnQ6IG1lbnVQbGFjZW1lbnQsIC4uLnJlc3RDb21wb3NpdGVCdXR0b25Qcm9wcywgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiAhaXNNdXRlID8gJ2NhbWVyYScgOiAnY2FtZXJhLW9mZicgfSksICFoYXNCcm93c2VyUGVybWlzc2lvbiAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX25vLW1lZGlhLXBlcm1pc3Npb25cIiwgdGl0bGU6IHQoJ0NoZWNrIHlvdXIgYnJvd3NlciB2aWRlbyBwZXJtaXNzaW9ucycpLCBjaGlsZHJlbjogXCIhXCIgfSkpXSB9KSk7XG59O1xuY29uc3QgVG9nZ2xlVmlkZW9QdWJsaXNoaW5nQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyBjYXB0aW9uLCBNZW51ID0ganN4KERldmljZVNlbGVjdG9yVmlkZW8sIHsgdmlzdWFsVHlwZTogXCJsaXN0XCIgfSksIG1lbnVQbGFjZW1lbnQgPSAndG9wJywgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGhhc1Blcm1pc3Npb24sIHJlcXVlc3RQZXJtaXNzaW9uLCBpc0F3YWl0aW5nUGVybWlzc2lvbiB9ID0gdXNlUmVxdWVzdFBlcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5TRU5EX1ZJREVPKTtcbiAgICBjb25zdCB7IHVzZUNhbWVyYVN0YXRlLCB1c2VDYWxsU2V0dGluZ3MgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgeyBjYW1lcmEsIGlzTXV0ZSwgaGFzQnJvd3NlclBlcm1pc3Npb24gfSA9IHVzZUNhbWVyYVN0YXRlKCk7XG4gICAgY29uc3QgY2FsbFNldHRpbmdzID0gdXNlQ2FsbFNldHRpbmdzKCk7XG4gICAgY29uc3QgaXNQdWJsaXNoaW5nVmlkZW9BbGxvd2VkID0gY2FsbFNldHRpbmdzPy52aWRlby5lbmFibGVkO1xuICAgIHJldHVybiAoanN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LlNFTkRfVklERU9dLCBjaGlsZHJlbjoganN4KFBlcm1pc3Npb25Ob3RpZmljYXRpb24sIHsgcGVybWlzc2lvbjogT3duQ2FwYWJpbGl0eS5TRU5EX1ZJREVPLCBpc0F3YWl0aW5nQXBwcm92YWw6IGlzQXdhaXRpbmdQZXJtaXNzaW9uLCBtZXNzYWdlQXBwcm92ZWQ6IHQoJ1lvdSBjYW4gbm93IHNoYXJlIHlvdXIgdmlkZW8uJyksIG1lc3NhZ2VBd2FpdGluZ0FwcHJvdmFsOiB0KCdBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc2hhcmUgeW91ciB2aWRlby4nKSwgbWVzc2FnZVJldm9rZWQ6IHQoJ1lvdSBjYW4gbm8gbG9uZ2VyIHNoYXJlIHlvdXIgdmlkZW8uJyksIGNoaWxkcmVuOiBqc3hzKENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzTXV0ZSwgY2FwdGlvbjogY2FwdGlvbiwgdmFyaWFudDogXCJzZWNvbmRhcnlcIiwgdGl0bGU6ICFoYXNQZXJtaXNzaW9uXG4gICAgICAgICAgICAgICAgICAgID8gdCgnWW91IGhhdmUgbm8gcGVybWlzc2lvbiB0byBzaGFyZSB5b3VyIHZpZGVvJylcbiAgICAgICAgICAgICAgICAgICAgOiAhaGFzQnJvd3NlclBlcm1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgID8gdCgnQ2hlY2sgeW91ciBicm93c2VyIHZpZGVvIHBlcm1pc3Npb25zJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogIWlzUHVibGlzaGluZ1ZpZGVvQWxsb3dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdCgnVmlkZW8gcHVibGlzaGluZyBpcyBkaXNhYmxlZCBieSB0aGUgc3lzdGVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhcHRpb24gfHwgdCgnVmlkZW8nKSwgZGlzYWJsZWQ6ICFoYXNCcm93c2VyUGVybWlzc2lvbiB8fCAhaGFzUGVybWlzc2lvbiB8fCAhaXNQdWJsaXNoaW5nVmlkZW9BbGxvd2VkLCBcImRhdGEtdGVzdGlkXCI6IGlzTXV0ZSA/ICd2aWRlby11bm11dGUtYnV0dG9uJyA6ICd2aWRlby1tdXRlLWJ1dHRvbicsIG9uQ2xpY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXF1ZXN0UGVybWlzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FtZXJhLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgTWVudTogTWVudSwgbWVudVBsYWNlbWVudDogbWVudVBsYWNlbWVudCwgbWVudU9mZnNldDogMTYsIC4uLnJlc3RDb21wb3NpdGVCdXR0b25Qcm9wcywgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBpc011dGUgPyAnY2FtZXJhLW9mZicgOiAnY2FtZXJhJyB9KSwgKCFoYXNCcm93c2VyUGVybWlzc2lvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWhhc1Blcm1pc3Npb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc1B1Ymxpc2hpbmdWaWRlb0FsbG93ZWQpICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbm8tbWVkaWEtcGVybWlzc2lvblwiLCBjaGlsZHJlbjogXCIhXCIgfSkpXSB9KSB9KSB9KSk7XG59O1xuXG5jb25zdCBFbmRDYWxsTWVudSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgb25MZWF2ZSwgb25FbmQgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2VuZC1jYWxsX19jb25maXJtYXRpb25cIiwgY2hpbGRyZW46IFtqc3hzKFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fYnV0dG9uIHN0ci12aWRlb19fZW5kLWNhbGxfX2xlYXZlXCIsIHR5cGU6IFwiYnV0dG9uXCIsIFwiZGF0YS10ZXN0aWRcIjogXCJsZWF2ZS1jYWxsLWJ1dHRvblwiLCBvbkNsaWNrOiBvbkxlYXZlLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2J1dHRvbl9faWNvbiBzdHItdmlkZW9fX2VuZC1jYWxsX19sZWF2ZS1pY29uXCIsIGljb246IFwibG9nb3V0XCIgfSksIHQoJ0xlYXZlIGNhbGwnKV0gfSksIGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5FTkRfQ0FMTF0sIGNoaWxkcmVuOiBqc3hzKFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fYnV0dG9uIHN0ci12aWRlb19fZW5kLWNhbGxfX2VuZFwiLCB0eXBlOiBcImJ1dHRvblwiLCBcImRhdGEtdGVzdGlkXCI6IFwiZW5kLWNhbGwtZm9yLWFsbC1idXR0b25cIiwgb25DbGljazogb25FbmQsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fYnV0dG9uX19pY29uIHN0ci12aWRlb19fZW5kLWNhbGxfX2VuZC1pY29uXCIsIGljb246IFwiY2FsbC1lbmRcIiB9KSwgdCgnRW5kIGNhbGwgZm9yIGFsbCcpXSB9KSB9KV0gfSkpO1xufTtcbmNvbnN0IENhbmNlbENhbGxUb2dnbGVNZW51QnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBDYW5jZWxDYWxsVG9nZ2xlTWVudUJ1dHRvbihwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goSWNvbkJ1dHRvbiwgeyBpY29uOiBcImNhbGwtZW5kXCIsIHZhcmlhbnQ6IFwiZGFuZ2VyXCIsIHRpdGxlOiB0KCdMZWF2ZSBjYWxsJyksIFwiZGF0YS10ZXN0aWRcIjogXCJsZWF2ZS1jYWxsLWJ1dHRvblwiLCByZWY6IHJlZiB9KSk7XG59KTtcbmNvbnN0IENhbmNlbENhbGxDb25maXJtQnV0dG9uID0gKHsgb25DbGljaywgb25MZWF2ZSwgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgaGFuZGxlTGVhdmUgPSB1c2VDYWxsYmFjayhhc3luYyAoZSkgPT4ge1xuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgb25DbGljayhlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWxsKSB7XG4gICAgICAgICAgICBhd2FpdCBjYWxsLmxlYXZlKCk7XG4gICAgICAgICAgICBvbkxlYXZlPy4oKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrLCBvbkxlYXZlLCBjYWxsXSk7XG4gICAgY29uc3QgaGFuZGxlRW5kQ2FsbCA9IHVzZUNhbGxiYWNrKGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGwpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGwuZW5kQ2FsbCgpO1xuICAgICAgICAgICAgb25MZWF2ZT8uKCk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbGljaywgb25MZWF2ZSwgY2FsbF0pO1xuICAgIHJldHVybiAoanN4KE1lbnVUb2dnbGUsIHsgcGxhY2VtZW50OiBcInRvcC1zdGFydFwiLCBUb2dnbGVCdXR0b246IENhbmNlbENhbGxUb2dnbGVNZW51QnV0dG9uLCBjaGlsZHJlbjoganN4KEVuZENhbGxNZW51LCB7IG9uRW5kOiBoYW5kbGVFbmRDYWxsLCBvbkxlYXZlOiBoYW5kbGVMZWF2ZSB9KSB9KSk7XG59O1xuY29uc3QgQ2FuY2VsQ2FsbEJ1dHRvbiA9ICh7IGRpc2FibGVkLCBvbkNsaWNrLCBvbkxlYXZlLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGwpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGwubGVhdmUoKTtcbiAgICAgICAgICAgIG9uTGVhdmU/LigpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2ssIG9uTGVhdmUsIGNhbGxdKTtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGRpc2FibGVkOiBkaXNhYmxlZCwgaWNvbjogXCJjYWxsLWVuZFwiLCB2YXJpYW50OiBcImRhbmdlclwiLCB0aXRsZTogdCgnTGVhdmUgY2FsbCcpLCBcImRhdGEtdGVzdGlkXCI6IFwiY2FuY2VsLWNhbGwtYnV0dG9uXCIsIG9uQ2xpY2s6IGhhbmRsZUNsaWNrIH0pKTtcbn07XG5cbmNvbnN0IENhbGxDb250cm9scyA9ICh7IG9uTGVhdmUgfSkgPT4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLWNvbnRyb2xzXCIsIGNoaWxkcmVuOiBbanN4KFJlY29yZENhbGxCdXR0b24sIHt9KSwganN4KFJlYWN0aW9uc0J1dHRvbiwge30pLCBqc3goU2NyZWVuU2hhcmVCdXR0b24sIHt9KSwganN4KFNwZWFraW5nV2hpbGVNdXRlZE5vdGlmaWNhdGlvbiwgeyBjaGlsZHJlbjoganN4KFRvZ2dsZUF1ZGlvUHVibGlzaGluZ0J1dHRvbiwge30pIH0pLCBqc3goVG9nZ2xlVmlkZW9QdWJsaXNoaW5nQnV0dG9uLCB7fSksIGpzeChDYW5jZWxDYWxsQnV0dG9uLCB7IG9uTGVhdmU6IG9uTGVhdmUgfSldIH0pKTtcblxuQ2hhcnQucmVnaXN0ZXIoQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQpO1xuY29uc3QgQ2FsbFN0YXRzTGF0ZW5jeUNoYXJ0ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB2YWx1ZXMgfSA9IHByb3BzO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGxhYmVsczogdmFsdWVzLm1hcCgocG9pbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShwb2ludC54ICogMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7ZGF0ZS5nZXRIb3VycygpfToke2RhdGUuZ2V0TWludXRlcygpfWA7XG4gICAgICAgIH0pLFxuICAgICAgICBkYXRhc2V0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcy5tYXAoKHBvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyMwMGUyYTEnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMwMGUyYTEnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IE1hdGgubWF4KDE4MCwgTWF0aC5jZWlsKChtYXggKyAxMCkgLyAxMCkgKiAxMCksXG4gICAgICAgICAgICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyM5NzljYTAnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFNpemU6IDMwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFttYXhdKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHMtbGluZS1jaGFydC1jb250YWluZXJcIiwgY2hpbGRyZW46IGpzeChMaW5lLCB7IG9wdGlvbnM6IG9wdGlvbnMsIGRhdGE6IGRhdGEsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2xhdGVuY3ljaGFydFwiIH0pIH0pKTtcbn07XG5cbnZhciBTdGF0dXNlcztcbihmdW5jdGlvbiAoU3RhdHVzZXMpIHtcbiAgICBTdGF0dXNlc1tcIkdPT0RcIl0gPSBcIkdvb2RcIjtcbiAgICBTdGF0dXNlc1tcIk9LXCJdID0gXCJPa1wiO1xuICAgIFN0YXR1c2VzW1wiQkFEXCJdID0gXCJCYWRcIjtcbn0pKFN0YXR1c2VzIHx8IChTdGF0dXNlcyA9IHt9KSk7XG5jb25zdCBzdGF0c1N0YXR1cyA9ICh7IHZhbHVlLCBsb3dCb3VuZCwgaGlnaEJvdW5kLCB9KSA9PiB7XG4gICAgaWYgKHZhbHVlIDw9IGxvd0JvdW5kKSB7XG4gICAgICAgIHJldHVybiBTdGF0dXNlcy5HT09EO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gbG93Qm91bmQgJiYgdmFsdWUgPD0gaGlnaEJvdW5kKSB7XG4gICAgICAgIHJldHVybiBTdGF0dXNlcy5PSztcbiAgICB9XG4gICAgaWYgKHZhbHVlID49IGhpZ2hCb3VuZCkge1xuICAgICAgICByZXR1cm4gU3RhdHVzZXMuQkFEO1xuICAgIH1cbiAgICByZXR1cm4gU3RhdHVzZXMuR09PRDtcbn07XG5jb25zdCBDYWxsU3RhdHMgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGxhdGVuY3lMb3dCb3VuZCA9IDc1LCBsYXRlbmN5SGlnaEJvdW5kID0gNDAwIH0gPSBwcm9wcztcbiAgICBjb25zdCBbbGF0ZW5jeUJ1ZmZlciwgc2V0TGF0ZW5jeUJ1ZmZlcl0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyMCB9LCAoXywgaSkgPT4gKHsgeDogbm93ICsgaSwgeTogMCB9KSk7XG4gICAgfSk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgW3B1Ymxpc2hCaXRyYXRlLCBzZXRQdWJsaXNoQml0cmF0ZV0gPSB1c2VTdGF0ZSgnLScpO1xuICAgIGNvbnN0IFtzdWJzY3JpYmVCaXRyYXRlLCBzZXRTdWJzY3JpYmVCaXRyYXRlXSA9IHVzZVN0YXRlKCctJyk7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0cyA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHsgdXNlQ2FsbFN0YXRzUmVwb3J0IH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGNhbGxTdGF0c1JlcG9ydCA9IHVzZUNhbGxTdGF0c1JlcG9ydCgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FsbFN0YXRzUmVwb3J0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXByZXZpb3VzU3RhdHMuY3VycmVudCkge1xuICAgICAgICAgICAgcHJldmlvdXNTdGF0cy5jdXJyZW50ID0gY2FsbFN0YXRzUmVwb3J0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ2FsbFN0YXRzUmVwb3J0ID0gcHJldmlvdXNTdGF0cy5jdXJyZW50O1xuICAgICAgICBzZXRQdWJsaXNoQml0cmF0ZSgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlUHVibGlzaEJpdHJhdGUocHJldmlvdXNDYWxsU3RhdHNSZXBvcnQsIGNhbGxTdGF0c1JlcG9ydCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRTdWJzY3JpYmVCaXRyYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVTdWJzY3JpYmVCaXRyYXRlKHByZXZpb3VzQ2FsbFN0YXRzUmVwb3J0LCBjYWxsU3RhdHNSZXBvcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0TGF0ZW5jeUJ1ZmZlcigobGF0ZW5jeUJ1ZikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3TGF0ZW5jeUJ1ZmZlciA9IGxhdGVuY3lCdWYuc2xpY2UoLTE5KTtcbiAgICAgICAgICAgIG5ld0xhdGVuY3lCdWZmZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogY2FsbFN0YXRzUmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICB5OiBjYWxsU3RhdHNSZXBvcnQucHVibGlzaGVyU3RhdHMuYXZlcmFnZVJvdW5kVHJpcFRpbWVJbk1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3TGF0ZW5jeUJ1ZmZlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzU3RhdHMuY3VycmVudCA9IGNhbGxTdGF0c1JlcG9ydDtcbiAgICB9LCBbY2FsbFN0YXRzUmVwb3J0XSk7XG4gICAgY29uc3QgbGF0ZW5jeUNvbXBhcmlzb24gPSB7XG4gICAgICAgIGxvd0JvdW5kOiBsYXRlbmN5TG93Qm91bmQsXG4gICAgICAgIGhpZ2hCb3VuZDogbGF0ZW5jeUhpZ2hCb3VuZCxcbiAgICAgICAgdmFsdWU6IGNhbGxTdGF0c1JlcG9ydD8ucHVibGlzaGVyU3RhdHMuYXZlcmFnZVJvdW5kVHJpcFRpbWVJbk1zIHx8IDAsXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNcIiwgY2hpbGRyZW46IGNhbGxTdGF0c1JlcG9ydCAmJiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19oZWFkZXJcIiwgY2hpbGRyZW46IFtqc3hzKFwiaDNcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19oZWFkaW5nXCIsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19faWNvblwiLCBpY29uOiBcImNhbGwtbGF0ZW5jeVwiIH0pLCB0KCdDYWxsIExhdGVuY3knKV0gfSksIGpzeChcInBcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19kZXNjcmlwdGlvblwiLCBjaGlsZHJlbjogdCgnVmVyeSBoaWdoIGxhdGVuY3kgdmFsdWVzIG1heSByZWR1Y2UgY2FsbCBxdWFsaXR5LCBjYXVzZSBsYWcsIGFuZCBtYWtlIHRoZSBjYWxsIGxlc3MgZW5qb3lhYmxlLicpIH0pXSB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19fbGF0ZW5jeWNoYXJ0XCIsIGNoaWxkcmVuOiBqc3goQ2FsbFN0YXRzTGF0ZW5jeUNoYXJ0LCB7IHZhbHVlczogbGF0ZW5jeUJ1ZmZlciB9KSB9KSwganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2hlYWRlclwiLCBjaGlsZHJlbjogW2pzeHMoXCJoM1wiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2hlYWRpbmdcIiwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19pY29uXCIsIGljb246IFwibmV0d29yay1xdWFsaXR5XCIgfSksIHQoJ0NhbGwgcGVyZm9ybWFuY2UnKV0gfSksIGpzeChcInBcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19kZXNjcmlwdGlvblwiLCBjaGlsZHJlbjogdCgnVmVyeSBoaWdoIGxhdGVuY3kgdmFsdWVzIG1heSByZWR1Y2UgY2FsbCBxdWFsaXR5LCBjYXVzZSBsYWcsIGFuZCBtYWtlIHRoZSBjYWxsIGxlc3MgZW5qb3lhYmxlLicpIH0pXSB9KSwganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2NhcmQtY29udGFpbmVyXCIsIGNoaWxkcmVuOiBbanN4KFN0YXRDYXJkLCB7IGxhYmVsOiBcIlJlZ2lvblwiLCB2YWx1ZTogY2FsbFN0YXRzUmVwb3J0LmRhdGFjZW50ZXIgfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJMYXRlbmN5XCIsIHZhbHVlOiBgJHtjYWxsU3RhdHNSZXBvcnQucHVibGlzaGVyU3RhdHMuYXZlcmFnZVJvdW5kVHJpcFRpbWVJbk1zfSBtcy5gLCBjb21wYXJpc29uOiBsYXRlbmN5Q29tcGFyaXNvbiB9KSwganN4KFN0YXRDYXJkLCB7IGxhYmVsOiBcIlJlY2VpdmUgaml0dGVyXCIsIHZhbHVlOiBgJHtjYWxsU3RhdHNSZXBvcnQuc3Vic2NyaWJlclN0YXRzLmF2ZXJhZ2VKaXR0ZXJJbk1zfSBtcy5gLCBjb21wYXJpc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmxhdGVuY3lDb21wYXJpc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2FsbFN0YXRzUmVwb3J0LnN1YnNjcmliZXJTdGF0cy5hdmVyYWdlSml0dGVySW5NcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUHVibGlzaCBqaXR0ZXJcIiwgdmFsdWU6IGAke2NhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlSml0dGVySW5Nc30gbXMuYCwgY29tcGFyaXNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5sYXRlbmN5Q29tcGFyaXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlSml0dGVySW5NcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUHVibGlzaCByZXNvbHV0aW9uXCIsIHZhbHVlOiB0b0ZyYW1lU2l6ZShjYWxsU3RhdHNSZXBvcnQucHVibGlzaGVyU3RhdHMpIH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUHVibGlzaCBxdWFsaXR5IGRyb3AgcmVhc29uXCIsIHZhbHVlOiBjYWxsU3RhdHNSZXBvcnQucHVibGlzaGVyU3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZWFzb25zIH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUmVjZWl2aW5nIHJlc29sdXRpb25cIiwgdmFsdWU6IHRvRnJhbWVTaXplKGNhbGxTdGF0c1JlcG9ydC5zdWJzY3JpYmVyU3RhdHMpIH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUmVjZWl2ZSBxdWFsaXR5IGRyb3AgcmVhc29uXCIsIHZhbHVlOiBjYWxsU3RhdHNSZXBvcnQuc3Vic2NyaWJlclN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uUmVhc29ucyB9KSwganN4KFN0YXRDYXJkLCB7IGxhYmVsOiBcIlB1Ymxpc2ggYml0cmF0ZVwiLCB2YWx1ZTogcHVibGlzaEJpdHJhdGUgfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJSZWNlaXZpbmcgYml0cmF0ZVwiLCB2YWx1ZTogc3Vic2NyaWJlQml0cmF0ZSB9KV0gfSldIH0pKSB9KSk7XG59O1xuY29uc3QgU3RhdENhcmRFeHBsYW5hdGlvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgZGVzY3JpcHRpb24gfSA9IHByb3BzO1xuICAgIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgeyByZWZzLCBmbG9hdGluZ1N0eWxlcywgY29udGV4dCB9ID0gdXNlRmxvYXRpbmcoe1xuICAgICAgICBvcGVuOiBpc09wZW4sXG4gICAgICAgIG9uT3BlbkNoYW5nZTogc2V0SXNPcGVuLFxuICAgIH0pO1xuICAgIGNvbnN0IGhvdmVyID0gdXNlSG92ZXIoY29udGV4dCk7XG4gICAgY29uc3QgeyBnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcyB9ID0gdXNlSW50ZXJhY3Rpb25zKFtob3Zlcl0pO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtZXhwbGFuYXRpb25cIiwgcmVmOiByZWZzLnNldFJlZmVyZW5jZSwgLi4uZ2V0UmVmZXJlbmNlUHJvcHMoKSwgY2hpbGRyZW46IGpzeChJY29uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtZXhwbGFuYXRpb25fX2ljb25cIiwgaWNvbjogXCJpbmZvXCIgfSkgfSksIGlzT3BlbiAmJiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1leHBsYW5hdGlvbl9fZGVzY3JpcHRpb25cIiwgcmVmOiByZWZzLnNldEZsb2F0aW5nLCBzdHlsZTogZmxvYXRpbmdTdHlsZXMsIC4uLmdldEZsb2F0aW5nUHJvcHMoKSwgY2hpbGRyZW46IGRlc2NyaXB0aW9uIH0pKV0gfSkpO1xufTtcbmNvbnN0IFN0YXRzVGFnID0gKHsgY2hpbGRyZW4sIHN0YXR1cyA9IFN0YXR1c2VzLkdPT0QsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19jYWxsLXN0YXRzX190YWcnLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19jYWxsLXN0YXRzX190YWctLWdvb2QnOiBzdGF0dXMgPT09IFN0YXR1c2VzLkdPT0QsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19jYWxsLXN0YXRzX190YWctLW9rJzogc3RhdHVzID09PSBTdGF0dXNlcy5PSyxcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2NhbGwtc3RhdHNfX3RhZy0tYmFkJzogc3RhdHVzID09PSBTdGF0dXNlcy5CQUQsXG4gICAgICAgIH0pLCBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19fdGFnX190ZXh0XCIsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59O1xuY29uc3QgU3RhdENhcmQgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGxhYmVsLCB2YWx1ZSwgZGVzY3JpcHRpb24sIGNvbXBhcmlzb24gfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHN0YXR1cyA9IGNvbXBhcmlzb24gPyBzdGF0c1N0YXR1cyhjb21wYXJpc29uKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19jYXJkXCIsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2NhcmQtY29udGVudFwiLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19jYXJkLWxhYmVsXCIsIGNoaWxkcmVuOiBbbGFiZWwsIGRlc2NyaXB0aW9uICYmIGpzeChTdGF0Q2FyZEV4cGxhbmF0aW9uLCB7IGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9KV0gfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2NhcmQtdmFsdWVcIiwgY2hpbGRyZW46IHZhbHVlIH0pXSB9KSwgY29tcGFyaXNvbiAmJiBzdGF0dXMgJiYganN4KFN0YXRzVGFnLCB7IHN0YXR1czogc3RhdHVzLCBjaGlsZHJlbjogdChzdGF0dXMpIH0pXSB9KSk7XG59O1xuY29uc3QgdG9GcmFtZVNpemUgPSAoc3RhdHMpID0+IHtcbiAgICBjb25zdCB7IGhpZ2hlc3RGcmFtZVdpZHRoOiB3LCBoaWdoZXN0RnJhbWVIZWlnaHQ6IGgsIGhpZ2hlc3RGcmFtZXNQZXJTZWNvbmQ6IGZwcywgfSA9IHN0YXRzO1xuICAgIGxldCBzaXplID0gYC1gO1xuICAgIGlmICh3ICYmIGgpIHtcbiAgICAgICAgc2l6ZSA9IGAke3d9eCR7aH1gO1xuICAgICAgICBpZiAoZnBzKSB7XG4gICAgICAgICAgICBzaXplICs9IGBAJHtmcHN9ZnBzLmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59O1xuY29uc3QgY2FsY3VsYXRlUHVibGlzaEJpdHJhdGUgPSAocHJldmlvdXNDYWxsU3RhdHNSZXBvcnQsIGNhbGxTdGF0c1JlcG9ydCkgPT4ge1xuICAgIGNvbnN0IHsgcHVibGlzaGVyU3RhdHM6IHsgdG90YWxCeXRlc1NlbnQ6IHByZXZpb3VzVG90YWxCeXRlc1NlbnQsIHRpbWVzdGFtcDogcHJldmlvdXNUaW1lc3RhbXAsIH0sIH0gPSBwcmV2aW91c0NhbGxTdGF0c1JlcG9ydDtcbiAgICBjb25zdCB7IHB1Ymxpc2hlclN0YXRzOiB7IHRvdGFsQnl0ZXNTZW50LCB0aW1lc3RhbXAgfSwgfSA9IGNhbGxTdGF0c1JlcG9ydDtcbiAgICBjb25zdCBieXRlc1NlbnQgPSB0b3RhbEJ5dGVzU2VudCAtIHByZXZpb3VzVG90YWxCeXRlc1NlbnQ7XG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSB0aW1lc3RhbXAgLSBwcmV2aW91c1RpbWVzdGFtcDtcbiAgICByZXR1cm4gYCR7KChieXRlc1NlbnQgKiA4KSAvIHRpbWVFbGFwc2VkKS50b0ZpeGVkKDIpfSBrYnBzYDtcbn07XG5jb25zdCBjYWxjdWxhdGVTdWJzY3JpYmVCaXRyYXRlID0gKHByZXZpb3VzQ2FsbFN0YXRzUmVwb3J0LCBjYWxsU3RhdHNSZXBvcnQpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmliZXJTdGF0czogeyB0b3RhbEJ5dGVzUmVjZWl2ZWQ6IHByZXZpb3VzVG90YWxCeXRlc1JlY2VpdmVkLCB0aW1lc3RhbXA6IHByZXZpb3VzVGltZXN0YW1wLCB9LCB9ID0gcHJldmlvdXNDYWxsU3RhdHNSZXBvcnQ7XG4gICAgY29uc3QgeyBzdWJzY3JpYmVyU3RhdHM6IHsgdG90YWxCeXRlc1JlY2VpdmVkLCB0aW1lc3RhbXAgfSwgfSA9IGNhbGxTdGF0c1JlcG9ydDtcbiAgICBjb25zdCBieXRlc1JlY2VpdmVkID0gdG90YWxCeXRlc1JlY2VpdmVkIC0gcHJldmlvdXNUb3RhbEJ5dGVzUmVjZWl2ZWQ7XG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSB0aW1lc3RhbXAgLSBwcmV2aW91c1RpbWVzdGFtcDtcbiAgICByZXR1cm4gYCR7KChieXRlc1JlY2VpdmVkICogOCkgLyB0aW1lRWxhcHNlZCkudG9GaXhlZCgyKX0ga2Jwc2A7XG59O1xuXG5jb25zdCBDYWxsU3RhdHNCdXR0b24gPSAoKSA9PiAoanN4KE1lbnVUb2dnbGUsIHsgcGxhY2VtZW50OiBcInRvcC1lbmRcIiwgVG9nZ2xlQnV0dG9uOiBUb2dnbGVNZW51QnV0dG9uLCBjaGlsZHJlbjoganN4KENhbGxTdGF0cywge30pIH0pKTtcbmNvbnN0IFRvZ2dsZU1lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZU1lbnVCdXR0b24ocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgY2FwdGlvbiwgbWVudVNob3duIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGpzeChDb21wb3NpdGVCdXR0b24sIHsgcmVmOiByZWYsIGFjdGl2ZTogbWVudVNob3duLCBjYXB0aW9uOiBjYXB0aW9uLCB0aXRsZTogY2FwdGlvbiB8fCB0KCdTdGF0aXN0aWNzJyksIFwiZGF0YS10ZXN0aWRcIjogXCJzdGF0cy1idXR0b25cIiwgY2hpbGRyZW46IGpzeChJY29uLCB7IGljb246IFwic3RhdHNcIiB9KSB9KSk7XG59KTtcblxuY29uc3QgVG9nZ2xlQXVkaW9PdXRwdXRCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IGNhcHRpb24sIE1lbnUgPSBEZXZpY2VTZWxlY3RvckF1ZGlvT3V0cHV0LCBtZW51UGxhY2VtZW50ID0gJ3RvcCcsIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGpzeChDb21wb3NpdGVCdXR0b24sIHsgTWVudTogTWVudSwgbWVudVBsYWNlbWVudDogbWVudVBsYWNlbWVudCwgY2FwdGlvbjogY2FwdGlvbiwgdGl0bGU6IGNhcHRpb24gfHwgdCgnU3BlYWtlcnMnKSwgXCJkYXRhLXRlc3RpZFwiOiBcImF1ZGlvLW91dHB1dC1idXR0b25cIiwgY2hpbGRyZW46IGpzeChJY29uLCB7IGljb246IFwic3BlYWtlclwiIH0pIH0pKTtcbn07XG5cbmNvbnN0IEJsb2NrZWRVc2VyTGlzdGluZyA9ICh7IGRhdGEgfSkgPT4ge1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nXCIsIGNoaWxkcmVuOiBkYXRhLm1hcCgodXNlcklkKSA9PiAoanN4KEJsb2NrZWRVc2VyTGlzdGluZ0l0ZW0sIHsgdXNlcklkOiB1c2VySWQgfSwgdXNlcklkKSkpIH0pIH0pKTtcbn07XG5jb25zdCBCbG9ja2VkVXNlckxpc3RpbmdJdGVtID0gKHsgdXNlcklkIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHVuYmxvY2tVc2VyQ2xpY2tIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAodXNlcklkKVxuICAgICAgICAgICAgY2FsbD8udW5ibG9ja1VzZXIodXNlcklkKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbVwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9fZGlzcGxheS1uYW1lXCIsIGNoaWxkcmVuOiB1c2VySWQgfSksIGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5CTE9DS19VU0VSU10sIGNoaWxkcmVuOiBqc3goVGV4dEJ1dHRvbiwgeyBvbkNsaWNrOiB1bmJsb2NrVXNlckNsaWNrSGFuZGxlciwgY2hpbGRyZW46IFwiVW5ibG9ja1wiIH0pIH0pXSB9KSk7XG59O1xuXG5jb25zdCBDYWxsUGFydGljaXBhbnRMaXN0SGVhZGVyID0gKHsgb25DbG9zZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlUGFydGljaXBhbnRzLCB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50IH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHVzZVBhcnRpY2lwYW50cygpO1xuICAgIGNvbnN0IGFub255bW91c1BhcnRpY2lwYW50Q291bnQgPSB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50KCk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdC1oZWFkZXJcIiwgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdC1oZWFkZXJfX3RpdGxlXCIsIGNoaWxkcmVuOiBbdCgnUGFydGljaXBhbnRzJyksICcgJywganN4cyhcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0LWhlYWRlcl9fdGl0bGUtY291bnRcIiwgY2hpbGRyZW46IFtcIltcIiwgcGFydGljaXBhbnRzLmxlbmd0aCwgXCJdXCJdIH0pLCBhbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50ID4gMCAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3QtaGVhZGVyX190aXRsZS1hbm9ueW1vdXNcIiwgY2hpbGRyZW46IHQoJ0Fub255bW91cycsIHsgY291bnQ6IGFub255bW91c1BhcnRpY2lwYW50Q291bnQgfSkgfSkpXSB9KSwganN4KEljb25CdXR0b24sIHsgb25DbGljazogb25DbG9zZSwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdC1oZWFkZXJfX2Nsb3NlLWJ1dHRvblwiLCBpY29uOiBcImNsb3NlXCIgfSldIH0pKTtcbn07XG5cbmNvbnN0IFRvb2x0aXAgPSAoeyBjaGlsZHJlbiwgcmVmZXJlbmNlRWxlbWVudCwgdG9vbHRpcENsYXNzTmFtZSwgdG9vbHRpcFBsYWNlbWVudCA9ICd0b3AnLCB2aXNpYmxlID0gZmFsc2UsIH0pID0+IHtcbiAgICBjb25zdCB7IHJlZnMsIHgsIHksIHN0cmF0ZWd5IH0gPSB1c2VGbG9hdGluZ1VJUHJlc2V0KHtcbiAgICAgICAgcGxhY2VtZW50OiB0b29sdGlwUGxhY2VtZW50LFxuICAgICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZWZzLnNldFJlZmVyZW5jZShyZWZlcmVuY2VFbGVtZW50KTtcbiAgICB9LCBbcmVmZXJlbmNlRWxlbWVudCwgcmVmc10pO1xuICAgIGlmICghdmlzaWJsZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fdG9vbHRpcCcsIHRvb2x0aXBDbGFzc05hbWUpLCByZWY6IHJlZnMuc2V0RmxvYXRpbmcsIHN0eWxlOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICAgICAgICB0b3A6IHkgPz8gMCxcbiAgICAgICAgICAgIGxlZnQ6IHggPz8gMCxcbiAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcblxuY29uc3QgdXNlRW50ZXJMZWF2ZUhhbmRsZXJzID0gKHsgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUsIH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IFt0b29sdGlwVmlzaWJsZSwgc2V0VG9vbHRpcFZpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGhhbmRsZU1vdXNlRW50ZXIgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBzZXRUb29sdGlwVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgb25Nb3VzZUVudGVyPy4oZSk7XG4gICAgfSwgW29uTW91c2VFbnRlcl0pO1xuICAgIGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBzZXRUb29sdGlwVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIG9uTW91c2VMZWF2ZT8uKGUpO1xuICAgIH0sIFtvbk1vdXNlTGVhdmVdKTtcbiAgICByZXR1cm4geyBoYW5kbGVNb3VzZUVudGVyLCBoYW5kbGVNb3VzZUxlYXZlLCB0b29sdGlwVmlzaWJsZSB9O1xufTtcblxuLy8gdG9kbzogZHVwbGljYXRlIG9mIENhbGxQYXJ0aWNpcGFudExpc3QudHN4I01lZGlhSW5kaWNhdG9yIC0gcmVmYWN0b3IgdG8gYSBzaW5nbGUgY29tcG9uZW50XG5jb25zdCBXaXRoVG9vbHRpcCA9ICh7IHRpdGxlLCB0b29sdGlwQ2xhc3NOYW1lLCB0b29sdGlwUGxhY2VtZW50LCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgeyBoYW5kbGVNb3VzZUVudGVyLCBoYW5kbGVNb3VzZUxlYXZlLCB0b29sdGlwVmlzaWJsZSB9ID0gdXNlRW50ZXJMZWF2ZUhhbmRsZXJzKCk7XG4gICAgY29uc3QgW3Rvb2x0aXBBbmNob3IsIHNldFRvb2x0aXBBbmNob3JdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFRvb2x0aXAsIHsgcmVmZXJlbmNlRWxlbWVudDogdG9vbHRpcEFuY2hvciwgdmlzaWJsZTogdG9vbHRpcFZpc2libGUsIHRvb2x0aXBDbGFzc05hbWU6IHRvb2x0aXBDbGFzc05hbWUsIHRvb2x0aXBQbGFjZW1lbnQ6IHRvb2x0aXBQbGFjZW1lbnQsIGNoaWxkcmVuOiB0aXRsZSB8fCAnJyB9KSwganN4KFwiZGl2XCIsIHsgcmVmOiBzZXRUb29sdGlwQW5jaG9yLCBvbk1vdXNlRW50ZXI6IGhhbmRsZU1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZTogaGFuZGxlTW91c2VMZWF2ZSwgLi4ucHJvcHMgfSldIH0pKTtcbn07XG5cbmNvbnN0IENhbGxQYXJ0aWNpcGFudExpc3RpbmdJdGVtID0gKHsgcGFydGljaXBhbnQsIERpc3BsYXlOYW1lID0gRGVmYXVsdERpc3BsYXlOYW1lLCB9KSA9PiB7XG4gICAgY29uc3QgaXNBdWRpb09uID0gcGFydGljaXBhbnQucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuQVVESU8pO1xuICAgIGNvbnN0IGlzVmlkZW9PbiA9IHBhcnRpY2lwYW50LnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlZJREVPKTtcbiAgICBjb25zdCBpc1Bpbm5lZCA9ICEhcGFydGljaXBhbnQucGluO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbVwiLCBjaGlsZHJlbjogW2pzeChBdmF0YXIsIHsgbmFtZTogcGFydGljaXBhbnQubmFtZSwgaW1hZ2VTcmM6IHBhcnRpY2lwYW50LmltYWdlIH0pLCBqc3goRGlzcGxheU5hbWUsIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50IH0pLCBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtX19tZWRpYS1pbmRpY2F0b3ItZ3JvdXBcIiwgY2hpbGRyZW46IFtqc3goTWVkaWFJbmRpY2F0b3IsIHsgdGl0bGU6IGlzQXVkaW9PbiA/IHQoJ01pY3JvcGhvbmUgb24nKSA6IHQoJ01pY3JvcGhvbmUgb2ZmJyksIGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nLWl0ZW1fX2ljb24nLCBgc3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nLWl0ZW1fX2ljb24tJHtpc0F1ZGlvT24gPyAnbWljJyA6ICdtaWMtb2ZmJ31gKSB9KSwganN4KE1lZGlhSW5kaWNhdG9yLCB7IHRpdGxlOiBpc1ZpZGVvT24gPyB0KCdDYW1lcmEgb24nKSA6IHQoJ0NhbWVyYSBvZmYnKSwgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbicsIGBzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbi0ke2lzVmlkZW9PbiA/ICdjYW1lcmEnIDogJ2NhbWVyYS1vZmYnfWApIH0pLCBpc1Bpbm5lZCAmJiAoanN4KE1lZGlhSW5kaWNhdG9yLCB7IHRpdGxlOiB0KCdQaW5uZWQnKSwgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbicsICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbi1waW5uZWQnKSB9KSksIGpzeChNZW51VG9nZ2xlLCB7IHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsIFRvZ2dsZUJ1dHRvbjogVG9nZ2xlQnV0dG9uJDIsIGNoaWxkcmVuOiBqc3goUGFydGljaXBhbnRWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBwYXJ0aWNpcGFudCwgdHJhY2tUeXBlOiAnbm9uZScgfSwgY2hpbGRyZW46IGpzeChQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSwge30pIH0pIH0pXSB9KV0gfSkpO1xufTtcbmNvbnN0IE1lZGlhSW5kaWNhdG9yID0gKHByb3BzKSA9PiAoanN4KFdpdGhUb29sdGlwLCB7IC4uLnByb3BzIH0pKTtcbmNvbnN0IERlZmF1bHREaXNwbGF5TmFtZSA9ICh7IHBhcnRpY2lwYW50IH0pID0+IHtcbiAgICBjb25zdCBjb25uZWN0ZWRVc2VyID0gdXNlQ29ubmVjdGVkVXNlcigpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IG1lRmxhZyA9IHBhcnRpY2lwYW50LnVzZXJJZCA9PT0gY29ubmVjdGVkVXNlcj8uaWQgPyB0KCdNZScpIDogJyc7XG4gICAgY29uc3QgbmFtZU9ySWQgPSBwYXJ0aWNpcGFudC5uYW1lIHx8IHBhcnRpY2lwYW50LnVzZXJJZCB8fCB0KCdVbmtub3duJyk7XG4gICAgbGV0IGRpc3BsYXlOYW1lO1xuICAgIGlmICghcGFydGljaXBhbnQubmFtZSkge1xuICAgICAgICBkaXNwbGF5TmFtZSA9IG1lRmxhZyB8fCBuYW1lT3JJZCB8fCB0KCdVbmtub3duJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1lRmxhZykge1xuICAgICAgICBkaXNwbGF5TmFtZSA9IGAke25hbWVPcklkfSAoJHttZUZsYWd9KWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkaXNwbGF5TmFtZSA9IG5hbWVPcklkO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChXaXRoVG9vbHRpcCwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nLWl0ZW1fX2Rpc3BsYXktbmFtZVwiLCB0aXRsZTogZGlzcGxheU5hbWUsIGNoaWxkcmVuOiBkaXNwbGF5TmFtZSB9KSk7XG59O1xuY29uc3QgVG9nZ2xlQnV0dG9uJDIgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZUJ1dHRvbihwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIGpzeChJY29uQnV0dG9uLCB7IGVuYWJsZWQ6IHByb3BzLm1lbnVTaG93biwgaWNvbjogXCJlbGxpcHNpc1wiLCByZWY6IHJlZiB9KTtcbn0pO1xuXG5jb25zdCBDYWxsUGFydGljaXBhbnRMaXN0aW5nID0gKHsgZGF0YSwgfSkgPT4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmdcIiwgY2hpbGRyZW46IGRhdGEubWFwKChwYXJ0aWNpcGFudCkgPT4gKGpzeChDYWxsUGFydGljaXBhbnRMaXN0aW5nSXRlbSwgeyBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQgfSwgcGFydGljaXBhbnQuc2Vzc2lvbklkKSkpIH0pKTtcblxuY29uc3QgRW1wdHlQYXJ0aWNpcGFudFNlYXJjaExpc3QgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0LS1lbXB0eVwiLCBjaGlsZHJlbjogdCgnTm8gcGFydGljaXBhbnRzIGZvdW5kJykgfSkpO1xufTtcblxuY29uc3QgU2VhcmNoSW5wdXQgPSAoeyBleGl0U2VhcmNoLCBpc0FjdGl2ZSwgLi4ucmVzdCB9KSA9PiB7XG4gICAgY29uc3QgW2lucHV0RWxlbWVudCwgc2V0SW5wdXRFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaW5wdXRFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmtleS50b0xvd2VyQ2FzZSgpID09PSAnZXNjYXBlJylcbiAgICAgICAgICAgICAgICBleGl0U2VhcmNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgICB9O1xuICAgIH0sIFtleGl0U2VhcmNoLCBpbnB1dEVsZW1lbnRdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fc2VhcmNoLWlucHV0X19jb250YWluZXInLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19zZWFyY2gtaW5wdXRfX2NvbnRhaW5lci0tYWN0aXZlJzogaXNBY3RpdmUsXG4gICAgICAgIH0pLCBjaGlsZHJlbjogW2pzeChcImlucHV0XCIsIHsgcGxhY2Vob2xkZXI6IFwiU2VhcmNoXCIsIC4uLnJlc3QsIHJlZjogc2V0SW5wdXRFbGVtZW50IH0pLCBpc0FjdGl2ZSA/IChqc3goXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zZWFyY2gtaW5wdXRfX2NsZWFyLWJ0blwiLCBvbkNsaWNrOiBleGl0U2VhcmNoLCBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NlYXJjaC1pbnB1dF9faWNvbi0tYWN0aXZlXCIgfSkgfSkpIDogKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zZWFyY2gtaW5wdXRfX2ljb25cIiB9KSldIH0pKTtcbn07XG5cbmNvbnN0IFNlYXJjaFJlc3VsdHMgPSAoeyBFbXB0eVNlYXJjaFJlc3VsdENvbXBvbmVudCwgTG9hZGluZ0luZGljYXRvcjogTG9hZGluZ0luZGljYXRvciQxID0gTG9hZGluZ0luZGljYXRvciwgc2VhcmNoUXVlcnlJblByb2dyZXNzLCBzZWFyY2hSZXN1bHRzLCBTZWFyY2hSZXN1bHRMaXN0LCB9KSA9PiB7XG4gICAgaWYgKHNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NlYXJjaC1yZXN1bHRzLS1sb2FkaW5nXCIsIGNoaWxkcmVuOiBqc3goTG9hZGluZ0luZGljYXRvciQxLCB7fSkgfSkpO1xuICAgIH1cbiAgICBpZiAoIXNlYXJjaFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBqc3goRW1wdHlTZWFyY2hSZXN1bHRDb21wb25lbnQsIHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpzeChTZWFyY2hSZXN1bHRMaXN0LCB7IGRhdGE6IHNlYXJjaFJlc3VsdHMgfSk7XG59O1xuXG5jb25zdCB1c2VTZWFyY2ggPSAoeyBkZWJvdW5jZUludGVydmFsLCBzZWFyY2hGbiwgc2VhcmNoUXVlcnkgPSAnJywgfSkgPT4ge1xuICAgIGNvbnN0IFtzZWFyY2hSZXN1bHRzLCBzZXRTZWFyY2hSZXN1bHRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBbc2VhcmNoUXVlcnlJblByb2dyZXNzLCBzZXRTZWFyY2hRdWVyeUluUHJvZ3Jlc3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc2VhcmNoUXVlcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXRTZWFyY2hRdWVyeUluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgICAgICAgICAgc2V0U2VhcmNoUmVzdWx0cyhbXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VhcmNoUXVlcnlJblByb2dyZXNzKHRydWUpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzZWFyY2hGbihzZWFyY2hRdWVyeSk7XG4gICAgICAgICAgICAgICAgc2V0U2VhcmNoUmVzdWx0cyhyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0U2VhcmNoUXVlcnlJblByb2dyZXNzKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZGVib3VuY2VJbnRlcnZhbCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgfSwgW2RlYm91bmNlSW50ZXJ2YWwsIHNlYXJjaEZuLCBzZWFyY2hRdWVyeV0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcyxcbiAgICAgICAgc2VhcmNoUmVzdWx0cyxcbiAgICB9O1xufTtcblxuY29uc3QgVXNlckxpc3RUeXBlcyA9IHtcbiAgICBhY3RpdmU6ICdBY3RpdmUgdXNlcnMnLFxuICAgIGJsb2NrZWQ6ICdCbG9ja2VkIHVzZXJzJyxcbn07XG5jb25zdCBERUZBVUxUX0RFQk9VTkNFX1NFQVJDSF9JTlRFUlZBTCA9IDIwMDtcbmNvbnN0IENhbGxQYXJ0aWNpcGFudHNMaXN0ID0gKHsgb25DbG9zZSwgYWN0aXZlVXNlcnNTZWFyY2hGbiwgYmxvY2tlZFVzZXJzU2VhcmNoRm4sIGRlYm91bmNlU2VhcmNoSW50ZXJ2YWwsIH0pID0+IHtcbiAgICBjb25zdCBbc2VhcmNoUXVlcnksIHNldFNlYXJjaFF1ZXJ5XSA9IHVzZVN0YXRlKCcnKTtcbiAgICBjb25zdCBbdXNlckxpc3RUeXBlLCBzZXRVc2VyTGlzdFR5cGVdID0gdXNlU3RhdGUoJ2FjdGl2ZScpO1xuICAgIGNvbnN0IGV4aXRTZWFyY2ggPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRTZWFyY2hRdWVyeSgnJyksIFtdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0XCIsIGNoaWxkcmVuOiBbanN4KENhbGxQYXJ0aWNpcGFudExpc3RIZWFkZXIsIHsgb25DbG9zZTogb25DbG9zZSB9KSwganN4KFNlYXJjaElucHV0LCB7IHZhbHVlOiBzZWFyY2hRdWVyeSwgb25DaGFuZ2U6ICh7IGN1cnJlbnRUYXJnZXQgfSkgPT4gc2V0U2VhcmNoUXVlcnkoY3VycmVudFRhcmdldC52YWx1ZSksIGV4aXRTZWFyY2g6IGV4aXRTZWFyY2gsIGlzQWN0aXZlOiAhIXNlYXJjaFF1ZXJ5IH0pLCBqc3goQ2FsbFBhcnRpY2lwYW50TGlzdENvbnRlbnRIZWFkZXIsIHsgdXNlckxpc3RUeXBlOiB1c2VyTGlzdFR5cGUsIHNldFVzZXJMaXN0VHlwZTogc2V0VXNlckxpc3RUeXBlIH0pLCBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdF9fY29udGVudFwiLCBjaGlsZHJlbjogW3VzZXJMaXN0VHlwZSA9PT0gJ2FjdGl2ZScgJiYgKGpzeChBY3RpdmVVc2Vyc1NlYXJjaFJlc3VsdHMsIHsgc2VhcmNoUXVlcnk6IHNlYXJjaFF1ZXJ5LCBhY3RpdmVVc2Vyc1NlYXJjaEZuOiBhY3RpdmVVc2Vyc1NlYXJjaEZuLCBkZWJvdW5jZVNlYXJjaEludGVydmFsOiBkZWJvdW5jZVNlYXJjaEludGVydmFsIH0pKSwgdXNlckxpc3RUeXBlID09PSAnYmxvY2tlZCcgJiYgKGpzeChCbG9ja2VkVXNlcnNTZWFyY2hSZXN1bHRzLCB7IHNlYXJjaFF1ZXJ5OiBzZWFyY2hRdWVyeSwgYmxvY2tlZFVzZXJzU2VhcmNoRm46IGJsb2NrZWRVc2Vyc1NlYXJjaEZuLCBkZWJvdW5jZVNlYXJjaEludGVydmFsOiBkZWJvdW5jZVNlYXJjaEludGVydmFsIH0pKV0gfSldIH0pKTtcbn07XG5jb25zdCBDYWxsUGFydGljaXBhbnRMaXN0Q29udGVudEhlYWRlciA9ICh7IHVzZXJMaXN0VHlwZSwgc2V0VXNlckxpc3RUeXBlLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCBtdXRlQWxsID0gKCkgPT4ge1xuICAgICAgICBjYWxsPy5tdXRlQWxsVXNlcnMoJ2F1ZGlvJyk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0X19jb250ZW50LWhlYWRlclwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RfX2NvbnRlbnQtaGVhZGVyLXRpdGxlXCIsIGNoaWxkcmVuOiB1c2VyTGlzdFR5cGUgPT09ICdhY3RpdmUnICYmIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuTVVURV9VU0VSU10sIGhhc1Blcm1pc3Npb25zT25seTogdHJ1ZSwgY2hpbGRyZW46IGpzeChUZXh0QnV0dG9uLCB7IG9uQ2xpY2s6IG11dGVBbGwsIGNoaWxkcmVuOiBcIk11dGUgYWxsXCIgfSkgfSkpIH0pLCBqc3goTWVudVRvZ2dsZSwgeyBwbGFjZW1lbnQ6IFwiYm90dG9tLWVuZFwiLCBUb2dnbGVCdXR0b246IFRvZ2dsZUJ1dHRvbiQxLCBjaGlsZHJlbjoganN4KEdlbmVyaWNNZW51LCB7IGNoaWxkcmVuOiBPYmplY3Qua2V5cyhVc2VyTGlzdFR5cGVzKS5tYXAoKGx0KSA9PiAoanN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBcImFyaWEtc2VsZWN0ZWRcIjogbHQgPT09IHVzZXJMaXN0VHlwZSwgb25DbGljazogKCkgPT4gc2V0VXNlckxpc3RUeXBlKGx0KSwgY2hpbGRyZW46IFVzZXJMaXN0VHlwZXNbbHRdIH0sIGx0KSkpIH0pIH0pXSB9KSk7XG59O1xuY29uc3QgQWN0aXZlVXNlcnNTZWFyY2hSZXN1bHRzID0gKHsgc2VhcmNoUXVlcnksIGFjdGl2ZVVzZXJzU2VhcmNoRm46IGFjdGl2ZVVzZXJzU2VhcmNoRm5Gcm9tUHJvcHMsIGRlYm91bmNlU2VhcmNoSW50ZXJ2YWwgPSBERUZBVUxUX0RFQk9VTkNFX1NFQVJDSF9JTlRFUlZBTCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlUGFydGljaXBhbnRzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHVzZVBhcnRpY2lwYW50cyh7IHNvcnRCeTogbmFtZSB9KTtcbiAgICBjb25zdCBhY3RpdmVVc2Vyc1NlYXJjaEZuID0gdXNlQ2FsbGJhY2soKHF1ZXJ5U3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVnRXhwID0gbmV3IFJlZ0V4cChxdWVyeVN0cmluZywgJ2knKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYXJ0aWNpcGFudHMuZmlsdGVyKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50Lm5hbWUubWF0Y2gocXVlcnlSZWdFeHApO1xuICAgICAgICB9KSk7XG4gICAgfSwgW3BhcnRpY2lwYW50c10pO1xuICAgIGNvbnN0IHsgc2VhcmNoUXVlcnlJblByb2dyZXNzLCBzZWFyY2hSZXN1bHRzIH0gPSB1c2VTZWFyY2goe1xuICAgICAgICBzZWFyY2hGbjogYWN0aXZlVXNlcnNTZWFyY2hGbkZyb21Qcm9wcyA/PyBhY3RpdmVVc2Vyc1NlYXJjaEZuLFxuICAgICAgICBkZWJvdW5jZUludGVydmFsOiBkZWJvdW5jZVNlYXJjaEludGVydmFsLFxuICAgICAgICBzZWFyY2hRdWVyeSxcbiAgICB9KTtcbiAgICByZXR1cm4gKGpzeChTZWFyY2hSZXN1bHRzLCB7IEVtcHR5U2VhcmNoUmVzdWx0Q29tcG9uZW50OiBFbXB0eVBhcnRpY2lwYW50U2VhcmNoTGlzdCwgTG9hZGluZ0luZGljYXRvcjogTG9hZGluZ0luZGljYXRvciwgc2VhcmNoUXVlcnlJblByb2dyZXNzOiBzZWFyY2hRdWVyeUluUHJvZ3Jlc3MsIHNlYXJjaFJlc3VsdHM6IHNlYXJjaFF1ZXJ5ID8gc2VhcmNoUmVzdWx0cyA6IHBhcnRpY2lwYW50cywgU2VhcmNoUmVzdWx0TGlzdDogQ2FsbFBhcnRpY2lwYW50TGlzdGluZyB9KSk7XG59O1xuY29uc3QgQmxvY2tlZFVzZXJzU2VhcmNoUmVzdWx0cyA9ICh7IGJsb2NrZWRVc2Vyc1NlYXJjaEZuOiBibG9ja2VkVXNlcnNTZWFyY2hGbkZyb21Qcm9wcywgZGVib3VuY2VTZWFyY2hJbnRlcnZhbCA9IERFRkFVTFRfREVCT1VOQ0VfU0VBUkNIX0lOVEVSVkFMLCBzZWFyY2hRdWVyeSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlQ2FsbEJsb2NrZWRVc2VySWRzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGJsb2NrZWRVc2VycyA9IHVzZUNhbGxCbG9ja2VkVXNlcklkcygpO1xuICAgIGNvbnN0IGJsb2NrZWRVc2Vyc1NlYXJjaEZuID0gdXNlQ2FsbGJhY2soKHF1ZXJ5U3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UmVnRXhwID0gbmV3IFJlZ0V4cChxdWVyeVN0cmluZywgJ2knKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShibG9ja2VkVXNlcnMuZmlsdGVyKChibG9ja2VkVXNlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrZWRVc2VyLm1hdGNoKHF1ZXJ5UmVnRXhwKTtcbiAgICAgICAgfSkpO1xuICAgIH0sIFtibG9ja2VkVXNlcnNdKTtcbiAgICBjb25zdCB7IHNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcywgc2VhcmNoUmVzdWx0cyB9ID0gdXNlU2VhcmNoKHtcbiAgICAgICAgc2VhcmNoRm46IGJsb2NrZWRVc2Vyc1NlYXJjaEZuRnJvbVByb3BzID8/IGJsb2NrZWRVc2Vyc1NlYXJjaEZuLFxuICAgICAgICBkZWJvdW5jZUludGVydmFsOiBkZWJvdW5jZVNlYXJjaEludGVydmFsLFxuICAgICAgICBzZWFyY2hRdWVyeSxcbiAgICB9KTtcbiAgICByZXR1cm4gKGpzeChTZWFyY2hSZXN1bHRzLCB7IEVtcHR5U2VhcmNoUmVzdWx0Q29tcG9uZW50OiBFbXB0eVBhcnRpY2lwYW50U2VhcmNoTGlzdCwgTG9hZGluZ0luZGljYXRvcjogTG9hZGluZ0luZGljYXRvciwgc2VhcmNoUXVlcnlJblByb2dyZXNzOiBzZWFyY2hRdWVyeUluUHJvZ3Jlc3MsIHNlYXJjaFJlc3VsdHM6IHNlYXJjaFF1ZXJ5ID8gc2VhcmNoUmVzdWx0cyA6IGJsb2NrZWRVc2VycywgU2VhcmNoUmVzdWx0TGlzdDogQmxvY2tlZFVzZXJMaXN0aW5nIH0pKTtcbn07XG5jb25zdCBUb2dnbGVCdXR0b24kMSA9IGZvcndhcmRSZWYoZnVuY3Rpb24gVG9nZ2xlQnV0dG9uKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4ganN4KEljb25CdXR0b24sIHsgZW5hYmxlZDogcHJvcHMubWVudVNob3duLCBpY29uOiBcImZpbHRlclwiLCByZWY6IHJlZiB9KTtcbn0pO1xuXG5jb25zdCBDYWxsUHJldmlldyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUNhbGxUaHVtYm5haWwgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgdGh1bWJuYWlsID0gdXNlQ2FsbFRodW1ibmFpbCgpO1xuICAgIGNvbnN0IFtpbWFnZVJlZiwgc2V0SW1hZ2VSZWZdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpbWFnZVJlZiB8fCAhY2FsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNhbGwuYmluZENhbGxUaHVtYm5haWxFbGVtZW50KGltYWdlUmVmKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFudXAoKTtcbiAgICB9LCBbaW1hZ2VSZWYsIGNhbGxdKTtcbiAgICBpZiAoIXRodW1ibmFpbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3goXCJpbWdcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fY2FsbC1wcmV2aWV3JywgY2xhc3NOYW1lKSwgc3R5bGU6IHN0eWxlLCBhbHQ6IFwiQ2FsbCBQcmV2aWV3IFRodW1ibmFpbFwiLCByZWY6IHNldEltYWdlUmVmIH0pKTtcbn07XG5cbmNvbnN0IENhbGxSZWNvcmRpbmdMaXN0SGVhZGVyID0gKHsgY2FsbFJlY29yZGluZ3MsIG9uUmVmcmVzaCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2hlYWRlclwiLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X190aXRsZVwiLCBjaGlsZHJlbjogW2pzeChcInNwYW5cIiwgeyBjaGlsZHJlbjogdCgnQ2FsbCBSZWNvcmRpbmdzJykgfSksIGNhbGxSZWNvcmRpbmdzLmxlbmd0aCA/IGpzeHMoXCJzcGFuXCIsIHsgY2hpbGRyZW46IFtcIihcIiwgY2FsbFJlY29yZGluZ3MubGVuZ3RoLCBcIilcIl0gfSkgOiBudWxsXSB9KSwgb25SZWZyZXNoICYmIChqc3goSWNvbkJ1dHRvbiwgeyBpY29uOiBcInJlZnJlc2hcIiwgdGl0bGU6IHQoJ1JlZnJlc2gnKSwgb25DbGljazogb25SZWZyZXNoIH0pKV0gfSkpO1xufTtcblxuY29uc3QgZGF0ZUZvcm1hdCA9IChkYXRlKSA9PiB7XG4gICAgY29uc3QgZm9ybWF0ID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgcmV0dXJuIGZvcm1hdC50b1RpbWVTdHJpbmcoKS5zcGxpdCgnICcpWzBdO1xufTtcbmNvbnN0IENhbGxSZWNvcmRpbmdMaXN0SXRlbSA9ICh7IHJlY29yZGluZywgfSkgPT4ge1xuICAgIHJldHVybiAoanN4cyhcImxpXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9faXRlbVwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RhYmxlLWNlbGwgc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19maWxlbmFtZVwiLCBjaGlsZHJlbjogcmVjb3JkaW5nLmZpbGVuYW1lIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X190YWJsZS1jZWxsIHN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fdGltZVwiLCBjaGlsZHJlbjogZGF0ZUZvcm1hdChyZWNvcmRpbmcuc3RhcnRfdGltZSkgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RhYmxlLWNlbGwgc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X190aW1lXCIsIGNoaWxkcmVuOiBkYXRlRm9ybWF0KHJlY29yZGluZy5lbmRfdGltZSkgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RhYmxlLWNlbGwgc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19kb3dubG9hZFwiLCBjaGlsZHJlbjoganN4KFwiYVwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0LWl0ZW1fX2FjdGlvbi1idXR0b24nLCAnc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0LWl0ZW1fX2FjdGlvbi1idXR0b24tLWRvd25sb2FkJyksIHJvbGU6IFwiYnV0dG9uXCIsIGhyZWY6IHJlY29yZGluZy51cmwsIGRvd25sb2FkOiByZWNvcmRpbmcuZmlsZW5hbWUsIHRpdGxlOiBcIkRvd25sb2FkIHRoZSByZWNvcmRpbmdcIiwgY2hpbGRyZW46IGpzeChJY29uLCB7IGljb246IFwiZG93bmxvYWRcIiB9KSB9KSB9KV0gfSkpO1xufTtcblxuY29uc3QgRW1wdHlDYWxsUmVjb3JkaW5nTGlzdGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0aW5nIHN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fbGlzdGluZy0tZW1wdHlcIiwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0aW5nLS1pY29uLWVtcHR5XCIgfSksIGpzeChcInBcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0aW5nLS10ZXh0LWVtcHR5XCIsIGNoaWxkcmVuOiBcIk5vIHJlY29yZGluZ3MgYXZhaWxhYmxlXCIgfSldIH0pKTtcbn07XG5cbmNvbnN0IExvYWRpbmdDYWxsUmVjb3JkaW5nTGlzdGluZyA9ICh7IGNhbGxSZWNvcmRpbmdzLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbY2FsbFJlY29yZGluZ3MubWFwKChyZWNvcmRpbmcpID0+IChqc3goQ2FsbFJlY29yZGluZ0xpc3RJdGVtLCB7IHJlY29yZGluZzogcmVjb3JkaW5nIH0sIHJlY29yZGluZy5maWxlbmFtZSkpKSwganN4KExvYWRpbmdJbmRpY2F0b3IsIHsgdGV4dDogXCJSZWNvcmRpbmcgZ2V0dGluZyByZWFkeVwiIH0pXSB9KSk7XG59O1xuXG5jb25zdCBDYWxsUmVjb3JkaW5nTGlzdCA9ICh7IGNhbGxSZWNvcmRpbmdzLCBDYWxsUmVjb3JkaW5nTGlzdEhlYWRlcjogQ2FsbFJlY29yZGluZ0xpc3RIZWFkZXIkMSA9IENhbGxSZWNvcmRpbmdMaXN0SGVhZGVyLCBDYWxsUmVjb3JkaW5nTGlzdEl0ZW06IENhbGxSZWNvcmRpbmdMaXN0SXRlbSQxID0gQ2FsbFJlY29yZGluZ0xpc3RJdGVtLCBFbXB0eUNhbGxSZWNvcmRpbmdMaXN0ID0gRW1wdHlDYWxsUmVjb3JkaW5nTGlzdGluZywgbG9hZGluZywgTG9hZGluZ0NhbGxSZWNvcmRpbmdMaXN0ID0gTG9hZGluZ0NhbGxSZWNvcmRpbmdMaXN0aW5nLCBvblJlZnJlc2gsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0XCIsIGNoaWxkcmVuOiBbanN4KENhbGxSZWNvcmRpbmdMaXN0SGVhZGVyJDEsIHsgY2FsbFJlY29yZGluZ3M6IGNhbGxSZWNvcmRpbmdzLCBvblJlZnJlc2g6IG9uUmVmcmVzaCB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fbGlzdGluZ1wiLCBjaGlsZHJlbjogbG9hZGluZyA/IChqc3goTG9hZGluZ0NhbGxSZWNvcmRpbmdMaXN0LCB7IGNhbGxSZWNvcmRpbmdzOiBjYWxsUmVjb3JkaW5ncyB9KSkgOiBjYWxsUmVjb3JkaW5ncy5sZW5ndGggPyAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcInVsXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fbGlzdFwiLCBjaGlsZHJlbjoganN4cyhcImxpXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9faXRlbVwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2ZpbGVuYW1lXCIsIGNoaWxkcmVuOiBcIk5hbWVcIiB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fdGltZVwiLCBjaGlsZHJlbjogXCJTdGFydCB0aW1lXCIgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RpbWVcIiwgY2hpbGRyZW46IFwiRW5kIHRpbWVcIiB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fZG93bmxvYWRcIiB9KV0gfSkgfSksIGpzeChcInVsXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fbGlzdFwiLCBjaGlsZHJlbjogY2FsbFJlY29yZGluZ3MubWFwKChyZWNvcmRpbmcpID0+IChqc3goQ2FsbFJlY29yZGluZ0xpc3RJdGVtJDEsIHsgcmVjb3JkaW5nOiByZWNvcmRpbmcgfSwgcmVjb3JkaW5nLmZpbGVuYW1lKSkpIH0pXSB9KSkgOiAoanN4KEVtcHR5Q2FsbFJlY29yZGluZ0xpc3QsIHt9KSkgfSldIH0pKTtcbn07XG5cbmNvbnN0IFJpbmdpbmdDYWxsQ29udHJvbHMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUNhbGxDYWxsaW5nU3RhdGUgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgY2FsbENhbGxpbmdTdGF0ZSA9IHVzZUNhbGxDYWxsaW5nU3RhdGUoKTtcbiAgICBpZiAoIWNhbGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJ1dHRvbnNEaXNhYmxlZCA9IGNhbGxDYWxsaW5nU3RhdGUgIT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVuZGluZy1jYWxsLWNvbnRyb2xzXCIsIGNoaWxkcmVuOiBjYWxsLmlzQ3JlYXRlZEJ5TWUgPyAoanN4KENhbmNlbENhbGxCdXR0b24sIHsgZGlzYWJsZWQ6IGJ1dHRvbnNEaXNhYmxlZCB9KSkgOiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChBY2NlcHRDYWxsQnV0dG9uLCB7IGRpc2FibGVkOiBidXR0b25zRGlzYWJsZWQgfSksIGpzeChDYW5jZWxDYWxsQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IGNhbGwubGVhdmUoeyByZWplY3Q6IHRydWUgfSksIGRpc2FibGVkOiBidXR0b25zRGlzYWJsZWQgfSldIH0pKSB9KSk7XG59O1xuXG5jb25zdCBDQUxMSU5HX1NUQVRFX1RPX0xBQkVMID0ge1xuICAgIFtDYWxsaW5nU3RhdGUuSk9JTklOR106ICdKb2luaW5nJyxcbiAgICBbQ2FsbGluZ1N0YXRlLlJJTkdJTkddOiAnUmluZ2luZycsXG4gICAgW0NhbGxpbmdTdGF0ZS5NSUdSQVRJTkddOiAnTWlncmF0aW5nJyxcbiAgICBbQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR106ICdSZS1jb25uZWN0aW5nJyxcbiAgICBbQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRURdOiAnRmFpbGVkJyxcbiAgICBbQ2FsbGluZ1N0YXRlLk9GRkxJTkVdOiAnTm8gaW50ZXJuZXQgY29ubmVjdGlvbicsXG4gICAgW0NhbGxpbmdTdGF0ZS5JRExFXTogJycsXG4gICAgW0NhbGxpbmdTdGF0ZS5VTktOT1dOXTogJycsXG4gICAgW0NhbGxpbmdTdGF0ZS5KT0lORURdOiAnSm9pbmVkJyxcbiAgICBbQ2FsbGluZ1N0YXRlLkxFRlRdOiAnTGVmdCBjYWxsJyxcbn07XG5jb25zdCBSaW5naW5nQ2FsbCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgaW5jbHVkZVNlbGYgPSBmYWxzZSwgdG90YWxNZW1iZXJzVG9TaG93ID0gMyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IHVzZUNhbGxDYWxsaW5nU3RhdGUsIHVzZUNhbGxNZW1iZXJzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGNhbGxpbmdTdGF0ZSA9IHVzZUNhbGxDYWxsaW5nU3RhdGUoKTtcbiAgICBjb25zdCBtZW1iZXJzID0gdXNlQ2FsbE1lbWJlcnMoKTtcbiAgICBjb25zdCBjb25uZWN0ZWRVc2VyID0gdXNlQ29ubmVjdGVkVXNlcigpO1xuICAgIGlmICghY2FsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gdGFrZSB0aGUgZmlyc3QgTiBtZW1iZXJzIHRvIHNob3cgdGhlaXIgYXZhdGFyc1xuICAgIGNvbnN0IG1lbWJlcnNUb1Nob3cgPSAobWVtYmVycyB8fCBbXSlcbiAgICAgICAgLnNsaWNlKDAsIHRvdGFsTWVtYmVyc1RvU2hvdylcbiAgICAgICAgLm1hcCgoeyB1c2VyIH0pID0+IHVzZXIpXG4gICAgICAgIC5maWx0ZXIoKHVzZXIpID0+IHVzZXIuaWQgIT09IGNvbm5lY3RlZFVzZXI/LmlkIHx8IGluY2x1ZGVTZWxmKTtcbiAgICBpZiAoaW5jbHVkZVNlbGYgJiZcbiAgICAgICAgIW1lbWJlcnNUb1Nob3cuZmluZCgodXNlcikgPT4gdXNlci5pZCA9PT0gY29ubmVjdGVkVXNlcj8uaWQpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHVzZXIgaXMgbm90IGluIHRoZSBpbml0aWFsIGJhdGNoIG9mIG1lbWJlcnMsXG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIGZpcnN0IGl0ZW0gaW4gbWVtYmVyc1RvU2hvdyBhcnJheSB3aXRoIHRoZSBjdXJyZW50IHVzZXJcbiAgICAgICAgY29uc3Qgc2VsZiA9IG1lbWJlcnMuZmluZCgoeyB1c2VyIH0pID0+IHVzZXIuaWQgPT09IGNvbm5lY3RlZFVzZXI/LmlkKTtcbiAgICAgICAgaWYgKHNlbGYpIHtcbiAgICAgICAgICAgIG1lbWJlcnNUb1Nob3cuc3BsaWNlKDAsIDEsIHNlbGYudXNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FsbGluZ1N0YXRlTGFiZWwgPSBDQUxMSU5HX1NUQVRFX1RPX0xBQkVMW2NhbGxpbmdTdGF0ZV07XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1wYW5lbCBzdHItdmlkZW9fX2NhbGwtcGFuZWwtLXJpbmdpbmdcIiwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXBhbmVsX19tZW1iZXJzLWxpc3RcIiwgY2hpbGRyZW46IG1lbWJlcnNUb1Nob3cubWFwKCh1c2VyKSA9PiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcGFuZWxfX21lbWJlci1ib3hcIiwgY2hpbGRyZW46IFtqc3goQXZhdGFyLCB7IG5hbWU6IHVzZXIubmFtZSwgaW1hZ2VTcmM6IHVzZXIuaW1hZ2UgfSksIHVzZXIubmFtZSAmJiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbWVtYmVyX2RldGFpbHNcIiwgY2hpbGRyZW46IGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19tZW1iZXJfbmFtZVwiLCBjaGlsZHJlbjogdXNlci5uYW1lIH0pIH0pKV0gfSwgdXNlci5pZCkpKSB9KSwgY2FsbGluZ1N0YXRlTGFiZWwgJiYgKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcGFuZWxfX2NhbGxpbmctc3RhdGUtbGFiZWxcIiwgY2hpbGRyZW46IHQoY2FsbGluZ1N0YXRlTGFiZWwpIH0pKSwgW0NhbGxpbmdTdGF0ZS5SSU5HSU5HLCBDYWxsaW5nU3RhdGUuSk9JTklOR10uaW5jbHVkZXMoY2FsbGluZ1N0YXRlKSAmJiAoanN4KFJpbmdpbmdDYWxsQ29udHJvbHMsIHt9KSldIH0pKTtcbn07XG5cbmNvbnN0IGJ5TmFtZU9ySWQgPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLm5hbWUgJiYgYi5uYW1lICYmIGEubmFtZSA8IGIubmFtZSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmIChhLm5hbWUgJiYgYi5uYW1lICYmIGEubmFtZSA+IGIubmFtZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGEuaWQgPCBiLmlkKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGEuaWQgPiBiLmlkKVxuICAgICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBQZXJtaXNzaW9uUmVxdWVzdHMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUxvY2FsUGFydGljaXBhbnQsIHVzZUhhc1Blcm1pc3Npb25zIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGxvY2FsUGFydGljaXBhbnQgPSB1c2VMb2NhbFBhcnRpY2lwYW50KCk7XG4gICAgY29uc3QgW2V4cGFuZGVkLCBzZXRFeHBhbmRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Blcm1pc3Npb25SZXF1ZXN0cywgc2V0UGVybWlzc2lvblJlcXVlc3RzXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBjYW5VcGRhdGVDYWxsUGVybWlzc2lvbnMgPSB1c2VIYXNQZXJtaXNzaW9ucyhPd25DYXBhYmlsaXR5LlVQREFURV9DQUxMX1BFUk1JU1NJT05TKTtcbiAgICBjb25zdCBsb2NhbFVzZXJJZCA9IGxvY2FsUGFydGljaXBhbnQ/LnVzZXJJZDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbGwgfHwgIWNhblVwZGF0ZUNhbGxQZXJtaXNzaW9ucylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGNhbGwub24oJ2NhbGwucGVybWlzc2lvbl9yZXF1ZXN0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudXNlci5pZCAhPT0gbG9jYWxVc2VySWQpIHtcbiAgICAgICAgICAgICAgICBzZXRQZXJtaXNzaW9uUmVxdWVzdHMoKHJlcXVlc3RzKSA9PiBbLi4ucmVxdWVzdHMsIGV2ZW50XS5zb3J0KChhLCBiKSA9PiBieU5hbWVPcklkKGEudXNlciwgYi51c2VyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBbY2FsbCwgY2FuVXBkYXRlQ2FsbFBlcm1pc3Npb25zLCBsb2NhbFVzZXJJZF0pO1xuICAgIGNvbnN0IGhhbmRsZVVwZGF0ZVBlcm1pc3Npb24gPSAocmVxdWVzdCwgdHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VyLCBwZXJtaXNzaW9ucyB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2dyYW50JzpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FsbD8uZ3JhbnRQZXJtaXNzaW9ucyh1c2VyLmlkLCBwZXJtaXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Jldm9rZSc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGw/LnJldm9rZVBlcm1pc3Npb25zKHVzZXIuaWQsIHBlcm1pc3Npb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRQZXJtaXNzaW9uUmVxdWVzdHMoKHJlcXVlc3RzKSA9PiByZXF1ZXN0cy5maWx0ZXIoKHIpID0+IHIgIT09IHJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHsgcmVmcywgeCwgeSwgc3RyYXRlZ3kgfSA9IHVzZUZsb2F0aW5nVUlQcmVzZXQoe1xuICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICB9KTtcbiAgICAvLyBkb24ndCByZW5kZXIgYW55dGhpbmcgaWYgdGhlcmUgYXJlIG5vIHBlcm1pc3Npb24gcmVxdWVzdHNcbiAgICBpZiAocGVybWlzc2lvblJlcXVlc3RzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0c1wiLCByZWY6IHJlZnMuc2V0UmVmZXJlbmNlLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RzX19ub3RpZmljYXRpb25cIiwgY2hpbGRyZW46IFtqc3hzKFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3Blcm1pc3Npb24tcmVxdWVzdHNfX25vdGlmaWNhdGlvbl9fbWVzc2FnZVwiLCBjaGlsZHJlbjogW3Blcm1pc3Npb25SZXF1ZXN0cy5sZW5ndGgsIFwiIHBlbmRpbmcgcGVybWlzc2lvbiByZXF1ZXN0c1wiXSB9KSwganN4KEJ1dHRvbiwgeyB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXhwYW5kZWQoKGUpID0+ICFlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBleHBhbmRlZCA/ICdIaWRlIHJlcXVlc3RzJyA6ICdTaG93IHJlcXVlc3RzJyB9KV0gfSksIGV4cGFuZGVkICYmIChqc3goUGVybWlzc2lvblJlcXVlc3RMaXN0LCB7IHJlZjogcmVmcy5zZXRGbG9hdGluZywgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHkgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogeCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICB9LCBwZXJtaXNzaW9uUmVxdWVzdHM6IHBlcm1pc3Npb25SZXF1ZXN0cywgaGFuZGxlVXBkYXRlUGVybWlzc2lvbjogaGFuZGxlVXBkYXRlUGVybWlzc2lvbiB9KSldIH0pKTtcbn07XG5jb25zdCBQZXJtaXNzaW9uUmVxdWVzdExpc3QgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFBlcm1pc3Npb25SZXF1ZXN0TGlzdChwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyBwZXJtaXNzaW9uUmVxdWVzdHMsIGhhbmRsZVVwZGF0ZVBlcm1pc3Npb24sIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0cy1saXN0XCIsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogcGVybWlzc2lvblJlcXVlc3RzLm1hcCgocmVxdWVzdCwgcmVxSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlciwgcGVybWlzc2lvbnMgfSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICByZXR1cm4gKGpzeChGcmFnbWVudCQxLCB7IGNoaWxkcmVuOiBwZXJtaXNzaW9ucy5tYXAoKHBlcm1pc3Npb24pID0+IChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0XCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0X19tZXNzYWdlXCIsIGNoaWxkcmVuOiBtZXNzYWdlRm9yUGVybWlzc2lvbih1c2VyLm5hbWUgfHwgdXNlci5pZCwgcGVybWlzc2lvbiwgdCkgfSksIGpzeChCdXR0b24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0X19idXR0b24tLWFsbG93XCIsIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IGhhbmRsZVVwZGF0ZVBlcm1pc3Npb24ocmVxdWVzdCwgJ2dyYW50JyksIGNoaWxkcmVuOiB0KCdBbGxvdycpIH0pLCBqc3goQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3Blcm1pc3Npb24tcmVxdWVzdF9fYnV0dG9uLS1yZWplY3RcIiwgdHlwZTogXCJidXR0b25cIiwgb25DbGljazogaGFuZGxlVXBkYXRlUGVybWlzc2lvbihyZXF1ZXN0LCAncmV2b2tlJyksIGNoaWxkcmVuOiB0KCdSZXZva2UnKSB9KSwganN4KEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RfX2J1dHRvbi0tcmVqZWN0XCIsIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IGhhbmRsZVVwZGF0ZVBlcm1pc3Npb24ocmVxdWVzdCwgJ2Rpc21pc3MnKSwgY2hpbGRyZW46IHQoJ0Rpc21pc3MnKSB9KV0gfSwgcGVybWlzc2lvbikpKSB9LCBgJHt1c2VyLmlkfS8ke3JlcUluZGV4fWApKTtcbiAgICAgICAgfSkgfSkpO1xufSk7XG5jb25zdCBCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChqc3goXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0X19idXR0b24nLCBjbGFzc05hbWUpLCAuLi5yZXN0IH0pKTtcbn07XG5jb25zdCBtZXNzYWdlRm9yUGVybWlzc2lvbiA9ICh1c2VyTmFtZSwgcGVybWlzc2lvbiwgdCkgPT4ge1xuICAgIHN3aXRjaCAocGVybWlzc2lvbikge1xuICAgICAgICBjYXNlIE93bkNhcGFiaWxpdHkuU0VORF9BVURJTzpcbiAgICAgICAgICAgIHJldHVybiB0KCd7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHNwZWFrJywgeyB1c2VyTmFtZSB9KTtcbiAgICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNFTkRfVklERU86XG4gICAgICAgICAgICByZXR1cm4gdCgne3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBzaGFyZSB0aGVpciBjYW1lcmEnLCB7XG4gICAgICAgICAgICAgICAgdXNlck5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFOlxuICAgICAgICAgICAgcmV0dXJuIHQoJ3t7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgdG8gcHJlc2VudCB0aGVpciBzY3JlZW4nLCB7XG4gICAgICAgICAgICAgICAgdXNlck5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0KCd7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHBlcm1pc3Npb246IHt7IHBlcm1pc3Npb24gfX0nLCB7XG4gICAgICAgICAgICAgICAgdXNlck5hbWUsXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmNvbnN0IFN0cmVhbVRoZW1lID0gKHsgYXM6IENvbXBvbmVudCA9ICdkaXYnLCBjbGFzc05hbWUsIGNoaWxkcmVuLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goQ29tcG9uZW50LCB7IC4uLnByb3BzLCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlbycsIGNsYXNzTmFtZSksIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCBEZWZhdWx0VmlkZW9QbGFjZWhvbGRlciA9IGZvcndhcmRSZWYoZnVuY3Rpb24gRGVmYXVsdFZpZGVvUGxhY2Vob2xkZXIoeyBwYXJ0aWNpcGFudCwgc3R5bGUgfSwgcmVmKSB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRpY2lwYW50Lm5hbWUgfHwgcGFydGljaXBhbnQudXNlcklkO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3ZpZGVvLXBsYWNlaG9sZGVyXCIsIHN0eWxlOiBzdHlsZSwgcmVmOiByZWYsIGNoaWxkcmVuOiBbKCFwYXJ0aWNpcGFudC5pbWFnZSB8fCBlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA/IChqc3goSW5pdGlhbHNGYWxsYmFjaywgeyBuYW1lOiBuYW1lIH0pKSA6IChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX192aWRlby1wbGFjZWhvbGRlcl9fbm8tdmlkZW8tbGFiZWxcIiwgY2hpbGRyZW46IHQoJ1ZpZGVvIGlzIGRpc2FibGVkJykgfSkpKSwgcGFydGljaXBhbnQuaW1hZ2UgJiYgIWVycm9yICYmIChqc3goXCJpbWdcIiwgeyBvbkVycm9yOiAoKSA9PiBzZXRFcnJvcih0cnVlKSwgYWx0OiBcInZpZGVvLXBsYWNlaG9sZGVyXCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3ZpZGVvLXBsYWNlaG9sZGVyX19hdmF0YXJcIiwgc3JjOiBwYXJ0aWNpcGFudC5pbWFnZSB9KSldIH0pKTtcbn0pO1xuY29uc3QgSW5pdGlhbHNGYWxsYmFjayA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgbmFtZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgaW5pdGlhbHMgPSBuYW1lXG4gICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgIC5zbGljZSgwLCAyKVxuICAgICAgICAubWFwKChuKSA9PiBuWzBdKVxuICAgICAgICAuam9pbignJyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX192aWRlby1wbGFjZWhvbGRlcl9faW5pdGlhbHMtZmFsbGJhY2tcIiwgY2hpbGRyZW46IGluaXRpYWxzIH0pKTtcbn07XG5cbmNvbnN0IFZpZGVvJDEgPSAoeyB0cmFja1R5cGUsIHBhcnRpY2lwYW50LCBjbGFzc05hbWUsIFZpZGVvUGxhY2Vob2xkZXIgPSBEZWZhdWx0VmlkZW9QbGFjZWhvbGRlciwgcmVmcywgLi4ucmVzdCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZXNzaW9uSWQsIHZpZGVvU3RyZWFtLCBzY3JlZW5TaGFyZVN0cmVhbSwgcHVibGlzaGVkVHJhY2tzLCB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSwgaXNMb2NhbFBhcnRpY2lwYW50LCB1c2VySWQsIH0gPSBwYXJ0aWNpcGFudDtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IFt2aWRlb0VsZW1lbnQsIHNldFZpZGVvRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICAvLyBzdGFydCB3aXRoIHRydWUsIHdpbGwgZmxpcCBvbmNlIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZ1xuICAgIGNvbnN0IFtpc1ZpZGVvUGF1c2VkLCBzZXRJc1ZpZGVvUGF1c2VkXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtpc1dpZGVNb2RlLCBzZXRJc1dpZGVNb2RlXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IHN0cmVhbSA9IHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snXG4gICAgICAgID8gdmlkZW9TdHJlYW1cbiAgICAgICAgOiB0cmFja1R5cGUgPT09ICdzY3JlZW5TaGFyZVRyYWNrJ1xuICAgICAgICAgICAgPyBzY3JlZW5TaGFyZVN0cmVhbVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsIHx8ICF2aWRlb0VsZW1lbnQgfHwgdHJhY2tUeXBlID09PSAnbm9uZScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBjYWxsLmJpbmRWaWRlb0VsZW1lbnQodmlkZW9FbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwPy4oKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY2FsbCwgdHJhY2tUeXBlLCBzZXNzaW9uSWQsIHZpZGVvRWxlbWVudF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc3RyZWFtIHx8ICF2aWRlb0VsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IFt0cmFja10gPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKCF0cmFjaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlUGxheVBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNWaWRlb1BhdXNlZCh2aWRlb0VsZW1lbnQucGF1c2VkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggPSAwLCBoZWlnaHQgPSAwIH0gPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgc2V0SXNXaWRlTW9kZSh3aWR0aCA+PSBoZWlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBwbGF5YmFjayBtYXkgaGF2ZSBzdGFydGVkIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG9cbiAgICAgICAgLy8gYXR0YWNoIHRoZSAncGxheS9wYXVzZScgZXZlbnQgbGlzdGVuZXIsIHNvIHdlIHNldCB0aGUgc3RhdGVcbiAgICAgICAgLy8gaGVyZSB0byBtYWtlIHN1cmUgaXQncyBpbiBzeW5jXG4gICAgICAgIHNldElzVmlkZW9QYXVzZWQodmlkZW9FbGVtZW50LnBhdXNlZCk7XG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5JywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXVzZScsIGhhbmRsZVBsYXlQYXVzZSk7XG4gICAgICAgICAgICB0cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCBoYW5kbGVQbGF5UGF1c2UpO1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhlICdwYXVzZScgc3RhdGUgb25jZSB3ZSB1bm1vdW50IHRoZSB2aWRlbyBlbGVtZW50XG4gICAgICAgICAgICBzZXRJc1ZpZGVvUGF1c2VkKHRydWUpO1xuICAgICAgICB9O1xuICAgIH0sIFtzdHJlYW0sIHZpZGVvRWxlbWVudF0pO1xuICAgIGlmICghY2FsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaXNQdWJsaXNoaW5nVHJhY2sgPSB0cmFja1R5cGUgPT09ICd2aWRlb1RyYWNrJ1xuICAgICAgICA/IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlZJREVPKVxuICAgICAgICA6IHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlVHJhY2snXG4gICAgICAgICAgICA/IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSlcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgaXNJbnZpc2libGUgPSB0cmFja1R5cGUgPT09ICdub25lJyB8fFxuICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZT8uW3RyYWNrVHlwZV0gPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEU7XG4gICAgY29uc3QgaGFzTm9WaWRlb09ySW52aXNpYmxlID0gIWlzUHVibGlzaGluZ1RyYWNrIHx8IGlzSW52aXNpYmxlO1xuICAgIGNvbnN0IG1pcnJvclZpZGVvID0gaXNMb2NhbFBhcnRpY2lwYW50ICYmIHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snO1xuICAgIGNvbnN0IGlzU2NyZWVuU2hhcmVUcmFjayA9IHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlVHJhY2snO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogWyFoYXNOb1ZpZGVvT3JJbnZpc2libGUgJiYgKGpzeChcInZpZGVvXCIsIHsgLi4ucmVzdCwgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3ZpZGVvJywgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLS1ub3QtcGxheWluZyc6IGlzVmlkZW9QYXVzZWQsXG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLS10YWxsJzogIWlzV2lkZU1vZGUsXG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLS1taXJyb3InOiBtaXJyb3JWaWRlbyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fdmlkZW8tLXNjcmVlbi1zaGFyZSc6IGlzU2NyZWVuU2hhcmVUcmFjayxcbiAgICAgICAgICAgICAgICB9KSwgXCJkYXRhLXVzZXItaWRcIjogdXNlcklkLCBcImRhdGEtc2Vzc2lvbi1pZFwiOiBzZXNzaW9uSWQsIHJlZjogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmlkZW9FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZWZzPy5zZXRWaWRlb0VsZW1lbnQ/LihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IH0pKSwgKGhhc05vVmlkZW9PckludmlzaWJsZSB8fCBpc1ZpZGVvUGF1c2VkKSAmJiBWaWRlb1BsYWNlaG9sZGVyICYmIChqc3goVmlkZW9QbGFjZWhvbGRlciwgeyBzdHlsZTogeyBwb3NpdGlvbjogJ2Fic29sdXRlJyB9LCBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQsIHJlZjogcmVmcz8uc2V0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnQgfSkpXSB9KSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBFeHRlbmRzIHZpZGVvIGVsZW1lbnQgd2l0aCBgc3RyZWFtYCBwcm9wZXJ0eVxuICogKGBzcmNPYmplY3RgKSB0byByZWFjdGl2ZWx5IGhhbmRsZSBzdHJlYW0gY2hhbmdlc1xuICovXG5jb25zdCBCYXNlVmlkZW8gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIEJhc2VWaWRlbyh7IHN0cmVhbSwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCBbdmlkZW9FbGVtZW50LCBzZXRWaWRlb0VsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF2aWRlb0VsZW1lbnQgfHwgIXN0cmVhbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHN0cmVhbSA9PT0gdmlkZW9FbGVtZW50LnNyY09iamVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgaWYgKEJyb3dzZXJzLmlzU2FmYXJpKCkgfHwgQnJvd3NlcnMuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggYW5kIFNhZmFyaSBoYXZlIHNvbWUgdGltaW5nIGlzc3VlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5wbGF5KCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBsYXkgc3RyZWFtYCwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnBhdXNlKCk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LCBbc3RyZWFtLCB2aWRlb0VsZW1lbnRdKTtcbiAgICByZXR1cm4gKGpzeChcInZpZGVvXCIsIHsgYXV0b1BsYXk6IHRydWUsIHBsYXlzSW5saW5lOiB0cnVlLCAuLi5yZXN0LCByZWY6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBhcHBseUVsZW1lbnRUb1JlZihyZWYsIGVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0VmlkZW9FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9IH0pKTtcbn0pO1xuXG5jb25zdCBEZWZhdWx0RGlzYWJsZWRWaWRlb1ByZXZpZXcgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyX3ZpZGVvX192aWRlby1wcmV2aWV3X19kaXNhYmxlZC12aWRlby1wcmV2aWV3XCIsIGNoaWxkcmVuOiB0KCdWaWRlbyBpcyBkaXNhYmxlZCcpIH0pKTtcbn07XG5jb25zdCBEZWZhdWx0Tm9DYW1lcmFQcmV2aWV3ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0cl92aWRlb19fdmlkZW8tcHJldmlld19fbm8tY2FtZXJhLXByZXZpZXdcIiwgY2hpbGRyZW46IHQoJ05vIGNhbWVyYSBmb3VuZCcpIH0pKTtcbn07XG5jb25zdCBWaWRlb1ByZXZpZXcgPSAoeyBjbGFzc05hbWUsIG1pcnJvciA9IHRydWUsIERpc2FibGVkVmlkZW9QcmV2aWV3ID0gRGVmYXVsdERpc2FibGVkVmlkZW9QcmV2aWV3LCBOb0NhbWVyYVByZXZpZXcgPSBEZWZhdWx0Tm9DYW1lcmFQcmV2aWV3LCBTdGFydGluZ0NhbWVyYVByZXZpZXcgPSBMb2FkaW5nSW5kaWNhdG9yLCB9KSA9PiB7XG4gICAgY29uc3QgeyB1c2VDYW1lcmFTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IGRldmljZXMsIHN0YXR1cywgaXNNdXRlLCBtZWRpYVN0cmVhbSB9ID0gdXNlQ2FtZXJhU3RhdGUoKTtcbiAgICBsZXQgY29udGVudHM7XG4gICAgaWYgKGlzTXV0ZSAmJiBkZXZpY2VzPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGVudHMgPSBqc3goTm9DYW1lcmFQcmV2aWV3LCB7fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgIGNvbnN0IGxvYWRpbmcgPSAhbWVkaWFTdHJlYW07XG4gICAgICAgIGNvbnRlbnRzID0gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFttZWRpYVN0cmVhbSAmJiAoanN4KEJhc2VWaWRlbywgeyBzdHJlYW06IG1lZGlhU3RyZWFtLCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fdmlkZW8tcHJldmlldycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLXByZXZpZXctLW1pcnJvcic6IG1pcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX3ZpZGVvLXByZXZpZXctLWxvYWRpbmcnOiBsb2FkaW5nLFxuICAgICAgICAgICAgICAgICAgICB9KSB9KSksIGxvYWRpbmcgJiYganN4KFN0YXJ0aW5nQ2FtZXJhUHJldmlldywge30pXSB9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250ZW50cyA9IGpzeChEaXNhYmxlZFZpZGVvUHJldmlldywge30pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX192aWRlby1wcmV2aWV3LWNvbnRhaW5lcicsIGNsYXNzTmFtZSksIGNoaWxkcmVuOiBjb250ZW50cyB9KSk7XG59O1xuXG5jb25zdCBQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50LCBwYXJ0aWNpcGFudFZpZXdFbGVtZW50LCB2aWRlb0VsZW1lbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCBbZnVsbHNjcmVlbk1vZGVPbiwgc2V0RnVsbHNjcmVlbk1vZGVPbl0gPSB1c2VTdGF0ZSghIWRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50KTtcbiAgICBjb25zdCBbcGljdHVyZUluUGljdHVyZUVsZW1lbnQsIHNldFBpY3R1cmVJblBpY3R1cmVFbGVtZW50XSA9IHVzZVN0YXRlKGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50KTtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgcGluLCBwdWJsaXNoZWRUcmFja3MsIHNlc3Npb25JZCwgdXNlcklkIH0gPSBwYXJ0aWNpcGFudDtcbiAgICBjb25zdCBoYXNBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLkFVRElPKTtcbiAgICBjb25zdCBoYXNWaWRlbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlZJREVPKTtcbiAgICBjb25zdCBoYXNTY3JlZW5TaGFyZSA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSk7XG4gICAgY29uc3QgaGFzU2NyZWVuU2hhcmVBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTyk7XG4gICAgY29uc3QgYmxvY2tVc2VyID0gKCkgPT4gY2FsbD8uYmxvY2tVc2VyKHVzZXJJZCk7XG4gICAgY29uc3QgbXV0ZUF1ZGlvID0gKCkgPT4gY2FsbD8ubXV0ZVVzZXIodXNlcklkLCAnYXVkaW8nKTtcbiAgICBjb25zdCBtdXRlVmlkZW8gPSAoKSA9PiBjYWxsPy5tdXRlVXNlcih1c2VySWQsICd2aWRlbycpO1xuICAgIGNvbnN0IG11dGVTY3JlZW5TaGFyZSA9ICgpID0+IGNhbGw/Lm11dGVVc2VyKHVzZXJJZCwgJ3NjcmVlbnNoYXJlJyk7XG4gICAgY29uc3QgbXV0ZVNjcmVlblNoYXJlQXVkaW8gPSAoKSA9PiBjYWxsPy5tdXRlVXNlcih1c2VySWQsICdzY3JlZW5zaGFyZV9hdWRpbycpO1xuICAgIGNvbnN0IGdyYW50UGVybWlzc2lvbiA9IChwZXJtaXNzaW9uKSA9PiAoKSA9PiB7XG4gICAgICAgIGNhbGw/LnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICBncmFudF9wZXJtaXNzaW9uczogW3Blcm1pc3Npb25dLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJldm9rZVBlcm1pc3Npb24gPSAocGVybWlzc2lvbikgPT4gKCkgPT4ge1xuICAgICAgICBjYWxsPy51cGRhdGVVc2VyUGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgcmV2b2tlX3Blcm1pc3Npb25zOiBbcGVybWlzc2lvbl0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlUGFydGljaXBhbnRQaW4gPSAoKSA9PiB7XG4gICAgICAgIGlmIChwaW4pIHtcbiAgICAgICAgICAgIGNhbGw/LnVucGluKHNlc3Npb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsPy5waW4oc2Vzc2lvbklkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGluRm9yRXZlcnlvbmUgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxcbiAgICAgICAgICAgID8ucGluRm9yRXZlcnlvbmUoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwaW4gcGFydGljaXBhbnQgJHt1c2VySWR9YCwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB1bnBpbkZvckV2ZXJ5b25lID0gKCkgPT4ge1xuICAgICAgICBjYWxsXG4gICAgICAgICAgICA/LnVucGluRm9yRXZlcnlvbmUoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1bnBpbiBwYXJ0aWNpcGFudCAke3VzZXJJZH1gLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRvZ2dsZUZ1bGxzY3JlZW5Nb2RlID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWZ1bGxzY3JlZW5Nb2RlT24pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWNpcGFudFZpZXdFbGVtZW50Py5yZXF1ZXN0RnVsbHNjcmVlbigpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH07XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gaGFuZGxlcyB0aGUgY2FzZSB3aGVuIGZ1bGxzY3JlZW4gbW9kZSBpcyB0b2dnbGVkIGV4dGVybmFsbHksXG4gICAgICAgIC8vIGUuZy4sIGJ5IHByZXNzaW5nIEVTQyBrZXkgb3Igc29tZSBvdGhlciBrZXlib2FyZCBzaG9ydGN1dFxuICAgICAgICBjb25zdCBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0RnVsbHNjcmVlbk1vZGVPbighIWRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXZpZGVvRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlUGlQID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0UGljdHVyZUluUGljdHVyZUVsZW1lbnQoZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgaGFuZGxlUGlQKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIGhhbmRsZVBpUCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgaGFuZGxlUGlQKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsZWF2ZXBpY3R1cmVpbnBpY3R1cmUnLCBoYW5kbGVQaVApO1xuICAgICAgICB9O1xuICAgIH0sIFt2aWRlb0VsZW1lbnRdKTtcbiAgICBjb25zdCB0b2dnbGVQaWN0dXJlSW5QaWN0dXJlID0gKCkgPT4ge1xuICAgICAgICBpZiAodmlkZW9FbGVtZW50ICYmIHBpY3R1cmVJblBpY3R1cmVFbGVtZW50ICE9PSB2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWRlb0VsZW1lbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdFBpY3R1cmVJblBpY3R1cmUoKVxuICAgICAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZXhpdFBpY3R1cmVJblBpY3R1cmUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICB9O1xuICAgIGNvbnN0IHsgY2xvc2UgfSA9IHVzZU1lbnVDb250ZXh0KCkgfHwge307XG4gICAgcmV0dXJuIChqc3hzKEdlbmVyaWNNZW51LCB7IG9uSXRlbUNsaWNrOiBjbG9zZSwgY2hpbGRyZW46IFtqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiB0b2dnbGVQYXJ0aWNpcGFudFBpbiwgZGlzYWJsZWQ6IHBpbiAmJiAhcGluLmlzTG9jYWxQaW4sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJwaW5cIiB9KSwgcGluID8gdCgnVW5waW4nKSA6IHQoJ1BpbicpXSB9KSwganN4cyhSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5QSU5fRk9SX0VWRVJZT05FXSwgY2hpbGRyZW46IFtqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBwaW5Gb3JFdmVyeW9uZSwgZGlzYWJsZWQ6IHBpbiAmJiAhcGluLmlzTG9jYWxQaW4sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJwaW5cIiB9KSwgdCgnUGluIGZvciBldmVyeW9uZScpXSB9KSwganN4cyhHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogdW5waW5Gb3JFdmVyeW9uZSwgZGlzYWJsZWQ6ICFwaW4gfHwgcGluLmlzTG9jYWxQaW4sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJwaW5cIiB9KSwgdCgnVW5waW4gZm9yIGV2ZXJ5b25lJyldIH0pXSB9KSwganN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LkJMT0NLX1VTRVJTXSwgY2hpbGRyZW46IGpzeHMoR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IGJsb2NrVXNlciwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBcIm5vdC1hbGxvd2VkXCIgfSksIHQoJ0Jsb2NrJyldIH0pIH0pLCBqc3hzKFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5Lk1VVEVfVVNFUlNdLCBjaGlsZHJlbjogW2hhc1ZpZGVvICYmIChqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBtdXRlVmlkZW8sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJjYW1lcmEtb2ZmLW91dGxpbmVcIiB9KSwgdCgnVHVybiBvZmYgdmlkZW8nKV0gfSkpLCBoYXNTY3JlZW5TaGFyZSAmJiAoanN4cyhHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogbXV0ZVNjcmVlblNoYXJlLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IFwic2NyZWVuLXNoYXJlLW9mZlwiIH0pLCB0KCdUdXJuIG9mZiBzY3JlZW4gc2hhcmUnKV0gfSkpLCBoYXNBdWRpbyAmJiAoanN4cyhHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogbXV0ZUF1ZGlvLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IFwibm8tYXVkaW9cIiB9KSwgdCgnTXV0ZSBhdWRpbycpXSB9KSksIGhhc1NjcmVlblNoYXJlQXVkaW8gJiYgKGpzeHMoR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IG11dGVTY3JlZW5TaGFyZUF1ZGlvLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IFwibm8tYXVkaW9cIiB9KSwgdCgnTXV0ZSBzY3JlZW4gc2hhcmUgYXVkaW8nKV0gfSkpXSB9KSwgcGFydGljaXBhbnRWaWV3RWxlbWVudCAmJiAoanN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiB0b2dnbGVGdWxsc2NyZWVuTW9kZSwgY2hpbGRyZW46IHQoJ3t7IGRpcmVjdGlvbiB9fSBmdWxsc2NyZWVuJywge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGZ1bGxzY3JlZW5Nb2RlT24gPyB0KCdMZWF2ZScpIDogdCgnRW50ZXInKSxcbiAgICAgICAgICAgICAgICB9KSB9KSksIHZpZGVvRWxlbWVudCAmJiBkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRW5hYmxlZCAmJiAoanN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiB0b2dnbGVQaWN0dXJlSW5QaWN0dXJlLCBjaGlsZHJlbjogdCgne3sgZGlyZWN0aW9uIH19IHBpY3R1cmUtaW4tcGljdHVyZScsIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBwaWN0dXJlSW5QaWN0dXJlRWxlbWVudCA9PT0gdmlkZW9FbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHQoJ0xlYXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdCgnRW50ZXInKSxcbiAgICAgICAgICAgICAgICB9KSB9KSksIGpzeHMoUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuVVBEQVRFX0NBTExfUEVSTUlTU0lPTlNdLCBjaGlsZHJlbjogW2pzeChHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogZ3JhbnRQZXJtaXNzaW9uKE93bkNhcGFiaWxpdHkuU0VORF9BVURJTyksIGNoaWxkcmVuOiB0KCdBbGxvdyBhdWRpbycpIH0pLCBqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IGdyYW50UGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNFTkRfVklERU8pLCBjaGlsZHJlbjogdCgnQWxsb3cgdmlkZW8nKSB9KSwganN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBncmFudFBlcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5TQ1JFRU5TSEFSRSksIGNoaWxkcmVuOiB0KCdBbGxvdyBzY3JlZW4gc2hhcmluZycpIH0pLCBqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IHJldm9rZVBlcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPKSwgY2hpbGRyZW46IHQoJ0Rpc2FibGUgYXVkaW8nKSB9KSwganN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiByZXZva2VQZXJtaXNzaW9uKE93bkNhcGFiaWxpdHkuU0VORF9WSURFTyksIGNoaWxkcmVuOiB0KCdEaXNhYmxlIHZpZGVvJykgfSksIGpzeChHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogcmV2b2tlUGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFKSwgY2hpbGRyZW46IHQoJ0Rpc2FibGUgc2NyZWVuIHNoYXJpbmcnKSB9KV0gfSldIH0pKTtcbn07XG5cbmNvbnN0IHVzZVRyYWNrRWxlbWVudFZpc2liaWxpdHkgPSAoeyB0cmFja2VkRWxlbWVudCwgZHluYXNjYWxlTWFuYWdlcjogcHJvcHNEeW5hc2NhbGVNYW5hZ2VyLCBzZXNzaW9uSWQsIHRyYWNrVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgbWFuYWdlciA9IHByb3BzRHluYXNjYWxlTWFuYWdlciA/PyBjYWxsPy5keW5hc2NhbGVNYW5hZ2VyO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdHJhY2tlZEVsZW1lbnQgfHwgIW1hbmFnZXIgfHwgIWNhbGwgfHwgdHJhY2tUeXBlID09PSAnbm9uZScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVub2JzZXJ2ZSA9IG1hbmFnZXIudHJhY2tFbGVtZW50VmlzaWJpbGl0eSh0cmFja2VkRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5vYnNlcnZlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW3RyYWNrZWRFbGVtZW50LCBtYW5hZ2VyLCBjYWxsLCBzZXNzaW9uSWQsIHRyYWNrVHlwZV0pO1xufTtcblxuY29uc3QgVG9nZ2xlQnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBUb2dnbGVCdXR0b24ocHJvcHMsIHJlZikge1xuICAgIHJldHVybiBqc3goSWNvbkJ1dHRvbiwgeyBlbmFibGVkOiBwcm9wcy5tZW51U2hvd24sIGljb246IFwiZWxsaXBzaXNcIiwgcmVmOiByZWYgfSk7XG59KTtcbmNvbnN0IERlZmF1bHRTY3JlZW5TaGFyZU92ZXJsYXkgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCBzdG9wU2NyZWVuU2hhcmUgPSAoKSA9PiB7XG4gICAgICAgIGNhbGw/LnNjcmVlblNoYXJlLmRpc2FibGUoKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NjcmVlbi1zaGFyZS1vdmVybGF5XCIsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJzY3JlZW4tc2hhcmUtb2ZmXCIgfSksIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zY3JlZW4tc2hhcmUtb3ZlcmxheV9fdGl0bGVcIiwgY2hpbGRyZW46IHQoJ1lvdSBhcmUgcHJlc2VudGluZyB5b3VyIHNjcmVlbicpIH0pLCBqc3hzKFwiYnV0dG9uXCIsIHsgb25DbGljazogc3RvcFNjcmVlblNoYXJlLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zY3JlZW4tc2hhcmUtb3ZlcmxheV9fYnV0dG9uXCIsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJjbG9zZVwiIH0pLCBcIiBcIiwgdCgnU3RvcCBTY3JlZW4gU2hhcmluZycpXSB9KV0gfSkpO1xufTtcbmNvbnN0IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSA9ICh7IGluZGljYXRvcnNWaXNpYmxlID0gdHJ1ZSwgbWVudVBsYWNlbWVudCA9ICdib3R0b20tc3RhcnQnLCBzaG93TWVudUJ1dHRvbiA9IHRydWUsIFBhcnRpY2lwYW50QWN0aW9uc0NvbnRleHRNZW51OiBQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSQxID0gUGFydGljaXBhbnRBY3Rpb25zQ29udGV4dE1lbnUsIH0pID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50LCB0cmFja1R5cGUgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCB7IHB1Ymxpc2hlZFRyYWNrcyB9ID0gcGFydGljaXBhbnQ7XG4gICAgY29uc3QgaGFzU2NyZWVuU2hhcmUgPSBwdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpO1xuICAgIGlmIChwYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnQgJiZcbiAgICAgICAgaGFzU2NyZWVuU2hhcmUgJiZcbiAgICAgICAgdHJhY2tUeXBlID09PSAnc2NyZWVuU2hhcmVUcmFjaycpIHtcbiAgICAgICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KERlZmF1bHRTY3JlZW5TaGFyZU92ZXJsYXksIHt9KSwganN4KFBhcnRpY2lwYW50RGV0YWlscywgeyBpbmRpY2F0b3JzVmlzaWJsZTogaW5kaWNhdG9yc1Zpc2libGUgfSldIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbc2hvd01lbnVCdXR0b24gJiYgKGpzeChNZW51VG9nZ2xlLCB7IHN0cmF0ZWd5OiBcImZpeGVkXCIsIHBsYWNlbWVudDogbWVudVBsYWNlbWVudCwgVG9nZ2xlQnV0dG9uOiBUb2dnbGVCdXR0b24sIGNoaWxkcmVuOiBqc3goUGFydGljaXBhbnRBY3Rpb25zQ29udGV4dE1lbnUkMSwge30pIH0pKSwganN4KFJlYWN0aW9uLCB7IHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCB9KSwganN4KFBhcnRpY2lwYW50RGV0YWlscywgeyBpbmRpY2F0b3JzVmlzaWJsZTogaW5kaWNhdG9yc1Zpc2libGUgfSldIH0pKTtcbn07XG5jb25zdCBQYXJ0aWNpcGFudERldGFpbHMgPSAoeyBpbmRpY2F0b3JzVmlzaWJsZSA9IHRydWUsIH0pID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50IH0gPSB1c2VQYXJ0aWNpcGFudFZpZXdDb250ZXh0KCk7XG4gICAgY29uc3QgeyBpc0xvY2FsUGFydGljaXBhbnQsIGNvbm5lY3Rpb25RdWFsaXR5LCBwdWJsaXNoZWRUcmFja3MsIHBpbiwgc2Vzc2lvbklkLCBuYW1lLCB1c2VySWQsIH0gPSBwYXJ0aWNpcGFudDtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25RdWFsaXR5QXNTdHJpbmcgPSAhIWNvbm5lY3Rpb25RdWFsaXR5ICYmXG4gICAgICAgIFNmdU1vZGVscy5Db25uZWN0aW9uUXVhbGl0eVtjb25uZWN0aW9uUXVhbGl0eV0udG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBoYXNBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLkFVRElPKTtcbiAgICBjb25zdCBoYXNWaWRlbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlZJREVPKTtcbiAgICBjb25zdCBjYW5VbnBpbiA9ICEhcGluICYmIHBpbi5pc0xvY2FsUGluO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWRldGFpbHNcIiwgY2hpbGRyZW46IGpzeHMoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc19fbmFtZVwiLCBjaGlsZHJlbjogW25hbWUgfHwgdXNlcklkLCBpbmRpY2F0b3JzVmlzaWJsZSAmJiAhaGFzQXVkaW8gJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1kZXRhaWxzX19uYW1lLS1hdWRpby1tdXRlZFwiIH0pKSwgaW5kaWNhdG9yc1Zpc2libGUgJiYgIWhhc1ZpZGVvICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc19fbmFtZS0tdmlkZW8tbXV0ZWRcIiB9KSksIGluZGljYXRvcnNWaXNpYmxlICYmIGNhblVucGluICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG1vbnN0cm9zaXR5IG9uY2Ugd2UgaGF2ZSBhIHByb3BlciBkZXNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIGpzeChcInNwYW5cIiwgeyB0aXRsZTogdCgnVW5waW4nKSwgb25DbGljazogKCkgPT4gY2FsbD8udW5waW4oc2Vzc2lvbklkKSwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc19fbmFtZS0tcGlubmVkXCIgfSkpLCBpbmRpY2F0b3JzVmlzaWJsZSAmJiBqc3goU3BlZWNoSW5kaWNhdG9yLCB7fSldIH0pIH0pLCBpbmRpY2F0b3JzVmlzaWJsZSAmJiAoanN4KE5vdGlmaWNhdGlvbiwgeyBpc1Zpc2libGU6IGlzTG9jYWxQYXJ0aWNpcGFudCAmJlxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uUXVhbGl0eSA9PT0gU2Z1TW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5LlBPT1IsIG1lc3NhZ2U6IHQoJ1Bvb3IgY29ubmVjdGlvbiBxdWFsaXR5JyksIGNoaWxkcmVuOiBjb25uZWN0aW9uUXVhbGl0eUFzU3RyaW5nICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWRldGFpbHNfX2Nvbm5lY3Rpb24tcXVhbGl0eScsIGBzdHItdmlkZW9fX3BhcnRpY2lwYW50LWRldGFpbHNfX2Nvbm5lY3Rpb24tcXVhbGl0eS0tJHtjb25uZWN0aW9uUXVhbGl0eUFzU3RyaW5nfWApLCB0aXRsZTogY29ubmVjdGlvblF1YWxpdHlBc1N0cmluZyB9KSkgfSkpXSB9KSk7XG59O1xuY29uc3QgU3BlZWNoSW5kaWNhdG9yID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCB7IGlzU3BlYWtpbmcsIGlzRG9taW5hbnRTcGVha2VyIH0gPSBwYXJ0aWNpcGFudDtcbiAgICByZXR1cm4gKGpzeHMoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3NwZWVjaC1pbmRpY2F0b3InLCBpc1NwZWFraW5nICYmICdzdHItdmlkZW9fX3NwZWVjaC1pbmRpY2F0b3ItLXNwZWFraW5nJywgaXNEb21pbmFudFNwZWFrZXIgJiYgJ3N0ci12aWRlb19fc3BlZWNoLWluZGljYXRvci0tZG9taW5hbnQnKSwgY2hpbGRyZW46IFtqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlZWNoLWluZGljYXRvcl9fYmFyXCIgfSksIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVlY2gtaW5kaWNhdG9yX19iYXJcIiB9KSwganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWVjaC1pbmRpY2F0b3JfX2JhclwiIH0pXSB9KSk7XG59O1xuXG5jb25zdCBQYXJ0aWNpcGFudFZpZXcgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFBhcnRpY2lwYW50Vmlldyh7IHBhcnRpY2lwYW50LCB0cmFja1R5cGUgPSAndmlkZW9UcmFjaycsIG11dGVBdWRpbywgcmVmczogeyBzZXRWaWRlb0VsZW1lbnQsIHNldFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50IH0gPSB7fSwgY2xhc3NOYW1lLCBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSSA9IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSwgfSwgcmVmKSB7XG4gICAgY29uc3QgeyBpc0xvY2FsUGFydGljaXBhbnQsIGlzU3BlYWtpbmcsIGlzRG9taW5hbnRTcGVha2VyLCBwdWJsaXNoZWRUcmFja3MsIHNlc3Npb25JZCwgfSA9IHBhcnRpY2lwYW50O1xuICAgIGNvbnN0IGhhc0F1ZGlvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuQVVESU8pO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuVklERU8pO1xuICAgIGNvbnN0IGhhc1NjcmVlblNoYXJlQXVkaW8gPSBwdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pO1xuICAgIGNvbnN0IFt0cmFja2VkRWxlbWVudCwgc2V0VHJhY2tlZEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2NvbnRleHRWaWRlb0VsZW1lbnQsIHNldENvbnRleHRWaWRlb0VsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2NvbnRleHRWaWRlb1BsYWNlaG9sZGVyRWxlbWVudCwgc2V0Q29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIC8vIFRPRE86IGFsbG93IHRvIHBhc3MgY3VzdG9tIFZpZXdwb3J0VHJhY2tlciBpbnN0YW5jZSBmcm9tIHByb3BzXG4gICAgdXNlVHJhY2tFbGVtZW50VmlzaWJpbGl0eSh7XG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgdHJhY2tlZEVsZW1lbnQsXG4gICAgICAgIHRyYWNrVHlwZSxcbiAgICB9KTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudFZpZXdDb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgICBwYXJ0aWNpcGFudFZpZXdFbGVtZW50OiB0cmFja2VkRWxlbWVudCxcbiAgICAgICAgdmlkZW9FbGVtZW50OiBjb250ZXh0VmlkZW9FbGVtZW50LFxuICAgICAgICB2aWRlb1BsYWNlaG9sZGVyRWxlbWVudDogY29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50LFxuICAgICAgICB0cmFja1R5cGUsXG4gICAgfSksIFtcbiAgICAgICAgY29udGV4dFZpZGVvRWxlbWVudCxcbiAgICAgICAgY29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50LFxuICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAgdHJhY2tlZEVsZW1lbnQsXG4gICAgICAgIHRyYWNrVHlwZSxcbiAgICBdKTtcbiAgICBjb25zdCB2aWRlb1JlZnMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIHNldFZpZGVvRWxlbWVudDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHNldFZpZGVvRWxlbWVudD8uKGVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0Q29udGV4dFZpZGVvRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnQ6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBzZXRWaWRlb1BsYWNlaG9sZGVyRWxlbWVudD8uKGVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0Q29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgIH0pLCBbc2V0VmlkZW9FbGVtZW50LCBzZXRWaWRlb1BsYWNlaG9sZGVyRWxlbWVudF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInBhcnRpY2lwYW50LXZpZXdcIiwgcmVmOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgYXBwbHlFbGVtZW50VG9SZWYocmVmLCBlbGVtZW50KTtcbiAgICAgICAgICAgIHNldFRyYWNrZWRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9LCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fcGFydGljaXBhbnQtdmlldycsIGlzRG9taW5hbnRTcGVha2VyICYmICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LXZpZXctLWRvbWluYW50LXNwZWFrZXInLCBpc1NwZWFraW5nICYmICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LXZpZXctLXNwZWFraW5nJywgIWhhc1ZpZGVvICYmICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LXZpZXctLW5vLXZpZGVvJywgIWhhc0F1ZGlvICYmICdzdHItdmlkZW9fX3BhcnRpY2lwYW50LXZpZXctLW5vLWF1ZGlvJywgY2xhc3NOYW1lKSwgY2hpbGRyZW46IGpzeHMoUGFydGljaXBhbnRWaWV3Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcGFydGljaXBhbnRWaWV3Q29udGV4dFZhbHVlLCBjaGlsZHJlbjogWyFpc0xvY2FsUGFydGljaXBhbnQgJiYgIW11dGVBdWRpbyAmJiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2hhc0F1ZGlvICYmIChqc3goQXVkaW8sIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50LCB0cmFja1R5cGU6IFwiYXVkaW9UcmFja1wiIH0pKSwgaGFzU2NyZWVuU2hhcmVBdWRpbyAmJiAoanN4KEF1ZGlvLCB7IHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCwgdHJhY2tUeXBlOiBcInNjcmVlblNoYXJlQXVkaW9UcmFja1wiIH0pKV0gfSkpLCBqc3goVmlkZW8kMSwgeyBWaWRlb1BsYWNlaG9sZGVyOiBWaWRlb1BsYWNlaG9sZGVyLCBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQsIHRyYWNrVHlwZTogdHJhY2tUeXBlLCByZWZzOiB2aWRlb1JlZnMsIGF1dG9QbGF5OiB0cnVlIH0pLCBpc0NvbXBvbmVudFR5cGUoUGFydGljaXBhbnRWaWV3VUkpID8gKGpzeChQYXJ0aWNpcGFudFZpZXdVSSwge30pKSA6IChQYXJ0aWNpcGFudFZpZXdVSSldIH0pIH0pKTtcbn0pO1xuXG4vLyByZS1leHBvcnRpbmcgdGhlIFN0cmVhbUNhbGxQcm92aWRlciBhcyBTdHJlYW1DYWxsXG5jb25zdCBTdHJlYW1DYWxsID0gU3RyZWFtQ2FsbFByb3ZpZGVyO1xuXG52YXIgSm9pbmluZyA9IFwiSm9pbmluZ1wiO1xudmFyIE1pYyA9IFwiTWljXCI7XG52YXIgUmluZ2luZyA9IFwiUmluZ2luZ1wiO1xudmFyIFNwZWFrZXJzID0gXCJTcGVha2Vyc1wiO1xudmFyIFZpZGVvID0gXCJWaWRlb1wiO1xudmFyIExpdmUgPSBcIkxpdmVcIjtcbnZhciBSZWFjdGlvbnMgPSBcIlJlYWN0aW9uc1wiO1xudmFyIFN0YXRpc3RpY3MgPSBcIlN0YXRpc3RpY3NcIjtcbnZhciBJbnZpdGUgPSBcIkludml0ZVwiO1xudmFyIEpvaW4gPSBcIkpvaW5cIjtcbnZhciBZb3UgPSBcIllvdVwiO1xudmFyIE1lID0gXCJNZVwiO1xudmFyIFVua25vd24gPSBcIlVua25vd25cIjtcbnZhciBSZWZyZXNoID0gXCJSZWZyZXNoXCI7XG52YXIgQWxsb3cgPSBcIkFsbG93XCI7XG52YXIgUmV2b2tlID0gXCJSZXZva2VcIjtcbnZhciBEaXNtaXNzID0gXCJEaXNtaXNzXCI7XG52YXIgUGlubmVkID0gXCJQaW5uZWRcIjtcbnZhciBVbnBpbiA9IFwiVW5waW5cIjtcbnZhciBQaW4gPSBcIlBpblwiO1xudmFyIEJsb2NrID0gXCJCbG9ja1wiO1xudmFyIEVudGVyID0gXCJFbnRlclwiO1xudmFyIExlYXZlID0gXCJMZWF2ZVwiO1xudmFyIFBhcnRpY2lwYW50cyA9IFwiUGFydGljaXBhbnRzXCI7XG52YXIgQW5vbnltb3VzID0gXCIsIGFuZCAoe3sgY291bnQgfX0pIGFub255bW91c1wiO1xudmFyIGVuID0ge1xuXHRKb2luaW5nOiBKb2luaW5nLFxuXHRNaWM6IE1pYyxcblx0XCJObyBpbnRlcm5ldCBjb25uZWN0aW9uXCI6IFwiTm8gaW50ZXJuZXQgY29ubmVjdGlvblwiLFxuXHRcIlJlLWNvbm5lY3RpbmdcIjogXCJSZS1jb25uZWN0aW5nXCIsXG5cdFJpbmdpbmc6IFJpbmdpbmcsXG5cdFwiU2NyZWVuIFNoYXJlXCI6IFwiU2NyZWVuIFNoYXJlXCIsXG5cdFwiU2VsZWN0IGEgQ2FtZXJhXCI6IFwiU2VsZWN0IGEgQ2FtZXJhXCIsXG5cdFwiU2VsZWN0IGEgTWljXCI6IFwiU2VsZWN0IGEgTWljXCIsXG5cdFwiU2VsZWN0IFNwZWFrZXJzXCI6IFwiU2VsZWN0IFNwZWFrZXJzXCIsXG5cdFNwZWFrZXJzOiBTcGVha2Vycyxcblx0VmlkZW86IFZpZGVvLFxuXHRcIllvdSBhcmUgbXV0ZWQuIFVubXV0ZSB0byBzcGVhay5cIjogXCJZb3UgYXJlIG11dGVkLiBVbm11dGUgdG8gc3BlYWsuXCIsXG5cdExpdmU6IExpdmUsXG5cdFwiWW91IGNhbiBub3cgc3BlYWsuXCI6IFwiWW91IGNhbiBub3cgc3BlYWsuXCIsXG5cdFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNwZWFrLlwiOiBcIkF3YWl0aW5nIGZvciBhbiBhcHByb3ZhbCB0byBzcGVhay5cIixcblx0XCJZb3UgY2FuIG5vIGxvbmdlciBzcGVhay5cIjogXCJZb3UgY2FuIG5vIGxvbmdlciBzcGVhay5cIixcblx0XCJZb3UgY2FuIG5vdyBzaGFyZSB5b3VyIHZpZGVvLlwiOiBcIllvdSBjYW4gbm93IHNoYXJlIHlvdXIgdmlkZW8uXCIsXG5cdFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNoYXJlIHlvdXIgdmlkZW8uXCI6IFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNoYXJlIHlvdXIgdmlkZW8uXCIsXG5cdFwiWW91IGNhbiBubyBsb25nZXIgc2hhcmUgeW91ciB2aWRlby5cIjogXCJZb3UgY2FuIG5vIGxvbmdlciBzaGFyZSB5b3VyIHZpZGVvLlwiLFxuXHRcIldhaXRpbmcgZm9yIHJlY29yZGluZyB0byBzdG9wLi4uXCI6IFwiV2FpdGluZyBmb3IgcmVjb3JkaW5nIHRvIHN0b3AuLi5cIixcblx0XCJXYWl0aW5nIGZvciByZWNvcmRpbmcgdG8gc3RhcnQuLi5cIjogXCJXYWl0aW5nIGZvciByZWNvcmRpbmcgdG8gc3RhcnQuLi5cIixcblx0XCJSZWNvcmQgY2FsbFwiOiBcIlJlY29yZCBjYWxsXCIsXG5cdFJlYWN0aW9uczogUmVhY3Rpb25zLFxuXHRTdGF0aXN0aWNzOiBTdGF0aXN0aWNzLFxuXHRcIllvdSBjYW4gbm93IHNoYXJlIHlvdXIgc2NyZWVuLlwiOiBcIllvdSBjYW4gbm93IHNoYXJlIHlvdXIgc2NyZWVuLlwiLFxuXHRcIkF3YWl0aW5nIGZvciBhbiBhcHByb3ZhbCB0byBzaGFyZSBzY3JlZW4uXCI6IFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNoYXJlIHNjcmVlbi5cIixcblx0XCJZb3UgY2FuIG5vIGxvbmdlciBzaGFyZSB5b3VyIHNjcmVlbi5cIjogXCJZb3UgY2FuIG5vIGxvbmdlciBzaGFyZSB5b3VyIHNjcmVlbi5cIixcblx0XCJTaGFyZSBzY3JlZW5cIjogXCJTaGFyZSBzY3JlZW5cIixcblx0XCJJbmNvbWluZyBDYWxsLi4uXCI6IFwiSW5jb21pbmcgQ2FsbC4uLlwiLFxuXHRcIkNhbGxpbmcuLi5cIjogXCJDYWxsaW5nLi4uXCIsXG5cdFwiTXV0ZSBBbGxcIjogXCJNdXRlIEFsbFwiLFxuXHRJbnZpdGU6IEludml0ZSxcblx0Sm9pbjogSm9pbixcblx0WW91OiBZb3UsXG5cdE1lOiBNZSxcblx0VW5rbm93bjogVW5rbm93bixcblx0XCJUb2dnbGUgZGV2aWNlIG1lbnVcIjogXCJUb2dnbGUgZGV2aWNlIG1lbnVcIixcblx0XCJDYWxsIFJlY29yZGluZ3NcIjogXCJDYWxsIFJlY29yZGluZ3NcIixcblx0UmVmcmVzaDogUmVmcmVzaCxcblx0XCJDaGVjayB5b3VyIGJyb3dzZXIgdmlkZW8gcGVybWlzc2lvbnNcIjogXCJDaGVjayB5b3VyIGJyb3dzZXIgdmlkZW8gcGVybWlzc2lvbnNcIixcblx0XCJWaWRlbyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkIGJ5IHRoZSBzeXN0ZW1cIjogXCJWaWRlbyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkIGJ5IHRoZSBzeXN0ZW1cIixcblx0XCJZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgdmlkZW9cIjogXCJZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgdmlkZW9cIixcblx0XCJZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgYXVkaW9cIjogXCJZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgYXVkaW9cIixcblx0XCJZb3UgYXJlIHByZXNlbnRpbmcgeW91ciBzY3JlZW5cIjogXCJZb3UgYXJlIHByZXNlbnRpbmcgeW91ciBzY3JlZW5cIixcblx0XCJTdG9wIFNjcmVlbiBTaGFyaW5nXCI6IFwiU3RvcCBTY3JlZW4gU2hhcmluZ1wiLFxuXHRBbGxvdzogQWxsb3csXG5cdFJldm9rZTogUmV2b2tlLFxuXHREaXNtaXNzOiBEaXNtaXNzLFxuXHRcIk1pY3JvcGhvbmUgb25cIjogXCJNaWNyb3Bob25lIG9uXCIsXG5cdFwiTWljcm9waG9uZSBvZmZcIjogXCJNaWNyb3Bob25lIG9mZlwiLFxuXHRcIkNhbWVyYSBvblwiOiBcIkNhbWVyYSBvblwiLFxuXHRcIkNhbWVyYSBvZmZcIjogXCJDYW1lcmEgb2ZmXCIsXG5cdFwiTm8gY2FtZXJhIGZvdW5kXCI6IFwiTm8gY2FtZXJhIGZvdW5kXCIsXG5cdFwiVmlkZW8gaXMgZGlzYWJsZWRcIjogXCJWaWRlbyBpcyBkaXNhYmxlZFwiLFxuXHRQaW5uZWQ6IFBpbm5lZCxcblx0VW5waW46IFVucGluLFxuXHRQaW46IFBpbixcblx0XCJQaW4gZm9yIGV2ZXJ5b25lXCI6IFwiUGluIGZvciBldmVyeW9uZVwiLFxuXHRcIlVucGluIGZvciBldmVyeW9uZVwiOiBcIlVucGluIGZvciBldmVyeW9uZVwiLFxuXHRCbG9jazogQmxvY2ssXG5cdFwiVHVybiBvZmYgdmlkZW9cIjogXCJUdXJuIG9mZiB2aWRlb1wiLFxuXHRcIlR1cm4gb2ZmIHNjcmVlbiBzaGFyZVwiOiBcIlR1cm4gb2ZmIHNjcmVlbiBzaGFyZVwiLFxuXHRcIk11dGUgYXVkaW9cIjogXCJNdXRlIGF1ZGlvXCIsXG5cdFwiTXV0ZSBzY3JlZW4gc2hhcmUgYXVkaW9cIjogXCJNdXRlIHNjcmVlbiBzaGFyZSBhdWRpb1wiLFxuXHRcIkFsbG93IGF1ZGlvXCI6IFwiQWxsb3cgYXVkaW9cIixcblx0XCJBbGxvdyB2aWRlb1wiOiBcIkFsbG93IHZpZGVvXCIsXG5cdFwiQWxsb3cgc2NyZWVuIHNoYXJpbmdcIjogXCJBbGxvdyBzY3JlZW4gc2hhcmluZ1wiLFxuXHRcIkRpc2FibGUgYXVkaW9cIjogXCJEaXNhYmxlIGF1ZGlvXCIsXG5cdFwiRGlzYWJsZSB2aWRlb1wiOiBcIkRpc2FibGUgdmlkZW9cIixcblx0XCJEaXNhYmxlIHNjcmVlbiBzaGFyaW5nXCI6IFwiRGlzYWJsZSBzY3JlZW4gc2hhcmluZ1wiLFxuXHRFbnRlcjogRW50ZXIsXG5cdExlYXZlOiBMZWF2ZSxcblx0XCJMZWF2ZSBjYWxsXCI6IFwiTGVhdmUgY2FsbFwiLFxuXHRcIkVuZCBjYWxsIGZvciBhbGxcIjogXCJFbmQgY2FsbCBmb3IgYWxsXCIsXG5cdFwie3sgZGlyZWN0aW9uIH19IGZ1bGxzY3JlZW5cIjogXCJ7eyBkaXJlY3Rpb24gfX0gZnVsbHNjcmVlblwiLFxuXHRcInt7IGRpcmVjdGlvbiB9fSBwaWN0dXJlLWluLXBpY3R1cmVcIjogXCJ7eyBkaXJlY3Rpb24gfX0gcGljdHVyZS1pbi1waWN0dXJlXCIsXG5cdFwiRG9taW5hbnQgU3BlYWtlclwiOiBcIkRvbWluYW50IFNwZWFrZXJcIixcblx0XCJQb29yIGNvbm5lY3Rpb24gcXVhbGl0eVwiOiBcIlBvb3IgY29ubmVjdGlvbiBxdWFsaXR5LiBQbGVhc2UgY2hlY2sgeW91ciBpbnRlcm5ldCBjb25uZWN0aW9uLlwiLFxuXHRQYXJ0aWNpcGFudHM6IFBhcnRpY2lwYW50cyxcblx0QW5vbnltb3VzOiBBbm9ueW1vdXMsXG5cdFwiTm8gcGFydGljaXBhbnRzIGZvdW5kXCI6IFwiTm8gcGFydGljaXBhbnRzIGZvdW5kXCIsXG5cdFwiUGFydGljaXBhbnRzICh7eyBudW1iZXJPZlBhcnRpY2lwYW50cyB9fSlcIjogXCJQYXJ0aWNpcGFudHMgKHt7IG51bWJlck9mUGFydGljaXBhbnRzIH19KVwiLFxuXHRcInt7IHVzZXJOYW1lIH19IGlzIHNoYXJpbmcgdGhlaXIgc2NyZWVuXCI6IFwie3sgdXNlck5hbWUgfX0gaXMgc2hhcmluZyB0aGVpciBzY3JlZW5cIixcblx0XCJ7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHNwZWFrXCI6IFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBzcGVha1wiLFxuXHRcInt7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgdG8gc2hhcmUgdGhlaXIgY2FtZXJhXCI6IFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBzaGFyZSB0aGVpciBjYW1lcmFcIixcblx0XCJ7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHByZXNlbnQgdGhlaXIgc2NyZWVuXCI6IFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBwcmVzZW50IHRoZWlyIHNjcmVlblwiLFxuXHRcInt7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgcGVybWlzc2lvbjoge3sgcGVybWlzc2lvbiB9fVwiOiBcInt7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgcGVybWlzc2lvbjoge3sgcGVybWlzc2lvbiB9fVwiXG59O1xuXG5jb25zdCB0cmFuc2xhdGlvbnMgPSB7IGVuIH07XG5cbmNvbnN0IFN0cmVhbVZpZGVvID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIChqc3goU3RyZWFtVmlkZW9Qcm92aWRlciwgeyB0cmFuc2xhdGlvbnNPdmVycmlkZXM6IHRyYW5zbGF0aW9ucywgLi4ucHJvcHMgfSkpO1xufTtcblxuY29uc3QgdXNlUGFnaW5hdGVkTGF5b3V0U29ydFByZXNldCA9IChjYWxsKSA9PiB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxsLnNldFNvcnRQYXJ0aWNpcGFudHNCeShwYWdpbmF0ZWRMYXlvdXRTb3J0UHJlc2V0KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2V0U29ydFByZXNldChjYWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY2FsbF0pO1xufTtcbmNvbnN0IHVzZVNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0ID0gKGNhbGwsIGlzT25lT25PbmVDYWxsKSA9PiB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBhbHdheXMgc2hvdyB0aGUgcmVtb3RlIHBhcnRpY2lwYW50IGluIHRoZSBzcG90bGlnaHRcbiAgICAgICAgaWYgKGlzT25lT25PbmVDYWxsKSB7XG4gICAgICAgICAgICBjYWxsLnNldFNvcnRQYXJ0aWNpcGFudHNCeShjb21iaW5lQ29tcGFyYXRvcnMoc2NyZWVuU2hhcmluZywgbG9nZ2VkSW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGwuc2V0U29ydFBhcnRpY2lwYW50c0J5KHNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzZXRTb3J0UHJlc2V0KGNhbGwpO1xuICAgICAgICB9O1xuICAgIH0sIFtjYWxsLCBpc09uZU9uT25lQ2FsbF0pO1xufTtcbmNvbnN0IHJlc2V0U29ydFByZXNldCA9IChjYWxsKSA9PiB7XG4gICAgLy8gcmVzZXQgdGhlIHNvcnRpbmcgdG8gdGhlIGRlZmF1bHQgZm9yIHRoZSBjYWxsIHR5cGVcbiAgICBjb25zdCBjYWxsQ29uZmlnID0gQ2FsbFR5cGVzLmdldChjYWxsLnR5cGUpO1xuICAgIGNhbGwuc2V0U29ydFBhcnRpY2lwYW50c0J5KGNhbGxDb25maWcub3B0aW9ucy5zb3J0UGFydGljaXBhbnRzQnkgfHwgZGVmYXVsdFNvcnRQcmVzZXQpO1xufTtcbmNvbnN0IGxvZ2dlZEluID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5pc0xvY2FsUGFydGljaXBhbnQpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChiLmlzTG9jYWxQYXJ0aWNpcGFudClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufTtcblxuY29uc3QgTGl2ZXN0cmVhbUxheW91dCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdXNlUGFydGljaXBhbnRzLCB1c2VSZW1vdGVQYXJ0aWNpcGFudHMsIHVzZUhhc09uZ29pbmdTY3JlZW5TaGFyZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IFtjdXJyZW50U3BlYWtlciwgLi4ub3RoZXJQYXJ0aWNpcGFudHNdID0gdXNlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnRzID0gdXNlUmVtb3RlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgaGFzT25nb2luZ1NjcmVlblNoYXJlID0gdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlKCk7XG4gICAgY29uc3QgcHJlc2VudGVyID0gaGFzT25nb2luZ1NjcmVlblNoYXJlXG4gICAgICAgID8gaGFzU2NyZWVuU2hhcmUkMShjdXJyZW50U3BlYWtlcikgJiYgY3VycmVudFNwZWFrZXJcbiAgICAgICAgOiBvdGhlclBhcnRpY2lwYW50cy5maW5kKGhhc1NjcmVlblNoYXJlJDEpO1xuICAgIHVzZVBhZ2luYXRlZExheW91dFNvcnRQcmVzZXQoY2FsbCk7XG4gICAgY29uc3QgT3ZlcmxheSA9IChqc3goUGFydGljaXBhbnRPdmVybGF5LCB7IHNob3dQYXJ0aWNpcGFudENvdW50OiBwcm9wcy5zaG93UGFydGljaXBhbnRDb3VudCwgc2hvd0R1cmF0aW9uOiBwcm9wcy5zaG93RHVyYXRpb24sIHNob3dMaXZlQmFkZ2U6IHByb3BzLnNob3dMaXZlQmFkZ2UsIHNob3dTcGVha2VyTmFtZTogcHJvcHMuc2hvd1NwZWFrZXJOYW1lIH0pKTtcbiAgICBjb25zdCB7IGZsb2F0aW5nUGFydGljaXBhbnRQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgRmxvYXRpbmdQYXJ0aWNpcGFudE92ZXJsYXkgPSBoYXNPbmdvaW5nU2NyZWVuU2hhcmUgJiYgKGpzeChQYXJ0aWNpcGFudE92ZXJsYXlcbiAgICAvLyB0aGVzZSBlbGVtZW50cyBhcmVuJ3QgbmVlZGVkIGZvciB0aGUgdmlkZW8gZmVlZFxuICAgICwgeyBcbiAgICAgICAgLy8gdGhlc2UgZWxlbWVudHMgYXJlbid0IG5lZWRlZCBmb3IgdGhlIHZpZGVvIGZlZWRcbiAgICAgICAgc2hvd1BhcnRpY2lwYW50Q291bnQ6IGZsb2F0aW5nUGFydGljaXBhbnRQcm9wcz8uc2hvd1BhcnRpY2lwYW50Q291bnQgPz8gZmFsc2UsIHNob3dEdXJhdGlvbjogZmxvYXRpbmdQYXJ0aWNpcGFudFByb3BzPy5zaG93RHVyYXRpb24gPz8gZmFsc2UsIHNob3dMaXZlQmFkZ2U6IGZsb2F0aW5nUGFydGljaXBhbnRQcm9wcz8uc2hvd0xpdmVCYWRnZSA/PyBmYWxzZSwgc2hvd1NwZWFrZXJOYW1lOiBmbG9hdGluZ1BhcnRpY2lwYW50UHJvcHM/LnNob3dTcGVha2VyTmFtZSA/PyB0cnVlIH0pKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fd3JhcHBlclwiLCBjaGlsZHJlbjogW2pzeChQYXJ0aWNpcGFudHNBdWRpbywgeyBwYXJ0aWNpcGFudHM6IHJlbW90ZVBhcnRpY2lwYW50cyB9KSwgaGFzT25nb2luZ1NjcmVlblNoYXJlICYmIHByZXNlbnRlciAmJiAoanN4KFBhcnRpY2lwYW50VmlldywgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fc2NyZWVuLXNoYXJlXCIsIHBhcnRpY2lwYW50OiBwcmVzZW50ZXIsIFBhcnRpY2lwYW50Vmlld1VJOiBPdmVybGF5LCB0cmFja1R5cGU6IFwic2NyZWVuU2hhcmVUcmFja1wiLCBtdXRlQXVkaW8gLy8gYXVkaW8gaXMgcmVuZGVyZWQgYnkgUGFydGljaXBhbnRzQXVkaW9cbiAgICAgICAgICAgICAgICA6IHRydWUgfSkpLCBjdXJyZW50U3BlYWtlciAmJiAoanN4KFBhcnRpY2lwYW50VmlldywgeyBjbGFzc05hbWU6IGNsc3goaGFzT25nb2luZ1NjcmVlblNoYXJlICYmXG4gICAgICAgICAgICAgICAgICAgIGNsc3goJ3N0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2Zsb2F0aW5nLXBhcnRpY2lwYW50JywgYHN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2Zsb2F0aW5nLXBhcnRpY2lwYW50LS0ke2Zsb2F0aW5nUGFydGljaXBhbnRQcm9wcz8ucG9zaXRpb24gPz8gJ3RvcC1yaWdodCd9YCkpLCBwYXJ0aWNpcGFudDogY3VycmVudFNwZWFrZXIsIFBhcnRpY2lwYW50Vmlld1VJOiBGbG9hdGluZ1BhcnRpY2lwYW50T3ZlcmxheSB8fCBPdmVybGF5LCBtdXRlQXVkaW8gLy8gYXVkaW8gaXMgcmVuZGVyZWQgYnkgUGFydGljaXBhbnRzQXVkaW9cbiAgICAgICAgICAgICAgICA6IHRydWUgfSkpXSB9KSk7XG59O1xuY29uc3QgaGFzU2NyZWVuU2hhcmUkMSA9IChwKSA9PiAhIXA/LnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSk7XG5jb25zdCBQYXJ0aWNpcGFudE92ZXJsYXkgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGVuYWJsZUZ1bGxTY3JlZW4gPSB0cnVlLCBzaG93UGFydGljaXBhbnRDb3VudCA9IHRydWUsIHNob3dEdXJhdGlvbiA9IHRydWUsIHNob3dMaXZlQmFkZ2UgPSB0cnVlLCBzaG93U3BlYWtlck5hbWUgPSBmYWxzZSwgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCB7IHVzZVBhcnRpY2lwYW50Q291bnQgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgcGFydGljaXBhbnRDb3VudCA9IHVzZVBhcnRpY2lwYW50Q291bnQoKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHVzZVVwZGF0ZUNhbGxEdXJhdGlvbigpO1xuICAgIGNvbnN0IHRvZ2dsZUZ1bGxTY3JlZW4gPSB1c2VUb2dnbGVGdWxsU2NyZWVuKCk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fb3ZlcmxheVwiLCBjaGlsZHJlbjoganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2xpdmVzdHJlYW0tbGF5b3V0X19vdmVybGF5X19iYXJcIiwgY2hpbGRyZW46IFtzaG93TGl2ZUJhZGdlICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2xpdmUtYmFkZ2VcIiwgY2hpbGRyZW46IHQoJ0xpdmUnKSB9KSksIHNob3dQYXJ0aWNpcGFudENvdW50ICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX3ZpZXdlcnMtY291bnRcIiwgY2hpbGRyZW46IHBhcnRpY2lwYW50Q291bnQgfSkpLCBzaG93U3BlYWtlck5hbWUgJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fc3BlYWtlci1uYW1lXCIsIHRpdGxlOiBwYXJ0aWNpcGFudC5uYW1lIHx8IHBhcnRpY2lwYW50LnVzZXJJZCB8fCAnJywgY2hpbGRyZW46IHBhcnRpY2lwYW50Lm5hbWUgfHwgcGFydGljaXBhbnQudXNlcklkIHx8ICcnIH0pKSwgc2hvd0R1cmF0aW9uICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2R1cmF0aW9uXCIsIGNoaWxkcmVuOiBmb3JtYXREdXJhdGlvbihkdXJhdGlvbikgfSkpLCBlbmFibGVGdWxsU2NyZWVuICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX2dvLWZ1bGxzY3JlZW5cIiwgb25DbGljazogdG9nZ2xlRnVsbFNjcmVlbiB9KSldIH0pIH0pKTtcbn07XG5jb25zdCB1c2VVcGRhdGVDYWxsRHVyYXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgeyB1c2VJc0NhbGxMaXZlLCB1c2VDYWxsU2Vzc2lvbiB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBpc0NhbGxMaXZlID0gdXNlSXNDYWxsTGl2ZSgpO1xuICAgIGNvbnN0IHNlc3Npb24gPSB1c2VDYWxsU2Vzc2lvbigpO1xuICAgIGNvbnN0IFtkdXJhdGlvbiwgc2V0RHVyYXRpb25dID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ubGl2ZV9zdGFydGVkX2F0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IGxpdmVTdGFydFRpbWUgPSBuZXcgRGF0ZShzZXNzaW9uLmxpdmVfc3RhcnRlZF9hdCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChub3cuZ2V0VGltZSgpIC0gbGl2ZVN0YXJ0VGltZS5nZXRUaW1lKCkpIC8gMTAwMCk7XG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0NhbGxMaXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHNldER1cmF0aW9uKChkKSA9PiBkICsgMSk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH07XG4gICAgfSwgW2lzQ2FsbExpdmVdKTtcbiAgICByZXR1cm4gZHVyYXRpb247XG59O1xuY29uc3QgdXNlVG9nZ2xlRnVsbFNjcmVlbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHBhcnRpY2lwYW50Vmlld0VsZW1lbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCBbaXNGdWxsc2NyZWVuLCBzZXRJc0Z1bGxzY3JlZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChpc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0SXNGdWxsc2NyZWVuKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFydGljaXBhbnRWaWV3RWxlbWVudD8ucmVxdWVzdEZ1bGxzY3JlZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRJc0Z1bGxzY3JlZW4odHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0Z1bGxzY3JlZW4sIHBhcnRpY2lwYW50Vmlld0VsZW1lbnRdKTtcbn07XG5jb25zdCBmb3JtYXREdXJhdGlvbiA9IChkdXJhdGlvbkluTXMpID0+IHtcbiAgICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihkdXJhdGlvbkluTXMgLyA4NjQwMCk7XG4gICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKGR1cmF0aW9uSW5NcyAvIDM2MDApO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChkdXJhdGlvbkluTXMgJSAzNjAwKSAvIDYwKTtcbiAgICBjb25zdCBzZWNvbmRzID0gZHVyYXRpb25Jbk1zICUgNjA7XG4gICAgcmV0dXJuIGAke2RheXMgPyBkYXlzICsgJyAnIDogJyd9JHtob3VycyA/IGhvdXJzICsgJzonIDogJyd9JHttaW51dGVzIDwgMTAgPyAnMCcgOiAnJ30ke21pbnV0ZXN9OiR7c2Vjb25kcyA8IDEwID8gJzAnIDogJyd9JHtzZWNvbmRzfWA7XG59O1xuXG5jb25zdCBHUk9VUF9TSVpFID0gMTY7XG5jb25zdCBQYWdpbmF0ZWRHcmlkTGF5b3V0R3JvdXAgPSAoeyBncm91cCwgVmlkZW9QbGFjZWhvbGRlciwgUGFydGljaXBhbnRWaWV3VUksIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXRfX2dyb3VwJywge1xuICAgICAgICAgICAgJ3N0ci12aWRlb19fcGFnaW5hdGVkLWdyaWQtbGF5b3V0LS1vbmUnOiBncm91cC5sZW5ndGggPT09IDEsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXQtLXR3by1mb3VyJzogZ3JvdXAubGVuZ3RoID49IDIgJiYgZ3JvdXAubGVuZ3RoIDw9IDQsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXQtLWZpdmUtbmluZSc6IGdyb3VwLmxlbmd0aCA+PSA1ICYmIGdyb3VwLmxlbmd0aCA8PSA5LFxuICAgICAgICB9KSwgY2hpbGRyZW46IGdyb3VwLm1hcCgocGFydGljaXBhbnQpID0+IChqc3goUGFydGljaXBhbnRWaWV3LCB7IHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCwgbXV0ZUF1ZGlvOiB0cnVlLCBWaWRlb1BsYWNlaG9sZGVyOiBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUkgfSwgcGFydGljaXBhbnQuc2Vzc2lvbklkKSkpIH0pKTtcbn07XG5jb25zdCBQYWdpbmF0ZWRHcmlkTGF5b3V0ID0gKHsgZ3JvdXBTaXplID0gR1JPVVBfU0laRSwgZXhjbHVkZUxvY2FsUGFydGljaXBhbnQgPSBmYWxzZSwgcGFnZUFycm93c1Zpc2libGUgPSB0cnVlLCBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSSA9IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSwgfSkgPT4ge1xuICAgIGNvbnN0IFtwYWdlLCBzZXRQYWdlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtwYWdpbmF0ZWRHcmlkTGF5b3V0V3JhcHBlckVsZW1lbnQsIHNldFBhZ2luYXRlZEdyaWRMYXlvdXRXcmFwcGVyRWxlbWVudCxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZVBhcnRpY2lwYW50cywgdXNlUmVtb3RlUGFydGljaXBhbnRzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHVzZVBhcnRpY2lwYW50cygpO1xuICAgIC8vIHVzZWQgdG8gcmVuZGVyIGF1ZGlvIGVsZW1lbnRzXG4gICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnRzID0gdXNlUmVtb3RlUGFydGljaXBhbnRzKCk7XG4gICAgdXNlUGFnaW5hdGVkTGF5b3V0U29ydFByZXNldChjYWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXBhZ2luYXRlZEdyaWRMYXlvdXRXcmFwcGVyRWxlbWVudCB8fCAhY2FsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNhbGwuc2V0Vmlld3BvcnQocGFnaW5hdGVkR3JpZExheW91dFdyYXBwZXJFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFudXAoKTtcbiAgICB9LCBbcGFnaW5hdGVkR3JpZExheW91dFdyYXBwZXJFbGVtZW50LCBjYWxsXSk7XG4gICAgLy8gb25seSB1c2VkIHRvIHJlbmRlciB2aWRlbyBlbGVtZW50c1xuICAgIGNvbnN0IHBhcnRpY2lwYW50R3JvdXBzID0gdXNlTWVtbygoKSA9PiBjaHVuayhleGNsdWRlTG9jYWxQYXJ0aWNpcGFudCA/IHJlbW90ZVBhcnRpY2lwYW50cyA6IHBhcnRpY2lwYW50cywgZ3JvdXBTaXplKSwgW2V4Y2x1ZGVMb2NhbFBhcnRpY2lwYW50LCByZW1vdGVQYXJ0aWNpcGFudHMsIHBhcnRpY2lwYW50cywgZ3JvdXBTaXplXSk7XG4gICAgY29uc3QgcGFnZUNvdW50ID0gcGFydGljaXBhbnRHcm91cHMubGVuZ3RoO1xuICAgIC8vIHVwZGF0ZSBwYWdlIHdoZW4gcGFnZSBjb3VudCBpcyByZWR1Y2VkIGFuZCBzZWxlY3RlZCBwYWdlIG5vIGxvbmdlciBleGlzdHNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocGFnZSA+IHBhZ2VDb3VudCAtIDEpIHtcbiAgICAgICAgICAgIHNldFBhZ2UoTWF0aC5tYXgoMCwgcGFnZUNvdW50IC0gMSkpO1xuICAgICAgICB9XG4gICAgfSwgW3BhZ2UsIHBhZ2VDb3VudF0pO1xuICAgIGNvbnN0IHNlbGVjdGVkR3JvdXAgPSBwYXJ0aWNpcGFudEdyb3Vwc1twYWdlXTtcbiAgICBpZiAoIWNhbGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhZ2luYXRlZC1ncmlkLWxheW91dF9fd3JhcHBlclwiLCByZWY6IHNldFBhZ2luYXRlZEdyaWRMYXlvdXRXcmFwcGVyRWxlbWVudCwgY2hpbGRyZW46IFtqc3goUGFydGljaXBhbnRzQXVkaW8sIHsgcGFydGljaXBhbnRzOiByZW1vdGVQYXJ0aWNpcGFudHMgfSksIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXRcIiwgY2hpbGRyZW46IFtwYWdlQXJyb3dzVmlzaWJsZSAmJiBwYWdlQ291bnQgPiAxICYmIChqc3goSWNvbkJ1dHRvbiwgeyBpY29uOiBcImNhcmV0LWxlZnRcIiwgZGlzYWJsZWQ6IHBhZ2UgPT09IDAsIG9uQ2xpY2s6ICgpID0+IHNldFBhZ2UoKGN1cnJlbnRQYWdlKSA9PiBNYXRoLm1heCgwLCBjdXJyZW50UGFnZSAtIDEpKSB9KSksIHNlbGVjdGVkR3JvdXAgJiYgKGpzeChQYWdpbmF0ZWRHcmlkTGF5b3V0R3JvdXAsIHsgZ3JvdXA6IHBhcnRpY2lwYW50R3JvdXBzW3BhZ2VdLCBWaWRlb1BsYWNlaG9sZGVyOiBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUkgfSkpLCBwYWdlQXJyb3dzVmlzaWJsZSAmJiBwYWdlQ291bnQgPiAxICYmIChqc3goSWNvbkJ1dHRvbiwgeyBkaXNhYmxlZDogcGFnZSA9PT0gcGFnZUNvdW50IC0gMSwgaWNvbjogXCJjYXJldC1yaWdodFwiLCBvbkNsaWNrOiAoKSA9PiBzZXRQYWdlKChjdXJyZW50UGFnZSkgPT4gTWF0aC5taW4ocGFnZUNvdW50IC0gMSwgY3VycmVudFBhZ2UgKyAxKSkgfSkpXSB9KV0gfSkpO1xufTtcblxuY29uc3QgdXNlQ2FsY3VsYXRlSGFyZExpbWl0ID0gKFxuLyoqXG4gKiBFbGVtZW50IHRoYXQgc3RyZXRjaGVzIHRvIDEwMCUgb2YgdGhlIHdob2xlIGxheW91dCBjb21wb25lbnRcbiAqL1xud3JhcHBlckVsZW1lbnQsIFxuLyoqXG4gKiBFbGVtZW50IHRoYXQgZGlyZWN0bHkgaG9zdHMgaW5kaXZpZHVhbCBgUGFydGljaXBhbnRWaWV3YCAob3Igd3JhcHBlcikgZWxlbWVudHNcbiAqL1xuaG9zdEVsZW1lbnQsIGxpbWl0KSA9PiB7XG4gICAgY29uc3QgW2NhbGN1bGF0ZWRMaW1pdCwgc2V0Q2FsY3VsYXRlZExpbWl0XSA9IHVzZVN0YXRlKHtcbiAgICAgICAgdmVydGljYWw6IHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgPyBsaW1pdCA6IG51bGwsXG4gICAgICAgIGhvcml6b250YWw6IHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgPyBsaW1pdCA6IG51bGwsXG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFob3N0RWxlbWVudCB8fFxuICAgICAgICAgICAgIXdyYXBwZXJFbGVtZW50IHx8XG4gICAgICAgICAgICB0eXBlb2YgbGltaXQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICB0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY2hpbGRXaWR0aCA9IG51bGw7XG4gICAgICAgIGxldCBjaGlsZEhlaWdodCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgLy8gdGhpcyBwYXJ0IHNob3VsZCBpZGVhbGx5IHJ1biBhcyBsaXR0bGUgdGltZXMgYXMgcG9zc2libGVcbiAgICAgICAgICAgIC8vIGdldCBjaGlsZCBtZWFzdXJlbWVudHMgYW5kIGRpc2Nvbm5lY3RcbiAgICAgICAgICAgIC8vIGRvZXMgbm90IGNvbnNpZGVyIGR5bmFtaWNhbGx5IHNpemVkIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB0aGlzIGhvb2sgaXMgZm9yIFNwZWFrZXJMYXlvdXQgdXNlIG9ubHksIHdoZXJlIGNoaWxkcmVuIGluIHRoZSBiYXIgYXJlIGZpeGVkIHNpemVcbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGhvc3RFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSGVpZ2h0ID0gY2hpbGQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFdpZHRoID0gY2hpbGQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VlcCB0aGUgc3RhdGUgYXQgeyB2ZXJ0aWNhbDogMSwgaG9yaXpvbnRhbDogMSB9XG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSBnZXQgdGhlIHByb3BlciBjaGlsZCBtZWFzdXJlbWVudHNcbiAgICAgICAgICAgIGlmIChjaGlsZEhlaWdodCA9PT0gbnVsbCB8fCBjaGlsZFdpZHRoID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsID0gTWF0aC5mbG9vcih3cmFwcGVyRWxlbWVudC5jbGllbnRIZWlnaHQgLyBjaGlsZEhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBob3Jpem9udGFsID0gTWF0aC5mbG9vcih3cmFwcGVyRWxlbWVudC5jbGllbnRXaWR0aCAvIGNoaWxkV2lkdGgpO1xuICAgICAgICAgICAgc2V0Q2FsY3VsYXRlZExpbWl0KChwdikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwdi52ZXJ0aWNhbCAhPT0gdmVydGljYWwgfHwgcHYuaG9yaXpvbnRhbCAhPT0gaG9yaXpvbnRhbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmVydGljYWwsIGhvcml6b250YWwgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUod3JhcHBlckVsZW1lbnQpO1xuICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGhvc3RFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaG9zdEVsZW1lbnQsIGxpbWl0LCB3cmFwcGVyRWxlbWVudF0pO1xuICAgIHJldHVybiBjYWxjdWxhdGVkTGltaXQ7XG59O1xuXG5jb25zdCBEZWZhdWx0UGFydGljaXBhbnRWaWV3VUlCYXIgPSAoKSA9PiAoanN4KERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSSwgeyBtZW51UGxhY2VtZW50OiBcInRvcC1lbmRcIiB9KSk7XG5jb25zdCBEZWZhdWx0UGFydGljaXBhbnRWaWV3VUlTcG90bGlnaHQgPSAoKSA9PiBqc3goRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJLCB7fSk7XG5jb25zdCBTcGVha2VyTGF5b3V0ID0gKHsgUGFydGljaXBhbnRWaWV3VUlCYXIgPSBEZWZhdWx0UGFydGljaXBhbnRWaWV3VUlCYXIsIFBhcnRpY2lwYW50Vmlld1VJU3BvdGxpZ2h0ID0gRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJU3BvdGxpZ2h0LCBWaWRlb1BsYWNlaG9sZGVyLCBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiA9ICdib3R0b20nLCBwYXJ0aWNpcGFudHNCYXJMaW1pdCwgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyB1c2VQYXJ0aWNpcGFudHMsIHVzZVJlbW90ZVBhcnRpY2lwYW50cyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBbcGFydGljaXBhbnRJblNwb3RsaWdodCwgLi4ub3RoZXJQYXJ0aWNpcGFudHNdID0gdXNlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnRzID0gdXNlUmVtb3RlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgW3BhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50LCBzZXRQYXJ0aWNpcGFudHNCYXJXcmFwcGVyRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbcGFydGljaXBhbnRzQmFyRWxlbWVudCwgc2V0UGFydGljaXBhbnRzQmFyRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbYnV0dG9uc1dyYXBwZXJFbGVtZW50LCBzZXRCdXR0b25zV3JhcHBlckVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgaXNTcGVha2VyU2NyZWVuU2hhcmluZyA9IGhhc1NjcmVlblNoYXJlKHBhcnRpY2lwYW50SW5TcG90bGlnaHQpO1xuICAgIGNvbnN0IGhhcmRMaW1pdCA9IHVzZUNhbGN1bGF0ZUhhcmRMaW1pdChidXR0b25zV3JhcHBlckVsZW1lbnQsIHBhcnRpY2lwYW50c0JhckVsZW1lbnQsIHBhcnRpY2lwYW50c0JhckxpbWl0KTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gcGFydGljaXBhbnRzQmFyUG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcGFydGljaXBhbnRzQmFyUG9zaXRpb24gPT09ICdib3R0b20nO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQgfHwgIWNhbGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBjYWxsLnNldFZpZXdwb3J0KHBhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFudXAoKTtcbiAgICB9LCBbcGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQsIGNhbGxdKTtcbiAgICBjb25zdCBpc09uZU9uT25lQ2FsbCA9IG90aGVyUGFydGljaXBhbnRzLmxlbmd0aCA9PT0gMTtcbiAgICB1c2VTcGVha2VyTGF5b3V0U29ydFByZXNldChjYWxsLCBpc09uZU9uT25lQ2FsbCk7XG4gICAgbGV0IHBhcnRpY2lwYW50c1dpdGhBcHBsaWVkTGltaXQgPSBvdGhlclBhcnRpY2lwYW50cztcbiAgICBjb25zdCBoYXJkTGltaXRUb0FwcGx5ID0gaXNWZXJ0aWNhbFxuICAgICAgICA/IGhhcmRMaW1pdC52ZXJ0aWNhbFxuICAgICAgICA6IGhhcmRMaW1pdC5ob3Jpem9udGFsO1xuICAgIGlmICh0eXBlb2YgcGFydGljaXBhbnRzQmFyTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIGhhcmRMaW1pdFRvQXBwbHkgIT09IG51bGwpIHtcbiAgICAgICAgcGFydGljaXBhbnRzV2l0aEFwcGxpZWRMaW1pdCA9IG90aGVyUGFydGljaXBhbnRzLnNsaWNlKDAsIFxuICAgICAgICAvLyBzdWJ0cmFjdCAxIGlmIHNwZWFrZXIgaXMgc2hhcmluZyBzY3JlZW4gYXNcbiAgICAgICAgLy8gdGhhdCBvbmUgaXMgcmVuZGVyZWQgaW5kZXBlbmRlbnRseSBmcm9tIG90aGVyUGFydGljaXBhbnRzIGFycmF5XG4gICAgICAgIGhhcmRMaW1pdFRvQXBwbHkgLSAoaXNTcGVha2VyU2NyZWVuU2hhcmluZyA/IDEgOiAwKSk7XG4gICAgfVxuICAgIGlmICghY2FsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3dyYXBwZXJcIiwgY2hpbGRyZW46IFtqc3goUGFydGljaXBhbnRzQXVkaW8sIHsgcGFydGljaXBhbnRzOiByZW1vdGVQYXJ0aWNpcGFudHMgfSksIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fc3BlYWtlci1sYXlvdXQnLCBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICBgc3RyLXZpZGVvX19zcGVha2VyLWxheW91dC0tdmFyaWFudC0ke3BhcnRpY2lwYW50c0JhclBvc2l0aW9ufWApLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0X19zcG90bGlnaHRcIiwgY2hpbGRyZW46IHBhcnRpY2lwYW50SW5TcG90bGlnaHQgJiYgKGpzeChQYXJ0aWNpcGFudFZpZXcsIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50SW5TcG90bGlnaHQsIG11dGVBdWRpbzogdHJ1ZSwgdHJhY2tUeXBlOiBpc1NwZWFrZXJTY3JlZW5TaGFyaW5nID8gJ3NjcmVlblNoYXJlVHJhY2snIDogJ3ZpZGVvVHJhY2snLCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUlTcG90bGlnaHQsIFZpZGVvUGxhY2Vob2xkZXI6IFZpZGVvUGxhY2Vob2xkZXIgfSkpIH0pLCBwYXJ0aWNpcGFudHNXaXRoQXBwbGllZExpbWl0Lmxlbmd0aCA+IDAgJiYgcGFydGljaXBhbnRzQmFyUG9zaXRpb24gJiYgKGpzeHMoXCJkaXZcIiwgeyByZWY6IHNldEJ1dHRvbnNXcmFwcGVyRWxlbWVudCwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXItYnV0dG9ucy13cmFwcGVyXCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXItd3JhcHBlclwiLCByZWY6IHNldFBhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50LCBjaGlsZHJlbjoganN4cyhcImRpdlwiLCB7IHJlZjogc2V0UGFydGljaXBhbnRzQmFyRWxlbWVudCwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXJcIiwgY2hpbGRyZW46IFtpc1NwZWFrZXJTY3JlZW5TaGFyaW5nICYmIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnQtdGlsZVwiLCBjaGlsZHJlbjoganN4KFBhcnRpY2lwYW50VmlldywgeyBwYXJ0aWNpcGFudDogcGFydGljaXBhbnRJblNwb3RsaWdodCwgUGFydGljaXBhbnRWaWV3VUk6IFBhcnRpY2lwYW50Vmlld1VJQmFyLCBWaWRlb1BsYWNlaG9sZGVyOiBWaWRlb1BsYWNlaG9sZGVyLCBtdXRlQXVkaW86IHRydWUgfSkgfSwgcGFydGljaXBhbnRJblNwb3RsaWdodC5zZXNzaW9uSWQpKSwgcGFydGljaXBhbnRzV2l0aEFwcGxpZWRMaW1pdC5tYXAoKHBhcnRpY2lwYW50KSA9PiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50LXRpbGVcIiwgY2hpbGRyZW46IGpzeChQYXJ0aWNpcGFudFZpZXcsIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50LCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUlCYXIsIFZpZGVvUGxhY2Vob2xkZXI6IFZpZGVvUGxhY2Vob2xkZXIsIG11dGVBdWRpbzogdHJ1ZSB9KSB9LCBwYXJ0aWNpcGFudC5zZXNzaW9uSWQpKSldIH0pIH0pLCBpc1ZlcnRpY2FsICYmIChqc3goVmVydGljYWxTY3JvbGxCdXR0b25zLCB7IHNjcm9sbFdyYXBwZXI6IHBhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50IH0pKSwgaXNIb3Jpem9udGFsICYmIChqc3goSG9yaXpvbnRhbFNjcm9sbEJ1dHRvbnMsIHsgc2Nyb2xsV3JhcHBlcjogcGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQgfSkpXSB9KSldIH0pXSB9KSk7XG59O1xuY29uc3QgSG9yaXpvbnRhbFNjcm9sbEJ1dHRvbnMgPSAoeyBzY3JvbGxXcmFwcGVyLCB9KSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB1c2VIb3Jpem9udGFsU2Nyb2xsUG9zaXRpb24oc2Nyb2xsV3JhcHBlcik7XG4gICAgY29uc3Qgc2Nyb2xsU3RhcnRDbGlja0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFdyYXBwZXI/LnNjcm9sbEJ5KHsgbGVmdDogLTE1MCwgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2Nyb2xsRW5kQ2xpY2tIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBzY3JvbGxXcmFwcGVyPy5zY3JvbGxCeSh7IGxlZnQ6IDE1MCwgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbc2Nyb2xsUG9zaXRpb24gJiYgc2Nyb2xsUG9zaXRpb24gIT09ICdzdGFydCcgJiYgKGpzeChJY29uQnV0dG9uLCB7IG9uQ2xpY2s6IHNjcm9sbFN0YXJ0Q2xpY2tIYW5kbGVyLCBpY29uOiBcImNhcmV0LWxlZnRcIiwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXItLWJ1dHRvbi1sZWZ0XCIgfSkpLCBzY3JvbGxQb3NpdGlvbiAmJiBzY3JvbGxQb3NpdGlvbiAhPT0gJ2VuZCcgJiYgKGpzeChJY29uQnV0dG9uLCB7IG9uQ2xpY2s6IHNjcm9sbEVuZENsaWNrSGFuZGxlciwgaWNvbjogXCJjYXJldC1yaWdodFwiLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnRzLWJhci0tYnV0dG9uLXJpZ2h0XCIgfSkpXSB9KSk7XG59O1xuY29uc3QgVmVydGljYWxTY3JvbGxCdXR0b25zID0gKHsgc2Nyb2xsV3JhcHBlciwgfSkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gdXNlVmVydGljYWxTY3JvbGxQb3NpdGlvbihzY3JvbGxXcmFwcGVyKTtcbiAgICBjb25zdCBzY3JvbGxUb3BDbGlja0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFdyYXBwZXI/LnNjcm9sbEJ5KHsgdG9wOiAtMTUwLCBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzY3JvbGxCb3R0b21DbGlja0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFdyYXBwZXI/LnNjcm9sbEJ5KHsgdG9wOiAxNTAsIGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW3Njcm9sbFBvc2l0aW9uICYmIHNjcm9sbFBvc2l0aW9uICE9PSAndG9wJyAmJiAoanN4KEljb25CdXR0b24sIHsgb25DbGljazogc2Nyb2xsVG9wQ2xpY2tIYW5kbGVyLCBpY29uOiBcImNhcmV0LXVwXCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0X19wYXJ0aWNpcGFudHMtYmFyLS1idXR0b24tdG9wXCIgfSkpLCBzY3JvbGxQb3NpdGlvbiAmJiBzY3JvbGxQb3NpdGlvbiAhPT0gJ2JvdHRvbScgJiYgKGpzeChJY29uQnV0dG9uLCB7IG9uQ2xpY2s6IHNjcm9sbEJvdHRvbUNsaWNrSGFuZGxlciwgaWNvbjogXCJjYXJldC1kb3duXCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0X19wYXJ0aWNpcGFudHMtYmFyLS1idXR0b24tYm90dG9tXCIgfSkpXSB9KSk7XG59O1xuY29uc3QgaGFzU2NyZWVuU2hhcmUgPSAocCkgPT4gISFwPy5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpO1xuXG5jb25zdCBbbWFqb3IsIG1pbm9yLCBwYXRjaF0gPSAoXCIwLjUuMTJcIiApLnNwbGl0KCcuJyk7XG5zZXRTZGtJbmZvKHtcbiAgICB0eXBlOiBTZnVNb2RlbHMuU2RrVHlwZS5SRUFDVCxcbiAgICBtYWpvcixcbiAgICBtaW5vcixcbiAgICBwYXRjaCxcbn0pO1xuXG5leHBvcnQgeyBBY2NlcHRDYWxsQnV0dG9uLCBBdWRpbywgQXZhdGFyLCBBdmF0YXJGYWxsYmFjaywgQmFja2dyb3VuZEZpbHRlcnNQcm92aWRlciwgQmFzZVZpZGVvLCBDYWxsQ29udHJvbHMsIENhbGxQYXJ0aWNpcGFudExpc3RpbmcsIENhbGxQYXJ0aWNpcGFudExpc3RpbmdJdGVtLCBDYWxsUGFydGljaXBhbnRzTGlzdCwgQ2FsbFByZXZpZXcsIENhbGxSZWNvcmRpbmdMaXN0LCBDYWxsUmVjb3JkaW5nTGlzdEhlYWRlciwgQ2FsbFJlY29yZGluZ0xpc3RJdGVtLCBDYWxsU3RhdHMsIENhbGxTdGF0c0J1dHRvbiwgQ2FsbFN0YXRzTGF0ZW5jeUNoYXJ0LCBDYW5jZWxDYWxsQnV0dG9uLCBDYW5jZWxDYWxsQ29uZmlybUJ1dHRvbiwgQ29tcG9zaXRlQnV0dG9uLCBEZWZhdWx0UGFydGljaXBhbnRWaWV3VUksIERlZmF1bHRSZWFjdGlvbnNNZW51LCBEZWZhdWx0U2NyZWVuU2hhcmVPdmVybGF5LCBEZWZhdWx0VmlkZW9QbGFjZWhvbGRlciwgRGV2aWNlU2VsZWN0b3IsIERldmljZVNlbGVjdG9yQXVkaW9JbnB1dCwgRGV2aWNlU2VsZWN0b3JBdWRpb091dHB1dCwgRGV2aWNlU2VsZWN0b3JWaWRlbywgRGV2aWNlU2V0dGluZ3MsIERyb3BEb3duU2VsZWN0LCBEcm9wRG93blNlbGVjdE9wdGlvbiwgRW1wdHlDYWxsUmVjb3JkaW5nTGlzdGluZywgR2VuZXJpY01lbnUsIEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgSWNvbiwgSWNvbkJ1dHRvbiwgTGl2ZXN0cmVhbUxheW91dCwgTG9hZGluZ0NhbGxSZWNvcmRpbmdMaXN0aW5nLCBMb2FkaW5nSW5kaWNhdG9yLCBNZW51VG9nZ2xlLCBNZW51VmlzdWFsVHlwZSwgTm90aWZpY2F0aW9uLCBQYWdpbmF0ZWRHcmlkTGF5b3V0LCBQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSwgUGFydGljaXBhbnREZXRhaWxzLCBQYXJ0aWNpcGFudFZpZXcsIFBhcnRpY2lwYW50Vmlld0NvbnRleHQsIFBhcnRpY2lwYW50c0F1ZGlvLCBQZXJtaXNzaW9uTm90aWZpY2F0aW9uLCBQZXJtaXNzaW9uUmVxdWVzdExpc3QsIFBlcm1pc3Npb25SZXF1ZXN0cywgUmVhY3Rpb25zQnV0dG9uLCBSZWNvcmRDYWxsQnV0dG9uLCBSZWNvcmRDYWxsQ29uZmlybWF0aW9uQnV0dG9uLCBSZWNvcmRpbmdJblByb2dyZXNzTm90aWZpY2F0aW9uLCBSaW5naW5nQ2FsbCwgUmluZ2luZ0NhbGxDb250cm9scywgU2NyZWVuU2hhcmVCdXR0b24sIFNlYXJjaElucHV0LCBTZWFyY2hSZXN1bHRzLCBTcGVha2VyTGF5b3V0LCBTcGVha2luZ1doaWxlTXV0ZWROb3RpZmljYXRpb24sIFNwZWVjaEluZGljYXRvciwgU3RhdENhcmQsIFN0YXRDYXJkRXhwbGFuYXRpb24sIFN0YXRzVGFnLCBTdGF0dXNlcywgU3RyZWFtQ2FsbCwgU3RyZWFtVGhlbWUsIFN0cmVhbVZpZGVvLCBUZXh0QnV0dG9uLCBUb2dnbGVBdWRpb091dHB1dEJ1dHRvbiwgVG9nZ2xlQXVkaW9QcmV2aWV3QnV0dG9uLCBUb2dnbGVBdWRpb1B1Ymxpc2hpbmdCdXR0b24sIFRvZ2dsZVZpZGVvUHJldmlld0J1dHRvbiwgVG9nZ2xlVmlkZW9QdWJsaXNoaW5nQnV0dG9uLCBUb29sdGlwLCBWaWRlbyQxIGFzIFZpZGVvLCBWaWRlb1ByZXZpZXcsIFdpdGhUb29sdGlwLCBkZWZhdWx0UmVhY3Rpb25zLCB0cmFuc2xhdGlvbnMsIHVzZUJhY2tncm91bmRGaWx0ZXJzLCB1c2VIb3Jpem9udGFsU2Nyb2xsUG9zaXRpb24sIHVzZU1lbnVDb250ZXh0LCB1c2VQYXJ0aWNpcGFudFZpZXdDb250ZXh0LCB1c2VQZXJzaXN0ZWREZXZpY2VQcmVmZXJlbmNlcywgdXNlUmVxdWVzdFBlcm1pc3Npb24sIHVzZVRyYWNrRWxlbWVudFZpc2liaWxpdHksIHVzZVZlcnRpY2FsU2Nyb2xsUG9zaXRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-react-sdk/dist/index.es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@stream-io/video-react-sdk/dist/css/styles.css":
/*!*********************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-sdk/dist/css/styles.css ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"7965c045aba3\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9jc3Mvc3R5bGVzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3lvb20vLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9jc3Mvc3R5bGVzLmNzcz84ZWVmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNzk2NWMwNDVhYmEzXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@stream-io/video-react-sdk/dist/css/styles.css\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@stream-io/node-sdk/dist/index.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/@stream-io/node-sdk/dist/index.es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APNConfigRequestAuthTypeEnum: () => (/* binding */ APNConfigRequestAuthTypeEnum),\n/* harmony export */   AppSearchBackendEnum: () => (/* binding */ AppSearchBackendEnum),\n/* harmony export */   AsyncModerationCallbackConfigRequestModeEnum: () => (/* binding */ AsyncModerationCallbackConfigRequestModeEnum),\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* binding */ AudioSettingsDefaultDeviceEnum),\n/* harmony export */   BlockListOptionsBehaviorEnum: () => (/* binding */ BlockListOptionsBehaviorEnum),\n/* harmony export */   BlockListOptionsRequestBehaviorEnum: () => (/* binding */ BlockListOptionsRequestBehaviorEnum),\n/* harmony export */   ChannelConfigAutomodBehaviorEnum: () => (/* binding */ ChannelConfigAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigAutomodEnum: () => (/* binding */ ChannelConfigAutomodEnum),\n/* harmony export */   ChannelConfigBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigRequestBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigRequestBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoAutomodBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoAutomodEnum: () => (/* binding */ ChannelConfigWithInfoAutomodEnum),\n/* harmony export */   ChannelConfigWithInfoBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoRequestAutomodBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoRequestAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoRequestAutomodEnum: () => (/* binding */ ChannelConfigWithInfoRequestAutomodEnum),\n/* harmony export */   ChannelConfigWithInfoRequestBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoRequestBlocklistBehaviorEnum),\n/* harmony export */   ChannelMemberRequestRoleEnum: () => (/* binding */ ChannelMemberRequestRoleEnum),\n/* harmony export */   ChannelMemberRoleEnum: () => (/* binding */ ChannelMemberRoleEnum),\n/* harmony export */   ChannelTypeConfigAutomodBehaviorEnum: () => (/* binding */ ChannelTypeConfigAutomodBehaviorEnum),\n/* harmony export */   ChannelTypeConfigAutomodEnum: () => (/* binding */ ChannelTypeConfigAutomodEnum),\n/* harmony export */   ChannelTypeConfigBlocklistBehaviorEnum: () => (/* binding */ ChannelTypeConfigBlocklistBehaviorEnum),\n/* harmony export */   CheckPushRequestPushProviderTypeEnum: () => (/* binding */ CheckPushRequestPushProviderTypeEnum),\n/* harmony export */   CheckSNSResponseStatusEnum: () => (/* binding */ CheckSNSResponseStatusEnum),\n/* harmony export */   CheckSQSResponseStatusEnum: () => (/* binding */ CheckSQSResponseStatusEnum),\n/* harmony export */   ConfigDefaultRoleEnum: () => (/* binding */ ConfigDefaultRoleEnum),\n/* harmony export */   ConfigRequestDefaultRoleEnum: () => (/* binding */ ConfigRequestDefaultRoleEnum),\n/* harmony export */   CreateCallRequestTypeEnum: () => (/* binding */ CreateCallRequestTypeEnum),\n/* harmony export */   CreateChannelTypeRequestAutomodBehaviorEnum: () => (/* binding */ CreateChannelTypeRequestAutomodBehaviorEnum),\n/* harmony export */   CreateChannelTypeRequestAutomodEnum: () => (/* binding */ CreateChannelTypeRequestAutomodEnum),\n/* harmony export */   CreateChannelTypeRequestBlocklistBehaviorEnum: () => (/* binding */ CreateChannelTypeRequestBlocklistBehaviorEnum),\n/* harmony export */   CreateChannelTypeResponseAutomodBehaviorEnum: () => (/* binding */ CreateChannelTypeResponseAutomodBehaviorEnum),\n/* harmony export */   CreateChannelTypeResponseAutomodEnum: () => (/* binding */ CreateChannelTypeResponseAutomodEnum),\n/* harmony export */   CreateChannelTypeResponseBlocklistBehaviorEnum: () => (/* binding */ CreateChannelTypeResponseBlocklistBehaviorEnum),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* binding */ CreateDeviceRequestPushProviderEnum),\n/* harmony export */   CreateImportRequestModeEnum: () => (/* binding */ CreateImportRequestModeEnum),\n/* harmony export */   DeleteUsersRequestConversationsEnum: () => (/* binding */ DeleteUsersRequestConversationsEnum),\n/* harmony export */   DeleteUsersRequestMessagesEnum: () => (/* binding */ DeleteUsersRequestMessagesEnum),\n/* harmony export */   DeleteUsersRequestUserEnum: () => (/* binding */ DeleteUsersRequestUserEnum),\n/* harmony export */   DeviceFieldsPushProviderEnum: () => (/* binding */ DeviceFieldsPushProviderEnum),\n/* harmony export */   DevicePushProviderEnum: () => (/* binding */ DevicePushProviderEnum),\n/* harmony export */   DeviceRequestPushProviderEnum: () => (/* binding */ DeviceRequestPushProviderEnum),\n/* harmony export */   ImageSizeCropEnum: () => (/* binding */ ImageSizeCropEnum),\n/* harmony export */   ImageSizeResizeEnum: () => (/* binding */ ImageSizeResizeEnum),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* binding */ LayoutSettingsNameEnum),\n/* harmony export */   MessageRequest1TypeEnum: () => (/* binding */ MessageRequest1TypeEnum),\n/* harmony export */   MessageRequestTypeEnum: () => (/* binding */ MessageRequestTypeEnum),\n/* harmony export */   MessageTypeEnum: () => (/* binding */ MessageTypeEnum),\n/* harmony export */   PermissionLevelEnum: () => (/* binding */ PermissionLevelEnum),\n/* harmony export */   PolicyRequest1ActionEnum: () => (/* binding */ PolicyRequest1ActionEnum),\n/* harmony export */   PolicyRequestActionEnum: () => (/* binding */ PolicyRequestActionEnum),\n/* harmony export */   PushConfigRequestVersionEnum: () => (/* binding */ PushConfigRequestVersionEnum),\n/* harmony export */   StreamCall: () => (/* binding */ StreamCall),\n/* harmony export */   StreamChannel: () => (/* binding */ StreamChannel),\n/* harmony export */   StreamChatClient: () => (/* binding */ StreamChatClient),\n/* harmony export */   StreamClient: () => (/* binding */ StreamClient),\n/* harmony export */   StreamVideoClient: () => (/* binding */ StreamVideoClient),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* binding */ TranscriptionSettingsModeEnum),\n/* harmony export */   TranslateMessageRequestLanguageEnum: () => (/* binding */ TranslateMessageRequestLanguageEnum),\n/* harmony export */   UpdateAppRequestEnforceUniqueUsernamesEnum: () => (/* binding */ UpdateAppRequestEnforceUniqueUsernamesEnum),\n/* harmony export */   UpdateAppRequestPermissionVersionEnum: () => (/* binding */ UpdateAppRequestPermissionVersionEnum),\n/* harmony export */   UpdateAppRequestVideoProviderEnum: () => (/* binding */ UpdateAppRequestVideoProviderEnum),\n/* harmony export */   UpdateChannelTypeRequestAutomodBehaviorEnum: () => (/* binding */ UpdateChannelTypeRequestAutomodBehaviorEnum),\n/* harmony export */   UpdateChannelTypeRequestAutomodEnum: () => (/* binding */ UpdateChannelTypeRequestAutomodEnum),\n/* harmony export */   UpdateChannelTypeRequestBlocklistBehaviorEnum: () => (/* binding */ UpdateChannelTypeRequestBlocklistBehaviorEnum),\n/* harmony export */   UpdateChannelTypeResponseAutomodBehaviorEnum: () => (/* binding */ UpdateChannelTypeResponseAutomodBehaviorEnum),\n/* harmony export */   UpdateChannelTypeResponseAutomodEnum: () => (/* binding */ UpdateChannelTypeResponseAutomodEnum),\n/* harmony export */   UpdateChannelTypeResponseBlocklistBehaviorEnum: () => (/* binding */ UpdateChannelTypeResponseBlocklistBehaviorEnum),\n/* harmony export */   VideoAudioSettingsDefaultDeviceEnum: () => (/* binding */ VideoAudioSettingsDefaultDeviceEnum),\n/* harmony export */   VideoAudioSettingsRequestDefaultDeviceEnum: () => (/* binding */ VideoAudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   VideoCreateDeviceRequestPushProviderEnum: () => (/* binding */ VideoCreateDeviceRequestPushProviderEnum),\n/* harmony export */   VideoLayoutSettingsNameEnum: () => (/* binding */ VideoLayoutSettingsNameEnum),\n/* harmony export */   VideoLayoutSettingsRequestNameEnum: () => (/* binding */ VideoLayoutSettingsRequestNameEnum),\n/* harmony export */   VideoOwnCapability: () => (/* binding */ VideoOwnCapability),\n/* harmony export */   VideoRecordSettingsRequestModeEnum: () => (/* binding */ VideoRecordSettingsRequestModeEnum),\n/* harmony export */   VideoRecordSettingsRequestQualityEnum: () => (/* binding */ VideoRecordSettingsRequestQualityEnum),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* binding */ VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoTranscriptionSettingsModeEnum: () => (/* binding */ VideoTranscriptionSettingsModeEnum),\n/* harmony export */   VideoTranscriptionSettingsRequestModeEnum: () => (/* binding */ VideoTranscriptionSettingsRequestModeEnum),\n/* harmony export */   VideoVideoSettingsCameraFacingEnum: () => (/* binding */ VideoVideoSettingsCameraFacingEnum),\n/* harmony export */   VideoVideoSettingsRequestCameraFacingEnum: () => (/* binding */ VideoVideoSettingsRequestCameraFacingEnum)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonwebtoken */ \"(action-browser)/./node_modules/jsonwebtoken/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n/**\n * @export\n */\nconst APNConfigRequestAuthTypeEnum = {\n    CERTIFICATE: 'certificate',\n    TOKEN: 'token'\n};\n/**\n * @export\n */\nconst AppSearchBackendEnum = {\n    ELASTICSEARCH: 'elasticsearch',\n    POSTGRES: 'postgres',\n    DISABLED: 'disabled'\n};\n/**\n * @export\n */\nconst AsyncModerationCallbackConfigRequestModeEnum = {\n    NONE: 'CALLBACK_MODE_NONE',\n    REST: 'CALLBACK_MODE_REST',\n    TWIRP: 'CALLBACK_MODE_TWIRP'\n};\n/**\n * @export\n */\nconst AudioSettingsDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst BlockListOptionsBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst BlockListOptionsRequestBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelMemberRoleEnum = {\n    MEMBER: 'member',\n    MODERATOR: 'moderator',\n    ADMIN: 'admin',\n    OWNER: 'owner'\n};\n/**\n * @export\n */\nconst ChannelMemberRequestRoleEnum = {\n    MEMBER: 'member',\n    MODERATOR: 'moderator',\n    ADMIN: 'admin',\n    OWNER: 'owner'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CheckPushRequestPushProviderTypeEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst CheckSNSResponseStatusEnum = {\n    OK: 'ok',\n    ERROR: 'error'\n};\n/**\n * @export\n */\nconst CheckSQSResponseStatusEnum = {\n    OK: 'ok',\n    ERROR: 'error'\n};\n/**\n * @export\n */\nconst ConfigDefaultRoleEnum = {\n    ATTENDEE: 'attendee',\n    PUBLISHER: 'publisher',\n    SUBSCRIBER: 'subscriber',\n    ADMIN: 'admin'\n};\n/**\n * @export\n */\nconst ConfigRequestDefaultRoleEnum = {\n    ATTENDEE: 'attendee',\n    PUBLISHER: 'publisher',\n    SUBSCRIBER: 'subscriber',\n    ADMIN: 'admin'\n};\n/**\n * @export\n */\nconst CreateCallRequestTypeEnum = {\n    AUDIO: 'audio',\n    VIDEO: 'video'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateDeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst CreateImportRequestModeEnum = {\n    INSERT: 'insert',\n    UPSERT: 'upsert'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestConversationsEnum = {\n    SOFT: 'soft',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestMessagesEnum = {\n    SOFT: 'soft',\n    PRUNING: 'pruning',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestUserEnum = {\n    SOFT: 'soft',\n    PRUNING: 'pruning',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DevicePushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst DeviceFieldsPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst DeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst ImageSizeCropEnum = {\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    LEFT: 'left',\n    RIGHT: 'right',\n    CENTER: 'center'\n};\n/**\n * @export\n */\nconst ImageSizeResizeEnum = {\n    CLIP: 'clip',\n    CROP: 'crop',\n    SCALE: 'scale',\n    FILL: 'fill'\n};\n/**\n * @export\n */\nconst LayoutSettingsNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * @export\n */\nconst MessageTypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst MessageRequestTypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst MessageRequest1TypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst PermissionLevelEnum = {\n    APP: 'app',\n    CHANNEL: 'channel'\n};\n/**\n * @export\n */\nconst PolicyRequestActionEnum = {\n    DENY: 'Deny',\n    ALLOW: 'Allow'\n};\n/**\n * @export\n */\nconst PolicyRequest1ActionEnum = {\n    DENY: 'Deny',\n    ALLOW: 'Allow'\n};\n/**\n * @export\n */\nconst PushConfigRequestVersionEnum = {\n    V1: 'v1',\n    V2: 'v2'\n};\n/**\n * @export\n */\nconst TranscriptionSettingsModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst TranslateMessageRequestLanguageEnum = {\n    AF: 'af',\n    SQ: 'sq',\n    AM: 'am',\n    AR: 'ar',\n    AZ: 'az',\n    BN: 'bn',\n    BS: 'bs',\n    BG: 'bg',\n    ZH: 'zh',\n    ZH_TW: 'zh-TW',\n    HR: 'hr',\n    CS: 'cs',\n    DA: 'da',\n    FA_AF: 'fa-AF',\n    NL: 'nl',\n    EN: 'en',\n    ET: 'et',\n    FI: 'fi',\n    FR: 'fr',\n    FR_CA: 'fr-CA',\n    KA: 'ka',\n    DE: 'de',\n    EL: 'el',\n    HA: 'ha',\n    HE: 'he',\n    HI: 'hi',\n    HU: 'hu',\n    ID: 'id',\n    IT: 'it',\n    JA: 'ja',\n    KO: 'ko',\n    LV: 'lv',\n    MS: 'ms',\n    NO: 'no',\n    FA: 'fa',\n    PS: 'ps',\n    PL: 'pl',\n    PT: 'pt',\n    RO: 'ro',\n    RU: 'ru',\n    SR: 'sr',\n    SK: 'sk',\n    SL: 'sl',\n    SO: 'so',\n    ES: 'es',\n    ES_MX: 'es-MX',\n    SW: 'sw',\n    SV: 'sv',\n    TL: 'tl',\n    TA: 'ta',\n    TH: 'th',\n    TR: 'tr',\n    UK: 'uk',\n    UR: 'ur',\n    VI: 'vi'\n};\n/**\n * @export\n */\nconst UpdateAppRequestEnforceUniqueUsernamesEnum = {\n    NO: 'no',\n    APP: 'app',\n    TEAM: 'team'\n};\n/**\n * @export\n */\nconst UpdateAppRequestPermissionVersionEnum = {\n    V1: 'v1',\n    V2: 'v2'\n};\n/**\n * @export\n */\nconst UpdateAppRequestVideoProviderEnum = {\n    AGORA: 'agora',\n    HMS: 'hms'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst VideoSettingsCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n\n/**\n * @export\n */\nconst VideoAudioSettingsDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst VideoAudioSettingsRequestDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst VideoCreateDeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst VideoLayoutSettingsNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * @export\n */\nconst VideoLayoutSettingsRequestNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * All possibility of string to use\n * @export\n */\nconst VideoOwnCapability = {\n    BLOCK_USERS: 'block-users',\n    CREATE_CALL: 'create-call',\n    CREATE_REACTION: 'create-reaction',\n    END_CALL: 'end-call',\n    JOIN_BACKSTAGE: 'join-backstage',\n    JOIN_CALL: 'join-call',\n    JOIN_ENDED_CALL: 'join-ended-call',\n    MUTE_USERS: 'mute-users',\n    PIN_FOR_EVERYONE: 'pin-for-everyone',\n    READ_CALL: 'read-call',\n    REMOVE_CALL_MEMBER: 'remove-call-member',\n    SCREENSHARE: 'screenshare',\n    SEND_AUDIO: 'send-audio',\n    SEND_VIDEO: 'send-video',\n    START_BROADCAST_CALL: 'start-broadcast-call',\n    START_RECORD_CALL: 'start-record-call',\n    START_TRANSCRIPTION_CALL: 'start-transcription-call',\n    STOP_BROADCAST_CALL: 'stop-broadcast-call',\n    STOP_RECORD_CALL: 'stop-record-call',\n    STOP_TRANSCRIPTION_CALL: 'stop-transcription-call',\n    UPDATE_CALL: 'update-call',\n    UPDATE_CALL_MEMBER: 'update-call-member',\n    UPDATE_CALL_PERMISSIONS: 'update-call-permissions',\n    UPDATE_CALL_SETTINGS: 'update-call-settings'\n};\n/**\n * @export\n */\nconst VideoRecordSettingsRequestModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoRecordSettingsRequestQualityEnum = {\n    _360P: '360p',\n    _480P: '480p',\n    _720P: '720p',\n    _1080P: '1080p',\n    _1440P: '1440p'\n};\n/**\n * @export\n */\nconst VideoTranscriptionSettingsModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoTranscriptionSettingsRequestModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoVideoSettingsCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n/**\n * @export\n */\nconst VideoVideoSettingsRequestCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nconst BASE_PATH$1 = \"https://chat.stream-io-api.com\".replace(/\\/+$/, \"\");\nlet Configuration$1 = class Configuration {\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n    }\n    set config(configuration) {\n        this.configuration = configuration;\n    }\n    get basePath() {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;\n    }\n    get fetchApi() {\n        return this.configuration.fetchApi;\n    }\n    get middleware() {\n        return this.configuration.middleware || [];\n    }\n    get queryParamsStringify() {\n        return this.configuration.queryParamsStringify || querystring$1;\n    }\n    get username() {\n        return this.configuration.username;\n    }\n    get password() {\n        return this.configuration.password;\n    }\n    get apiKey() {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n    get accessToken() {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });\n        }\n        return undefined;\n    }\n    get headers() {\n        return this.configuration.headers;\n    }\n    get credentials() {\n        return this.configuration.credentials;\n    }\n};\nconst DefaultConfig$1 = new Configuration$1();\n/**\n * This is the base class for all generated API classes.\n */\nlet BaseAPI$1 = class BaseAPI {\n    constructor(configuration = DefaultConfig$1) {\n        this.configuration = configuration;\n        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {\n            let fetchParams = { url, init };\n            for (const middleware of this.middleware) {\n                if (middleware.pre) {\n                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;\n                }\n            }\n            let response = undefined;\n            try {\n                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n            }\n            catch (e) {\n                for (const middleware of this.middleware) {\n                    if (middleware.onError) {\n                        response = (yield middleware.onError({\n                            fetch: this.fetchApi,\n                            url: fetchParams.url,\n                            init: fetchParams.init,\n                            error: e,\n                            response: response ? response.clone() : undefined,\n                        })) || response;\n                    }\n                }\n                if (response === undefined) {\n                    if (e instanceof Error) {\n                        throw new FetchError$1(e, 'The request failed and the interceptors did not return an alternative response');\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            for (const middleware of this.middleware) {\n                if (middleware.post) {\n                    response = (yield middleware.post({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        response: response.clone(),\n                    })) || response;\n                }\n            }\n            return response;\n        });\n        this.middleware = configuration.middleware;\n    }\n    withMiddleware(...middlewares) {\n        const next = this.clone();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n    withPreMiddleware(...preMiddlewares) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware(...middlewares);\n    }\n    withPostMiddleware(...postMiddlewares) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware(...middlewares);\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        if (!mime) {\n            return false;\n        }\n        return BaseAPI.jsonRegex.test(mime);\n    }\n    request(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { url, init } = yield this.createFetchParams(context, initOverrides);\n            const response = yield this.fetchApi(url, init);\n            if (response && (response.status >= 200 && response.status < 300)) {\n                return response;\n            }\n            throw new ResponseError$1(response, 'Response returned an error code');\n        });\n    }\n    createFetchParams(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.configuration.basePath + context.path;\n            if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n                // only add the querystring to the URL if there are query parameters.\n                // this is done to avoid urls ending with a \"?\" character which buggy webservers\n                // do not handle correctly sometimes.\n                url += '?' + this.configuration.queryParamsStringify(context.query);\n            }\n            const headers = Object.assign({}, this.configuration.headers, context.headers);\n            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n            const initOverrideFn = typeof initOverrides === \"function\"\n                ? initOverrides\n                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });\n            const initParams = {\n                method: context.method,\n                headers,\n                body: context.body,\n                credentials: this.configuration.credentials,\n            };\n            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({\n                init: initParams,\n                context,\n            })));\n            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData$1(overriddenInit.body) ||\n                    overriddenInit.body instanceof URLSearchParams ||\n                    isBlob$1(overriddenInit.body)\n                    ? overriddenInit.body\n                    : JSON.stringify(overriddenInit.body) });\n            return { url, init };\n        });\n    }\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    clone() {\n        const constructor = this.constructor;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n};\nBaseAPI$1.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');\nfunction isBlob$1(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData$1(value) {\n    return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nlet ResponseError$1 = class ResponseError extends Error {\n    constructor(response, msg) {\n        super(msg);\n        this.response = response;\n        this.name = \"ResponseError\";\n    }\n};\nlet FetchError$1 = class FetchError extends Error {\n    constructor(cause, msg) {\n        super(msg);\n        this.cause = cause;\n        this.name = \"FetchError\";\n    }\n};\nlet RequiredError$1 = class RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n};\nconst COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\nfunction querystring$1(params, prefix = '') {\n    return Object.keys(params)\n        .map(key => querystringSingleKey$1(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\nfunction querystringSingleKey$1(key, value, keyPrefix = '') {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey$1(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring$1(value, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nfunction canConsumeForm(consumes) {\n    for (const consume of consumes) {\n        if ('multipart/form-data' === consume.contentType) {\n            return true;\n        }\n    }\n    return false;\n}\nlet JSONApiResponse$1 = class JSONApiResponse {\n    constructor(raw, transformer = (jsonValue) => jsonValue) {\n        this.raw = raw;\n        this.transformer = transformer;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.transformer(yield this.raw.json());\n        });\n    }\n};\nlet VoidApiResponse$1 = class VoidApiResponse {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return undefined;\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ChannelTypesApi extends BaseAPI$1 {\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {\n                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listChannelTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');\n            }\n            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {\n                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ChannelsApi extends BaseAPI$1 {\n    /**\n     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Delete channel\n     */\n    deleteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteChannel.');\n            }\n            const queryParameters = {};\n            if (requestParameters.hardDelete !== undefined) {\n                queryParameters['hard_delete'] = requestParameters.hardDelete;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Delete channel\n     */\n    deleteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Deletes channels asynchronously\n     */\n    deleteChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deleteChannelsRequest === null || requestParameters.deleteChannelsRequest === undefined) {\n                throw new RequiredError$1('deleteChannelsRequest', 'Required parameter requestParameters.deleteChannelsRequest was null or undefined when calling deleteChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/delete`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deleteChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Deletes channels asynchronously\n     */\n    deleteChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports channel data to JSON file\n     * Export channels\n     */\n    exportChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.exportChannelsRequest === null || requestParameters.exportChannelsRequest === undefined) {\n                throw new RequiredError$1('exportChannelsRequest', 'Required parameter requestParameters.exportChannelsRequest was null or undefined when calling exportChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export_channels`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.exportChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports channel data to JSON file\n     * Export channels\n     */\n    exportChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Export channels status\n     */\n    getExportChannelsStatusRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getExportChannelsStatus.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export_channels/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     *\n     * Export channels status\n     */\n    getExportChannelsStatus(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getExportChannelsStatusRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start\n     * Get or create channel\n     */\n    getOrCreateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateChannel.');\n            }\n            if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {\n                throw new RequiredError$1('channelGetOrCreateRequest', 'Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/query`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.channelGetOrCreateRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start\n     * Get or create channel\n     */\n    getOrCreateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOrCreateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel\n     * Hide channel\n     */\n    hideChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling hideChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling hideChannel.');\n            }\n            if (requestParameters.hideChannelRequest === null || requestParameters.hideChannelRequest === undefined) {\n                throw new RequiredError$1('hideChannelRequest', 'Required parameter requestParameters.hideChannelRequest was null or undefined when calling hideChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/hide`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.hideChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel\n     * Hide channel\n     */\n    hideChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.hideChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {\n                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/read`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markChannelsReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');\n            }\n            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {\n                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/read`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnreadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {\n                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/unread`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markUnreadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnread(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markUnreadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel\n     * Mute channel\n     */\n    muteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.muteChannelRequest === null || requestParameters.muteChannelRequest === undefined) {\n                throw new RequiredError$1('muteChannelRequest', 'Required parameter requestParameters.muteChannelRequest was null or undefined when calling muteChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/mute/channel`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.muteChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel\n     * Mute channel\n     */\n    muteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query channels with filter query  Required permissions: - ReadChannel\n     * Query channels\n     */\n    queryChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.queryChannelsRequest === null || requestParameters.queryChannelsRequest === undefined) {\n                throw new RequiredError$1('queryChannelsRequest', 'Required parameter requestParameters.queryChannelsRequest was null or undefined when calling queryChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.queryChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Query channels with filter query  Required permissions: - ReadChannel\n     * Query channels\n     */\n    queryChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter channel members  Required permissions: - ReadChannel\n     * Query members\n     */\n    queryMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/members`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter channel members  Required permissions: - ReadChannel\n     * Query members\n     */\n    queryMembers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    searchRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/search`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    search(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.searchRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Shows previously hidden channel  Sends events: - channel.visible\n     * Show channel\n     */\n    showChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling showChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling showChannel.');\n            }\n            if (requestParameters.showChannelRequest === null || requestParameters.showChannelRequest === undefined) {\n                throw new RequiredError$1('showChannelRequest', 'Required parameter requestParameters.showChannelRequest was null or undefined when calling showChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/show`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.showChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Shows previously hidden channel  Sends events: - channel.visible\n     * Show channel\n     */\n    showChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.showChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel\n     * Truncate channel\n     */\n    truncateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling truncateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling truncateChannel.');\n            }\n            if (requestParameters.truncateChannelRequest === null || requestParameters.truncateChannelRequest === undefined) {\n                throw new RequiredError$1('truncateChannelRequest', 'Required parameter requestParameters.truncateChannelRequest was null or undefined when calling truncateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/truncate`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.truncateChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel\n     * Truncate channel\n     */\n    truncateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.truncateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel\n     * Unmute channel\n     */\n    unmuteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.unmuteChannelRequest === null || requestParameters.unmuteChannelRequest === undefined) {\n                throw new RequiredError$1('unmuteChannelRequest', 'Required parameter requestParameters.unmuteChannelRequest was null or undefined when calling unmuteChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unmute/channel`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.unmuteChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel\n     * Unmute channel\n     */\n    unmuteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unmuteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * UnreadCount counts\n     * UnreadCount counts\n     */\n    unreadCountsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/unread`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * UnreadCount counts\n     * UnreadCount counts\n     */\n    unreadCounts(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unreadCountsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers\n     * Update channel\n     */\n    updateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannel.');\n            }\n            if (requestParameters.updateChannelRequest === null || requestParameters.updateChannelRequest === undefined) {\n                throw new RequiredError$1('updateChannelRequest', 'Required parameter requestParameters.updateChannelRequest was null or undefined when calling updateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers\n     * Update channel\n     */\n    updateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen\n     * Partially update channel\n     */\n    updateChannelPartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannelPartial.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannelPartial.');\n            }\n            if (requestParameters.updateChannelPartialRequest === null || requestParameters.updateChannelPartialRequest === undefined) {\n                throw new RequiredError$1('updateChannelPartialRequest', 'Required parameter requestParameters.updateChannelPartialRequest was null or undefined when calling updateChannelPartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelPartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen\n     * Partially update channel\n     */\n    updateChannelPartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelPartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass CustomCommandsApi extends BaseAPI$1 {\n    /**\n     * Creates custom chat command\n     * Create command\n     */\n    createCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createCommandRequest === null || requestParameters.createCommandRequest === undefined) {\n                throw new RequiredError$1('createCommandRequest', 'Required parameter requestParameters.createCommandRequest was null or undefined when calling createCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createCommandRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates custom chat command\n     * Create command\n     */\n    createCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes custom chat command\n     * Delete command\n     */\n    deleteCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes custom chat command\n     * Delete command\n     */\n    deleteCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns custom command by its name\n     * Get command\n     */\n    getCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns custom command by its name\n     * Get command\n     */\n    getCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all custom commands\n     * List commands\n     */\n    listCommandsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all custom commands\n     * List commands\n     */\n    listCommands(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listCommandsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates custom chat command\n     * Update command\n     */\n    updateCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateCommand.');\n            }\n            if (requestParameters.updateCommandRequest === null || requestParameters.updateCommandRequest === undefined) {\n                throw new RequiredError$1('updateCommandRequest', 'Required parameter requestParameters.updateCommandRequest was null or undefined when calling updateCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateCommandRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates custom chat command\n     * Update command\n     */\n    updateCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass DevicesApi extends BaseAPI$1 {\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {\n                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createDeviceRequest,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.createDeviceRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDevice(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevicesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevices(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listDevicesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass EventsApi extends BaseAPI$1 {\n    /**\n     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent\n     * Send event\n     */\n    sendEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.sendEventRequest === null || requestParameters.sendEventRequest === undefined) {\n                throw new RequiredError$1('sendEventRequest', 'Required parameter requestParameters.sendEventRequest was null or undefined when calling sendEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/event`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent\n     * Send event\n     */\n    sendEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends a custom event to a user  Sends events: - custom\n     * Send user event\n     */\n    sendUserCustomEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling sendUserCustomEvent.');\n            }\n            if (requestParameters.sendUserCustomEventRequest === null || requestParameters.sendUserCustomEventRequest === undefined) {\n                throw new RequiredError$1('sendUserCustomEventRequest', 'Required parameter requestParameters.sendUserCustomEventRequest was null or undefined when calling sendUserCustomEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/event`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendUserCustomEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a custom event to a user  Sends events: - custom\n     * Send user event\n     */\n    sendUserCustomEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendUserCustomEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass MessagesApi extends BaseAPI$1 {\n    /**\n     * Deletes previously uploaded file  Required permissions: - DeleteAttachment\n     * Delete file\n     */\n    deleteFileRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteFile.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteFile.');\n            }\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/file`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously uploaded file  Required permissions: - DeleteAttachment\n     * Delete file\n     */\n    deleteFile(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteFileRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes previously uploaded image  Required permissions: - DeleteAttachment\n     * Delete image\n     */\n    deleteImageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteImage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteImage.');\n            }\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/image`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously uploaded image  Required permissions: - DeleteAttachment\n     * Delete image\n     */\n    deleteImage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteImageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage\n     * Delete message\n     */\n    deleteMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteMessage.');\n            }\n            const queryParameters = {};\n            if (requestParameters.hard !== undefined) {\n                queryParameters['hard'] = requestParameters.hard;\n            }\n            if (requestParameters.deletedBy !== undefined) {\n                queryParameters['deleted_by'] = requestParameters.deletedBy;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage\n     * Delete message\n     */\n    deleteMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction\n     * Delete reaction\n     */\n    deleteReactionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteReaction.');\n            }\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteReaction.');\n            }\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reaction/{type}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction\n     * Delete reaction\n     */\n    deleteReaction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteReactionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.flagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns list messages found by IDs  Required permissions: - ReadChannel\n     * Get many messages\n     */\n    getManyMessagesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getManyMessages.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getManyMessages.');\n            }\n            const queryParameters = {};\n            if (requestParameters.ids) {\n                queryParameters['ids'] = requestParameters.ids.join(',');\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/messages`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns list messages found by IDs  Required permissions: - ReadChannel\n     * Get many messages\n     */\n    getManyMessages(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getManyMessagesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns message by ID  Required permissions: - ReadChannel\n     * Get message\n     */\n    getMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns message by ID  Required permissions: - ReadChannel\n     * Get message\n     */\n    getMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Get an OpenGraph attachment for a link\n     * Get OG\n     */\n    getOGRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/og`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Get an OpenGraph attachment for a link\n     * Get OG\n     */\n    getOG(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOGRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns list of reactions of specific message  Required permissions: - ReadChannel\n     * Get reactions\n     */\n    getReactionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getReactions.');\n            }\n            const queryParameters = {};\n            if (requestParameters.limit !== undefined) {\n                queryParameters['limit'] = requestParameters.limit;\n            }\n            if (requestParameters.offset !== undefined) {\n                queryParameters['offset'] = requestParameters.offset;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reactions`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns list of reactions of specific message  Required permissions: - ReadChannel\n     * Get reactions\n     */\n    getReactions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getReactionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns replies (thread) of the message  Required permissions: - ReadChannel\n     * Get replies\n     */\n    getRepliesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.parentId === null || requestParameters.parentId === undefined) {\n                throw new RequiredError$1('parentId', 'Required parameter requestParameters.parentId was null or undefined when calling getReplies.');\n            }\n            const queryParameters = {};\n            if (requestParameters.idGte !== undefined) {\n                queryParameters['id_gte'] = requestParameters.idGte;\n            }\n            if (requestParameters.idGt !== undefined) {\n                queryParameters['id_gt'] = requestParameters.idGt;\n            }\n            if (requestParameters.idLte !== undefined) {\n                queryParameters['id_lte'] = requestParameters.idLte;\n            }\n            if (requestParameters.idLt !== undefined) {\n                queryParameters['id_lt'] = requestParameters.idLt;\n            }\n            if (requestParameters.createdAtAfterOrEqual !== undefined) {\n                queryParameters['created_at_after_or_equal'] = requestParameters.createdAtAfterOrEqual;\n            }\n            if (requestParameters.createdAtAfter !== undefined) {\n                queryParameters['created_at_after'] = requestParameters.createdAtAfter;\n            }\n            if (requestParameters.createdAtBeforeOrEqual !== undefined) {\n                queryParameters['created_at_before_or_equal'] = requestParameters.createdAtBeforeOrEqual;\n            }\n            if (requestParameters.createdAtBefore !== undefined) {\n                queryParameters['created_at_before'] = requestParameters.createdAtBefore;\n            }\n            if (requestParameters.idAround !== undefined) {\n                queryParameters['id_around'] = requestParameters.idAround;\n            }\n            if (requestParameters.createdAtAround !== undefined) {\n                queryParameters['created_at_around'] = requestParameters.createdAtAround;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{parent_id}/replies`.replace(`{${\"parent_id\"}}`, encodeURIComponent(String(requestParameters.parentId))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns replies (thread) of the message  Required permissions: - ReadChannel\n     * Get replies\n     */\n    getReplies(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getRepliesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {\n                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/read`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markChannelsReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');\n            }\n            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {\n                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/read`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnreadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {\n                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/unread`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markUnreadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnread(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markUnreadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter message flags  Required permissions: - ReadMessageFlags\n     * Query Message Flags\n     */\n    queryMessageFlagsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flags/message`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter message flags  Required permissions: - ReadMessageFlags\n     * Query Message Flags\n     */\n    queryMessageFlags(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMessageFlagsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction\n     * Run message command action\n     */\n    runMessageActionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling runMessageAction.');\n            }\n            if (requestParameters.messageActionRequest === null || requestParameters.messageActionRequest === undefined) {\n                throw new RequiredError$1('messageActionRequest', 'Required parameter requestParameters.messageActionRequest was null or undefined when calling runMessageAction.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/action`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.messageActionRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction\n     * Run message command action\n     */\n    runMessageAction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.runMessageActionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    searchRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/search`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    search(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.searchRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel\n     * Send new message\n     */\n    sendMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendMessage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendMessage.');\n            }\n            if (requestParameters.sendMessageRequest === null || requestParameters.sendMessageRequest === undefined) {\n                throw new RequiredError$1('sendMessageRequest', 'Required parameter requestParameters.sendMessageRequest was null or undefined when calling sendMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/message`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel\n     * Send new message\n     */\n    sendMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel\n     * Send reaction\n     */\n    sendReactionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendReaction.');\n            }\n            if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {\n                throw new RequiredError$1('sendReactionRequest', 'Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendReaction.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reaction`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendReactionRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel\n     * Send reaction\n     */\n    sendReaction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendReactionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel\n     * Translate message\n     */\n    translateMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling translateMessage.');\n            }\n            if (requestParameters.translateMessageRequest === null || requestParameters.translateMessageRequest === undefined) {\n                throw new RequiredError$1('translateMessageRequest', 'Required parameter requestParameters.translateMessageRequest was null or undefined when calling translateMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/translate`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.translateMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel\n     * Translate message\n     */\n    translateMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.translateMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unflag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unflagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Update message\n     */\n    updateMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessage.');\n            }\n            if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {\n                throw new RequiredError$1('updateMessageRequest', 'Required parameter requestParameters.updateMessageRequest was null or undefined when calling updateMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Update message\n     */\n    updateMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Partially message update\n     */\n    updateMessagePartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessagePartial.');\n            }\n            if (requestParameters.updateMessagePartialRequest === null || requestParameters.updateMessagePartialRequest === undefined) {\n                throw new RequiredError$1('updateMessagePartialRequest', 'Required parameter requestParameters.updateMessagePartialRequest was null or undefined when calling updateMessagePartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateMessagePartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Partially message update\n     */\n    updateMessagePartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateMessagePartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Uploads file  Required permissions: - UploadAttachment\n     * Upload file\n     */\n    uploadFileRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadFile.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadFile.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const consumes = [\n                { contentType: 'multipart/form-data' },\n            ];\n            // @ts-ignore: canConsumeForm may be unused\n            canConsumeForm(consumes);\n            let formParams;\n            {\n                formParams = new URLSearchParams();\n            }\n            if (requestParameters.file !== undefined) {\n                formParams.append('file', requestParameters.file);\n            }\n            if (requestParameters.user !== undefined) {\n                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: \"application/json\", }));\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/file`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: formParams,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Uploads file  Required permissions: - UploadAttachment\n     * Upload file\n     */\n    uploadFile(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.uploadFileRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Uploads image  Required permissions: - UploadAttachment\n     * Upload image\n     */\n    uploadImageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadImage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadImage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const consumes = [\n                { contentType: 'multipart/form-data' },\n            ];\n            // @ts-ignore: canConsumeForm may be unused\n            canConsumeForm(consumes);\n            let formParams;\n            {\n                formParams = new URLSearchParams();\n            }\n            if (requestParameters.file !== undefined) {\n                formParams.append('file', requestParameters.file);\n            }\n            if (requestParameters.uploadSizes) {\n                formParams.append('upload_sizes', requestParameters.uploadSizes.join(COLLECTION_FORMATS[\"csv\"]));\n            }\n            if (requestParameters.user !== undefined) {\n                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: \"application/json\", }));\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/image`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: formParams,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Uploads image  Required permissions: - UploadAttachment\n     * Upload image\n     */\n    uploadImage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.uploadImageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass PermissionsV2Api extends BaseAPI$1 {\n    /**\n     * Creates custom role\n     * Create role\n     */\n    createRoleRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createRoleRequest === null || requestParameters.createRoleRequest === undefined) {\n                throw new RequiredError$1('createRoleRequest', 'Required parameter requestParameters.createRoleRequest was null or undefined when calling createRole.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createRoleRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates custom role\n     * Create role\n     */\n    createRole(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createRoleRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes custom role\n     * Delete role\n     */\n    deleteRoleRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteRole.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes custom role\n     * Delete role\n     */\n    deleteRole(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteRoleRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets custom permission\n     * Get permission\n     */\n    getPermissionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getPermission.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/permissions/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets custom permission\n     * Get permission\n     */\n    getPermission(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getPermissionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available permissions\n     * List permissions\n     */\n    listPermissionsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/permissions`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available permissions\n     * List permissions\n     */\n    listPermissions(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPermissionsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available roles\n     * List roles\n     */\n    listRolesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available roles\n     * List roles\n     */\n    listRoles(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listRolesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass PushApi extends BaseAPI$1 {\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {\n                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createDeviceRequest,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.createDeviceRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');\n            }\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers/{type}/{name}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProvidersRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProviders(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPushProvidersRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nlet ServerSideApi$1 = class ServerSideApi extends BaseAPI$1 {\n    /**\n     * Upsert a push provider for v2 with multi bundle/package support\n     * Upsert a push provider\n     */\n    upsertPushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.upsertPushProviderRequest === null || requestParameters.upsertPushProviderRequest === undefined) {\n                throw new RequiredError$1('upsertPushProviderRequest', 'Required parameter requestParameters.upsertPushProviderRequest was null or undefined when calling upsertPushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.upsertPushProviderRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Upsert a push provider for v2 with multi bundle/package support\n     * Upsert a push provider\n     */\n    upsertPushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.upsertPushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nlet SettingsApi$1 = class SettingsApi extends BaseAPI$1 {\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPushRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {\n                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_push`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkPushRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPush(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkPushRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {\n                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sns`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSNSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSNSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {\n                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sqs`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSQSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSQSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Creates a new application blocklist, once created the blocklist can be used by any channel type\n     * Create block list\n     */\n    createBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createBlockListRequest === null || requestParameters.createBlockListRequest === undefined) {\n                throw new RequiredError$1('createBlockListRequest', 'Required parameter requestParameters.createBlockListRequest was null or undefined when calling createBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createBlockListRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates a new application blocklist, once created the blocklist can be used by any channel type\n     * Create block list\n     */\n    createBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {\n                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes previously created application blocklist\n     * Delete block list\n     */\n    deleteBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously created application blocklist\n     * Delete block list\n     */\n    deleteBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');\n            }\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers/{type}/{name}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method returns the application settings\n     * Get App Settings\n     */\n    getAppRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/app`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method returns the application settings\n     * Get App Settings\n     */\n    getApp(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getAppRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns block list by given name\n     * Get block list\n     */\n    getBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns block list by given name\n     * Get block list\n     */\n    getBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Get rate limits usage and quotas\n     * Get rate limits\n     */\n    getRateLimitsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.serverSide !== undefined) {\n                queryParameters['server_side'] = requestParameters.serverSide;\n            }\n            if (requestParameters.android !== undefined) {\n                queryParameters['android'] = requestParameters.android;\n            }\n            if (requestParameters.ios !== undefined) {\n                queryParameters['ios'] = requestParameters.ios;\n            }\n            if (requestParameters.web !== undefined) {\n                queryParameters['web'] = requestParameters.web;\n            }\n            if (requestParameters.endpoints !== undefined) {\n                queryParameters['endpoints'] = requestParameters.endpoints;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/rate_limits`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Get rate limits usage and quotas\n     * Get rate limits\n     */\n    getRateLimits(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getRateLimitsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available block lists\n     * List block lists\n     */\n    listBlockListsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all available block lists\n     * List block lists\n     */\n    listBlockLists(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listBlockListsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listChannelTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProvidersRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProviders(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPushProvidersRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method updates one or more application settings\n     * Update App Settings\n     */\n    updateAppRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateAppRequest === null || requestParameters.updateAppRequest === undefined) {\n                throw new RequiredError$1('updateAppRequest', 'Required parameter requestParameters.updateAppRequest was null or undefined when calling updateApp.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/app`,\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateAppRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method updates one or more application settings\n     * Update App Settings\n     */\n    updateApp(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateAppRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates contents of the block list\n     * Update block list\n     */\n    updateBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateBlockList.');\n            }\n            if (requestParameters.updateBlockListRequest === null || requestParameters.updateBlockListRequest === undefined) {\n                throw new RequiredError$1('updateBlockListRequest', 'Required parameter requestParameters.updateBlockListRequest was null or undefined when calling updateBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateBlockListRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates contents of the block list\n     * Update block list\n     */\n    updateBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');\n            }\n            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {\n                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass TasksApi extends BaseAPI$1 {\n    /**\n     * Gets status of a task\n     * Get status of a task\n     */\n    getTaskRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getTask.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/tasks/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets status of a task\n     * Get status of a task\n     */\n    getTask(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getTaskRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass TestingApi extends BaseAPI$1 {\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPushRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {\n                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_push`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkPushRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPush(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkPushRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {\n                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sns`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSNSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSNSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {\n                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sqs`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSQSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSQSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass UsersApi extends BaseAPI$1 {\n    /**\n     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser\n     * Ban user\n     */\n    banRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {\n                throw new RequiredError$1('banRequest', 'Required parameter requestParameters.banRequest was null or undefined when calling ban.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/ban`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.banRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser\n     * Ban user\n     */\n    ban(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.banRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user  Sends events: - user.updated\n     * Connect (WebSocket)\n     */\n    connectRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.json !== undefined) {\n                queryParameters['json'] = requestParameters.json;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/connect`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user  Sends events: - user.updated\n     * Connect (WebSocket)\n     */\n    connect(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.connectRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Creates guest user\n     * Create guest\n     */\n    createGuestRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.guestRequest === null || requestParameters.guestRequest === undefined) {\n                throw new RequiredError$1('guestRequest', 'Required parameter requestParameters.guestRequest was null or undefined when calling createGuest.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/guest`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.guestRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates guest user\n     * Create guest\n     */\n    createGuest(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createGuestRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated\n     * Deactivate user\n     */\n    deactivateUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');\n            }\n            if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {\n                throw new RequiredError$1('deactivateUserRequest', 'Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/deactivate`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deactivateUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated\n     * Deactivate user\n     */\n    deactivateUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deactivateUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deactivate users in batches  Sends events: - user.deactivated\n     * Deactivate users\n     */\n    deactivateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {\n                throw new RequiredError$1('deactivateUsersRequest', 'Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/deactivate`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deactivateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deactivate users in batches  Sends events: - user.deactivated\n     * Deactivate users\n     */\n    deactivateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deactivateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \\'Delete Users\\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted\n     * Delete user\n     */\n    deleteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deleteUser.');\n            }\n            const queryParameters = {};\n            if (requestParameters.markMessagesDeleted !== undefined) {\n                queryParameters['mark_messages_deleted'] = requestParameters.markMessagesDeleted;\n            }\n            if (requestParameters.hardDelete !== undefined) {\n                queryParameters['hard_delete'] = requestParameters.hardDelete;\n            }\n            if (requestParameters.deleteConversationChannels !== undefined) {\n                queryParameters['delete_conversation_channels'] = requestParameters.deleteConversationChannels;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \\'Delete Users\\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted\n     * Delete user\n     */\n    deleteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted\n     * Delete Users\n     */\n    deleteUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {\n                throw new RequiredError$1('deleteUsersRequest', 'Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/delete`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deleteUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted\n     * Delete Users\n     */\n    deleteUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports the user\\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions\n     * Export user\n     */\n    exportUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling exportUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/export`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports the user\\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions\n     * Export user\n     */\n    exportUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports user profile, reactions and messages for list of given users\n     * Export users\n     */\n    exportUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {\n                throw new RequiredError$1('exportUsersRequest', 'Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export/users`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.exportUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports user profile, reactions and messages for list of given users\n     * Export users\n     */\n    exportUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.flagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * WebSocket fallback transport endpoint  Sends events: - user.updated\n     * Long Poll (Transport)\n     */\n    longPollRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.json !== undefined) {\n                queryParameters['json'] = requestParameters.json;\n            }\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/longpoll`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * WebSocket fallback transport endpoint  Sends events: - user.updated\n     * Long Poll (Transport)\n     */\n    longPoll(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.longPollRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser\n     * Mute user\n     */\n    muteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {\n                throw new RequiredError$1('muteUserRequest', 'Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/mute`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.muteUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser\n     * Mute user\n     */\n    muteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel\n     * Query Banned Users\n     */\n    queryBannedUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/query_banned_users`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel\n     * Query Banned Users\n     */\n    queryBannedUsers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryBannedUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter users  Required permissions: - SearchUser\n     * Query users\n     */\n    queryUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter users  Required permissions: - SearchUser\n     * Query users\n     */\n    queryUsers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Activates user who\\'s been deactivated previously  Sends events: - user.reactivated\n     * Reactivate user\n     */\n    reactivateUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');\n            }\n            if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {\n                throw new RequiredError$1('reactivateUserRequest', 'Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/reactivate`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.reactivateUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Activates user who\\'s been deactivated previously  Sends events: - user.reactivated\n     * Reactivate user\n     */\n    reactivateUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.reactivateUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reactivate users in batches  Sends events: - user.reactivated\n     * Reactivate users\n     */\n    reactivateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {\n                throw new RequiredError$1('reactivateUsersRequest', 'Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/reactivate`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.reactivateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reactivate users in batches  Sends events: - user.reactivated\n     * Reactivate users\n     */\n    reactivateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.reactivateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Restore soft deleted users\n     * Restore users\n     */\n    restoreUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {\n                throw new RequiredError$1('restoreUsersRequest', 'Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/restore`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.restoreUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Restore soft deleted users\n     * Restore users\n     */\n    restoreUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.restoreUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser\n     * Unban user\n     */\n    unbanRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.targetUserId !== undefined) {\n                queryParameters['target_user_id'] = requestParameters.targetUserId;\n            }\n            if (requestParameters.type !== undefined) {\n                queryParameters['type'] = requestParameters.type;\n            }\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.createdBy !== undefined) {\n                queryParameters['created_by'] = requestParameters.createdBy;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/ban`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser\n     * Unban user\n     */\n    unban(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unbanRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unflag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unflagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser\n     * Unmute user\n     */\n    unmuteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {\n                throw new RequiredError$1('unmuteUserRequest', 'Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unmute`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.unmuteUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser\n     * Unmute user\n     */\n    unmuteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unmuteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Update or create users in bulk  Sends events: - user.updated\n     * Upsert users\n     */\n    updateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {\n                throw new RequiredError$1('updateUsersRequest', 'Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Update or create users in bulk  Sends events: - user.updated\n     * Upsert users\n     */\n    updateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated\n     * Partially update user\n     */\n    updateUsersPartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateUserPartialRequest === null || requestParameters.updateUserPartialRequest === undefined) {\n                throw new RequiredError$1('updateUserPartialRequest', 'Required parameter requestParameters.updateUserPartialRequest was null or undefined when calling updateUsersPartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateUserPartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated\n     * Partially update user\n     */\n    updateUsersPartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUsersPartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\nclass StreamChannel {\n    constructor(streamClient, type, id) {\n        this.streamClient = streamClient;\n        this.type = type;\n        this.id = id;\n        this.delete = (request) => {\n            return this.channelsApi.deleteChannel(Object.assign(Object.assign({}, this.baseRequest), (request !== null && request !== void 0 ? request : {})));\n        };\n        this.update = (updateChannelRequest) => {\n            return this.channelsApi.updateChannel(Object.assign(Object.assign({}, this.baseRequest), { updateChannelRequest }));\n        };\n        this.updatePartial = (updateChannelPartialRequest) => {\n            return this.channelsApi.updateChannelPartial(Object.assign(Object.assign({}, this.baseRequest), { updateChannelPartialRequest }));\n        };\n        this.getOrCreate = (channelGetOrCreateRequest) => __awaiter(this, void 0, void 0, function* () {\n            if (this.id) {\n                return yield this.channelsApi.getOrCreateChannel(Object.assign(Object.assign({}, this.baseRequest), { channelGetOrCreateRequest: channelGetOrCreateRequest !== null && channelGetOrCreateRequest !== void 0 ? channelGetOrCreateRequest : {} }));\n            }\n            else {\n                throw new Error(`This operation isn't yet implemented`);\n                // if (!channelGetOrCreateRequest?.data?.members) {\n                //   throw new Error('You need to provide members to create a channel without ID');\n                // }\n                // const response = await this.channelsApi.getOrCreateChannelType1({type: this.type, channelGetOrCreateRequest});\n                // this.id = response.channel?.id;\n                // return response;\n            }\n        });\n        this.markRead = (markReadRequest) => {\n            return this.channelsApi.markRead(Object.assign(Object.assign({}, this.baseRequest), { markReadRequest }));\n        };\n        this.markUnread = (markUnreadRequest) => {\n            return this.channelsApi.markUnread(Object.assign(Object.assign({}, this.baseRequest), { markUnreadRequest }));\n        };\n        this.show = (showChannelRequest) => {\n            return this.channelsApi.showChannel(Object.assign(Object.assign({}, this.baseRequest), { showChannelRequest }));\n        };\n        this.hide = (hideChannelRequest) => {\n            return this.channelsApi.hideChannel(Object.assign(Object.assign({}, this.baseRequest), { hideChannelRequest }));\n        };\n        this.truncate = (truncateChannelRequest) => {\n            return this.channelsApi.truncateChannel(Object.assign(Object.assign({}, this.baseRequest), { truncateChannelRequest }));\n        };\n        this.queryMembers = (request) => {\n            return this.channelsApi.queryMembers({\n                payload: Object.assign(Object.assign({}, this.baseRequest), request),\n            });\n        };\n        this.mute = (muteChannelRequest) => {\n            return this.channelsApi.muteChannel({\n                muteChannelRequest: Object.assign(Object.assign({}, muteChannelRequest), { channel_cids: [this.cid] }),\n            });\n        };\n        this.unmute = (unmuteChannelRequest) => {\n            return this.channelsApi.unmuteChannel({\n                unmuteChannelRequest: Object.assign(Object.assign({}, unmuteChannelRequest), { channel_cid: this.cid, channel_cids: [] }),\n            });\n        };\n        // TODO: there is probably an issue with the generated code here\n        // uploadFile = (options: Omit<OmitTypeId<UploadFileRequest>, 'file'>, file: Buffer) => {\n        //   return this.messagesApi.uploadFile({...options, ...this.baseRequest, file: file as any as string});\n        // }\n        // deleteFile = (request: OmitTypeId<DeleteFileRequest>) => {\n        //   return this.messagesApi.deleteFile({...request, ...this.baseRequest});\n        // }\n        // uploadImage = (request: OmitTypeId<UploadImageRequest>) => {\n        //   return this.messagesApi.uploadImage({...request, ...this.baseRequest});\n        // }\n        // deleteImage = (request: OmitTypeId<DeleteImageRequest>) => {\n        //   return this.messagesApi.deleteImage({...request, ...this.baseRequest});\n        // }\n        this.sendMessage = (sendMessageRequest) => {\n            return this.messagesApi.sendMessage(Object.assign(Object.assign({}, this.baseRequest), { sendMessageRequest }));\n        };\n        this.deleteMessage = (request) => {\n            return this.messagesApi.deleteMessage(request);\n        };\n        this.updateMessage = (id, updateMessageRequest) => {\n            return this.messagesApi.updateMessage({ id, updateMessageRequest });\n        };\n        this.updateMessagePartial = (id, updateMessagePartialRequest) => {\n            return this.messagesApi.updateMessagePartial({\n                id,\n                updateMessagePartialRequest,\n            });\n        };\n        this.getMessage = (request) => {\n            return this.messagesApi.getMessage(request);\n        };\n        this.getManyMessages = (request) => {\n            return this.messagesApi.getManyMessages(Object.assign(Object.assign({}, request), this.baseRequest));\n        };\n        this.translateMessage = (id, translateMessageRequest) => {\n            return this.messagesApi.translateMessage({ id, translateMessageRequest });\n        };\n        this.getMessagesAround = (request) => {\n            return this.messagesApi.getReplies(request);\n        };\n        this.getOpenGraphData = (request) => {\n            return this.messagesApi.getOG(request);\n        };\n        this.sendMessageReaction = (messageId, sendReactionRequest) => {\n            return this.messagesApi.sendReaction({\n                id: messageId,\n                sendReactionRequest,\n            });\n        };\n        this.deleteMessageReaction = (messageId, request) => {\n            return this.messagesApi.deleteReaction(Object.assign(Object.assign({}, request), { id: messageId }));\n        };\n        this.getMessageReactions = (messageId, request) => {\n            return this.messagesApi.getReactions(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), { id: messageId }));\n        };\n        this.sendCustomEvent = (event) => {\n            return this.eventsApi.sendEvent(Object.assign(Object.assign({}, this.baseRequest), { sendEventRequest: { event } }));\n        };\n        const configuration = this.streamClient.getConfiguration();\n        /** @ts-expect-error */\n        this.channelsApi = new ChannelsApi(configuration);\n        /** @ts-expect-error */\n        this.messagesApi = new MessagesApi(configuration);\n        /** @ts-expect-error */\n        this.eventsApi = new EventsApi(configuration);\n    }\n    get cid() {\n        return `${this.baseRequest.type}:${this.baseRequest.id}`;\n    }\n    get baseRequest() {\n        if (!this.id) {\n            throw new Error('You need to initialize the channel with `getOrCreate`');\n        }\n        return {\n            id: this.id,\n            type: this.type,\n        };\n    }\n}\n\nclass StreamChatClient {\n    constructor(streamClient) {\n        this.streamClient = streamClient;\n        this.channel = (type, id) => {\n            return new StreamChannel(this.streamClient, type, id);\n        };\n        this.createBlockList = (createBlockListRequest) => {\n            return this.settingsApi.createBlockList({ createBlockListRequest });\n        };\n        this.listBlockLists = () => {\n            return this.settingsApi.listBlockLists();\n        };\n        this.getBlockList = (request) => {\n            return this.settingsApi.getBlockList(request);\n        };\n        this.updateBlockList = (name, updateBlockListRequest) => {\n            return this.settingsApi.updateBlockList({ name, updateBlockListRequest });\n        };\n        this.deleteBlockList = (request) => {\n            return this.settingsApi.deleteBlockList(request);\n        };\n        this.createChannelType = (createChannelTypeRequest) => {\n            return this.channelTypesApi.createChannelType({ createChannelTypeRequest });\n        };\n        this.deleteChannelType = (request) => {\n            return this.channelTypesApi.deleteChannelType(request);\n        };\n        this.getChannelType = (request) => {\n            return this.channelTypesApi.getChannelType(request);\n        };\n        this.listChannelTypes = () => {\n            return this.channelTypesApi.listChannelTypes();\n        };\n        this.updateChannelType = (name, updateChannelTypeRequest) => {\n            return this.channelTypesApi.updateChannelType({\n                name,\n                updateChannelTypeRequest,\n            });\n        };\n        this.queryChannels = (queryChannelsRequest) => {\n            return this.channelsApi.queryChannels({\n                queryChannelsRequest: queryChannelsRequest !== null && queryChannelsRequest !== void 0 ? queryChannelsRequest : null,\n            });\n        };\n        this.searchMessages = (payload) => {\n            return this.channelsApi.search({ payload });\n        };\n        this.exportChannels = (exportChannelsRequest) => {\n            return this.channelsApi.exportChannels({\n                exportChannelsRequest: exportChannelsRequest !== null && exportChannelsRequest !== void 0 ? exportChannelsRequest : null,\n            });\n        };\n        this.getExportStatus = (request) => {\n            return this.channelsApi.getExportChannelsStatus(request);\n        };\n        this.listCommands = () => {\n            return this.commandsApi.listCommands();\n        };\n        this.createCommand = (createCommandRequest) => {\n            return this.commandsApi.createCommand({ createCommandRequest });\n        };\n        this.getCommand = (getCommandRequest) => {\n            return this.commandsApi.getCommand(getCommandRequest);\n        };\n        this.updateCommand = (name, updateCommandRequest) => {\n            return this.commandsApi.updateCommand({ name, updateCommandRequest });\n        };\n        this.deleteCommand = (request) => {\n            return this.commandsApi.deleteCommand(request);\n        };\n        const configuration = this.streamClient.getConfiguration();\n        /** @ts-expect-error */\n        this.settingsApi = new SettingsApi$1(configuration);\n        /** @ts-expect-error */\n        this.channelTypesApi = new ChannelTypesApi(configuration);\n        /** @ts-expect-error */\n        this.channelsApi = new ChannelsApi(configuration);\n        /** @ts-expect-error */\n        this.commandsApi = new CustomCommandsApi(configuration);\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nconst BASE_PATH = \"https://stream-io-api.com\".replace(/\\/+$/, \"\");\nclass Configuration {\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n    }\n    set config(configuration) {\n        this.configuration = configuration;\n    }\n    get basePath() {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;\n    }\n    get fetchApi() {\n        return this.configuration.fetchApi;\n    }\n    get middleware() {\n        return this.configuration.middleware || [];\n    }\n    get queryParamsStringify() {\n        return this.configuration.queryParamsStringify || querystring;\n    }\n    get username() {\n        return this.configuration.username;\n    }\n    get password() {\n        return this.configuration.password;\n    }\n    get apiKey() {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n    get accessToken() {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });\n        }\n        return undefined;\n    }\n    get headers() {\n        return this.configuration.headers;\n    }\n    get credentials() {\n        return this.configuration.credentials;\n    }\n}\nconst DefaultConfig = new Configuration();\n/**\n * This is the base class for all generated API classes.\n */\nclass BaseAPI {\n    constructor(configuration = DefaultConfig) {\n        this.configuration = configuration;\n        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {\n            let fetchParams = { url, init };\n            for (const middleware of this.middleware) {\n                if (middleware.pre) {\n                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;\n                }\n            }\n            let response = undefined;\n            try {\n                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n            }\n            catch (e) {\n                for (const middleware of this.middleware) {\n                    if (middleware.onError) {\n                        response = (yield middleware.onError({\n                            fetch: this.fetchApi,\n                            url: fetchParams.url,\n                            init: fetchParams.init,\n                            error: e,\n                            response: response ? response.clone() : undefined,\n                        })) || response;\n                    }\n                }\n                if (response === undefined) {\n                    if (e instanceof Error) {\n                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            for (const middleware of this.middleware) {\n                if (middleware.post) {\n                    response = (yield middleware.post({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        response: response.clone(),\n                    })) || response;\n                }\n            }\n            return response;\n        });\n        this.middleware = configuration.middleware;\n    }\n    withMiddleware(...middlewares) {\n        const next = this.clone();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n    withPreMiddleware(...preMiddlewares) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware(...middlewares);\n    }\n    withPostMiddleware(...postMiddlewares) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware(...middlewares);\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        if (!mime) {\n            return false;\n        }\n        return BaseAPI.jsonRegex.test(mime);\n    }\n    request(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { url, init } = yield this.createFetchParams(context, initOverrides);\n            const response = yield this.fetchApi(url, init);\n            if (response && (response.status >= 200 && response.status < 300)) {\n                return response;\n            }\n            throw new ResponseError(response, 'Response returned an error code');\n        });\n    }\n    createFetchParams(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.configuration.basePath + context.path;\n            if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n                // only add the querystring to the URL if there are query parameters.\n                // this is done to avoid urls ending with a \"?\" character which buggy webservers\n                // do not handle correctly sometimes.\n                url += '?' + this.configuration.queryParamsStringify(context.query);\n            }\n            const headers = Object.assign({}, this.configuration.headers, context.headers);\n            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n            const initOverrideFn = typeof initOverrides === \"function\"\n                ? initOverrides\n                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });\n            const initParams = {\n                method: context.method,\n                headers,\n                body: context.body,\n                credentials: this.configuration.credentials,\n            };\n            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({\n                init: initParams,\n                context,\n            })));\n            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData(overriddenInit.body) ||\n                    overriddenInit.body instanceof URLSearchParams ||\n                    isBlob(overriddenInit.body)\n                    ? overriddenInit.body\n                    : JSON.stringify(overriddenInit.body) });\n            return { url, init };\n        });\n    }\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    clone() {\n        const constructor = this.constructor;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n}\nBaseAPI.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');\nfunction isBlob(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData(value) {\n    return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nclass ResponseError extends Error {\n    constructor(response, msg) {\n        super(msg);\n        this.response = response;\n        this.name = \"ResponseError\";\n    }\n}\nclass FetchError extends Error {\n    constructor(cause, msg) {\n        super(msg);\n        this.cause = cause;\n        this.name = \"FetchError\";\n    }\n}\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nfunction querystring(params, prefix = '') {\n    return Object.keys(params)\n        .map(key => querystringSingleKey(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\nfunction querystringSingleKey(key, value, keyPrefix = '') {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring(value, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nclass JSONApiResponse {\n    constructor(raw, transformer = (jsonValue) => jsonValue) {\n        this.raw = raw;\n        this.transformer = transformer;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.transformer(yield this.raw.json());\n        });\n    }\n}\nclass VoidApiResponse {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return undefined;\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass DefaultApi extends BaseAPI {\n    /**\n     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser\n     * Block user on a call\n     */\n    blockUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling blockUser.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling blockUser.');\n            }\n            if (requestParameters.videoBlockUserRequest === null || requestParameters.videoBlockUserRequest === undefined) {\n                throw new RequiredError('videoBlockUserRequest', 'Required parameter requestParameters.videoBlockUserRequest was null or undefined when calling blockUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/block`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoBlockUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser\n     * Block user on a call\n     */\n    blockUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.blockUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateDeviceRequest === null || requestParameters.videoCreateDeviceRequest === undefined) {\n                throw new RequiredError('videoCreateDeviceRequest', 'Required parameter requestParameters.videoCreateDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateDeviceRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Create Guest\n     */\n    createGuestRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateGuestRequest === null || requestParameters.videoCreateGuestRequest === undefined) {\n                throw new RequiredError('videoCreateGuestRequest', 'Required parameter requestParameters.videoCreateGuestRequest was null or undefined when calling createGuest.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/guest`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateGuestRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Create Guest\n     */\n    createGuest(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createGuestRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDevice(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.ended  Required permissions: - EndCall\n     * End call\n     */\n    endCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling endCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling endCall.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/mark_ended`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.ended  Required permissions: - EndCall\n     * End call\n     */\n    endCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.endCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Required permissions: - ReadCall\n     * Get Call\n     */\n    getCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getCall.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            if (requestParameters.membersLimit !== undefined) {\n                queryParameters['members_limit'] = requestParameters.membersLimit;\n            }\n            if (requestParameters.ring !== undefined) {\n                queryParameters['ring'] = requestParameters.ring;\n            }\n            if (requestParameters.notify !== undefined) {\n                queryParameters['notify'] = requestParameters.notify;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Required permissions: - ReadCall\n     * Get Call\n     */\n    getCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns the list of all edges available for video calls.\n     * Get Edges\n     */\n    getEdgesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/edges`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Returns the list of all edges available for video calls.\n     * Get Edges\n     */\n    getEdges(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getEdgesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings\n     * Get or create a call\n     */\n    getOrCreateCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateCall.');\n            }\n            if (requestParameters.videoGetOrCreateCallRequest === null || requestParameters.videoGetOrCreateCallRequest === undefined) {\n                throw new RequiredError('videoGetOrCreateCallRequest', 'Required parameter requestParameters.videoGetOrCreateCallRequest was null or undefined when calling getOrCreateCall.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoGetOrCreateCallRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings\n     * Get or create a call\n     */\n    getOrCreateCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOrCreateCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.live_started  Required permissions: - UpdateCall\n     * Set call as live\n     */\n    goLiveRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling goLive.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling goLive.');\n            }\n            if (requestParameters.videoGoLiveRequest === null || requestParameters.videoGoLiveRequest === undefined) {\n                throw new RequiredError('videoGoLiveRequest', 'Required parameter requestParameters.videoGoLiveRequest was null or undefined when calling goLive.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/go_live`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoGoLiveRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.live_started  Required permissions: - UpdateCall\n     * Set call as live\n     */\n    goLive(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.goLiveRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevicesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevices(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listDevicesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists recordings  Required permissions: - ListRecordings\n     * List recordings\n     */\n    listRecordingsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listRecordings.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listRecordings.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/recordings`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists recordings  Required permissions: - ListRecordings\n     * List recordings\n     */\n    listRecordings(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listRecordingsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists transcriptions  Required permissions: - ListTranscriptions\n     * List transcriptions\n     */\n    listTranscriptionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listTranscriptions.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listTranscriptions.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/transcriptions`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists transcriptions  Required permissions: - ListTranscriptions\n     * List transcriptions\n     */\n    listTranscriptions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listTranscriptionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Mutes users in a call  Required permissions: - MuteUsers\n     * Mute users\n     */\n    muteUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling muteUsers.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling muteUsers.');\n            }\n            if (requestParameters.videoMuteUsersRequest === null || requestParameters.videoMuteUsersRequest === undefined) {\n                throw new RequiredError('videoMuteUsersRequest', 'Required parameter requestParameters.videoMuteUsersRequest was null or undefined when calling muteUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/mute_users`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoMuteUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Mutes users in a call  Required permissions: - MuteUsers\n     * Mute users\n     */\n    muteUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query calls with filter query  Required permissions: - ReadCall\n     * Query call\n     */\n    queryCallsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoQueryCallsRequest === null || requestParameters.videoQueryCallsRequest === undefined) {\n                throw new RequiredError('videoQueryCallsRequest', 'Required parameter requestParameters.videoQueryCallsRequest was null or undefined when calling queryCalls.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calls`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoQueryCallsRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Query calls with filter query  Required permissions: - ReadCall\n     * Query call\n     */\n    queryCalls(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryCallsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query call members with filter query  Required permissions: - ReadCall\n     * Query call members\n     */\n    queryMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoQueryMembersRequest === null || requestParameters.videoQueryMembersRequest === undefined) {\n                throw new RequiredError('videoQueryMembersRequest', 'Required parameter requestParameters.videoQueryMembersRequest was null or undefined when calling queryMembers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/members`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoQueryMembersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Query call members with filter query  Required permissions: - ReadCall\n     * Query call members\n     */\n    queryMembers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent\n     * Send custom event\n     */\n    sendEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.videoSendEventRequest === null || requestParameters.videoSendEventRequest === undefined) {\n                throw new RequiredError('videoSendEventRequest', 'Required parameter requestParameters.videoSendEventRequest was null or undefined when calling sendEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/event`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoSendEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent\n     * Send custom event\n     */\n    sendEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts HLS broadcasting  Required permissions: - StartBroadcasting\n     * Start HLS broadcasting\n     */\n    startHLSBroadcastingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startHLSBroadcasting.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startHLSBroadcasting.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_broadcasting`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts HLS broadcasting  Required permissions: - StartBroadcasting\n     * Start HLS broadcasting\n     */\n    startHLSBroadcasting(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startHLSBroadcastingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording\n     * Start recording\n     */\n    startRecordingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startRecording.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startRecording.');\n            }\n            if (requestParameters.videoStartRecordingRequest === null || requestParameters.videoStartRecordingRequest === undefined) {\n                throw new RequiredError('videoStartRecordingRequest', 'Required parameter requestParameters.videoStartRecordingRequest was null or undefined when calling startRecording.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_recording`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoStartRecordingRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording\n     * Start recording\n     */\n    startRecording(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startRecordingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts transcription  Required permissions: - StartTranscription\n     * Start transcription\n     */\n    startTranscriptionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startTranscription.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startTranscription.');\n            }\n            if (requestParameters.videoStartTranscriptionRequest === null || requestParameters.videoStartTranscriptionRequest === undefined) {\n                throw new RequiredError('videoStartTranscriptionRequest', 'Required parameter requestParameters.videoStartTranscriptionRequest was null or undefined when calling startTranscription.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_transcription`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoStartTranscriptionRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts transcription  Required permissions: - StartTranscription\n     * Start transcription\n     */\n    startTranscription(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startTranscriptionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops HLS broadcasting  Required permissions: - StopBroadcasting\n     * Stop HLS broadcasting\n     */\n    stopHLSBroadcastingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopHLSBroadcasting.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopHLSBroadcasting.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_broadcasting`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops HLS broadcasting  Required permissions: - StopBroadcasting\n     * Stop HLS broadcasting\n     */\n    stopHLSBroadcasting(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopHLSBroadcastingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Set call as not live\n     */\n    stopLiveRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopLive.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopLive.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_live`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Set call as not live\n     */\n    stopLive(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopLiveRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording\n     * Stop recording\n     */\n    stopRecordingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopRecording.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopRecording.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_recording`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording\n     * Stop recording\n     */\n    stopRecording(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopRecordingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription\n     * Stop transcription\n     */\n    stopTranscriptionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopTranscription.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopTranscription.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_transcription`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription\n     * Stop transcription\n     */\n    stopTranscription(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopTranscriptionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser\n     * Unblocks user on a call\n     */\n    unblockUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling unblockUser.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling unblockUser.');\n            }\n            if (requestParameters.videoUnblockUserRequest === null || requestParameters.videoUnblockUserRequest === undefined) {\n                throw new RequiredError('videoUnblockUserRequest', 'Required parameter requestParameters.videoUnblockUserRequest was null or undefined when calling unblockUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/unblock`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUnblockUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser\n     * Unblocks user on a call\n     */\n    unblockUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unblockUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Update Call\n     */\n    updateCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCall.');\n            }\n            if (requestParameters.videoUpdateCallRequest === null || requestParameters.videoUpdateCallRequest === undefined) {\n                throw new RequiredError('videoUpdateCallRequest', 'Required parameter requestParameters.videoUpdateCallRequest was null or undefined when calling updateCall.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Update Call\n     */\n    updateCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole\n     * Update Call Member\n     */\n    updateCallMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCallMembers.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCallMembers.');\n            }\n            if (requestParameters.videoUpdateCallMembersRequest === null || requestParameters.videoUpdateCallMembersRequest === undefined) {\n                throw new RequiredError('videoUpdateCallMembersRequest', 'Required parameter requestParameters.videoUpdateCallMembersRequest was null or undefined when calling updateCallMembers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/members`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallMembersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole\n     * Update Call Member\n     */\n    updateCallMembers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions\n     * Update user permissions\n     */\n    updateUserPermissionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateUserPermissions.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateUserPermissions.');\n            }\n            if (requestParameters.videoUpdateUserPermissionsRequest === null || requestParameters.videoUpdateUserPermissionsRequest === undefined) {\n                throw new RequiredError('videoUpdateUserPermissionsRequest', 'Required parameter requestParameters.videoUpdateUserPermissionsRequest was null or undefined when calling updateUserPermissions.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/user_permissions`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateUserPermissionsRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions\n     * Update user permissions\n     */\n    updateUserPermissions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUserPermissionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check\n     * Video Connect (WebSocket)\n     */\n    videoConnectRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoWSAuthMessageRequest === null || requestParameters.videoWSAuthMessageRequest === undefined) {\n                throw new RequiredError('videoWSAuthMessageRequest', 'Required parameter requestParameters.videoWSAuthMessageRequest was null or undefined when calling videoConnect.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/connect`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoWSAuthMessageRequest,\n            }, initOverrides);\n            return new VoidApiResponse(response);\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check\n     * Video Connect (WebSocket)\n     */\n    videoConnect(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.videoConnectRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Pins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Pin\n     */\n    videoPinRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoPin.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoPin.');\n            }\n            if (requestParameters.videoPinRequest === null || requestParameters.videoPinRequest === undefined) {\n                throw new RequiredError('videoPinRequest', 'Required parameter requestParameters.videoPinRequest was null or undefined when calling videoPin.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/pin`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoPinRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Pins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Pin\n     */\n    videoPin(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.videoPinRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Unpin\n     */\n    videoUnpinRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoUnpin.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoUnpin.');\n            }\n            if (requestParameters.videoUnpinRequest === null || requestParameters.videoUnpinRequest === undefined) {\n                throw new RequiredError('videoUnpinRequest', 'Required parameter requestParameters.videoUnpinRequest was null or undefined when calling videoUnpin.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/unpin`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUnpinRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Unpin\n     */\n    videoUnpin(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.videoUnpinRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ServerSideApi extends BaseAPI {\n    /**\n     *\n     * Check External Storage\n     */\n    checkExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}/check`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Check External Storage\n     */\n    checkExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Create Call Type\n     */\n    createCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateCallTypeRequest === null || requestParameters.videoCreateCallTypeRequest === undefined) {\n                throw new RequiredError('videoCreateCallTypeRequest', 'Required parameter requestParameters.videoCreateCallTypeRequest was null or undefined when calling createCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateCallTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Create Call Type\n     */\n    createCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Delete Call Type\n     */\n    deleteCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Delete Call Type\n     */\n    deleteCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Get Call Type\n     */\n    getCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Get Call Type\n     */\n    getCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * List Call Type\n     */\n    listCallTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * List Call Type\n     */\n    listCallTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listCallTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Update Call Type\n     */\n    updateCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateCallType.');\n            }\n            if (requestParameters.videoUpdateCallTypeRequest === null || requestParameters.videoUpdateCallTypeRequest === undefined) {\n                throw new RequiredError('videoUpdateCallTypeRequest', 'Required parameter requestParameters.videoUpdateCallTypeRequest was null or undefined when calling updateCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Update Call Type\n     */\n    updateCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Update External Storage\n     */\n    updateExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');\n            }\n            if (requestParameters.videoUpdateExternalStorageRequest === null || requestParameters.videoUpdateExternalStorageRequest === undefined) {\n                throw new RequiredError('videoUpdateExternalStorageRequest', 'Required parameter requestParameters.videoUpdateExternalStorageRequest was null or undefined when calling updateExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateExternalStorageRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Update External Storage\n     */\n    updateExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass SettingsApi extends BaseAPI {\n    /**\n     * Creates new external storage\n     * Create external storage\n     */\n    createExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateExternalStorageRequest === null || requestParameters.videoCreateExternalStorageRequest === undefined) {\n                throw new RequiredError('videoCreateExternalStorageRequest', 'Required parameter requestParameters.videoCreateExternalStorageRequest was null or undefined when calling createExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateExternalStorageRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Creates new external storage\n     * Create external storage\n     */\n    createExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes external storage\n     * Delete external storage\n     */\n    deleteExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Deletes external storage\n     * Delete external storage\n     */\n    deleteExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists external storage\n     * List external storage\n     */\n    listExternalStorageRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists external storage\n     * List external storage\n     */\n    listExternalStorage(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listExternalStorageRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\nclass StreamCall {\n    constructor(streamClient, type, id) {\n        this.streamClient = streamClient;\n        this.type = type;\n        this.id = id;\n        this.blockUser = (videoBlockUserRequest) => {\n            return this.apiClient.blockUser(Object.assign(Object.assign({}, this.baseRequest), { videoBlockUserRequest }));\n        };\n        this.endCall = () => {\n            return this.apiClient.endCall(Object.assign({}, this.baseRequest));\n        };\n        this.get = (request) => {\n            return this.apiClient.getCall(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest));\n        };\n        this.getOrCreate = (videoGetOrCreateCallRequest) => {\n            return this.apiClient.getOrCreateCall(Object.assign(Object.assign({}, this.baseRequest), { videoGetOrCreateCallRequest: videoGetOrCreateCallRequest !== null && videoGetOrCreateCallRequest !== void 0 ? videoGetOrCreateCallRequest : {} }));\n        };\n        this.create = (getOrCreateCallRequest) => {\n            return this.getOrCreate(getOrCreateCallRequest);\n        };\n        this.goLive = (videoGoLiveRequest) => {\n            return this.apiClient.goLive(Object.assign(Object.assign({}, this.baseRequest), { videoGoLiveRequest: videoGoLiveRequest !== null && videoGoLiveRequest !== void 0 ? videoGoLiveRequest : {} }));\n        };\n        this.listRecordings = () => {\n            return this.apiClient.listRecordings(Object.assign({}, this.baseRequest));\n        };\n        this.muteUsers = (videoMuteUsersRequest) => {\n            return this.apiClient.muteUsers(Object.assign(Object.assign({}, this.baseRequest), { videoMuteUsersRequest }));\n        };\n        this.queryMembers = (request) => {\n            return this.apiClient.queryMembers({\n                videoQueryMembersRequest: Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest),\n            });\n        };\n        this.sendCustomEvent = (event) => {\n            return this.apiClient.sendEvent(Object.assign({ videoSendEventRequest: { custom: event } }, this.baseRequest));\n        };\n        this.startHLSBroadcasting = () => {\n            return this.apiClient.startHLSBroadcasting(Object.assign({}, this.baseRequest));\n        };\n        this.startRecording = (request) => {\n            return this.apiClient.startRecording(Object.assign(Object.assign({}, this.baseRequest), { videoStartRecordingRequest: request !== null && request !== void 0 ? request : {} }));\n        };\n        this.startTranscription = (videoStartTranscriptionRequest = {}) => {\n            return this.apiClient.startTranscription(Object.assign(Object.assign({}, this.baseRequest), { videoStartTranscriptionRequest }));\n        };\n        this.stopHLSBroadcasting = () => {\n            return this.apiClient.stopHLSBroadcasting(Object.assign({}, this.baseRequest));\n        };\n        this.stopLive = () => {\n            return this.apiClient.stopLive(Object.assign({}, this.baseRequest));\n        };\n        this.stopRecording = () => {\n            return this.apiClient.stopRecording(Object.assign({}, this.baseRequest));\n        };\n        this.stopTranscription = () => {\n            return this.apiClient.stopTranscription(Object.assign({}, this.baseRequest));\n        };\n        this.unblockUser = (videoUnblockUserRequest) => {\n            return this.apiClient.unblockUser(Object.assign({ videoUnblockUserRequest }, this.baseRequest));\n        };\n        this.update = (videoUpdateCallRequest) => {\n            return this.apiClient.updateCall(Object.assign({ videoUpdateCallRequest }, this.baseRequest));\n        };\n        this.updateCallMembers = (videoUpdateCallMembersRequest) => {\n            return this.apiClient.updateCallMembers(Object.assign({ videoUpdateCallMembersRequest }, this.baseRequest));\n        };\n        this.updateUserPermissions = (videoUpdateUserPermissionsRequest) => {\n            return this.apiClient.updateUserPermissions(Object.assign({ videoUpdateUserPermissionsRequest }, this.baseRequest));\n        };\n        this.pinVideo = (videoPinRequest) => {\n            return this.apiClient.videoPin(Object.assign({ videoPinRequest }, this.baseRequest));\n        };\n        this.unpinVideo = (videoUnpinRequest) => {\n            return this.apiClient.videoUnpin(Object.assign({ videoUnpinRequest }, this.baseRequest));\n        };\n        this.baseRequest = { id: this.id, type: this.type };\n        const configuration = this.streamClient.getConfiguration('video');\n        this.apiClient = new DefaultApi(configuration);\n    }\n}\n\nclass StreamVideoClient {\n    constructor(streamClient) {\n        this.streamClient = streamClient;\n        this.call = (type, id) => {\n            return new StreamCall(this.streamClient, type, id);\n        };\n        this.queryCalls = (request) => {\n            return this.apiClient.queryCalls({\n                videoQueryCallsRequest: request !== null && request !== void 0 ? request : {},\n            });\n        };\n        this.createCallType = (videoCreateCallTypeRequest) => {\n            return this.videoServerSideApiClient.createCallType({\n                videoCreateCallTypeRequest,\n            });\n        };\n        this.deleteCallType = (request) => {\n            return this.videoServerSideApiClient.deleteCallType(request);\n        };\n        this.getCallType = (request) => {\n            return this.videoServerSideApiClient.getCallType(request);\n        };\n        this.listCallTypes = () => {\n            return this.videoServerSideApiClient.listCallTypes();\n        };\n        this.updateCallType = (name, videoUpdateCallTypeRequest) => {\n            return this.videoServerSideApiClient.updateCallType({\n                name,\n                videoUpdateCallTypeRequest,\n            });\n        };\n        this.listExternalStorages = () => {\n            return this.settingsApi.listExternalStorage();\n        };\n        this.createExternalStorage = (videoCreateExternalStorageRequest) => {\n            return this.settingsApi.createExternalStorage({\n                videoCreateExternalStorageRequest,\n            });\n        };\n        this.deleteExternalStorage = (request) => {\n            return this.settingsApi.deleteExternalStorage(request);\n        };\n        this.updateExternalStorage = (name, videoUpdateExternalStorageRequest) => {\n            return this.videoServerSideApiClient.updateExternalStorage({\n                name,\n                videoUpdateExternalStorageRequest,\n            });\n        };\n        this.checkExternalStorage = (request) => {\n            return this.videoServerSideApiClient.checkExternalStorage(request);\n        };\n        const configuration = this.streamClient.getConfiguration('video');\n        this.apiClient = new DefaultApi(configuration);\n        this.settingsApi = new SettingsApi(configuration);\n        this.videoServerSideApiClient = new ServerSideApi(configuration);\n    }\n}\n\nfunction JWTUserToken(apiSecret, userId, extraData = {}, jwtOptions = {}) {\n    if (typeof userId !== 'string') {\n        throw new TypeError('userId should be a string');\n    }\n    const payload = Object.assign({ user_id: userId }, extraData);\n    // make sure we return a clear error when jwt is shimmed (ie. browser build)\n    if ((jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default()) == null || (jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign) == null) {\n        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);\n    }\n    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);\n    if (payload.iat) {\n        opts.noTimestamp = false;\n    }\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, apiSecret, opts);\n}\nfunction JWTServerToken(apiSecret, jwtOptions = {}) {\n    const payload = {\n        server: true,\n    };\n    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, apiSecret, opts);\n}\n\nclass StreamClient {\n    /**\n     *\n     * @param apiKey\n     * @param secret\n     * @param config can be a string, which will be interpreted as base path (deprecated), or a config object\n     */\n    constructor(apiKey, secret, config) {\n        var _a;\n        this.apiKey = apiKey;\n        this.secret = secret;\n        this.config = config;\n        this.options = {};\n        this.createDevice = (createDeviceRequest) => {\n            return this.devicesApi.createDevice({ createDeviceRequest });\n        };\n        this.deleteDevice = (requestParameters) => {\n            return this.devicesApi.deleteDevice(requestParameters);\n        };\n        this.listDevices = (requestParameters) => {\n            return this.devicesApi.listDevices(requestParameters);\n        };\n        this.listPushProviders = () => {\n            return this.pushApi.listPushProviders();\n        };\n        this.deletePushProvider = (request) => {\n            return this.pushApi.deletePushProvider(request);\n        };\n        this.upsertPushProvider = (request) => {\n            return this.serversideApi.upsertPushProvider({\n                upsertPushProviderRequest: { push_provider: request },\n            });\n        };\n        this.checkPush = (checkPushRequest) => {\n            return this.testingApi.checkPush({ checkPushRequest });\n        };\n        this.createGuest = (guestRequest) => __awaiter(this, void 0, void 0, function* () {\n            guestRequest.user = this.mapCustomDataBeforeSend(guestRequest.user);\n            const response = yield this.usersApi.createGuest({ guestRequest });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.banUser = (banRequest) => {\n            banRequest.user = this.mapCustomDataBeforeSend(banRequest.user);\n            banRequest.banned_by = this.mapCustomDataBeforeSend(banRequest.banned_by);\n            return this.usersApi.ban({ banRequest });\n        };\n        this.deactivateUser = (deactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.deactivateUser({\n                deactivateUserRequest,\n                userId: deactivateUserRequest.user_id,\n            });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.deactivateUsers = (deactivateUsersRequest) => {\n            return this.usersApi.deactivateUsers({ deactivateUsersRequest });\n        };\n        /**\n         * @deprecated use `deleteUsers` instead\n         * @param deleteUsersRequest\n         * @returns\n         */\n        this.deleteUser = (request) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.deleteUser(request);\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.deleteUsers = (deleteUsersRequest) => {\n            return this.usersApi.deleteUsers({ deleteUsersRequest });\n        };\n        this.exportUser = (request) => {\n            return this.usersApi.exportUser(request);\n        };\n        this.exportUsers = (exportUsersRequest) => {\n            return this.usersApi.exportUsers({ exportUsersRequest });\n        };\n        this.flag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _b, _c;\n            flagRequest.user = this.mapCustomDataBeforeSend(flagRequest.user);\n            const response = yield this.usersApi.flag({ flagRequest });\n            if ((_b = response.flag) === null || _b === void 0 ? void 0 : _b.user) {\n                response.flag.user = this.mapCustomDataAfterReceive((_c = response.flag) === null || _c === void 0 ? void 0 : _c.user);\n            }\n            return response;\n        });\n        this.queryBannedUsers = (payload) => __awaiter(this, void 0, void 0, function* () {\n            payload.user = this.mapCustomDataBeforeSend(payload.user);\n            const response = yield this.usersApi.queryBannedUsers({ payload });\n            response.bans.forEach((b) => {\n                b.banned_by = this.mapCustomDataAfterReceive(b.banned_by);\n                b.user = this.mapCustomDataAfterReceive(b.user);\n            });\n            return response;\n        });\n        this.queryUsers = (payload) => __awaiter(this, void 0, void 0, function* () {\n            payload.user = this.mapCustomDataBeforeSend(payload.user);\n            const response = yield this.usersApi.queryUsers({ payload });\n            /** @ts-expect-error */\n            response.users = response.users.map((u) => this.mapCustomDataAfterReceive(u));\n            return response;\n        });\n        this.reactivateUser = (reactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.reactivateUser({\n                reactivateUserRequest,\n                userId: reactivateUserRequest.user_id,\n            });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n        });\n        this.reactivateUsers = (reactivateUsersRequest) => {\n            return this.usersApi.reactivateUsers({ reactivateUsersRequest });\n        };\n        this.restoreUsers = (restoreUsersRequest) => {\n            return this.usersApi.restoreUsers({ restoreUsersRequest });\n        };\n        this.unbanUser = (request) => {\n            return this.usersApi.unban(request);\n        };\n        this.unflag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _d;\n            const response = yield this.usersApi.unflag({ flagRequest });\n            if ((_d = response.flag) === null || _d === void 0 ? void 0 : _d.user) {\n                response.flag.user = this.mapCustomDataAfterReceive(response.flag.user);\n            }\n            return response;\n        });\n        this.upsertUsers = (updateUsersRequest) => __awaiter(this, void 0, void 0, function* () {\n            Object.keys(updateUsersRequest.users).forEach((key) => {\n                updateUsersRequest.users[key] = this.mapCustomDataBeforeSend(updateUsersRequest.users[key]);\n            });\n            const response = yield this.usersApi.updateUsers({ updateUsersRequest });\n            Object.keys(response.users).forEach((key) => {\n                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);\n            });\n            return response;\n        });\n        this.updateUsersPartial = (request) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.updateUsersPartial({\n                /** @ts-expect-error */\n                updateUserPartialRequest: request,\n            });\n            Object.keys(response.users).forEach((key) => {\n                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);\n            });\n            return response;\n        });\n        this.muteUser = (muteUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _e, _f;\n            muteUserRequest.user = this.mapCustomDataBeforeSend(muteUserRequest.user);\n            const response = yield this.usersApi.muteUser({ muteUserRequest });\n            if ((_e = response.mute) === null || _e === void 0 ? void 0 : _e.user) {\n                response.mute.user = this.mapCustomDataAfterReceive((_f = response.mute) === null || _f === void 0 ? void 0 : _f.user);\n            }\n            if (response.mutes) {\n                response.mutes = response.mutes.map((m) => {\n                    return Object.assign(Object.assign({}, m), { user: this.mapCustomDataAfterReceive(m.user) });\n                });\n            }\n            return response;\n        });\n        this.unmuteUser = (unmuteUserRequest) => {\n            unmuteUserRequest.user = this.mapCustomDataBeforeSend(unmuteUserRequest.user);\n            return this.usersApi.unmuteUser({ unmuteUserRequest });\n        };\n        this.sendCustomEventToUser = (userId, event) => {\n            return this.eventsApi.sendUserCustomEvent({\n                userId,\n                sendUserCustomEventRequest: { event },\n            });\n        };\n        this.createRole = (createRoleRequest) => {\n            return this.permissionsApi.createRole({ createRoleRequest });\n        };\n        this.deleteRole = (request) => {\n            return this.permissionsApi.deleteRole(request);\n        };\n        this.getPermission = (request) => {\n            return this.permissionsApi.getPermission(request);\n        };\n        this.listPermissions = () => {\n            return this.permissionsApi.listPermissions();\n        };\n        this.listRoles = () => {\n            return this.permissionsApi.listRoles();\n        };\n        this.getAppSettings = () => {\n            return this.settingsApi.getApp();\n        };\n        this.updateAppSettings = (updateAppRequest) => {\n            return this.settingsApi.updateApp({ updateAppRequest });\n        };\n        this.getRateLimits = () => {\n            return this.settingsApi.getRateLimits();\n        };\n        this.getTaskStatus = (request) => {\n            return this.tasksApi.getTask(request);\n        };\n        this.verifyWebhook = (requestBody, xSignature) => {\n            const key = Buffer.from(this.secret, 'utf8');\n            const hash = crypto__WEBPACK_IMPORTED_MODULE_1___default().createHmac('sha256', key)\n                .update(requestBody)\n                .digest('hex');\n            try {\n                return crypto__WEBPACK_IMPORTED_MODULE_1___default().timingSafeEqual(Buffer.from(hash), Buffer.from(xSignature));\n            }\n            catch (err) {\n                return false;\n            }\n        };\n        this.getConfiguration = (product = 'chat') => {\n            var _a;\n            return new Configuration({\n                apiKey: (name) => {\n                    const mapping = {\n                        'Stream-Auth-Type': 'jwt',\n                        api_key: this.apiKey,\n                        Authorization: this.token,\n                    };\n                    return mapping[name];\n                },\n                basePath: (_a = this.options.basePath) !== null && _a !== void 0 ? _a : (product === 'chat'\n                    ? 'https://chat.stream-io-api.com'\n                    : 'https://video.stream-io-api.com'),\n                headers: {\n                    'X-Stream-Client': 'stream-node-' + \"0.1.12\",\n                },\n                middleware: [\n                    {\n                        pre: (context) => {\n                            context.init.headers = Object.assign(Object.assign({}, context.init.headers), { 'x-client-request-id': (0,uuid__WEBPACK_IMPORTED_MODULE_2__.v4)(), 'Accept-Encoding': 'gzip' });\n                            return Promise.resolve(context);\n                        },\n                    },\n                    {\n                        // This should be the last post middleware because that will throw an error\n                        // The Fetch API won't throw an error for HTTP error responses, which means the \"onError\" middleware won't be called so we need to throw error from \"post\" middleware\n                        post: (context) => __awaiter(this, void 0, void 0, function* () {\n                            if ((context.response && context.response.status < 200) ||\n                                context.response.status >= 300) {\n                                const response = new JSONApiResponse(context.response);\n                                const value = (yield response.value());\n                                throw new Error(`Stream error code ${value.code}: ${value.message}`);\n                            }\n                        }),\n                    },\n                    {\n                        pre: (context) => {\n                            context.init.signal = AbortSignal.timeout(this.options.timeout);\n                            return Promise.resolve(context);\n                        },\n                        onError: (context) => {\n                            const error = context.error;\n                            if (error.name === 'AbortError' || error.name === 'TimeoutError') {\n                                throw new FetchError(error, `The request was aborted due to to the ${this.options.timeout}ms timeout, you can set the timeout in the StreamClient constructor`);\n                            }\n                            return Promise.resolve(context.response);\n                        },\n                    },\n                ],\n                // https://github.com/OpenAPITools/openapi-generator/issues/13222\n                queryParamsStringify: (params) => {\n                    const newParams = [];\n                    for (const k in params) {\n                        if (Array.isArray(params[k]) || typeof params[k] === 'object') {\n                            newParams.push(`${k}=${encodeURIComponent(JSON.stringify(params[k]))}`);\n                        }\n                        else {\n                            const value = params[k];\n                            if (typeof value === 'string' ||\n                                typeof value === 'number' ||\n                                typeof value === 'boolean') {\n                                newParams.push(`${k}=${encodeURIComponent(value)}`);\n                            }\n                        }\n                    }\n                    return newParams.join('&');\n                },\n            });\n        };\n        this.reservedKeywords = [\n            'ban_expires',\n            'banned',\n            'id',\n            'invisible',\n            'language',\n            'push_notifications',\n            'revoke_tokens_issued_before',\n            'role',\n            'teams',\n            'created_at',\n            'deactivated_at',\n            'deleted_at',\n            'last_active',\n            'online',\n            'updated_at',\n            'shadow_banned',\n            'name',\n            'image',\n        ];\n        this.mapCustomDataBeforeSend = (user) => {\n            if (!user) {\n                return undefined;\n            }\n            const copy = Object.assign({}, user);\n            delete copy.custom;\n            return Object.assign(Object.assign({}, copy), user.custom);\n        };\n        this.token = JWTServerToken(this.secret);\n        if (typeof config === 'string') {\n            this.options.basePath = config;\n            this.options.timeout = StreamClient.DEFAULT_TIMEOUT;\n        }\n        else {\n            if (config) {\n                this.options = config;\n            }\n            this.options.timeout = (_a = config === null || config === void 0 ? void 0 : config.timeout) !== null && _a !== void 0 ? _a : StreamClient.DEFAULT_TIMEOUT;\n        }\n        this.video = new StreamVideoClient(this);\n        this.chat = new StreamChatClient(this);\n        const chatConfiguration = this.getConfiguration();\n        /** @ts-expect-error */\n        this.usersApi = new UsersApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.devicesApi = new DevicesApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.pushApi = new PushApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.serversideApi = new ServerSideApi$1(chatConfiguration);\n        /** @ts-expect-error */\n        this.testingApi = new TestingApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.permissionsApi = new PermissionsV2Api(chatConfiguration);\n        /** @ts-expect-error */\n        this.settingsApi = new SettingsApi$1(chatConfiguration);\n        /** @ts-expect-error */\n        this.eventsApi = new EventsApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.tasksApi = new TasksApi(chatConfiguration);\n    }\n    /**\n     *\n     * @param userID\n     * @param exp\n     * @param iat deprecated, the default date will be set internally\n     * @param call_cids this parameter is deprecated use `createCallToken` for call tokens\n     * @returns\n     */\n    createToken(userID, exp = Math.round(new Date().getTime() / 1000) + 60 * 60, iat = Math.round(Date.now() / 1000), call_cids) {\n        const extra = {};\n        if (exp) {\n            extra.exp = exp;\n        }\n        if (iat) {\n            extra.iat = iat;\n        }\n        if (call_cids) {\n            console.warn(`Use createCallToken method for creating call tokens, the \"call_cids\" param will be removed from the createToken method with version 0.2.0`);\n            extra.call_cids = call_cids;\n        }\n        return JWTUserToken(this.secret, userID, extra);\n    }\n    /**\n     *\n     * @param userID\n     * @param call_cids\n     * @param exp\n     * @param iat this is deprecated, the current date will be set internally\n     * @returns\n     */\n    createCallToken(userID, call_cids, exp = Math.round(new Date().getTime() / 1000) + 60 * 60, iat = Math.round(Date.now() / 1000)) {\n        const extra = {};\n        if (exp) {\n            extra.exp = exp;\n        }\n        if (iat) {\n            extra.iat = iat;\n        }\n        extra.call_cids = call_cids;\n        return JWTUserToken(this.secret, userID, extra);\n    }\n    mapCustomDataAfterReceive(user) {\n        if (!user) {\n            return undefined;\n        }\n        /** @ts-expect-error */\n        const result = {};\n        Object.keys(user).forEach((key) => {\n            if (!this.reservedKeywords.includes(key)) {\n                if (!result.custom) {\n                    result.custom = {};\n                }\n                result.custom[key] = user[key];\n            }\n            else {\n                result[key] = user[key];\n            }\n        });\n        return result;\n    }\n}\nStreamClient.DEFAULT_TIMEOUT = 3000;\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL25vZGUtc2RrL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNLO0FBQ0g7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxZQUFZLEVBQUUsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0Esa0NBQWtDLEtBQUssRUFBRSxHQUFHLGtCQUFrQixFQUFFLFFBQVEsaUVBQWlFLEVBQUUsTUFBTTtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLCtCQUErQixRQUFRLGtCQUFrQixFQUFFLFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxLQUFLLEVBQUUsR0FBRyxpQkFBaUIsRUFBRSxRQUFRLGlFQUFpRSxFQUFFLE1BQU07QUFDaEo7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxLQUFLLEVBQUUsR0FBRyxrQkFBa0IsRUFBRSxRQUFRLGlFQUFpRSxFQUFFLE1BQU07QUFDako7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxHQUFHLFlBQVksRUFBRSxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRyxXQUFXLEtBQUssWUFBWSxFQUFFLE1BQU0sK0RBQStELEVBQUUsUUFBUTtBQUNsSjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxLQUFLLEVBQUUsR0FBRyxxQkFBcUIsRUFBRSxRQUFRLGlFQUFpRSxFQUFFLE1BQU07QUFDcEo7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxHQUFHLFlBQVksRUFBRSxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxHQUFHLHNCQUFzQixFQUFFLE1BQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxVQUFVLG9CQUFvQixFQUFFLGFBQWE7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxLQUFLLEVBQUUsR0FBRyxpQkFBaUIsRUFBRSxRQUFRLGlFQUFpRSxFQUFFLE1BQU07QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxFQUFFLEdBQUcsbUJBQW1CLEVBQUUsUUFBUSxpRUFBaUUsRUFBRSxNQUFNO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRyxtQkFBbUIsRUFBRSxNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxFQUFFLEdBQUcsb0JBQW9CLEVBQUUsUUFBUSxpRUFBaUUsRUFBRSxNQUFNO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0Esa0NBQWtDLEdBQUcscUJBQXFCLEVBQUUsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtDQUFrQyxHQUFHLHNCQUFzQixFQUFFLE1BQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0Esa0NBQWtDLEdBQUcsWUFBWSxFQUFFLE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRyxZQUFZLEVBQUUsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQkFBa0Isb0NBQW9DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsMkJBQTJCO0FBQzFIO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxFQUFFLEdBQUcsaUJBQWlCLEVBQUUsUUFBUSxpRUFBaUUsRUFBRSxNQUFNO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLGtCQUFrQixvQ0FBb0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRiwyQkFBMkI7QUFDMUg7QUFDQTtBQUNBLGtDQUFrQyxLQUFLLEVBQUUsR0FBRyxrQkFBa0IsRUFBRSxRQUFRLGlFQUFpRSxFQUFFLE1BQU07QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSyxZQUFZLEVBQUUsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0EscUNBQXFDLEdBQUcsWUFBWSxFQUFFLE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFd25GO0FBQ3huRiIsInNvdXJjZXMiOlsid2VicGFjazovL3lvb20vLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby9ub2RlLXNkay9kaXN0L2luZGV4LmVzLmpzPzRjNjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFQTkNvbmZpZ1JlcXVlc3RBdXRoVHlwZUVudW0gPSB7XG4gICAgQ0VSVElGSUNBVEU6ICdjZXJ0aWZpY2F0ZScsXG4gICAgVE9LRU46ICd0b2tlbidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXBwU2VhcmNoQmFja2VuZEVudW0gPSB7XG4gICAgRUxBU1RJQ1NFQVJDSDogJ2VsYXN0aWNzZWFyY2gnLFxuICAgIFBPU1RHUkVTOiAncG9zdGdyZXMnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFzeW5jTW9kZXJhdGlvbkNhbGxiYWNrQ29uZmlnUmVxdWVzdE1vZGVFbnVtID0ge1xuICAgIE5PTkU6ICdDQUxMQkFDS19NT0RFX05PTkUnLFxuICAgIFJFU1Q6ICdDQUxMQkFDS19NT0RFX1JFU1QnLFxuICAgIFRXSVJQOiAnQ0FMTEJBQ0tfTU9ERV9UV0lSUCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXVkaW9TZXR0aW5nc0RlZmF1bHREZXZpY2VFbnVtID0ge1xuICAgIFNQRUFLRVI6ICdzcGVha2VyJyxcbiAgICBFQVJQSUVDRTogJ2VhcnBpZWNlJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBCbG9ja0xpc3RPcHRpb25zQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBCbG9ja0xpc3RPcHRpb25zUmVxdWVzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbENvbmZpZ0F1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbENvbmZpZ0F1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdCbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdSZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9BdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb0F1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb0Jsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvUmVxdWVzdEF1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvUmVxdWVzdEF1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RCbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxNZW1iZXJSb2xlRW51bSA9IHtcbiAgICBNRU1CRVI6ICdtZW1iZXInLFxuICAgIE1PREVSQVRPUjogJ21vZGVyYXRvcicsXG4gICAgQURNSU46ICdhZG1pbicsXG4gICAgT1dORVI6ICdvd25lcidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbE1lbWJlclJlcXVlc3RSb2xlRW51bSA9IHtcbiAgICBNRU1CRVI6ICdtZW1iZXInLFxuICAgIE1PREVSQVRPUjogJ21vZGVyYXRvcicsXG4gICAgQURNSU46ICdhZG1pbicsXG4gICAgT1dORVI6ICdvd25lcidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbFR5cGVDb25maWdBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxUeXBlQ29uZmlnQXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbFR5cGVDb25maWdCbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoZWNrUHVzaFJlcXVlc3RQdXNoUHJvdmlkZXJUeXBlRW51bSA9IHtcbiAgICBGSVJFQkFTRTogJ2ZpcmViYXNlJyxcbiAgICBBUE46ICdhcG4nLFxuICAgIEhVQVdFSTogJ2h1YXdlaScsXG4gICAgWElBT01JOiAneGlhb21pJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGVja1NOU1Jlc3BvbnNlU3RhdHVzRW51bSA9IHtcbiAgICBPSzogJ29rJyxcbiAgICBFUlJPUjogJ2Vycm9yJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGVja1NRU1Jlc3BvbnNlU3RhdHVzRW51bSA9IHtcbiAgICBPSzogJ29rJyxcbiAgICBFUlJPUjogJ2Vycm9yJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDb25maWdEZWZhdWx0Um9sZUVudW0gPSB7XG4gICAgQVRURU5ERUU6ICdhdHRlbmRlZScsXG4gICAgUFVCTElTSEVSOiAncHVibGlzaGVyJyxcbiAgICBTVUJTQ1JJQkVSOiAnc3Vic2NyaWJlcicsXG4gICAgQURNSU46ICdhZG1pbidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29uZmlnUmVxdWVzdERlZmF1bHRSb2xlRW51bSA9IHtcbiAgICBBVFRFTkRFRTogJ2F0dGVuZGVlJyxcbiAgICBQVUJMSVNIRVI6ICdwdWJsaXNoZXInLFxuICAgIFNVQlNDUklCRVI6ICdzdWJzY3JpYmVyJyxcbiAgICBBRE1JTjogJ2FkbWluJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDcmVhdGVDYWxsUmVxdWVzdFR5cGVFbnVtID0ge1xuICAgIEFVRElPOiAnYXVkaW8nLFxuICAgIFZJREVPOiAndmlkZW8nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEF1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDcmVhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDcmVhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0gPSB7XG4gICAgRklSRUJBU0U6ICdmaXJlYmFzZScsXG4gICAgQVBOOiAnYXBuJyxcbiAgICBIVUFXRUk6ICdodWF3ZWknLFxuICAgIFhJQU9NSTogJ3hpYW9taSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlSW1wb3J0UmVxdWVzdE1vZGVFbnVtID0ge1xuICAgIElOU0VSVDogJ2luc2VydCcsXG4gICAgVVBTRVJUOiAndXBzZXJ0J1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZWxldGVVc2Vyc1JlcXVlc3RDb252ZXJzYXRpb25zRW51bSA9IHtcbiAgICBTT0ZUOiAnc29mdCcsXG4gICAgSEFSRDogJ2hhcmQnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IERlbGV0ZVVzZXJzUmVxdWVzdE1lc3NhZ2VzRW51bSA9IHtcbiAgICBTT0ZUOiAnc29mdCcsXG4gICAgUFJVTklORzogJ3BydW5pbmcnLFxuICAgIEhBUkQ6ICdoYXJkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZWxldGVVc2Vyc1JlcXVlc3RVc2VyRW51bSA9IHtcbiAgICBTT0ZUOiAnc29mdCcsXG4gICAgUFJVTklORzogJ3BydW5pbmcnLFxuICAgIEhBUkQ6ICdoYXJkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZXZpY2VQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IERldmljZUZpZWxkc1B1c2hQcm92aWRlckVudW0gPSB7XG4gICAgRklSRUJBU0U6ICdmaXJlYmFzZScsXG4gICAgQVBOOiAnYXBuJyxcbiAgICBIVUFXRUk6ICdodWF3ZWknLFxuICAgIFhJQU9NSTogJ3hpYW9taSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0gPSB7XG4gICAgRklSRUJBU0U6ICdmaXJlYmFzZScsXG4gICAgQVBOOiAnYXBuJyxcbiAgICBIVUFXRUk6ICdodWF3ZWknLFxuICAgIFhJQU9NSTogJ3hpYW9taSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgSW1hZ2VTaXplQ3JvcEVudW0gPSB7XG4gICAgVE9QOiAndG9wJyxcbiAgICBCT1RUT006ICdib3R0b20nLFxuICAgIExFRlQ6ICdsZWZ0JyxcbiAgICBSSUdIVDogJ3JpZ2h0JyxcbiAgICBDRU5URVI6ICdjZW50ZXInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEltYWdlU2l6ZVJlc2l6ZUVudW0gPSB7XG4gICAgQ0xJUDogJ2NsaXAnLFxuICAgIENST1A6ICdjcm9wJyxcbiAgICBTQ0FMRTogJ3NjYWxlJyxcbiAgICBGSUxMOiAnZmlsbCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTGF5b3V0U2V0dGluZ3NOYW1lRW51bSA9IHtcbiAgICBTUE9UTElHSFQ6ICdzcG90bGlnaHQnLFxuICAgIEdSSUQ6ICdncmlkJyxcbiAgICBTSU5HTEVfUEFSVElDSVBBTlQ6ICdzaW5nbGUtcGFydGljaXBhbnQnLFxuICAgIE1PQklMRTogJ21vYmlsZScsXG4gICAgQ1VTVE9NOiAnY3VzdG9tJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBNZXNzYWdlVHlwZUVudW0gPSB7XG4gICAgUkVHVUxBUjogJ3JlZ3VsYXInLFxuICAgIEVQSEVNRVJBTDogJ2VwaGVtZXJhbCcsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgUkVQTFk6ICdyZXBseScsXG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcbiAgICBERUxFVEVEOiAnZGVsZXRlZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWVzc2FnZVJlcXVlc3RUeXBlRW51bSA9IHtcbiAgICBSRUdVTEFSOiAncmVndWxhcicsXG4gICAgRVBIRU1FUkFMOiAnZXBoZW1lcmFsJyxcbiAgICBFUlJPUjogJ2Vycm9yJyxcbiAgICBSRVBMWTogJ3JlcGx5JyxcbiAgICBTWVNURU06ICdzeXN0ZW0nLFxuICAgIERFTEVURUQ6ICdkZWxldGVkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBNZXNzYWdlUmVxdWVzdDFUeXBlRW51bSA9IHtcbiAgICBSRUdVTEFSOiAncmVndWxhcicsXG4gICAgRVBIRU1FUkFMOiAnZXBoZW1lcmFsJyxcbiAgICBFUlJPUjogJ2Vycm9yJyxcbiAgICBSRVBMWTogJ3JlcGx5JyxcbiAgICBTWVNURU06ICdzeXN0ZW0nLFxuICAgIERFTEVURUQ6ICdkZWxldGVkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBQZXJtaXNzaW9uTGV2ZWxFbnVtID0ge1xuICAgIEFQUDogJ2FwcCcsXG4gICAgQ0hBTk5FTDogJ2NoYW5uZWwnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFBvbGljeVJlcXVlc3RBY3Rpb25FbnVtID0ge1xuICAgIERFTlk6ICdEZW55JyxcbiAgICBBTExPVzogJ0FsbG93J1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBQb2xpY3lSZXF1ZXN0MUFjdGlvbkVudW0gPSB7XG4gICAgREVOWTogJ0RlbnknLFxuICAgIEFMTE9XOiAnQWxsb3cnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFB1c2hDb25maWdSZXF1ZXN0VmVyc2lvbkVudW0gPSB7XG4gICAgVjE6ICd2MScsXG4gICAgVjI6ICd2Midcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNjcmlwdGlvblNldHRpbmdzTW9kZUVudW0gPSB7XG4gICAgQVZBSUxBQkxFOiAnYXZhaWxhYmxlJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBBVVRPX09OOiAnYXV0by1vbidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNsYXRlTWVzc2FnZVJlcXVlc3RMYW5ndWFnZUVudW0gPSB7XG4gICAgQUY6ICdhZicsXG4gICAgU1E6ICdzcScsXG4gICAgQU06ICdhbScsXG4gICAgQVI6ICdhcicsXG4gICAgQVo6ICdheicsXG4gICAgQk46ICdibicsXG4gICAgQlM6ICdicycsXG4gICAgQkc6ICdiZycsXG4gICAgWkg6ICd6aCcsXG4gICAgWkhfVFc6ICd6aC1UVycsXG4gICAgSFI6ICdocicsXG4gICAgQ1M6ICdjcycsXG4gICAgREE6ICdkYScsXG4gICAgRkFfQUY6ICdmYS1BRicsXG4gICAgTkw6ICdubCcsXG4gICAgRU46ICdlbicsXG4gICAgRVQ6ICdldCcsXG4gICAgRkk6ICdmaScsXG4gICAgRlI6ICdmcicsXG4gICAgRlJfQ0E6ICdmci1DQScsXG4gICAgS0E6ICdrYScsXG4gICAgREU6ICdkZScsXG4gICAgRUw6ICdlbCcsXG4gICAgSEE6ICdoYScsXG4gICAgSEU6ICdoZScsXG4gICAgSEk6ICdoaScsXG4gICAgSFU6ICdodScsXG4gICAgSUQ6ICdpZCcsXG4gICAgSVQ6ICdpdCcsXG4gICAgSkE6ICdqYScsXG4gICAgS086ICdrbycsXG4gICAgTFY6ICdsdicsXG4gICAgTVM6ICdtcycsXG4gICAgTk86ICdubycsXG4gICAgRkE6ICdmYScsXG4gICAgUFM6ICdwcycsXG4gICAgUEw6ICdwbCcsXG4gICAgUFQ6ICdwdCcsXG4gICAgUk86ICdybycsXG4gICAgUlU6ICdydScsXG4gICAgU1I6ICdzcicsXG4gICAgU0s6ICdzaycsXG4gICAgU0w6ICdzbCcsXG4gICAgU086ICdzbycsXG4gICAgRVM6ICdlcycsXG4gICAgRVNfTVg6ICdlcy1NWCcsXG4gICAgU1c6ICdzdycsXG4gICAgU1Y6ICdzdicsXG4gICAgVEw6ICd0bCcsXG4gICAgVEE6ICd0YScsXG4gICAgVEg6ICd0aCcsXG4gICAgVFI6ICd0cicsXG4gICAgVUs6ICd1aycsXG4gICAgVVI6ICd1cicsXG4gICAgVkk6ICd2aSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQXBwUmVxdWVzdEVuZm9yY2VVbmlxdWVVc2VybmFtZXNFbnVtID0ge1xuICAgIE5POiAnbm8nLFxuICAgIEFQUDogJ2FwcCcsXG4gICAgVEVBTTogJ3RlYW0nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUFwcFJlcXVlc3RQZXJtaXNzaW9uVmVyc2lvbkVudW0gPSB7XG4gICAgVjE6ICd2MScsXG4gICAgVjI6ICd2Midcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQXBwUmVxdWVzdFZpZGVvUHJvdmlkZXJFbnVtID0ge1xuICAgIEFHT1JBOiAnYWdvcmEnLFxuICAgIEhNUzogJ2htcydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlcXVlc3RCbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VBdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1NldHRpbmdzQ2FtZXJhRmFjaW5nRW51bSA9IHtcbiAgICBGUk9OVDogJ2Zyb250JyxcbiAgICBCQUNLOiAnYmFjaycsXG4gICAgRVhURVJOQUw6ICdleHRlcm5hbCdcbn07XG5cbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb0F1ZGlvU2V0dGluZ3NEZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9BdWRpb1NldHRpbmdzUmVxdWVzdERlZmF1bHREZXZpY2VFbnVtID0ge1xuICAgIFNQRUFLRVI6ICdzcGVha2VyJyxcbiAgICBFQVJQSUVDRTogJ2VhcnBpZWNlJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb0NyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvTGF5b3V0U2V0dGluZ3NOYW1lRW51bSA9IHtcbiAgICBTUE9UTElHSFQ6ICdzcG90bGlnaHQnLFxuICAgIEdSSUQ6ICdncmlkJyxcbiAgICBTSU5HTEVfUEFSVElDSVBBTlQ6ICdzaW5nbGUtcGFydGljaXBhbnQnLFxuICAgIE1PQklMRTogJ21vYmlsZScsXG4gICAgQ1VTVE9NOiAnY3VzdG9tJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb0xheW91dFNldHRpbmdzUmVxdWVzdE5hbWVFbnVtID0ge1xuICAgIFNQT1RMSUdIVDogJ3Nwb3RsaWdodCcsXG4gICAgR1JJRDogJ2dyaWQnLFxuICAgIFNJTkdMRV9QQVJUSUNJUEFOVDogJ3NpbmdsZS1wYXJ0aWNpcGFudCcsXG4gICAgTU9CSUxFOiAnbW9iaWxlJyxcbiAgICBDVVNUT006ICdjdXN0b20nXG59O1xuLyoqXG4gKiBBbGwgcG9zc2liaWxpdHkgb2Ygc3RyaW5nIHRvIHVzZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb093bkNhcGFiaWxpdHkgPSB7XG4gICAgQkxPQ0tfVVNFUlM6ICdibG9jay11c2VycycsXG4gICAgQ1JFQVRFX0NBTEw6ICdjcmVhdGUtY2FsbCcsXG4gICAgQ1JFQVRFX1JFQUNUSU9OOiAnY3JlYXRlLXJlYWN0aW9uJyxcbiAgICBFTkRfQ0FMTDogJ2VuZC1jYWxsJyxcbiAgICBKT0lOX0JBQ0tTVEFHRTogJ2pvaW4tYmFja3N0YWdlJyxcbiAgICBKT0lOX0NBTEw6ICdqb2luLWNhbGwnLFxuICAgIEpPSU5fRU5ERURfQ0FMTDogJ2pvaW4tZW5kZWQtY2FsbCcsXG4gICAgTVVURV9VU0VSUzogJ211dGUtdXNlcnMnLFxuICAgIFBJTl9GT1JfRVZFUllPTkU6ICdwaW4tZm9yLWV2ZXJ5b25lJyxcbiAgICBSRUFEX0NBTEw6ICdyZWFkLWNhbGwnLFxuICAgIFJFTU9WRV9DQUxMX01FTUJFUjogJ3JlbW92ZS1jYWxsLW1lbWJlcicsXG4gICAgU0NSRUVOU0hBUkU6ICdzY3JlZW5zaGFyZScsXG4gICAgU0VORF9BVURJTzogJ3NlbmQtYXVkaW8nLFxuICAgIFNFTkRfVklERU86ICdzZW5kLXZpZGVvJyxcbiAgICBTVEFSVF9CUk9BRENBU1RfQ0FMTDogJ3N0YXJ0LWJyb2FkY2FzdC1jYWxsJyxcbiAgICBTVEFSVF9SRUNPUkRfQ0FMTDogJ3N0YXJ0LXJlY29yZC1jYWxsJyxcbiAgICBTVEFSVF9UUkFOU0NSSVBUSU9OX0NBTEw6ICdzdGFydC10cmFuc2NyaXB0aW9uLWNhbGwnLFxuICAgIFNUT1BfQlJPQURDQVNUX0NBTEw6ICdzdG9wLWJyb2FkY2FzdC1jYWxsJyxcbiAgICBTVE9QX1JFQ09SRF9DQUxMOiAnc3RvcC1yZWNvcmQtY2FsbCcsXG4gICAgU1RPUF9UUkFOU0NSSVBUSU9OX0NBTEw6ICdzdG9wLXRyYW5zY3JpcHRpb24tY2FsbCcsXG4gICAgVVBEQVRFX0NBTEw6ICd1cGRhdGUtY2FsbCcsXG4gICAgVVBEQVRFX0NBTExfTUVNQkVSOiAndXBkYXRlLWNhbGwtbWVtYmVyJyxcbiAgICBVUERBVEVfQ0FMTF9QRVJNSVNTSU9OUzogJ3VwZGF0ZS1jYWxsLXBlcm1pc3Npb25zJyxcbiAgICBVUERBVEVfQ0FMTF9TRVRUSU5HUzogJ3VwZGF0ZS1jYWxsLXNldHRpbmdzJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1JlY29yZFNldHRpbmdzUmVxdWVzdE1vZGVFbnVtID0ge1xuICAgIEFWQUlMQUJMRTogJ2F2YWlsYWJsZScsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgQVVUT19PTjogJ2F1dG8tb24nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvUmVjb3JkU2V0dGluZ3NSZXF1ZXN0UXVhbGl0eUVudW0gPSB7XG4gICAgXzM2MFA6ICczNjBwJyxcbiAgICBfNDgwUDogJzQ4MHAnLFxuICAgIF83MjBQOiAnNzIwcCcsXG4gICAgXzEwODBQOiAnMTA4MHAnLFxuICAgIF8xNDQwUDogJzE0NDBwJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtID0ge1xuICAgIEFWQUlMQUJMRTogJ2F2YWlsYWJsZScsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgQVVUT19PTjogJ2F1dG8tb24nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdE1vZGVFbnVtID0ge1xuICAgIEFWQUlMQUJMRTogJ2F2YWlsYWJsZScsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgQVVUT19PTjogJ2F1dG8tb24nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0gPSB7XG4gICAgRlJPTlQ6ICdmcm9udCcsXG4gICAgQkFDSzogJ2JhY2snLFxuICAgIEVYVEVSTkFMOiAnZXh0ZXJuYWwnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvVmlkZW9TZXR0aW5nc1JlcXVlc3RDYW1lcmFGYWNpbmdFbnVtID0ge1xuICAgIEZST05UOiAnZnJvbnQnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBFWFRFUk5BTDogJ2V4dGVybmFsJ1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5jb25zdCBCQVNFX1BBVEgkMSA9IFwiaHR0cHM6Ly9jaGF0LnN0cmVhbS1pby1hcGkuY29tXCIucmVwbGFjZSgvXFwvKyQvLCBcIlwiKTtcbmxldCBDb25maWd1cmF0aW9uJDEgPSBjbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uID0ge30pIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICB9XG4gICAgc2V0IGNvbmZpZyhjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCAhPSBudWxsID8gdGhpcy5jb25maWd1cmF0aW9uLmJhc2VQYXRoIDogQkFTRV9QQVRIJDE7XG4gICAgfVxuICAgIGdldCBmZXRjaEFwaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5mZXRjaEFwaTtcbiAgICB9XG4gICAgZ2V0IG1pZGRsZXdhcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ubWlkZGxld2FyZSB8fCBbXTtcbiAgICB9XG4gICAgZ2V0IHF1ZXJ5UGFyYW1zU3RyaW5naWZ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnF1ZXJ5UGFyYW1zU3RyaW5naWZ5IHx8IHF1ZXJ5c3RyaW5nJDE7XG4gICAgfVxuICAgIGdldCB1c2VybmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi51c2VybmFtZTtcbiAgICB9XG4gICAgZ2V0IHBhc3N3b3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnBhc3N3b3JkO1xuICAgIH1cbiAgICBnZXQgYXBpS2V5KCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5O1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFwaUtleSA9PT0gJ2Z1bmN0aW9uJyA/IGFwaUtleSA6ICgpID0+IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5jb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuO1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbicgPyBhY2Nlc3NUb2tlbiA6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIGFjY2Vzc1Rva2VuOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5oZWFkZXJzO1xuICAgIH1cbiAgICBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uY3JlZGVudGlhbHM7XG4gICAgfVxufTtcbmNvbnN0IERlZmF1bHRDb25maWckMSA9IG5ldyBDb25maWd1cmF0aW9uJDEoKTtcbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGdlbmVyYXRlZCBBUEkgY2xhc3Nlcy5cbiAqL1xubGV0IEJhc2VBUEkkMSA9IGNsYXNzIEJhc2VBUEkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24gPSBEZWZhdWx0Q29uZmlnJDEpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy5mZXRjaEFwaSA9ICh1cmwsIGluaXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBmZXRjaFBhcmFtcyA9IHsgdXJsLCBpbml0IH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2YgdGhpcy5taWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUucHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoUGFyYW1zID0gKHlpZWxkIG1pZGRsZXdhcmUucHJlKE9iamVjdC5hc3NpZ24oeyBmZXRjaDogdGhpcy5mZXRjaEFwaSB9LCBmZXRjaFBhcmFtcykpKSB8fCBmZXRjaFBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgKHRoaXMuY29uZmlndXJhdGlvbi5mZXRjaEFwaSB8fCBmZXRjaCkoZmV0Y2hQYXJhbXMudXJsLCBmZXRjaFBhcmFtcy5pbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWlkZGxld2FyZS5vbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9ICh5aWVsZCBtaWRkbGV3YXJlLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoQXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZmV0Y2hQYXJhbXMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IGZldGNoUGFyYW1zLmluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlID8gcmVzcG9uc2UuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB8fCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmV0Y2hFcnJvciQxKGUsICdUaGUgcmVxdWVzdCBmYWlsZWQgYW5kIHRoZSBpbnRlcmNlcHRvcnMgZGlkIG5vdCByZXR1cm4gYW4gYWx0ZXJuYXRpdmUgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2YgdGhpcy5taWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUucG9zdCkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9ICh5aWVsZCBtaWRkbGV3YXJlLnBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2hBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoUGFyYW1zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IGZldGNoUGFyYW1zLmluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgfSkpIHx8IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZSA9IGNvbmZpZ3VyYXRpb24ubWlkZGxld2FyZTtcbiAgICB9XG4gICAgd2l0aE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgbmV4dC5taWRkbGV3YXJlID0gbmV4dC5taWRkbGV3YXJlLmNvbmNhdCguLi5taWRkbGV3YXJlcyk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICB3aXRoUHJlTWlkZGxld2FyZSguLi5wcmVNaWRkbGV3YXJlcykge1xuICAgICAgICBjb25zdCBtaWRkbGV3YXJlcyA9IHByZU1pZGRsZXdhcmVzLm1hcCgocHJlKSA9PiAoeyBwcmUgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoTWlkZGxld2FyZSguLi5taWRkbGV3YXJlcyk7XG4gICAgfVxuICAgIHdpdGhQb3N0TWlkZGxld2FyZSguLi5wb3N0TWlkZGxld2FyZXMpIHtcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZXMgPSBwb3N0TWlkZGxld2FyZXMubWFwKChwb3N0KSA9PiAoeyBwb3N0IH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBhIEpTT04gTUlNRS5cbiAgICAgKiBKU09OIE1JTUUgZXhhbXBsZXM6XG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uXG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURjhcbiAgICAgKiAgIEFQUExJQ0FUSU9OL0pTT05cbiAgICAgKiAgIGFwcGxpY2F0aW9uL3ZuZC5jb21wYW55K2pzb25cbiAgICAgKiBAcGFyYW0gbWltZSAtIE1JTUUgKE11bHRpcHVycG9zZSBJbnRlcm5ldCBNYWlsIEV4dGVuc2lvbnMpXG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBnaXZlbiBNSU1FIGlzIEpTT04sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0pzb25NaW1lKG1pbWUpIHtcbiAgICAgICAgaWYgKCFtaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJhc2VBUEkuanNvblJlZ2V4LnRlc3QobWltZSk7XG4gICAgfVxuICAgIHJlcXVlc3QoY29udGV4dCwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB1cmwsIGluaXQgfSA9IHlpZWxkIHRoaXMuY3JlYXRlRmV0Y2hQYXJhbXMoY29udGV4dCwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZmV0Y2hBcGkodXJsLCBpbml0KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlRXJyb3IkMShyZXNwb25zZSwgJ1Jlc3BvbnNlIHJldHVybmVkIGFuIGVycm9yIGNvZGUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUZldGNoUGFyYW1zKGNvbnRleHQsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggKyBjb250ZXh0LnBhdGg7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5xdWVyeSAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKGNvbnRleHQucXVlcnkpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRoZSBxdWVyeXN0cmluZyB0byB0aGUgVVJMIGlmIHRoZXJlIGFyZSBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZG9uZSB0byBhdm9pZCB1cmxzIGVuZGluZyB3aXRoIGEgXCI/XCIgY2hhcmFjdGVyIHdoaWNoIGJ1Z2d5IHdlYnNlcnZlcnNcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgaGFuZGxlIGNvcnJlY3RseSBzb21ldGltZXMuXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMuY29uZmlndXJhdGlvbi5xdWVyeVBhcmFtc1N0cmluZ2lmeShjb250ZXh0LnF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZ3VyYXRpb24uaGVhZGVycywgY29udGV4dC5oZWFkZXJzKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IGhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkID8gZGVsZXRlIGhlYWRlcnNba2V5XSA6IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRPdmVycmlkZUZuID0gdHlwZW9mIGluaXRPdmVycmlkZXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gaW5pdE92ZXJyaWRlc1xuICAgICAgICAgICAgICAgIDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gaW5pdE92ZXJyaWRlczsgfSk7XG4gICAgICAgICAgICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBjb250ZXh0LmJvZHksXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY29uZmlndXJhdGlvbi5jcmVkZW50aWFscyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZGVuSW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdFBhcmFtcyksICh5aWVsZCBpbml0T3ZlcnJpZGVGbih7XG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdFBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRkZW5Jbml0KSwgeyBib2R5OiBpc0Zvcm1EYXRhJDEob3ZlcnJpZGRlbkluaXQuYm9keSkgfHxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGRlbkluaXQuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyB8fFxuICAgICAgICAgICAgICAgICAgICBpc0Jsb2IkMShvdmVycmlkZGVuSW5pdC5ib2R5KVxuICAgICAgICAgICAgICAgICAgICA/IG92ZXJyaWRkZW5Jbml0LmJvZHlcbiAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShvdmVycmlkZGVuSW5pdC5ib2R5KSB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHVybCwgaW5pdCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2hhbGxvdyBjbG9uZSBvZiBgdGhpc2AgYnkgY29uc3RydWN0aW5nIGEgbmV3IGluc3RhbmNlXG4gICAgICogYW5kIHRoZW4gc2hhbGxvdyBjbG9uaW5nIGRhdGEgbWVtYmVycy5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCBuZXh0ID0gbmV3IGNvbnN0cnVjdG9yKHRoaXMuY29uZmlndXJhdGlvbik7XG4gICAgICAgIG5leHQubWlkZGxld2FyZSA9IHRoaXMubWlkZGxld2FyZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG59O1xuQmFzZUFQSSQxLmpzb25SZWdleCA9IG5ldyBSZWdFeHAoJ14oOj9hcHBsaWNhdGlvblxcL2pzb258W147LyBcXHRdK1xcL1teOy8gXFx0XStbK11qc29uKVsgXFx0XSooOj87LiopPyQnLCAnaScpO1xuZnVuY3Rpb24gaXNCbG9iJDEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYjtcbn1cbmZ1bmN0aW9uIGlzRm9ybURhdGEkMSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YTtcbn1cbmxldCBSZXNwb25zZUVycm9yJDEgPSBjbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlRXJyb3JcIjtcbiAgICB9XG59O1xubGV0IEZldGNoRXJyb3IkMSA9IGNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F1c2UsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRmV0Y2hFcnJvclwiO1xuICAgIH1cbn07XG5sZXQgUmVxdWlyZWRFcnJvciQxID0gY2xhc3MgUmVxdWlyZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSZXF1aXJlZEVycm9yXCI7XG4gICAgfVxufTtcbmNvbnN0IENPTExFQ1RJT05fRk9STUFUUyA9IHtcbiAgICBjc3Y6IFwiLFwiLFxuICAgIHNzdjogXCIgXCIsXG4gICAgdHN2OiBcIlxcdFwiLFxuICAgIHBpcGVzOiBcInxcIixcbn07XG5mdW5jdGlvbiBxdWVyeXN0cmluZyQxKHBhcmFtcywgcHJlZml4ID0gJycpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgICAubWFwKGtleSA9PiBxdWVyeXN0cmluZ1NpbmdsZUtleSQxKGtleSwgcGFyYW1zW2tleV0sIHByZWZpeCkpXG4gICAgICAgIC5maWx0ZXIocGFydCA9PiBwYXJ0Lmxlbmd0aCA+IDApXG4gICAgICAgIC5qb2luKCcmJyk7XG59XG5mdW5jdGlvbiBxdWVyeXN0cmluZ1NpbmdsZUtleSQxKGtleSwgdmFsdWUsIGtleVByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgZnVsbEtleSA9IGtleVByZWZpeCArIChrZXlQcmVmaXgubGVuZ3RoID8gYFske2tleX1dYCA6IGtleSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgbXVsdGlWYWx1ZSA9IHZhbHVlLm1hcChzaW5nbGVWYWx1ZSA9PiBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNpbmdsZVZhbHVlKSkpXG4gICAgICAgICAgICAuam9pbihgJiR7ZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxLZXkpfT1gKTtcbiAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09JHttdWx0aVZhbHVlfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBjb25zdCB2YWx1ZUFzQXJyYXkgPSBBcnJheS5mcm9tKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5c3RyaW5nU2luZ2xlS2V5JDEoa2V5LCB2YWx1ZUFzQXJyYXksIGtleVByZWZpeCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUudG9JU09TdHJpbmcoKSl9YDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBxdWVyeXN0cmluZyQxKHZhbHVlLCBmdWxsS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHZhbHVlKSl9YDtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN1bWVGb3JtKGNvbnN1bWVzKSB7XG4gICAgZm9yIChjb25zdCBjb25zdW1lIG9mIGNvbnN1bWVzKSB7XG4gICAgICAgIGlmICgnbXVsdGlwYXJ0L2Zvcm0tZGF0YScgPT09IGNvbnN1bWUuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmxldCBKU09OQXBpUmVzcG9uc2UkMSA9IGNsYXNzIEpTT05BcGlSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IocmF3LCB0cmFuc2Zvcm1lciA9IChqc29uVmFsdWUpID0+IGpzb25WYWx1ZSkge1xuICAgICAgICB0aGlzLnJhdyA9IHJhdztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xuICAgIH1cbiAgICB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWVyKHlpZWxkIHRoaXMucmF3Lmpzb24oKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5sZXQgVm9pZEFwaVJlc3BvbnNlJDEgPSBjbGFzcyBWb2lkQXBpUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJhdykge1xuICAgICAgICB0aGlzLnJhdyA9IHJhdztcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIENoYW5uZWxUeXBlc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgY2hhbm5lbCB0eXBlXG4gICAgICogQ3JlYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBEZWxldGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgZGVsZXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWx0eXBlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBEZWxldGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgZGVsZXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2hhbm5lbCB0eXBlXG4gICAgICogR2V0IGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGdldENoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0Q2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2hhbm5lbCB0eXBlXG4gICAgICogR2V0IGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGdldENoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0Q2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIGNoYW5uZWwgdHlwZXNcbiAgICAgKiBMaXN0IGNoYW5uZWwgdHlwZXNcbiAgICAgKi9cbiAgICBsaXN0Q2hhbm5lbFR5cGVzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWx0eXBlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSBjaGFubmVsIHR5cGVzXG4gICAgICogTGlzdCBjaGFubmVsIHR5cGVzXG4gICAgICovXG4gICAgbGlzdENoYW5uZWxUeXBlcyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdENoYW5uZWxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBVcGRhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNoYW5uZWwgdHlwZVxuICAgICAqIFVwZGF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICB1cGRhdGVDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgQ2hhbm5lbHNBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQ2hhbm5lbFxuICAgICAqIERlbGV0ZSBjaGFubmVsXG4gICAgICovXG4gICAgZGVsZXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5oYXJkRGVsZXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2hhcmRfZGVsZXRlJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5oYXJkRGVsZXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUNoYW5uZWxcbiAgICAgKiBEZWxldGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIGRlbGV0ZSBzZXZlcmFsIGNoYW5uZWxzIGF0IG9uY2UgYXN5bmNocm9ub3VzbHkgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUNoYW5uZWxcbiAgICAgKiBEZWxldGVzIGNoYW5uZWxzIGFzeW5jaHJvbm91c2x5XG4gICAgICovXG4gICAgZGVsZXRlQ2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVDaGFubmVsc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdkZWxldGVDaGFubmVsc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZUNoYW5uZWxzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUNoYW5uZWxzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy9kZWxldGVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVDaGFubmVsc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIGRlbGV0ZSBzZXZlcmFsIGNoYW5uZWxzIGF0IG9uY2UgYXN5bmNocm9ub3VzbHkgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUNoYW5uZWxcbiAgICAgKiBEZWxldGVzIGNoYW5uZWxzIGFzeW5jaHJvbm91c2x5XG4gICAgICovXG4gICAgZGVsZXRlQ2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVDaGFubmVsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgY2hhbm5lbCBkYXRhIHRvIEpTT04gZmlsZVxuICAgICAqIEV4cG9ydCBjaGFubmVsc1xuICAgICAqL1xuICAgIGV4cG9ydENoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0Q2hhbm5lbHNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydENoYW5uZWxzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZXhwb3J0Q2hhbm5lbHNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRDaGFubmVsc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBleHBvcnRDaGFubmVscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvZXhwb3J0X2NoYW5uZWxzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0Q2hhbm5lbHNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgY2hhbm5lbCBkYXRhIHRvIEpTT04gZmlsZVxuICAgICAqIEV4cG9ydCBjaGFubmVsc1xuICAgICAqL1xuICAgIGV4cG9ydENoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZXhwb3J0Q2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEV4cG9ydCBjaGFubmVscyBzdGF0dXNcbiAgICAgKi9cbiAgICBnZXRFeHBvcnRDaGFubmVsc1N0YXR1c1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRFeHBvcnRDaGFubmVsc1N0YXR1cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2V4cG9ydF9jaGFubmVscy97aWR9YC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHMgc3RhdHVzXG4gICAgICovXG4gICAgZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRFeHBvcnRDaGFubmVsc1N0YXR1c1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBjaGFubmVsIG9yIHJldHVybnMgYW4gZXhpc3Rpbmcgb25lIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcyAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuY3JlYXRlZCAtIG1lbWJlci5hZGRlZCAtIG1lbWJlci5yZW1vdmVkIC0gbWVtYmVyLnVwZGF0ZWQgLSB1c2VyLndhdGNoaW5nLnN0YXJ0XG4gICAgICogR2V0IG9yIGNyZWF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRPckNyZWF0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9xdWVyeWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIGNoYW5uZWwgb3IgcmV0dXJucyBhbiBleGlzdGluZyBvbmUgd2l0aCBtYXRjaGluZyBhdHRyaWJ1dGVzICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5jcmVhdGVkIC0gbWVtYmVyLmFkZGVkIC0gbWVtYmVyLnJlbW92ZWQgLSBtZW1iZXIudXBkYXRlZCAtIHVzZXIud2F0Y2hpbmcuc3RhcnRcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICBnZXRPckNyZWF0ZUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRPckNyZWF0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIGhpZGRlbiBmb3IgY3VycmVudCB1c2VyICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5oaWRkZW4gIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogSGlkZSBjaGFubmVsXG4gICAgICovXG4gICAgaGlkZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBoaWRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgaGlkZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaGlkZUNoYW5uZWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmhpZGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaGlkZUNoYW5uZWxSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5oaWRlQ2hhbm5lbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBoaWRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vaGlkZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmhpZGVDaGFubmVsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIGhpZGRlbiBmb3IgY3VycmVudCB1c2VyICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5oaWRkZW4gIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogSGlkZSBjaGFubmVsXG4gICAgICovXG4gICAgaGlkZUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5oaWRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWxzIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UuIElmIG5vIGNoYW5uZWxzIGlzIGdpdmVuLCBtYXJrIGFsbCBjaGFubmVsIGFzIHJlYWQgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayBjaGFubmVscyBhcyByZWFkXG4gICAgICovXG4gICAgbWFya0NoYW5uZWxzUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdtYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubWFya0NoYW5uZWxzUmVhZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrQ2hhbm5lbHNSZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy9yZWFkYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubWFya0NoYW5uZWxzUmVhZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbHMgYXMgcmVhZCB1cCB0byB0aGUgc3BlY2lmaWMgbWVzc2FnZS4gSWYgbm8gY2hhbm5lbHMgaXMgZ2l2ZW4sIG1hcmsgYWxsIGNoYW5uZWwgYXMgcmVhZCAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UucmVhZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBNYXJrIGNoYW5uZWxzIGFzIHJlYWRcbiAgICAgKi9cbiAgICBtYXJrQ2hhbm5lbHNSZWFkKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubWFya0NoYW5uZWxzUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgcmVhZCB1cCB0byB0aGUgc3BlY2lmaWMgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UucmVhZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBNYXJrIHJlYWRcbiAgICAgKi9cbiAgICBtYXJrUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtSZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrUmVhZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdtYXJrUmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtSZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9yZWFkYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgcmVhZCB1cCB0byB0aGUgc3BlY2lmaWMgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UucmVhZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBNYXJrIHJlYWRcbiAgICAgKi9cbiAgICBtYXJrUmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtSZWFkUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyB1bnJlYWQgZnJvbSBhIHNwZWNpZmljIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayB1bnJlYWRcbiAgICAgKi9cbiAgICBtYXJrVW5yZWFkUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1VucmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1VucmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya1VucmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtVbnJlYWRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1VucmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vdW5yZWFkYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyB1bnJlYWQgZnJvbSBhIHNwZWNpZmljIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayB1bnJlYWRcbiAgICAgKi9cbiAgICBtYXJrVW5yZWFkKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubWFya1VucmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGVzIGNoYW5uZWwgZm9yIHVzZXIgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlQ2hhbm5lbFxuICAgICAqIE11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIG11dGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubXV0ZUNoYW5uZWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbXV0ZUNoYW5uZWxSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tdXRlQ2hhbm5lbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtdXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9tdXRlL2NoYW5uZWxgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5tdXRlQ2hhbm5lbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgY2hhbm5lbCBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwubXV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIE11dGVDaGFubmVsXG4gICAgICogTXV0ZSBjaGFubmVsXG4gICAgICovXG4gICAgbXV0ZUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5tdXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGNoYW5uZWxzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFF1ZXJ5IGNoYW5uZWxzXG4gICAgICovXG4gICAgcXVlcnlDaGFubmVsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdxdWVyeUNoYW5uZWxzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMucXVlcnlDaGFubmVsc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBxdWVyeUNoYW5uZWxzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGNoYW5uZWxzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFF1ZXJ5IGNoYW5uZWxzXG4gICAgICovXG4gICAgcXVlcnlDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5Q2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgY2hhbm5lbCBtZW1iZXJzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFF1ZXJ5IG1lbWJlcnNcbiAgICAgKi9cbiAgICBxdWVyeU1lbWJlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sncGF5bG9hZCddID0gcmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZW1iZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgY2hhbm5lbCBtZW1iZXJzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFF1ZXJ5IG1lbWJlcnNcbiAgICAgKi9cbiAgICBxdWVyeU1lbWJlcnMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5TWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBtZXNzYWdlcyBhY3Jvc3MgY2hhbm5lbHMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzXG4gICAgICovXG4gICAgc2VhcmNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvc2VhcmNoYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXMgYWNyb3NzIGNoYW5uZWxzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFNlYXJjaCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHNlYXJjaChyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VhcmNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgcHJldmlvdXNseSBoaWRkZW4gY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudmlzaWJsZVxuICAgICAqIFNob3cgY2hhbm5lbFxuICAgICAqL1xuICAgIHNob3dDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2hvd0NoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNob3dDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnNob3dDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5zaG93Q2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3Nob3dDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuc2hvd0NoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2hvd0NoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3Nob3dgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5zaG93Q2hhbm5lbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgcHJldmlvdXNseSBoaWRkZW4gY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudmlzaWJsZVxuICAgICAqIFNob3cgY2hhbm5lbFxuICAgICAqL1xuICAgIHNob3dDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2hvd0NoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudHJ1bmNhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsIC0gVHJ1bmNhdGVDaGFubmVsXG4gICAgICogVHJ1bmNhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHRydW5jYXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHRydW5jYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdHJ1bmNhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnRydW5jYXRlQ2hhbm5lbFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHJ1bmNhdGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHJ1bmNhdGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHJ1bmNhdGVDaGFubmVsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHRydW5jYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vdHJ1bmNhdGVgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy50cnVuY2F0ZUNoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC50cnVuY2F0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUNoYW5uZWwgLSBUcnVuY2F0ZUNoYW5uZWxcbiAgICAgKiBUcnVuY2F0ZSBjaGFubmVsXG4gICAgICovXG4gICAgdHJ1bmNhdGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudHJ1bmNhdGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5tdXRlcyBjaGFubmVsIGZvciB1c2VyICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51bm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlQ2hhbm5lbFxuICAgICAqIFVubXV0ZSBjaGFubmVsXG4gICAgICovXG4gICAgdW5tdXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZUNoYW5uZWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZUNoYW5uZWxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1bm11dGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudW5tdXRlQ2hhbm5lbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1bm11dGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL3VubXV0ZS9jaGFubmVsYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudW5tdXRlQ2hhbm5lbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5tdXRlcyBjaGFubmVsIGZvciB1c2VyICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51bm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlQ2hhbm5lbFxuICAgICAqIFVubXV0ZSBjaGFubmVsXG4gICAgICovXG4gICAgdW5tdXRlQ2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVubXV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlYWRDb3VudCBjb3VudHNcbiAgICAgKiBVbnJlYWRDb3VudCBjb3VudHNcbiAgICAgKi9cbiAgICB1bnJlYWRDb3VudHNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdW5yZWFkYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlYWRDb3VudCBjb3VudHNcbiAgICAgKiBVbnJlYWRDb3VudCBjb3VudHNcbiAgICAgKi9cbiAgICB1bnJlYWRDb3VudHMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVucmVhZENvdW50c1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGNoYW5uZWwgZGF0YSAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudXBkYXRlZCAtIG1lbWJlci5hZGRlZCAtIG1lbWJlci5yZW1vdmVkIC0gbWVtYmVyLnVwZGF0ZWQgLSBtZXNzYWdlLm5ldyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkT3duQ2hhbm5lbE1lbWJlcnNoaXAgLSBSZW1vdmVPd25DaGFubmVsTWVtYmVyc2hpcCAtIFVwZGF0ZUNoYW5uZWwgLSBVcGRhdGVDaGFubmVsQ29vbGRvd24gLSBVcGRhdGVDaGFubmVsRnJvemVuIC0gVXBkYXRlQ2hhbm5lbE1lbWJlcnNcbiAgICAgKiBVcGRhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjaGFubmVsIGRhdGEgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnVwZGF0ZWQgLSBtZW1iZXIuYWRkZWQgLSBtZW1iZXIucmVtb3ZlZCAtIG1lbWJlci51cGRhdGVkIC0gbWVzc2FnZS5uZXcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZE93bkNoYW5uZWxNZW1iZXJzaGlwIC0gUmVtb3ZlT3duQ2hhbm5lbE1lbWJlcnNoaXAgLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plbiAtIFVwZGF0ZUNoYW5uZWxNZW1iZXJzXG4gICAgICogVXBkYXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2VydGFpbiBmaWVsZHMgb2YgdGhlIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNoYW5uZWwgLSBVcGRhdGVDaGFubmVsQ29vbGRvd24gLSBVcGRhdGVDaGFubmVsRnJvemVuXG4gICAgICogUGFydGlhbGx5IHVwZGF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFBhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsUGFydGlhbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUGFydGlhbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsUGFydGlhbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2VydGFpbiBmaWVsZHMgb2YgdGhlIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNoYW5uZWwgLSBVcGRhdGVDaGFubmVsQ29vbGRvd24gLSBVcGRhdGVDaGFubmVsRnJvemVuXG4gICAgICogUGFydGlhbGx5IHVwZGF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFBhcnRpYWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDaGFubmVsUGFydGlhbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIEN1c3RvbUNvbW1hbmRzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGN1c3RvbSBjaGF0IGNvbW1hbmRcbiAgICAgKiBDcmVhdGUgY29tbWFuZFxuICAgICAqL1xuICAgIGNyZWF0ZUNvbW1hbmRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDb21tYW5kUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDb21tYW5kUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY3JlYXRlQ29tbWFuZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNvbW1hbmRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlQ29tbWFuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY29tbWFuZHNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDb21tYW5kUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGN1c3RvbSBjaGF0IGNvbW1hbmRcbiAgICAgKiBDcmVhdGUgY29tbWFuZFxuICAgICAqL1xuICAgIGNyZWF0ZUNvbW1hbmQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogRGVsZXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBkZWxldGVDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlQ29tbWFuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NvbW1hbmRzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGN1c3RvbSBjaGF0IGNvbW1hbmRcbiAgICAgKiBEZWxldGUgY29tbWFuZFxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1hbmQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXN0b20gY29tbWFuZCBieSBpdHMgbmFtZVxuICAgICAqIEdldCBjb21tYW5kXG4gICAgICovXG4gICAgZ2V0Q29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXN0b20gY29tbWFuZCBieSBpdHMgbmFtZVxuICAgICAqIEdldCBjb21tYW5kXG4gICAgICovXG4gICAgZ2V0Q29tbWFuZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldENvbW1hbmRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjdXN0b20gY29tbWFuZHNcbiAgICAgKiBMaXN0IGNvbW1hbmRzXG4gICAgICovXG4gICAgbGlzdENvbW1hbmRzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NvbW1hbmRzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjdXN0b20gY29tbWFuZHNcbiAgICAgKiBMaXN0IGNvbW1hbmRzXG4gICAgICovXG4gICAgbGlzdENvbW1hbmRzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0Q29tbWFuZHNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY3VzdG9tIGNoYXQgY29tbWFuZFxuICAgICAqIFVwZGF0ZSBjb21tYW5kXG4gICAgICovXG4gICAgdXBkYXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ29tbWFuZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ29tbWFuZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZUNvbW1hbmRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDb21tYW5kUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NvbW1hbmRzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDb21tYW5kUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGN1c3RvbSBjaGF0IGNvbW1hbmRcbiAgICAgKiBVcGRhdGUgY29tbWFuZFxuICAgICAqL1xuICAgIHVwZGF0ZUNvbW1hbmQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgRGV2aWNlc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBkZXZpY2UgdG8gYSB1c2VyLCBpZiB0aGUgc2FtZSBkZXZpY2UgYWxyZWFkeSBleGlzdHMgdGhlIGNhbGwgd2lsbCBoYXZlIG5vIGVmZmVjdFxuICAgICAqIENyZWF0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBjcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZURldmljZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZURldmljZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZURldmljZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVEZXZpY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZvaWRBcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZURldmljZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG9uZSBkZXZpY2VcbiAgICAgKiBEZWxldGUgZGV2aWNlXG4gICAgICovXG4gICAgZGVsZXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG9uZSBkZXZpY2VcbiAgICAgKiBEZWxldGUgZGV2aWNlXG4gICAgICovXG4gICAgZGVsZXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBhdmFpbGFibGUgZGV2aWNlc1xuICAgICAqIExpc3QgZGV2aWNlc1xuICAgICAqL1xuICAgIGxpc3REZXZpY2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXNlcl9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBkZXZpY2VzXG4gICAgICogTGlzdCBkZXZpY2VzXG4gICAgICovXG4gICAgbGlzdERldmljZXMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3REZXZpY2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgRXZlbnRzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBTZW5kcyBldmVudCB0byB0aGUgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGFueSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VuZEN1c3RvbUV2ZW50XG4gICAgICogU2VuZCBldmVudFxuICAgICAqL1xuICAgIHNlbmRFdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRFdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZEV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRFdmVudFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZEV2ZW50UmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnc2VuZEV2ZW50UmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZEV2ZW50UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRFdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vZXZlbnRgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5zZW5kRXZlbnRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGV2ZW50IHRvIHRoZSBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gYW55ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTZW5kQ3VzdG9tRXZlbnRcbiAgICAgKiBTZW5kIGV2ZW50XG4gICAgICovXG4gICAgc2VuZEV2ZW50KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZEV2ZW50UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBjdXN0b20gZXZlbnQgdG8gYSB1c2VyICBTZW5kcyBldmVudHM6IC0gY3VzdG9tXG4gICAgICogU2VuZCB1c2VyIGV2ZW50XG4gICAgICovXG4gICAgc2VuZFVzZXJDdXN0b21FdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VzZXJJZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZFVzZXJDdXN0b21FdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZW5kVXNlckN1c3RvbUV2ZW50UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5zZW5kVXNlckN1c3RvbUV2ZW50UmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnc2VuZFVzZXJDdXN0b21FdmVudFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRVc2VyQ3VzdG9tRXZlbnRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZFVzZXJDdXN0b21FdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9L2V2ZW50YC5yZXBsYWNlKGB7JHtcInVzZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRVc2VyQ3VzdG9tRXZlbnRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgY3VzdG9tIGV2ZW50IHRvIGEgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGN1c3RvbVxuICAgICAqIFNlbmQgdXNlciBldmVudFxuICAgICAqL1xuICAgIHNlbmRVc2VyQ3VzdG9tRXZlbnQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kVXNlckN1c3RvbUV2ZW50UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgTWVzc2FnZXNBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgcHJldmlvdXNseSB1cGxvYWRlZCBmaWxlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVBdHRhY2htZW50XG4gICAgICogRGVsZXRlIGZpbGVcbiAgICAgKi9cbiAgICBkZWxldGVGaWxlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlRmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlRmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1cmwnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9maWxlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgdXBsb2FkZWQgZmlsZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQXR0YWNobWVudFxuICAgICAqIERlbGV0ZSBmaWxlXG4gICAgICovXG4gICAgZGVsZXRlRmlsZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZUZpbGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgdXBsb2FkZWQgaW1hZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUF0dGFjaG1lbnRcbiAgICAgKiBEZWxldGUgaW1hZ2VcbiAgICAgKi9cbiAgICBkZWxldGVJbWFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUltYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVJbWFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1cmwnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9pbWFnZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IHVwbG9hZGVkIGltYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVBdHRhY2htZW50XG4gICAgICogRGVsZXRlIGltYWdlXG4gICAgICovXG4gICAgZGVsZXRlSW1hZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVJbWFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UuZGVsZXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlTWVzc2FnZVxuICAgICAqIERlbGV0ZSBtZXNzYWdlXG4gICAgICovXG4gICAgZGVsZXRlTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaGFyZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydoYXJkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5oYXJkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZWRCeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydkZWxldGVkX2J5J10gPSByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVkQnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVzc2FnZXMve2lkfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UuZGVsZXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlTWVzc2FnZVxuICAgICAqIERlbGV0ZSBtZXNzYWdlXG4gICAgICovXG4gICAgZGVsZXRlTWVzc2FnZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZU1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHVzZXIgcmVhY3Rpb24gZnJvbSB0aGUgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIHJlYWN0aW9uLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZVJlYWN0aW9uXG4gICAgICogRGVsZXRlIHJlYWN0aW9uXG4gICAgICovXG4gICAgZGVsZXRlUmVhY3Rpb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlUmVhY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlUmVhY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXNlcl9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH0vcmVhY3Rpb24ve3R5cGV9YC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSkucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHVzZXIgcmVhY3Rpb24gZnJvbSB0aGUgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIHJlYWN0aW9uLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZVJlYWN0aW9uXG4gICAgICogRGVsZXRlIHJlYWN0aW9uXG4gICAgICovXG4gICAgZGVsZXRlUmVhY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVSZWFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgbWVzc2FnZSBvciB1c2VyIGZvciByZXZpZXcgYnkgbW9kZXJhdG9ycyAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UuZmxhZ2dlZCAtIHVzZXIuZmxhZ2dlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRmxhZ01lc3NhZ2UgLSBGbGFnVXNlclxuICAgICAqIEZsYWdcbiAgICAgKi9cbiAgICBmbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2ZsYWdSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGZsYWcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21vZGVyYXRpb24vZmxhZ2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgbWVzc2FnZSBvciB1c2VyIGZvciByZXZpZXcgYnkgbW9kZXJhdG9ycyAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UuZmxhZ2dlZCAtIHVzZXIuZmxhZ2dlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRmxhZ01lc3NhZ2UgLSBGbGFnVXNlclxuICAgICAqIEZsYWdcbiAgICAgKi9cbiAgICBmbGFnKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGlzdCBtZXNzYWdlcyBmb3VuZCBieSBJRHMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IG1hbnkgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBnZXRNYW55TWVzc2FnZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRNYW55TWVzc2FnZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE1hbnlNZXNzYWdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWRzJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZHMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L21lc3NhZ2VzYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3QgbWVzc2FnZXMgZm91bmQgYnkgSURzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCBtYW55IG1lc3NhZ2VzXG4gICAgICovXG4gICAgZ2V0TWFueU1lc3NhZ2VzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0TWFueU1lc3NhZ2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtZXNzYWdlIGJ5IElEICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCBtZXNzYWdlXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVzc2FnZXMve2lkfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWVzc2FnZSBieSBJRCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgbWVzc2FnZVxuICAgICAqL1xuICAgIGdldE1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuIE9wZW5HcmFwaCBhdHRhY2htZW50IGZvciBhIGxpbmtcbiAgICAgKiBHZXQgT0dcbiAgICAgKi9cbiAgICBnZXRPR1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VybCddID0gcmVxdWVzdFBhcmFtZXRlcnMudXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL29nYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gT3BlbkdyYXBoIGF0dGFjaG1lbnQgZm9yIGEgbGlua1xuICAgICAqIEdldCBPR1xuICAgICAqL1xuICAgIGdldE9HKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRPR1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGlzdCBvZiByZWFjdGlvbnMgb2Ygc3BlY2lmaWMgbWVzc2FnZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgcmVhY3Rpb25zXG4gICAgICovXG4gICAgZ2V0UmVhY3Rpb25zUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFJlYWN0aW9ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2xpbWl0J10gPSByZXF1ZXN0UGFyYW1ldGVycy5saW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5vZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snb2Zmc2V0J10gPSByZXF1ZXN0UGFyYW1ldGVycy5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVzc2FnZXMve2lkfS9yZWFjdGlvbnNgLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgcmVhY3Rpb25zIG9mIHNwZWNpZmljIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IHJlYWN0aW9uc1xuICAgICAqL1xuICAgIGdldFJlYWN0aW9ucyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldFJlYWN0aW9uc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmVwbGllcyAodGhyZWFkKSBvZiB0aGUgbWVzc2FnZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgcmVwbGllc1xuICAgICAqL1xuICAgIGdldFJlcGxpZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncGFyZW50SWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnBhcmVudElkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0UmVwbGllcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkX2d0ZSddID0gcmVxdWVzdFBhcmFtZXRlcnMuaWRHdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWRHdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZF9ndCddID0gcmVxdWVzdFBhcmFtZXRlcnMuaWRHdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEx0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZF9sdGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkTHRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkTHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWRfbHQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkTHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QWZ0ZXJPckVxdWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2NyZWF0ZWRfYXRfYWZ0ZXJfb3JfZXF1YWwnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEFmdGVyT3JFcXVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRBZnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2FmdGVyJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRCZWZvcmVPckVxdWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2NyZWF0ZWRfYXRfYmVmb3JlX29yX2VxdWFsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRCZWZvcmVPckVxdWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2JlZm9yZSddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QmVmb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkQXJvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkX2Fyb3VuZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuaWRBcm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QXJvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2NyZWF0ZWRfYXRfYXJvdW5kJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRBcm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVzc2FnZXMve3BhcmVudF9pZH0vcmVwbGllc2AucmVwbGFjZShgeyR7XCJwYXJlbnRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRJZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJlcGxpZXMgKHRocmVhZCkgb2YgdGhlIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IHJlcGxpZXNcbiAgICAgKi9cbiAgICBnZXRSZXBsaWVzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0UmVwbGllc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWxzIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UuIElmIG5vIGNoYW5uZWxzIGlzIGdpdmVuLCBtYXJrIGFsbCBjaGFubmVsIGFzIHJlYWQgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayBjaGFubmVscyBhcyByZWFkXG4gICAgICovXG4gICAgbWFya0NoYW5uZWxzUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdtYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubWFya0NoYW5uZWxzUmVhZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrQ2hhbm5lbHNSZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy9yZWFkYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubWFya0NoYW5uZWxzUmVhZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbHMgYXMgcmVhZCB1cCB0byB0aGUgc3BlY2lmaWMgbWVzc2FnZS4gSWYgbm8gY2hhbm5lbHMgaXMgZ2l2ZW4sIG1hcmsgYWxsIGNoYW5uZWwgYXMgcmVhZCAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UucmVhZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBNYXJrIGNoYW5uZWxzIGFzIHJlYWRcbiAgICAgKi9cbiAgICBtYXJrQ2hhbm5lbHNSZWFkKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubWFya0NoYW5uZWxzUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgcmVhZCB1cCB0byB0aGUgc3BlY2lmaWMgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UucmVhZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBNYXJrIHJlYWRcbiAgICAgKi9cbiAgICBtYXJrUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtSZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrUmVhZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdtYXJrUmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtSZWFkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9yZWFkYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgcmVhZCB1cCB0byB0aGUgc3BlY2lmaWMgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UucmVhZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBNYXJrIHJlYWRcbiAgICAgKi9cbiAgICBtYXJrUmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtSZWFkUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyB1bnJlYWQgZnJvbSBhIHNwZWNpZmljIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayB1bnJlYWRcbiAgICAgKi9cbiAgICBtYXJrVW5yZWFkUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1VucmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1VucmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya1VucmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtVbnJlYWRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1VucmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vdW5yZWFkYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyB1bnJlYWQgZnJvbSBhIHNwZWNpZmljIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayB1bnJlYWRcbiAgICAgKi9cbiAgICBtYXJrVW5yZWFkKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubWFya1VucmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIGZpbHRlciBtZXNzYWdlIGZsYWdzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkTWVzc2FnZUZsYWdzXG4gICAgICogUXVlcnkgTWVzc2FnZSBGbGFnc1xuICAgICAqL1xuICAgIHF1ZXJ5TWVzc2FnZUZsYWdzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9mbGFncy9tZXNzYWdlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgbWVzc2FnZSBmbGFncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZE1lc3NhZ2VGbGFnc1xuICAgICAqIFF1ZXJ5IE1lc3NhZ2UgRmxhZ3NcbiAgICAgKi9cbiAgICBxdWVyeU1lc3NhZ2VGbGFncyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlNZXNzYWdlRmxhZ3NSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBtZXNzYWdlIGNvbW1hbmQgYWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycyAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UubmV3ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSdW5NZXNzYWdlQWN0aW9uXG4gICAgICogUnVuIG1lc3NhZ2UgY29tbWFuZCBhY3Rpb25cbiAgICAgKi9cbiAgICBydW5NZXNzYWdlQWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHJ1bk1lc3NhZ2VBY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWVzc2FnZUFjdGlvblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWVzc2FnZUFjdGlvblJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ21lc3NhZ2VBY3Rpb25SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tZXNzYWdlQWN0aW9uUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHJ1bk1lc3NhZ2VBY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH0vYWN0aW9uYC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1lc3NhZ2VBY3Rpb25SZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIG1lc3NhZ2UgY29tbWFuZCBhY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5uZXcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJ1bk1lc3NhZ2VBY3Rpb25cbiAgICAgKiBSdW4gbWVzc2FnZSBjb21tYW5kIGFjdGlvblxuICAgICAqL1xuICAgIHJ1bk1lc3NhZ2VBY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5ydW5NZXNzYWdlQWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzIGFjcm9zcyBjaGFubmVscyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXNcbiAgICAgKi9cbiAgICBzZWFyY2hSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sncGF5bG9hZCddID0gcmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9zZWFyY2hgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBtZXNzYWdlcyBhY3Jvc3MgY2hhbm5lbHMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzXG4gICAgICovXG4gICAgc2VhcmNoKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZWFyY2hSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBuZXcgbWVzc2FnZSB0byB0aGUgc3BlY2lmaWVkIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLm5ldyAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkTGlua3MgLSBDcmVhdGVNZXNzYWdlIC0gUGluTWVzc2FnZSAtIFNraXBDaGFubmVsQ29vbGRvd24gLSBTa2lwTWVzc2FnZU1vZGVyYXRpb24gLSBVc2VGcm96ZW5DaGFubmVsXG4gICAgICogU2VuZCBuZXcgbWVzc2FnZVxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZE1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRNZXNzYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5zZW5kTWVzc2FnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3NlbmRNZXNzYWdlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZE1lc3NhZ2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZE1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L21lc3NhZ2VgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5zZW5kTWVzc2FnZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgbmV3IG1lc3NhZ2UgdG8gdGhlIHNwZWNpZmllZCBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5uZXcgLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZExpbmtzIC0gQ3JlYXRlTWVzc2FnZSAtIFBpbk1lc3NhZ2UgLSBTa2lwQ2hhbm5lbENvb2xkb3duIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXNlRnJvemVuQ2hhbm5lbFxuICAgICAqIFNlbmQgbmV3IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgcmVhY3Rpb24gdG8gc3BlY2lmaWVkIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5uZXcgLSByZWFjdGlvbi51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBDcmVhdGVSZWFjdGlvbiAtIFVzZUZyb3plbkNoYW5uZWxcbiAgICAgKiBTZW5kIHJlYWN0aW9uXG4gICAgICovXG4gICAgc2VuZFJlYWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRSZWFjdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZW5kUmVhY3Rpb25SZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRSZWFjdGlvblJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3NlbmRSZWFjdGlvblJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRSZWFjdGlvblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kUmVhY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH0vcmVhY3Rpb25gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2VuZFJlYWN0aW9uUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyByZWFjdGlvbiB0byBzcGVjaWZpZWQgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIHJlYWN0aW9uLm5ldyAtIHJlYWN0aW9uLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIENyZWF0ZVJlYWN0aW9uIC0gVXNlRnJvemVuQ2hhbm5lbFxuICAgICAqIFNlbmQgcmVhY3Rpb25cbiAgICAgKi9cbiAgICBzZW5kUmVhY3Rpb24ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kUmVhY3Rpb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG1lc3NhZ2UgdG8gYSBnaXZlbiBsYW5ndWFnZSB1c2luZyBhdXRvbWF0ZWQgdHJhbnNsYXRpb24gc29mdHdhcmUgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogVHJhbnNsYXRlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB0cmFuc2xhdGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHRyYW5zbGF0ZU1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHJhbnNsYXRlTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHJhbnNsYXRlTWVzc2FnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3RyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHRyYW5zbGF0ZU1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH0vdHJhbnNsYXRlYC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgbWVzc2FnZSB0byBhIGdpdmVuIGxhbmd1YWdlIHVzaW5nIGF1dG9tYXRlZCB0cmFuc2xhdGlvbiBzb2Z0d2FyZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBUcmFuc2xhdGUgbWVzc2FnZVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy50cmFuc2xhdGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBwcmV2aW91c2x5IGNyZWF0ZWQgdXNlciBvciBtZXNzYWdlIGZsYWcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBVbmZsYWdcbiAgICAgKi9cbiAgICB1bmZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZmxhZ1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5mbGFnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL3VuZmxhZ2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBjcmVhdGVkIHVzZXIgb3IgbWVzc2FnZSBmbGFnICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogVW5mbGFnXG4gICAgICovXG4gICAgdW5mbGFnKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudW5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBtZXNzYWdlIHdpdGggbmV3IGRhdGEgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZExpbmtzIC0gUGluTWVzc2FnZSAtIFNraXBNZXNzYWdlTW9kZXJhdGlvbiAtIFVwZGF0ZU1lc3NhZ2VcbiAgICAgKiBVcGRhdGUgbWVzc2FnZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlTWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlTWVzc2FnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZU1lc3NhZ2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlTWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVzc2FnZXMve2lkfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIG1lc3NhZ2Ugd2l0aCBuZXcgZGF0YSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkTGlua3MgLSBQaW5NZXNzYWdlIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXBkYXRlTWVzc2FnZVxuICAgICAqIFVwZGF0ZSBtZXNzYWdlXG4gICAgICovXG4gICAgdXBkYXRlTWVzc2FnZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZU1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSBtZXNzYWdlICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRMaW5rcyAtIFBpbk1lc3NhZ2UgLSBTa2lwTWVzc2FnZU1vZGVyYXRpb24gLSBVcGRhdGVNZXNzYWdlXG4gICAgICogUGFydGlhbGx5IG1lc3NhZ2UgdXBkYXRlXG4gICAgICovXG4gICAgdXBkYXRlTWVzc2FnZVBhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlTWVzc2FnZVBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVBhcnRpYWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlTWVzc2FnZVBhcnRpYWxSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUGFydGlhbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVNZXNzYWdlUGFydGlhbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVzc2FnZXMve2lkfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSBtZXNzYWdlICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRMaW5rcyAtIFBpbk1lc3NhZ2UgLSBTa2lwTWVzc2FnZU1vZGVyYXRpb24gLSBVcGRhdGVNZXNzYWdlXG4gICAgICogUGFydGlhbGx5IG1lc3NhZ2UgdXBkYXRlXG4gICAgICovXG4gICAgdXBkYXRlTWVzc2FnZVBhcnRpYWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVNZXNzYWdlUGFydGlhbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgZmlsZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBsb2FkQXR0YWNobWVudFxuICAgICAqIFVwbG9hZCBmaWxlXG4gICAgICovXG4gICAgdXBsb2FkRmlsZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwbG9hZEZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwbG9hZEZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25zdW1lcyA9IFtcbiAgICAgICAgICAgICAgICB7IGNvbnRlbnRUeXBlOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBjYW5Db25zdW1lRm9ybSBtYXkgYmUgdW51c2VkXG4gICAgICAgICAgICBjYW5Db25zdW1lRm9ybShjb25zdW1lcyk7XG4gICAgICAgICAgICBsZXQgZm9ybVBhcmFtcztcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3JtUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmZpbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCdmaWxlJywgcmVxdWVzdFBhcmFtZXRlcnMuZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcy5hcHBlbmQoJ3VzZXInLCBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocmVxdWVzdFBhcmFtZXRlcnMudXNlcildLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9maWxlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogZm9ybVBhcmFtcyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGZpbGUgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgZmlsZVxuICAgICAqL1xuICAgIHVwbG9hZEZpbGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGxvYWRGaWxlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBpbWFnZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBsb2FkQXR0YWNobWVudFxuICAgICAqIFVwbG9hZCBpbWFnZVxuICAgICAqL1xuICAgIHVwbG9hZEltYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBsb2FkSW1hZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwbG9hZEltYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29uc3VtZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBjb250ZW50VHlwZTogJ211bHRpcGFydC9mb3JtLWRhdGEnIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogY2FuQ29uc3VtZUZvcm0gbWF5IGJlIHVudXNlZFxuICAgICAgICAgICAgY2FuQ29uc3VtZUZvcm0oY29uc3VtZXMpO1xuICAgICAgICAgICAgbGV0IGZvcm1QYXJhbXM7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5maWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JtUGFyYW1zLmFwcGVuZCgnZmlsZScsIHJlcXVlc3RQYXJhbWV0ZXJzLmZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwbG9hZFNpemVzKSB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcy5hcHBlbmQoJ3VwbG9hZF9zaXplcycsIHJlcXVlc3RQYXJhbWV0ZXJzLnVwbG9hZFNpemVzLmpvaW4oQ09MTEVDVElPTl9GT1JNQVRTW1wiY3N2XCJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcy5hcHBlbmQoJ3VzZXInLCBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocmVxdWVzdFBhcmFtZXRlcnMudXNlcildLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9pbWFnZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1QYXJhbXMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBpbWFnZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBsb2FkQXR0YWNobWVudFxuICAgICAqIFVwbG9hZCBpbWFnZVxuICAgICAqL1xuICAgIHVwbG9hZEltYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBsb2FkSW1hZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBQZXJtaXNzaW9uc1YyQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGN1c3RvbSByb2xlXG4gICAgICogQ3JlYXRlIHJvbGVcbiAgICAgKi9cbiAgICBjcmVhdGVSb2xlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlUm9sZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlUm9sZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZVJvbGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVSb2xlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZVJvbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3JvbGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlUm9sZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gcm9sZVxuICAgICAqIENyZWF0ZSByb2xlXG4gICAgICovXG4gICAgY3JlYXRlUm9sZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZVJvbGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGN1c3RvbSByb2xlXG4gICAgICogRGVsZXRlIHJvbGVcbiAgICAgKi9cbiAgICBkZWxldGVSb2xlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlUm9sZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3JvbGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGN1c3RvbSByb2xlXG4gICAgICogRGVsZXRlIHJvbGVcbiAgICAgKi9cbiAgICBkZWxldGVSb2xlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlUm9sZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY3VzdG9tIHBlcm1pc3Npb25cbiAgICAgKiBHZXQgcGVybWlzc2lvblxuICAgICAqL1xuICAgIGdldFBlcm1pc3Npb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0UGVybWlzc2lvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3Blcm1pc3Npb25zL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGN1c3RvbSBwZXJtaXNzaW9uXG4gICAgICogR2V0IHBlcm1pc3Npb25cbiAgICAgKi9cbiAgICBnZXRQZXJtaXNzaW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0UGVybWlzc2lvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgcGVybWlzc2lvbnNcbiAgICAgKiBMaXN0IHBlcm1pc3Npb25zXG4gICAgICovXG4gICAgbGlzdFBlcm1pc3Npb25zUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3Blcm1pc3Npb25zYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIHBlcm1pc3Npb25zXG4gICAgICogTGlzdCBwZXJtaXNzaW9uc1xuICAgICAqL1xuICAgIGxpc3RQZXJtaXNzaW9ucyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdFBlcm1pc3Npb25zUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIHJvbGVzXG4gICAgICogTGlzdCByb2xlc1xuICAgICAqL1xuICAgIGxpc3RSb2xlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yb2xlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSByb2xlc1xuICAgICAqIExpc3Qgcm9sZXNcbiAgICAgKi9cbiAgICBsaXN0Um9sZXMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RSb2xlc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgUHVzaEFwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBkZXZpY2UgdG8gYSB1c2VyLCBpZiB0aGUgc2FtZSBkZXZpY2UgYWxyZWFkeSBleGlzdHMgdGhlIGNhbGwgd2lsbCBoYXZlIG5vIGVmZmVjdFxuICAgICAqIENyZWF0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBjcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZURldmljZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZURldmljZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZURldmljZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVEZXZpY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZvaWRBcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZURldmljZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyIGZyb20gdjIgd2l0aCBtdWx0aSBidW5kbGUvcGFja2FnZSBzdXBwb3J0LiB2MSBpc25cXCd0IHN1cHBvcnRlZCBpbiB0aGlzIGVuZHBvaW50XG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlclxuICAgICAqL1xuICAgIGRlbGV0ZVB1c2hQcm92aWRlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVB1c2hQcm92aWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wdXNoX3Byb3ZpZGVycy97dHlwZX0ve25hbWV9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlciBmcm9tIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydC4gdjEgaXNuXFwndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbmRwb2ludFxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICBkZWxldGVQdXNoUHJvdmlkZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGRldGFpbHMgb2YgYWxsIHB1c2ggcHJvdmlkZXJzLlxuICAgICAqIExpc3QgcHVzaCBwcm92aWRlcnNcbiAgICAgKi9cbiAgICBsaXN0UHVzaFByb3ZpZGVyc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wdXNoX3Byb3ZpZGVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBkZXRhaWxzIG9mIGFsbCBwdXNoIHByb3ZpZGVycy5cbiAgICAgKiBMaXN0IHB1c2ggcHJvdmlkZXJzXG4gICAgICovXG4gICAgbGlzdFB1c2hQcm92aWRlcnMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RQdXNoUHJvdmlkZXJzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5sZXQgU2VydmVyU2lkZUFwaSQxID0gY2xhc3MgU2VydmVyU2lkZUFwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogVXBzZXJ0IGEgcHVzaCBwcm92aWRlciBmb3IgdjIgd2l0aCBtdWx0aSBidW5kbGUvcGFja2FnZSBzdXBwb3J0XG4gICAgICogVXBzZXJ0IGEgcHVzaCBwcm92aWRlclxuICAgICAqL1xuICAgIHVwc2VydFB1c2hQcm92aWRlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwc2VydFB1c2hQcm92aWRlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwc2VydFB1c2hQcm92aWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcHVzaF9wcm92aWRlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cHNlcnRQdXNoUHJvdmlkZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwc2VydCBhIHB1c2ggcHJvdmlkZXIgZm9yIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydFxuICAgICAqIFVwc2VydCBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICB1cHNlcnRQdXNoUHJvdmlkZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cHNlcnRQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xubGV0IFNldHRpbmdzQXBpJDEgPSBjbGFzcyBTZXR0aW5nc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0ZXN0IG1lc3NhZ2UgdmlhIHB1c2gsIHRoaXMgaXMgYSB0ZXN0IGVuZHBvaW50IHRvIHZlcmlmeSB5b3VyIHB1c2ggc2V0dGluZ3NcbiAgICAgKiBDaGVjayBwdXNoXG4gICAgICovXG4gICAgY2hlY2tQdXNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1B1c2hSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjaGVja1B1c2hSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1B1c2hSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tQdXNoLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGVja19wdXNoYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHRlc3QgbWVzc2FnZSB2aWEgcHVzaCwgdGhpcyBpcyBhIHRlc3QgZW5kcG9pbnQgdG8gdmVyaWZ5IHlvdXIgcHVzaCBzZXR0aW5nc1xuICAgICAqIENoZWNrIHB1c2hcbiAgICAgKi9cbiAgICBjaGVja1B1c2gocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jaGVja1B1c2hSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNOUyBjb25maWd1cmF0aW9uXG4gICAgICogQ2hlY2sgU05TXG4gICAgICovXG4gICAgY2hlY2tTTlNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjaGVja1NOU1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU05TUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNoZWNrU05TLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGVja19zbnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTTlMgY29uZmlndXJhdGlvblxuICAgICAqIENoZWNrIFNOU1xuICAgICAqL1xuICAgIGNoZWNrU05TKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tTTlNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNRUyBjcmVkZW50aWFsc1xuICAgICAqIENoZWNrIFNRU1xuICAgICAqL1xuICAgIGNoZWNrU1FTUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tTUVNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NRU1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja1NRUy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfc3FzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBBbWF6b24gU1FTIGNyZWRlbnRpYWxzXG4gICAgICogQ2hlY2sgU1FTXG4gICAgICovXG4gICAgY2hlY2tTUVMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jaGVja1NRU1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXBwbGljYXRpb24gYmxvY2tsaXN0LCBvbmNlIGNyZWF0ZWQgdGhlIGJsb2NrbGlzdCBjYW4gYmUgdXNlZCBieSBhbnkgY2hhbm5lbCB0eXBlXG4gICAgICogQ3JlYXRlIGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICBjcmVhdGVCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVCbG9ja0xpc3RSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUJsb2NrTGlzdFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZUJsb2NrTGlzdFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUJsb2NrTGlzdFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVCbG9ja0xpc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVCbG9ja0xpc3RSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXBwbGljYXRpb24gYmxvY2tsaXN0LCBvbmNlIGNyZWF0ZWQgdGhlIGJsb2NrbGlzdCBjYW4gYmUgdXNlZCBieSBhbnkgY2hhbm5lbCB0eXBlXG4gICAgICogQ3JlYXRlIGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICBjcmVhdGVCbG9ja0xpc3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBjaGFubmVsIHR5cGVcbiAgICAgKiBDcmVhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgY3JlYXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUNoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgY2hhbm5lbCB0eXBlXG4gICAgICogQ3JlYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgY3JlYXRlZCBhcHBsaWNhdGlvbiBibG9ja2xpc3RcbiAgICAgKiBEZWxldGUgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIGRlbGV0ZUJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUJsb2NrTGlzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgcHJldmlvdXNseSBjcmVhdGVkIGFwcGxpY2F0aW9uIGJsb2NrbGlzdFxuICAgICAqIERlbGV0ZSBibG9jayBsaXN0XG4gICAgICovXG4gICAgZGVsZXRlQmxvY2tMaXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBEZWxldGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgZGVsZXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWx0eXBlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBEZWxldGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgZGVsZXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXIgZnJvbSB2MiB3aXRoIG11bHRpIGJ1bmRsZS9wYWNrYWdlIHN1cHBvcnQuIHYxIGlzblxcJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW5kcG9pbnRcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyXG4gICAgICovXG4gICAgZGVsZXRlUHVzaFByb3ZpZGVyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlUHVzaFByb3ZpZGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVB1c2hQcm92aWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3B1c2hfcHJvdmlkZXJzL3t0eXBlfS97bmFtZX1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyIGZyb20gdjIgd2l0aCBtdWx0aSBidW5kbGUvcGFja2FnZSBzdXBwb3J0LiB2MSBpc25cXCd0IHN1cHBvcnRlZCBpbiB0aGlzIGVuZHBvaW50XG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlclxuICAgICAqL1xuICAgIGRlbGV0ZVB1c2hQcm92aWRlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZVB1c2hQcm92aWRlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAgICogR2V0IEFwcCBTZXR0aW5nc1xuICAgICAqL1xuICAgIGdldEFwcFJhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9hcHBgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAgICogR2V0IEFwcCBTZXR0aW5nc1xuICAgICAqL1xuICAgIGdldEFwcChpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0QXBwUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJsb2NrIGxpc3QgYnkgZ2l2ZW4gbmFtZVxuICAgICAqIEdldCBibG9jayBsaXN0XG4gICAgICovXG4gICAgZ2V0QmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0QmxvY2tMaXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvYmxvY2tsaXN0cy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBibG9jayBsaXN0IGJ5IGdpdmVuIG5hbWVcbiAgICAgKiBHZXQgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIGdldEJsb2NrTGlzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldEJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2hhbm5lbCB0eXBlXG4gICAgICogR2V0IGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGdldENoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0Q2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2hhbm5lbCB0eXBlXG4gICAgICogR2V0IGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGdldENoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0Q2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcmF0ZSBsaW1pdHMgdXNhZ2UgYW5kIHF1b3Rhc1xuICAgICAqIEdldCByYXRlIGxpbWl0c1xuICAgICAqL1xuICAgIGdldFJhdGVMaW1pdHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnNlcnZlclNpZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snc2VydmVyX3NpZGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnNlcnZlclNpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuYW5kcm9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydhbmRyb2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5hbmRyb2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpb3MnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy53ZWIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snd2ViJ10gPSByZXF1ZXN0UGFyYW1ldGVycy53ZWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZW5kcG9pbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2VuZHBvaW50cyddID0gcmVxdWVzdFBhcmFtZXRlcnMuZW5kcG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3JhdGVfbGltaXRzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcmF0ZSBsaW1pdHMgdXNhZ2UgYW5kIHF1b3Rhc1xuICAgICAqIEdldCByYXRlIGxpbWl0c1xuICAgICAqL1xuICAgIGdldFJhdGVMaW1pdHMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldFJhdGVMaW1pdHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBhdmFpbGFibGUgYmxvY2sgbGlzdHNcbiAgICAgKiBMaXN0IGJsb2NrIGxpc3RzXG4gICAgICovXG4gICAgbGlzdEJsb2NrTGlzdHNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvYmxvY2tsaXN0c2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGJsb2NrIGxpc3RzXG4gICAgICogTGlzdCBibG9jayBsaXN0c1xuICAgICAqL1xuICAgIGxpc3RCbG9ja0xpc3RzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0QmxvY2tMaXN0c1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSBjaGFubmVsIHR5cGVzXG4gICAgICogTGlzdCBjaGFubmVsIHR5cGVzXG4gICAgICovXG4gICAgbGlzdENoYW5uZWxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgY2hhbm5lbCB0eXBlc1xuICAgICAqIExpc3QgY2hhbm5lbCB0eXBlc1xuICAgICAqL1xuICAgIGxpc3RDaGFubmVsVHlwZXMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RDaGFubmVsVHlwZXNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgZGV0YWlscyBvZiBhbGwgcHVzaCBwcm92aWRlcnMuXG4gICAgICogTGlzdCBwdXNoIHByb3ZpZGVyc1xuICAgICAqL1xuICAgIGxpc3RQdXNoUHJvdmlkZXJzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3B1c2hfcHJvdmlkZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGRldGFpbHMgb2YgYWxsIHB1c2ggcHJvdmlkZXJzLlxuICAgICAqIExpc3QgcHVzaCBwcm92aWRlcnNcbiAgICAgKi9cbiAgICBsaXN0UHVzaFByb3ZpZGVycyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdFB1c2hQcm92aWRlcnNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgb25lIG9yIG1vcmUgYXBwbGljYXRpb24gc2V0dGluZ3NcbiAgICAgKiBVcGRhdGUgQXBwIFNldHRpbmdzXG4gICAgICovXG4gICAgdXBkYXRlQXBwUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQXBwUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVBcHBSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVBcHBSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVBcHBSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQXBwLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9hcHBgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQXBwUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIG9uZSBvciBtb3JlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAgICogVXBkYXRlIEFwcCBTZXR0aW5nc1xuICAgICAqL1xuICAgIHVwZGF0ZUFwcChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUFwcFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udGVudHMgb2YgdGhlIGJsb2NrIGxpc3RcbiAgICAgKiBVcGRhdGUgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIHVwZGF0ZUJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUJsb2NrTGlzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUJsb2NrTGlzdFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZUJsb2NrTGlzdFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUJsb2NrTGlzdFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVCbG9ja0xpc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUJsb2NrTGlzdFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjb250ZW50cyBvZiB0aGUgYmxvY2sgbGlzdFxuICAgICAqIFVwZGF0ZSBibG9jayBsaXN0XG4gICAgICovXG4gICAgdXBkYXRlQmxvY2tMaXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBVcGRhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNoYW5uZWwgdHlwZVxuICAgICAqIFVwZGF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICB1cGRhdGVDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFRhc2tzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHN0YXR1cyBvZiBhIHRhc2tcbiAgICAgKiBHZXQgc3RhdHVzIG9mIGEgdGFza1xuICAgICAqL1xuICAgIGdldFRhc2tSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0VGFzay4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3Rhc2tzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHN0YXR1cyBvZiBhIHRhc2tcbiAgICAgKiBHZXQgc3RhdHVzIG9mIGEgdGFza1xuICAgICAqL1xuICAgIGdldFRhc2socmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRUYXNrUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgVGVzdGluZ0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0ZXN0IG1lc3NhZ2UgdmlhIHB1c2gsIHRoaXMgaXMgYSB0ZXN0IGVuZHBvaW50IHRvIHZlcmlmeSB5b3VyIHB1c2ggc2V0dGluZ3NcbiAgICAgKiBDaGVjayBwdXNoXG4gICAgICovXG4gICAgY2hlY2tQdXNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1B1c2hSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjaGVja1B1c2hSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1B1c2hSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tQdXNoLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGVja19wdXNoYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHRlc3QgbWVzc2FnZSB2aWEgcHVzaCwgdGhpcyBpcyBhIHRlc3QgZW5kcG9pbnQgdG8gdmVyaWZ5IHlvdXIgcHVzaCBzZXR0aW5nc1xuICAgICAqIENoZWNrIHB1c2hcbiAgICAgKi9cbiAgICBjaGVja1B1c2gocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jaGVja1B1c2hSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNOUyBjb25maWd1cmF0aW9uXG4gICAgICogQ2hlY2sgU05TXG4gICAgICovXG4gICAgY2hlY2tTTlNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjaGVja1NOU1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU05TUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNoZWNrU05TLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGVja19zbnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTTlMgY29uZmlndXJhdGlvblxuICAgICAqIENoZWNrIFNOU1xuICAgICAqL1xuICAgIGNoZWNrU05TKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tTTlNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNRUyBjcmVkZW50aWFsc1xuICAgICAqIENoZWNrIFNRU1xuICAgICAqL1xuICAgIGNoZWNrU1FTUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tTUVNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NRU1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja1NRUy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfc3FzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBBbWF6b24gU1FTIGNyZWRlbnRpYWxzXG4gICAgICogQ2hlY2sgU1FTXG4gICAgICovXG4gICAgY2hlY2tTUVMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jaGVja1NRU1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFVzZXJzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBSZXN0cmljdHMgdXNlciBhY3Rpdml0eSBlaXRoZXIgaW4gc3BlY2lmaWMgY2hhbm5lbCBvciBnbG9iYWxseSAgU2VuZHMgZXZlbnRzOiAtIHVzZXIuYmFubmVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBCYW5DaGFubmVsTWVtYmVyIC0gQmFuVXNlclxuICAgICAqIEJhbiB1c2VyXG4gICAgICovXG4gICAgYmFuUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuYmFuUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5iYW5SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdiYW5SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5iYW5SZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgYmFuLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL2JhbmAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmJhblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdHJpY3RzIHVzZXIgYWN0aXZpdHkgZWl0aGVyIGluIHNwZWNpZmljIGNoYW5uZWwgb3IgZ2xvYmFsbHkgIFNlbmRzIGV2ZW50czogLSB1c2VyLmJhbm5lZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQmFuQ2hhbm5lbE1lbWJlciAtIEJhblVzZXJcbiAgICAgKiBCYW4gdXNlclxuICAgICAqL1xuICAgIGJhbihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmJhblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci51cGRhdGVkXG4gICAgICogQ29ubmVjdCAoV2ViU29ja2V0KVxuICAgICAqL1xuICAgIGNvbm5lY3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmpzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snanNvbiddID0gcmVxdWVzdFBhcmFtZXRlcnMuanNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb25uZWN0YCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlcyBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIENvbm5lY3QgKFdlYlNvY2tldClcbiAgICAgKi9cbiAgICBjb25uZWN0KHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGd1ZXN0IHVzZXJcbiAgICAgKiBDcmVhdGUgZ3Vlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVHdWVzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmd1ZXN0UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5ndWVzdFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2d1ZXN0UmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZ3Vlc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlR3Vlc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2d1ZXN0YCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZ3Vlc3RSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZ3Vlc3QgdXNlclxuICAgICAqIENyZWF0ZSBndWVzdFxuICAgICAqL1xuICAgIGNyZWF0ZUd1ZXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlR3Vlc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyB1c2VyIHdpdGggcG9zc2liaWxpdHkgdG8gYWN0aXZhdGUgaXQgYmFjayAgU2VuZHMgZXZlbnRzOiAtIHVzZXIuZGVhY3RpdmF0ZWRcbiAgICAgKiBEZWFjdGl2YXRlIHVzZXJcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VzZXJJZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVhY3RpdmF0ZVVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2VyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWFjdGl2YXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9L2RlYWN0aXZhdGVgLnJlcGxhY2UoYHske1widXNlcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGVzIHVzZXIgd2l0aCBwb3NzaWJpbGl0eSB0byBhY3RpdmF0ZSBpdCBiYWNrICBTZW5kcyBldmVudHM6IC0gdXNlci5kZWFjdGl2YXRlZFxuICAgICAqIERlYWN0aXZhdGUgdXNlclxuICAgICAqL1xuICAgIGRlYWN0aXZhdGVVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVhY3RpdmF0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlIHVzZXJzIGluIGJhdGNoZXMgIFNlbmRzIGV2ZW50czogLSB1c2VyLmRlYWN0aXZhdGVkXG4gICAgICogRGVhY3RpdmF0ZSB1c2Vyc1xuICAgICAqL1xuICAgIGRlYWN0aXZhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlYWN0aXZhdGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMvZGVhY3RpdmF0ZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZSB1c2VycyBpbiBiYXRjaGVzICBTZW5kcyBldmVudHM6IC0gdXNlci5kZWFjdGl2YXRlZFxuICAgICAqIERlYWN0aXZhdGUgdXNlcnNcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWFjdGl2YXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHVzZXIgYW5kIG9wdGlvbmFsbHkgYWxsIHRoZWlyIGJlbG9uZ2luZ3MuIFRoZSBFbmRwb2ludCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFxcJ0RlbGV0ZSBVc2Vyc1xcJyBlbmRwb2ludCBpbnN0ZWFkICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkIC0gbWVzc2FnZS5kZWxldGVkIC0gdXNlci5kZWxldGVkXG4gICAgICogRGVsZXRlIHVzZXJcbiAgICAgKi9cbiAgICBkZWxldGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXNlcklkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya01lc3NhZ2VzRGVsZXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydtYXJrX21lc3NhZ2VzX2RlbGV0ZWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtNZXNzYWdlc0RlbGV0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaGFyZERlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydoYXJkX2RlbGV0ZSddID0gcmVxdWVzdFBhcmFtZXRlcnMuaGFyZERlbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVDb252ZXJzYXRpb25DaGFubmVscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydkZWxldGVfY29udmVyc2F0aW9uX2NoYW5uZWxzJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVDb252ZXJzYXRpb25DaGFubmVscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC91c2Vycy97dXNlcl9pZH1gLnJlcGxhY2UoYHske1widXNlcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHVzZXIgYW5kIG9wdGlvbmFsbHkgYWxsIHRoZWlyIGJlbG9uZ2luZ3MuIFRoZSBFbmRwb2ludCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIFxcJ0RlbGV0ZSBVc2Vyc1xcJyBlbmRwb2ludCBpbnN0ZWFkICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkIC0gbWVzc2FnZS5kZWxldGVkIC0gdXNlci5kZWxldGVkXG4gICAgICogRGVsZXRlIHVzZXJcbiAgICAgKi9cbiAgICBkZWxldGVVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdXNlcnMgYW5kIG9wdGlvbmFsbHkgYWxsIHRoZWlyIGJlbG9uZ2luZ3MgYXN5bmNocm9ub3VzbHkuICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkIC0gdXNlci5kZWxldGVkXG4gICAgICogRGVsZXRlIFVzZXJzXG4gICAgICovXG4gICAgZGVsZXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlVXNlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdkZWxldGVVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZVVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVVzZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC91c2Vycy9kZWxldGVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB1c2VycyBhbmQgb3B0aW9uYWxseSBhbGwgdGhlaXIgYmVsb25naW5ncyBhc3luY2hyb25vdXNseS4gIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmRlbGV0ZWQgLSB1c2VyLmRlbGV0ZWRcbiAgICAgKiBEZWxldGUgVXNlcnNcbiAgICAgKi9cbiAgICBkZWxldGVVc2VycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgdXNlclxcJ3MgcHJvZmlsZSwgcmVhY3Rpb25zIGFuZCBtZXNzYWdlcy4gUmFpc2VzIGFuIGVycm9yIGlmIGEgdXNlciBoYXMgbW9yZSB0aGFuIDEwayBtZXNzYWdlcyBvciByZWFjdGlvbnNcbiAgICAgKiBFeHBvcnQgdXNlclxuICAgICAqL1xuICAgIGV4cG9ydFVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1c2VySWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGV4cG9ydFVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC91c2Vycy97dXNlcl9pZH0vZXhwb3J0YC5yZXBsYWNlKGB7JHtcInVzZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgdXNlclxcJ3MgcHJvZmlsZSwgcmVhY3Rpb25zIGFuZCBtZXNzYWdlcy4gUmFpc2VzIGFuIGVycm9yIGlmIGEgdXNlciBoYXMgbW9yZSB0aGFuIDEwayBtZXNzYWdlcyBvciByZWFjdGlvbnNcbiAgICAgKiBFeHBvcnQgdXNlclxuICAgICAqL1xuICAgIGV4cG9ydFVzZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5leHBvcnRVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB1c2VyIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMgZm9yIGxpc3Qgb2YgZ2l2ZW4gdXNlcnNcbiAgICAgKiBFeHBvcnQgdXNlcnNcbiAgICAgKi9cbiAgICBleHBvcnRVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydFVzZXJzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2V4cG9ydFVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0VXNlcnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZXhwb3J0VXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2V4cG9ydC91c2Vyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydFVzZXJzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHVzZXIgcHJvZmlsZSwgcmVhY3Rpb25zIGFuZCBtZXNzYWdlcyBmb3IgbGlzdCBvZiBnaXZlbiB1c2Vyc1xuICAgICAqIEV4cG9ydCB1c2Vyc1xuICAgICAqL1xuICAgIGV4cG9ydFVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZXhwb3J0VXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIG1lc3NhZ2Ugb3IgdXNlciBmb3IgcmV2aWV3IGJ5IG1vZGVyYXRvcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmZsYWdnZWQgLSB1c2VyLmZsYWdnZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBGbGFnXG4gICAgICovXG4gICAgZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdmbGFnUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBmbGFnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL2ZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIG1lc3NhZ2Ugb3IgdXNlciBmb3IgcmV2aWV3IGJ5IG1vZGVyYXRvcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmZsYWdnZWQgLSB1c2VyLmZsYWdnZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBGbGFnXG4gICAgICovXG4gICAgZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZWJTb2NrZXQgZmFsbGJhY2sgdHJhbnNwb3J0IGVuZHBvaW50ICBTZW5kcyBldmVudHM6IC0gdXNlci51cGRhdGVkXG4gICAgICogTG9uZyBQb2xsIChUcmFuc3BvcnQpXG4gICAgICovXG4gICAgbG9uZ1BvbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmpzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snanNvbiddID0gcmVxdWVzdFBhcmFtZXRlcnMuanNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snY29ubmVjdGlvbl9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuY29ubmVjdGlvbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2xvbmdwb2xsYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZWJTb2NrZXQgZmFsbGJhY2sgdHJhbnNwb3J0IGVuZHBvaW50ICBTZW5kcyBldmVudHM6IC0gdXNlci51cGRhdGVkXG4gICAgICogTG9uZyBQb2xsIChUcmFuc3BvcnQpXG4gICAgICovXG4gICAgbG9uZ1BvbGwocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5sb25nUG9sbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdXRlcyBvbmUgb3Igc2V2ZXJhbCB1c2VycyAgU2VuZHMgZXZlbnRzOiAtIHVzZXIubXV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIE11dGVVc2VyXG4gICAgICogTXV0ZSB1c2VyXG4gICAgICovXG4gICAgbXV0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tdXRlVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubXV0ZVVzZXJSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdtdXRlVXNlclJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVVc2VyUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG11dGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL211dGVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5tdXRlVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgb25lIG9yIHNldmVyYWwgdXNlcnMgIFNlbmRzIGV2ZW50czogLSB1c2VyLm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIE11dGUgdXNlclxuICAgICAqL1xuICAgIG11dGVVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubXV0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgY2hhbm5lbCBzY29wZWQgb3IgZ2xvYmFsIHVzZXIgYmFucyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBCYW5uZWQgVXNlcnNcbiAgICAgKi9cbiAgICBxdWVyeUJhbm5lZFVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcXVlcnlfYmFubmVkX3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgY2hhbm5lbCBzY29wZWQgb3IgZ2xvYmFsIHVzZXIgYmFucyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBCYW5uZWQgVXNlcnNcbiAgICAgKi9cbiAgICBxdWVyeUJhbm5lZFVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5xdWVyeUJhbm5lZFVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIHVzZXJzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTZWFyY2hVc2VyXG4gICAgICogUXVlcnkgdXNlcnNcbiAgICAgKi9cbiAgICBxdWVyeVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIGZpbHRlciB1c2VycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VhcmNoVXNlclxuICAgICAqIFF1ZXJ5IHVzZXJzXG4gICAgICovXG4gICAgcXVlcnlVc2VycyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB1c2VyIHdob1xcJ3MgYmVlbiBkZWFjdGl2YXRlZCBwcmV2aW91c2x5ICBTZW5kcyBldmVudHM6IC0gdXNlci5yZWFjdGl2YXRlZFxuICAgICAqIFJlYWN0aXZhdGUgdXNlclxuICAgICAqL1xuICAgIHJlYWN0aXZhdGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXNlcklkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyByZWFjdGl2YXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGl2YXRlVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdyZWFjdGl2YXRlVXNlclJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2VyUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHJlYWN0aXZhdGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC91c2Vycy97dXNlcl9pZH0vcmVhY3RpdmF0ZWAucmVwbGFjZShgeyR7XCJ1c2VyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGl2YXRlVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHVzZXIgd2hvXFwncyBiZWVuIGRlYWN0aXZhdGVkIHByZXZpb3VzbHkgIFNlbmRzIGV2ZW50czogLSB1c2VyLnJlYWN0aXZhdGVkXG4gICAgICogUmVhY3RpdmF0ZSB1c2VyXG4gICAgICovXG4gICAgcmVhY3RpdmF0ZVVzZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZWFjdGl2YXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWN0aXZhdGUgdXNlcnMgaW4gYmF0Y2hlcyAgU2VuZHMgZXZlbnRzOiAtIHVzZXIucmVhY3RpdmF0ZWRcbiAgICAgKiBSZWFjdGl2YXRlIHVzZXJzXG4gICAgICovXG4gICAgcmVhY3RpdmF0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGl2YXRlVXNlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdyZWFjdGl2YXRlVXNlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGl2YXRlVXNlcnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcmVhY3RpdmF0ZVVzZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC91c2Vycy9yZWFjdGl2YXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFjdGl2YXRlIHVzZXJzIGluIGJhdGNoZXMgIFNlbmRzIGV2ZW50czogLSB1c2VyLnJlYWN0aXZhdGVkXG4gICAgICogUmVhY3RpdmF0ZSB1c2Vyc1xuICAgICAqL1xuICAgIHJlYWN0aXZhdGVVc2VycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlYWN0aXZhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgc29mdCBkZWxldGVkIHVzZXJzXG4gICAgICogUmVzdG9yZSB1c2Vyc1xuICAgICAqL1xuICAgIHJlc3RvcmVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3RvcmVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMucmVzdG9yZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncmVzdG9yZVVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMucmVzdG9yZVVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHJlc3RvcmVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMvcmVzdG9yZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3RvcmVVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdG9yZSBzb2Z0IGRlbGV0ZWQgdXNlcnNcbiAgICAgKiBSZXN0b3JlIHVzZXJzXG4gICAgICovXG4gICAgcmVzdG9yZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVzdG9yZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBwcmV2aW91c2x5IGFwcGxpZWQgYmFuICBTZW5kcyBldmVudHM6IC0gdXNlci51bmJhbm5lZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQmFuQ2hhbm5lbE1lbWJlciAtIEJhblVzZXJcbiAgICAgKiBVbmJhbiB1c2VyXG4gICAgICovXG4gICAgdW5iYW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldFVzZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd0YXJnZXRfdXNlcl9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMudGFyZ2V0VXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndHlwZSddID0gcmVxdWVzdFBhcmFtZXRlcnMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2NyZWF0ZWRfYnknXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRCeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL2JhbmAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBwcmV2aW91c2x5IGFwcGxpZWQgYmFuICBTZW5kcyBldmVudHM6IC0gdXNlci51bmJhbm5lZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQmFuQ2hhbm5lbE1lbWJlciAtIEJhblVzZXJcbiAgICAgKiBVbmJhbiB1c2VyXG4gICAgICovXG4gICAgdW5iYW4ocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVuYmFuUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBwcmV2aW91c2x5IGNyZWF0ZWQgdXNlciBvciBtZXNzYWdlIGZsYWcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBVbmZsYWdcbiAgICAgKi9cbiAgICB1bmZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZmxhZ1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5mbGFnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL3VuZmxhZ2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBjcmVhdGVkIHVzZXIgb3IgbWVzc2FnZSBmbGFnICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogVW5mbGFnXG4gICAgICovXG4gICAgdW5mbGFnKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudW5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5tdXRlcyBwcmV2aW91c2x5IG11dGVkIHVzZXIgIFNlbmRzIGV2ZW50czogLSB1c2VyLnVubXV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIE11dGVVc2VyXG4gICAgICogVW5tdXRlIHVzZXJcbiAgICAgKi9cbiAgICB1bm11dGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudW5tdXRlVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudW5tdXRlVXNlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VubXV0ZVVzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51bm11dGVVc2VyUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVubXV0ZVVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21vZGVyYXRpb24vdW5tdXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudW5tdXRlVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5tdXRlcyBwcmV2aW91c2x5IG11dGVkIHVzZXIgIFNlbmRzIGV2ZW50czogLSB1c2VyLnVubXV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIE11dGVVc2VyXG4gICAgICogVW5tdXRlIHVzZXJcbiAgICAgKi9cbiAgICB1bm11dGVVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudW5tdXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBvciBjcmVhdGUgdXNlcnMgaW4gYnVsayAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIFVwc2VydCB1c2Vyc1xuICAgICAqL1xuICAgIHVwZGF0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlVXNlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG9yIGNyZWF0ZSB1c2VycyBpbiBidWxrICBTZW5kcyBldmVudHM6IC0gdXNlci51cGRhdGVkXG4gICAgICogVXBzZXJ0IHVzZXJzXG4gICAgICovXG4gICAgdXBkYXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2VydGFpbiBmaWVsZHMgb2YgdGhlIHVzZXIgIFNlbmRzIGV2ZW50czogLSB1c2VyLnByZXNlbmNlLmNoYW5nZWQgLSB1c2VyLnVwZGF0ZWRcbiAgICAgKiBQYXJ0aWFsbHkgdXBkYXRlIHVzZXJcbiAgICAgKi9cbiAgICB1cGRhdGVVc2Vyc1BhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2VyUGFydGlhbFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlclBhcnRpYWxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVVc2VyUGFydGlhbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJQYXJ0aWFsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZVVzZXJzUGFydGlhbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlclBhcnRpYWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2VydGFpbiBmaWVsZHMgb2YgdGhlIHVzZXIgIFNlbmRzIGV2ZW50czogLSB1c2VyLnByZXNlbmNlLmNoYW5nZWQgLSB1c2VyLnVwZGF0ZWRcbiAgICAgKiBQYXJ0aWFsbHkgdXBkYXRlIHVzZXJcbiAgICAgKi9cbiAgICB1cGRhdGVVc2Vyc1BhcnRpYWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVVc2Vyc1BhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtQ2xpZW50LCB0eXBlLCBpZCkge1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5kZWxldGVDaGFubmVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIChyZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUgPSAodXBkYXRlQ2hhbm5lbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLnVwZGF0ZUNoYW5uZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB1cGRhdGVDaGFubmVsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlUGFydGlhbCA9ICh1cGRhdGVDaGFubmVsUGFydGlhbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLnVwZGF0ZUNoYW5uZWxQYXJ0aWFsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRPckNyZWF0ZSA9IChjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmNoYW5uZWxzQXBpLmdldE9yQ3JlYXRlQ2hhbm5lbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3Q6IGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgIT09IG51bGwgJiYgY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCAhPT0gdm9pZCAwID8gY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCA6IHt9IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBvcGVyYXRpb24gaXNuJ3QgeWV0IGltcGxlbWVudGVkYCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKCFjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0Py5kYXRhPy5tZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHByb3ZpZGUgbWVtYmVycyB0byBjcmVhdGUgYSBjaGFubmVsIHdpdGhvdXQgSUQnKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNoYW5uZWxzQXBpLmdldE9yQ3JlYXRlQ2hhbm5lbFR5cGUxKHt0eXBlOiB0aGlzLnR5cGUsIGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3R9KTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmlkID0gcmVzcG9uc2UuY2hhbm5lbD8uaWQ7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrUmVhZCA9IChtYXJrUmVhZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLm1hcmtSZWFkKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgbWFya1JlYWRSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYXJrVW5yZWFkID0gKG1hcmtVbnJlYWRSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5tYXJrVW5yZWFkKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgbWFya1VucmVhZFJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNob3cgPSAoc2hvd0NoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5zaG93Q2hhbm5lbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHNob3dDaGFubmVsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGlkZSA9IChoaWRlQ2hhbm5lbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLmhpZGVDaGFubmVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgaGlkZUNoYW5uZWxSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cnVuY2F0ZSA9ICh0cnVuY2F0ZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS50cnVuY2F0ZUNoYW5uZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB0cnVuY2F0ZUNoYW5uZWxSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWVyeU1lbWJlcnMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkucXVlcnlNZW1iZXJzKHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCByZXF1ZXN0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm11dGUgPSAobXV0ZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5tdXRlQ2hhbm5lbCh7XG4gICAgICAgICAgICAgICAgbXV0ZUNoYW5uZWxSZXF1ZXN0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG11dGVDaGFubmVsUmVxdWVzdCksIHsgY2hhbm5lbF9jaWRzOiBbdGhpcy5jaWRdIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5tdXRlID0gKHVubXV0ZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS51bm11dGVDaGFubmVsKHtcbiAgICAgICAgICAgICAgICB1bm11dGVDaGFubmVsUmVxdWVzdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1bm11dGVDaGFubmVsUmVxdWVzdCksIHsgY2hhbm5lbF9jaWQ6IHRoaXMuY2lkLCBjaGFubmVsX2NpZHM6IFtdIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IHRoZXJlIGlzIHByb2JhYmx5IGFuIGlzc3VlIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlIGhlcmVcbiAgICAgICAgLy8gdXBsb2FkRmlsZSA9IChvcHRpb25zOiBPbWl0PE9taXRUeXBlSWQ8VXBsb2FkRmlsZVJlcXVlc3Q+LCAnZmlsZSc+LCBmaWxlOiBCdWZmZXIpID0+IHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS51cGxvYWRGaWxlKHsuLi5vcHRpb25zLCAuLi50aGlzLmJhc2VSZXF1ZXN0LCBmaWxlOiBmaWxlIGFzIGFueSBhcyBzdHJpbmd9KTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBkZWxldGVGaWxlID0gKHJlcXVlc3Q6IE9taXRUeXBlSWQ8RGVsZXRlRmlsZVJlcXVlc3Q+KSA9PiB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZGVsZXRlRmlsZSh7Li4ucmVxdWVzdCwgLi4udGhpcy5iYXNlUmVxdWVzdH0pO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHVwbG9hZEltYWdlID0gKHJlcXVlc3Q6IE9taXRUeXBlSWQ8VXBsb2FkSW1hZ2VSZXF1ZXN0PikgPT4ge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnVwbG9hZEltYWdlKHsuLi5yZXF1ZXN0LCAuLi50aGlzLmJhc2VSZXF1ZXN0fSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZGVsZXRlSW1hZ2UgPSAocmVxdWVzdDogT21pdFR5cGVJZDxEZWxldGVJbWFnZVJlcXVlc3Q+KSA9PiB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZGVsZXRlSW1hZ2Uoey4uLnJlcXVlc3QsIC4uLnRoaXMuYmFzZVJlcXVlc3R9KTtcbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlID0gKHNlbmRNZXNzYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuc2VuZE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyBzZW5kTWVzc2FnZVJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZU1lc3NhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZGVsZXRlTWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVNZXNzYWdlID0gKGlkLCB1cGRhdGVNZXNzYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudXBkYXRlTWVzc2FnZSh7IGlkLCB1cGRhdGVNZXNzYWdlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVNZXNzYWdlUGFydGlhbCA9IChpZCwgdXBkYXRlTWVzc2FnZVBhcnRpYWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS51cGRhdGVNZXNzYWdlUGFydGlhbCh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgdXBkYXRlTWVzc2FnZVBhcnRpYWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0TWVzc2FnZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS5nZXRNZXNzYWdlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE1hbnlNZXNzYWdlcyA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS5nZXRNYW55TWVzc2FnZXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZU1lc3NhZ2UgPSAoaWQsIHRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS50cmFuc2xhdGVNZXNzYWdlKHsgaWQsIHRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE1lc3NhZ2VzQXJvdW5kID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmdldFJlcGxpZXMocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T3BlbkdyYXBoRGF0YSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS5nZXRPRyhyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVJlYWN0aW9uID0gKG1lc3NhZ2VJZCwgc2VuZFJlYWN0aW9uUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuc2VuZFJlYWN0aW9uKHtcbiAgICAgICAgICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHNlbmRSZWFjdGlvblJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVNZXNzYWdlUmVhY3Rpb24gPSAobWVzc2FnZUlkLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS5kZWxldGVSZWFjdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IGlkOiBtZXNzYWdlSWQgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE1lc3NhZ2VSZWFjdGlvbnMgPSAobWVzc2FnZUlkLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS5nZXRSZWFjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAocmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDoge30pKSwgeyBpZDogbWVzc2FnZUlkIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kQ3VzdG9tRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50c0FwaS5zZW5kRXZlbnQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyBzZW5kRXZlbnRSZXF1ZXN0OiB7IGV2ZW50IH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5zdHJlYW1DbGllbnQuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmNoYW5uZWxzQXBpID0gbmV3IENoYW5uZWxzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLm1lc3NhZ2VzQXBpID0gbmV3IE1lc3NhZ2VzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmV2ZW50c0FwaSA9IG5ldyBFdmVudHNBcGkoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGdldCBjaWQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VSZXF1ZXN0LnR5cGV9OiR7dGhpcy5iYXNlUmVxdWVzdC5pZH1gO1xuICAgIH1cbiAgICBnZXQgYmFzZVJlcXVlc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBpbml0aWFsaXplIHRoZSBjaGFubmVsIHdpdGggYGdldE9yQ3JlYXRlYCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIFN0cmVhbUNoYXRDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbUNsaWVudCkge1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gKHR5cGUsIGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUNoYW5uZWwodGhpcy5zdHJlYW1DbGllbnQsIHR5cGUsIGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVCbG9ja0xpc3QgPSAoY3JlYXRlQmxvY2tMaXN0UmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuY3JlYXRlQmxvY2tMaXN0KHsgY3JlYXRlQmxvY2tMaXN0UmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0QmxvY2tMaXN0cyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmxpc3RCbG9ja0xpc3RzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0QmxvY2tMaXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmdldEJsb2NrTGlzdChyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVCbG9ja0xpc3QgPSAobmFtZSwgdXBkYXRlQmxvY2tMaXN0UmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkudXBkYXRlQmxvY2tMaXN0KHsgbmFtZSwgdXBkYXRlQmxvY2tMaXN0UmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVCbG9ja0xpc3QgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuZGVsZXRlQmxvY2tMaXN0KHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUNoYW5uZWxUeXBlID0gKGNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGVzQXBpLmNyZWF0ZUNoYW5uZWxUeXBlKHsgY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZUNoYW5uZWxUeXBlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxUeXBlc0FwaS5kZWxldGVDaGFubmVsVHlwZShyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDaGFubmVsVHlwZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsVHlwZXNBcGkuZ2V0Q2hhbm5lbFR5cGUocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdENoYW5uZWxUeXBlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxUeXBlc0FwaS5saXN0Q2hhbm5lbFR5cGVzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlQ2hhbm5lbFR5cGUgPSAobmFtZSwgdXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsVHlwZXNBcGkudXBkYXRlQ2hhbm5lbFR5cGUoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucXVlcnlDaGFubmVscyA9IChxdWVyeUNoYW5uZWxzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkucXVlcnlDaGFubmVscyh7XG4gICAgICAgICAgICAgICAgcXVlcnlDaGFubmVsc1JlcXVlc3Q6IHF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0ICE9PSBudWxsICYmIHF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0ICE9PSB2b2lkIDAgPyBxdWVyeUNoYW5uZWxzUmVxdWVzdCA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZWFyY2hNZXNzYWdlcyA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5zZWFyY2goeyBwYXlsb2FkIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4cG9ydENoYW5uZWxzID0gKGV4cG9ydENoYW5uZWxzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuZXhwb3J0Q2hhbm5lbHMoe1xuICAgICAgICAgICAgICAgIGV4cG9ydENoYW5uZWxzUmVxdWVzdDogZXhwb3J0Q2hhbm5lbHNSZXF1ZXN0ICE9PSBudWxsICYmIGV4cG9ydENoYW5uZWxzUmVxdWVzdCAhPT0gdm9pZCAwID8gZXhwb3J0Q2hhbm5lbHNSZXF1ZXN0IDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEV4cG9ydFN0YXR1cyA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5nZXRFeHBvcnRDaGFubmVsc1N0YXR1cyhyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0Q29tbWFuZHMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kc0FwaS5saXN0Q29tbWFuZHMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb21tYW5kID0gKGNyZWF0ZUNvbW1hbmRSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kc0FwaS5jcmVhdGVDb21tYW5kKHsgY3JlYXRlQ29tbWFuZFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29tbWFuZCA9IChnZXRDb21tYW5kUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkuZ2V0Q29tbWFuZChnZXRDb21tYW5kUmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlQ29tbWFuZCA9IChuYW1lLCB1cGRhdGVDb21tYW5kUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkudXBkYXRlQ29tbWFuZCh7IG5hbWUsIHVwZGF0ZUNvbW1hbmRSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZUNvbW1hbmQgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkuZGVsZXRlQ29tbWFuZChyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuc3RyZWFtQ2xpZW50LmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5zZXR0aW5nc0FwaSA9IG5ldyBTZXR0aW5nc0FwaSQxKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmNoYW5uZWxUeXBlc0FwaSA9IG5ldyBDaGFubmVsVHlwZXNBcGkoY29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuY2hhbm5lbHNBcGkgPSBuZXcgQ2hhbm5lbHNBcGkoY29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuY29tbWFuZHNBcGkgPSBuZXcgQ3VzdG9tQ29tbWFuZHNBcGkoY29uZmlndXJhdGlvbik7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2MTAwLjQuM1xuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbmNvbnN0IEJBU0VfUEFUSCA9IFwiaHR0cHM6Ly9zdHJlYW0taW8tYXBpLmNvbVwiLnJlcGxhY2UoL1xcLyskLywgXCJcIik7XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uID0ge30pIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICB9XG4gICAgc2V0IGNvbmZpZyhjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCAhPSBudWxsID8gdGhpcy5jb25maWd1cmF0aW9uLmJhc2VQYXRoIDogQkFTRV9QQVRIO1xuICAgIH1cbiAgICBnZXQgZmV0Y2hBcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGk7XG4gICAgfVxuICAgIGdldCBtaWRkbGV3YXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLm1pZGRsZXdhcmUgfHwgW107XG4gICAgfVxuICAgIGdldCBxdWVyeVBhcmFtc1N0cmluZ2lmeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5xdWVyeVBhcmFtc1N0cmluZ2lmeSB8fCBxdWVyeXN0cmluZztcbiAgICB9XG4gICAgZ2V0IHVzZXJuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnVzZXJuYW1lO1xuICAgIH1cbiAgICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ucGFzc3dvcmQ7XG4gICAgfVxuICAgIGdldCBhcGlLZXkoKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXk7XG4gICAgICAgIGlmIChhcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXBpS2V5ID09PSAnZnVuY3Rpb24nID8gYXBpS2V5IDogKCkgPT4gYXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBhY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW47XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhY2Nlc3NUb2tlbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjY2Vzc1Rva2VuIDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gYWNjZXNzVG9rZW47IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmhlYWRlcnM7XG4gICAgfVxuICAgIGdldCBjcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5jcmVkZW50aWFscztcbiAgICB9XG59XG5jb25zdCBEZWZhdWx0Q29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oKTtcbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGdlbmVyYXRlZCBBUEkgY2xhc3Nlcy5cbiAqL1xuY2xhc3MgQmFzZUFQSSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiA9IERlZmF1bHRDb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy5mZXRjaEFwaSA9ICh1cmwsIGluaXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBmZXRjaFBhcmFtcyA9IHsgdXJsLCBpbml0IH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2YgdGhpcy5taWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUucHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoUGFyYW1zID0gKHlpZWxkIG1pZGRsZXdhcmUucHJlKE9iamVjdC5hc3NpZ24oeyBmZXRjaDogdGhpcy5mZXRjaEFwaSB9LCBmZXRjaFBhcmFtcykpKSB8fCBmZXRjaFBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgKHRoaXMuY29uZmlndXJhdGlvbi5mZXRjaEFwaSB8fCBmZXRjaCkoZmV0Y2hQYXJhbXMudXJsLCBmZXRjaFBhcmFtcy5pbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWlkZGxld2FyZS5vbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9ICh5aWVsZCBtaWRkbGV3YXJlLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoQXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZmV0Y2hQYXJhbXMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IGZldGNoUGFyYW1zLmluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlID8gcmVzcG9uc2UuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB8fCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmV0Y2hFcnJvcihlLCAnVGhlIHJlcXVlc3QgZmFpbGVkIGFuZCB0aGUgaW50ZXJjZXB0b3JzIGRpZCBub3QgcmV0dXJuIGFuIGFsdGVybmF0aXZlIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5wb3N0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoQXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBmZXRjaFBhcmFtcy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIH0pKSB8fCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmUgPSBjb25maWd1cmF0aW9uLm1pZGRsZXdhcmU7XG4gICAgfVxuICAgIHdpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG5leHQubWlkZGxld2FyZSA9IG5leHQubWlkZGxld2FyZS5jb25jYXQoLi4ubWlkZGxld2FyZXMpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgd2l0aFByZU1pZGRsZXdhcmUoLi4ucHJlTWlkZGxld2FyZXMpIHtcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZXMgPSBwcmVNaWRkbGV3YXJlcy5tYXAoKHByZSkgPT4gKHsgcHJlIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpO1xuICAgIH1cbiAgICB3aXRoUG9zdE1pZGRsZXdhcmUoLi4ucG9zdE1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gcG9zdE1pZGRsZXdhcmVzLm1hcCgocG9zdCkgPT4gKHsgcG9zdCB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIE1JTUUgaXMgYSBKU09OIE1JTUUuXG4gICAgICogSlNPTiBNSU1FIGV4YW1wbGVzOlxuICAgICAqICAgYXBwbGljYXRpb24vanNvblxuICAgICAqICAgYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEY4XG4gICAgICogICBBUFBMSUNBVElPTi9KU09OXG4gICAgICogICBhcHBsaWNhdGlvbi92bmQuY29tcGFueStqc29uXG4gICAgICogQHBhcmFtIG1pbWUgLSBNSU1FIChNdWx0aXB1cnBvc2UgSW50ZXJuZXQgTWFpbCBFeHRlbnNpb25zKVxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBKU09OLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNKc29uTWltZShtaW1lKSB7XG4gICAgICAgIGlmICghbWltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXNlQVBJLmpzb25SZWdleC50ZXN0KG1pbWUpO1xuICAgIH1cbiAgICByZXF1ZXN0KGNvbnRleHQsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsLCBpbml0IH0gPSB5aWVsZCB0aGlzLmNyZWF0ZUZldGNoUGFyYW1zKGNvbnRleHQsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZldGNoQXBpKHVybCwgaW5pdCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yKHJlc3BvbnNlLCAnUmVzcG9uc2UgcmV0dXJuZWQgYW4gZXJyb3IgY29kZScpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlRmV0Y2hQYXJhbXMoY29udGV4dCwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHVybCA9IHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCArIGNvbnRleHQucGF0aDtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnF1ZXJ5ICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0LmtleXMoY29udGV4dC5xdWVyeSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhZGQgdGhlIHF1ZXJ5c3RyaW5nIHRvIHRoZSBVUkwgaWYgdGhlcmUgYXJlIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBkb25lIHRvIGF2b2lkIHVybHMgZW5kaW5nIHdpdGggYSBcIj9cIiBjaGFyYWN0ZXIgd2hpY2ggYnVnZ3kgd2Vic2VydmVyc1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBoYW5kbGUgY29ycmVjdGx5IHNvbWV0aW1lcy5cbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy5jb25maWd1cmF0aW9uLnF1ZXJ5UGFyYW1zU3RyaW5naWZ5KGNvbnRleHQucXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlndXJhdGlvbi5oZWFkZXJzLCBjb250ZXh0LmhlYWRlcnMpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChrZXkgPT4gaGVhZGVyc1trZXldID09PSB1bmRlZmluZWQgPyBkZWxldGUgaGVhZGVyc1trZXldIDoge30pO1xuICAgICAgICAgICAgY29uc3QgaW5pdE92ZXJyaWRlRm4gPSB0eXBlb2YgaW5pdE92ZXJyaWRlcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgPyBpbml0T3ZlcnJpZGVzXG4gICAgICAgICAgICAgICAgOiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBpbml0T3ZlcnJpZGVzOyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBjb250ZXh0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGNvbnRleHQuYm9keSxcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5jb25maWd1cmF0aW9uLmNyZWRlbnRpYWxzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRkZW5Jbml0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbml0UGFyYW1zKSwgKHlpZWxkIGluaXRPdmVycmlkZUZuKHtcbiAgICAgICAgICAgICAgICBpbml0OiBpbml0UGFyYW1zLFxuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgY29uc3QgaW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGRlbkluaXQpLCB7IGJvZHk6IGlzRm9ybURhdGEob3ZlcnJpZGRlbkluaXQuYm9keSkgfHxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGRlbkluaXQuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyB8fFxuICAgICAgICAgICAgICAgICAgICBpc0Jsb2Iob3ZlcnJpZGRlbkluaXQuYm9keSlcbiAgICAgICAgICAgICAgICAgICAgPyBvdmVycmlkZGVuSW5pdC5ib2R5XG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkob3ZlcnJpZGRlbkluaXQuYm9keSkgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB1cmwsIGluaXQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY2xvbmUgb2YgYHRoaXNgIGJ5IGNvbnN0cnVjdGluZyBhIG5ldyBpbnN0YW5jZVxuICAgICAqIGFuZCB0aGVuIHNoYWxsb3cgY2xvbmluZyBkYXRhIG1lbWJlcnMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5ldyBjb25zdHJ1Y3Rvcih0aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBuZXh0Lm1pZGRsZXdhcmUgPSB0aGlzLm1pZGRsZXdhcmUuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxufVxuQmFzZUFQSS5qc29uUmVnZXggPSBuZXcgUmVnRXhwKCdeKDo/YXBwbGljYXRpb25cXC9qc29ufFteOy8gXFx0XStcXC9bXjsvIFxcdF0rWytdanNvbilbIFxcdF0qKDo/Oy4qKT8kJywgJ2knKTtcbmZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBCbG9iO1xufVxuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YTtcbn1cbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVzcG9uc2VFcnJvclwiO1xuICAgIH1cbn1cbmNsYXNzIEZldGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F1c2UsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRmV0Y2hFcnJvclwiO1xuICAgIH1cbn1cbmNsYXNzIFJlcXVpcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVxdWlyZWRFcnJvclwiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHBhcmFtcywgcHJlZml4ID0gJycpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgICAubWFwKGtleSA9PiBxdWVyeXN0cmluZ1NpbmdsZUtleShrZXksIHBhcmFtc1trZXldLCBwcmVmaXgpKVxuICAgICAgICAuZmlsdGVyKHBhcnQgPT4gcGFydC5sZW5ndGggPiAwKVxuICAgICAgICAuam9pbignJicpO1xufVxuZnVuY3Rpb24gcXVlcnlzdHJpbmdTaW5nbGVLZXkoa2V5LCB2YWx1ZSwga2V5UHJlZml4ID0gJycpIHtcbiAgICBjb25zdCBmdWxsS2V5ID0ga2V5UHJlZml4ICsgKGtleVByZWZpeC5sZW5ndGggPyBgWyR7a2V5fV1gIDoga2V5KTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBjb25zdCBtdWx0aVZhbHVlID0gdmFsdWUubWFwKHNpbmdsZVZhbHVlID0+IGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc2luZ2xlVmFsdWUpKSlcbiAgICAgICAgICAgIC5qb2luKGAmJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PWApO1xuICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxLZXkpfT0ke211bHRpVmFsdWV9YDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQXNBcnJheSA9IEFycmF5LmZyb20odmFsdWUpO1xuICAgICAgICByZXR1cm4gcXVlcnlzdHJpbmdTaW5nbGVLZXkoa2V5LCB2YWx1ZUFzQXJyYXksIGtleVByZWZpeCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUudG9JU09TdHJpbmcoKSl9YDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBxdWVyeXN0cmluZyh2YWx1ZSwgZnVsbEtleSk7XG4gICAgfVxuICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh2YWx1ZSkpfWA7XG59XG5jbGFzcyBKU09OQXBpUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJhdywgdHJhbnNmb3JtZXIgPSAoanNvblZhbHVlKSA9PiBqc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1lcih5aWVsZCB0aGlzLnJhdy5qc29uKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBWb2lkQXBpUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJhdykge1xuICAgICAgICB0aGlzLnJhdyA9IHJhdztcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHYxMDAuNC4zXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBEZWZhdWx0QXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQmxvY2sgYSB1c2VyLCBwcmV2ZW50aW5nIHRoZW0gZnJvbSBqb2luaW5nIHRoZSBjYWxsIHVudGlsIHRoZXkgYXJlIHVuYmxvY2tlZC4gIFNlbmRzIGV2ZW50czogLSBjYWxsLmJsb2NrZWRfdXNlciAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQmxvY2tVc2VyXG4gICAgICogQmxvY2sgdXNlciBvbiBhIGNhbGxcbiAgICAgKi9cbiAgICBibG9ja1VzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgYmxvY2tVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgYmxvY2tVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQmxvY2tVc2VyUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0Jsb2NrVXNlclJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQmxvY2tVc2VyUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9ibG9ja2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQmxvY2tVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmxvY2sgYSB1c2VyLCBwcmV2ZW50aW5nIHRoZW0gZnJvbSBqb2luaW5nIHRoZSBjYWxsIHVudGlsIHRoZXkgYXJlIHVuYmxvY2tlZC4gIFNlbmRzIGV2ZW50czogLSBjYWxsLmJsb2NrZWRfdXNlciAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQmxvY2tVc2VyXG4gICAgICogQmxvY2sgdXNlciBvbiBhIGNhbGxcbiAgICAgKi9cbiAgICBibG9ja1VzZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5ibG9ja1VzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRldmljZSB0byBhIHVzZXIsIGlmIHRoZSBzYW1lIGRldmljZSBhbHJlYWR5IGV4aXN0cyB0aGUgY2FsbCB3aWxsIGhhdmUgbm8gZWZmZWN0XG4gICAgICogQ3JlYXRlIGRldmljZVxuICAgICAqL1xuICAgIGNyZWF0ZURldmljZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRGV2aWNlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0NyZWF0ZURldmljZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRGV2aWNlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZURldmljZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZGV2aWNlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRGV2aWNlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBkZXZpY2UgdG8gYSB1c2VyLCBpZiB0aGUgc2FtZSBkZXZpY2UgYWxyZWFkeSBleGlzdHMgdGhlIGNhbGwgd2lsbCBoYXZlIG5vIGVmZmVjdFxuICAgICAqIENyZWF0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBjcmVhdGVEZXZpY2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZSBHdWVzdFxuICAgICAqL1xuICAgIGNyZWF0ZUd1ZXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVHdWVzdFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVHdWVzdFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0NyZWF0ZUd1ZXN0UmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVHdWVzdFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVHdWVzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZ3Vlc3RgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZUd1ZXN0UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGUgR3Vlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVHdWVzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZUd1ZXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBvbmUgZGV2aWNlXG4gICAgICogRGVsZXRlIGRldmljZVxuICAgICAqL1xuICAgIGRlbGV0ZURldmljZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1c2VyX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZGV2aWNlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgb25lIGRldmljZVxuICAgICAqIERlbGV0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBkZWxldGVEZXZpY2UocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZURldmljZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwuZW5kZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEVuZENhbGxcbiAgICAgKiBFbmQgY2FsbFxuICAgICAqL1xuICAgIGVuZENhbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZW5kQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGVuZENhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L21hcmtfZW5kZWRgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC5lbmRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRW5kQ2FsbFxuICAgICAqIEVuZCBjYWxsXG4gICAgICovXG4gICAgZW5kQ2FsbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmVuZENhbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogR2V0IENhbGxcbiAgICAgKi9cbiAgICBnZXRDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2Nvbm5lY3Rpb25faWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tZW1iZXJzTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snbWVtYmVyc19saW1pdCddID0gcmVxdWVzdFBhcmFtZXRlcnMubWVtYmVyc0xpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sncmluZyddID0gcmVxdWVzdFBhcmFtZXRlcnMucmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5ub3RpZnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snbm90aWZ5J10gPSByZXF1ZXN0UGFyYW1ldGVycy5ub3RpZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENhbGxcbiAgICAgKiBHZXQgQ2FsbFxuICAgICAqL1xuICAgIGdldENhbGwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgZWRnZXMgYXZhaWxhYmxlIGZvciB2aWRlbyBjYWxscy5cbiAgICAgKiBHZXQgRWRnZXNcbiAgICAgKi9cbiAgICBnZXRFZGdlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9lZGdlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGVkZ2VzIGF2YWlsYWJsZSBmb3IgdmlkZW8gY2FsbHMuXG4gICAgICogR2V0IEVkZ2VzXG4gICAgICovXG4gICAgZ2V0RWRnZXMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldEVkZ2VzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIGNyZWF0ZXMgYSBuZXcgY2FsbCAgU2VuZHMgZXZlbnRzOiAtIGNhbGwuY3JlYXRlZCAtIGNhbGwubm90aWZpY2F0aW9uIC0gY2FsbC5yaW5nICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBDcmVhdGVDYWxsIC0gUmVhZENhbGwgLSBVcGRhdGVDYWxsU2V0dGluZ3NcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGEgY2FsbFxuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlQ2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRPckNyZWF0ZUNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRPckNyZWF0ZUNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9HZXRPckNyZWF0ZUNhbGxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9HZXRPckNyZWF0ZUNhbGxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2Nvbm5lY3Rpb25faWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3IgY3JlYXRlcyBhIG5ldyBjYWxsICBTZW5kcyBldmVudHM6IC0gY2FsbC5jcmVhdGVkIC0gY2FsbC5ub3RpZmljYXRpb24gLSBjYWxsLnJpbmcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIENyZWF0ZUNhbGwgLSBSZWFkQ2FsbCAtIFVwZGF0ZUNhbGxTZXR0aW5nc1xuICAgICAqIEdldCBvciBjcmVhdGUgYSBjYWxsXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVDYWxsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0T3JDcmVhdGVDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC5saXZlX3N0YXJ0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxcbiAgICAgKiBTZXQgY2FsbCBhcyBsaXZlXG4gICAgICovXG4gICAgZ29MaXZlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdvTGl2ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdvTGl2ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dvTGl2ZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9Hb0xpdmVSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9Hb0xpdmVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dvTGl2ZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnb0xpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vZ29fbGl2ZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR29MaXZlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC5saXZlX3N0YXJ0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxcbiAgICAgKiBTZXQgY2FsbCBhcyBsaXZlXG4gICAgICovXG4gICAgZ29MaXZlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ29MaXZlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGRldmljZXNcbiAgICAgKiBMaXN0IGRldmljZXNcbiAgICAgKi9cbiAgICBsaXN0RGV2aWNlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGRldmljZXNcbiAgICAgKiBMaXN0IGRldmljZXNcbiAgICAgKi9cbiAgICBsaXN0RGV2aWNlcyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdERldmljZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyByZWNvcmRpbmdzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBMaXN0UmVjb3JkaW5nc1xuICAgICAqIExpc3QgcmVjb3JkaW5nc1xuICAgICAqL1xuICAgIGxpc3RSZWNvcmRpbmdzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGxpc3RSZWNvcmRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbGlzdFJlY29yZGluZ3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3JlY29yZGluZ3NgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyByZWNvcmRpbmdzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBMaXN0UmVjb3JkaW5nc1xuICAgICAqIExpc3QgcmVjb3JkaW5nc1xuICAgICAqL1xuICAgIGxpc3RSZWNvcmRpbmdzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdFJlY29yZGluZ3NSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0cmFuc2NyaXB0aW9ucyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTGlzdFRyYW5zY3JpcHRpb25zXG4gICAgICogTGlzdCB0cmFuc2NyaXB0aW9uc1xuICAgICAqL1xuICAgIGxpc3RUcmFuc2NyaXB0aW9uc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBsaXN0VHJhbnNjcmlwdGlvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBsaXN0VHJhbnNjcmlwdGlvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3RyYW5zY3JpcHRpb25zYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdHJhbnNjcmlwdGlvbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIExpc3RUcmFuc2NyaXB0aW9uc1xuICAgICAqIExpc3QgdHJhbnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBsaXN0VHJhbnNjcmlwdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0VHJhbnNjcmlwdGlvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdXRlcyB1c2VycyBpbiBhIGNhbGwgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIE11dGVVc2Vyc1xuICAgICAqIE11dGUgdXNlcnNcbiAgICAgKi9cbiAgICBtdXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbXV0ZVVzZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbXV0ZVVzZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvTXV0ZVVzZXJzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb011dGVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb011dGVVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvTXV0ZVVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG11dGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9tdXRlX3VzZXJzYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9NdXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdXRlcyB1c2VycyBpbiBhIGNhbGwgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIE11dGVVc2Vyc1xuICAgICAqIE11dGUgdXNlcnNcbiAgICAgKi9cbiAgICBtdXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5tdXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjYWxscyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENhbGxcbiAgICAgKiBRdWVyeSBjYWxsXG4gICAgICovXG4gICAgcXVlcnlDYWxsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlDYWxsc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9RdWVyeUNhbGxzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvUXVlcnlDYWxsc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlDYWxsc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBxdWVyeUNhbGxzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2Nvbm5lY3Rpb25faWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGxzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9RdWVyeUNhbGxzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgY2FsbHMgd2l0aCBmaWx0ZXIgcXVlcnkgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogUXVlcnkgY2FsbFxuICAgICAqL1xuICAgIHF1ZXJ5Q2FsbHMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5xdWVyeUNhbGxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgY2FsbCBtZW1iZXJzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIFF1ZXJ5IGNhbGwgbWVtYmVyc1xuICAgICAqL1xuICAgIHF1ZXJ5TWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlNZW1iZXJzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlNZW1iZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHF1ZXJ5TWVtYmVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC9tZW1iZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjYWxsIG1lbWJlcnMgd2l0aCBmaWx0ZXIgcXVlcnkgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogUXVlcnkgY2FsbCBtZW1iZXJzXG4gICAgICovXG4gICAgcXVlcnlNZW1iZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlNZW1iZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgY3VzdG9tIGV2ZW50IHRvIHRoZSBjYWxsICBTZW5kcyBldmVudHM6IC0gY3VzdG9tICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTZW5kRXZlbnRcbiAgICAgKiBTZW5kIGN1c3RvbSBldmVudFxuICAgICAqL1xuICAgIHNlbmRFdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TZW5kRXZlbnRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvU2VuZEV2ZW50UmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TZW5kRXZlbnRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZEV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L2V2ZW50YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TZW5kRXZlbnRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBjdXN0b20gZXZlbnQgdG8gdGhlIGNhbGwgIFNlbmRzIGV2ZW50czogLSBjdXN0b20gIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFNlbmRFdmVudFxuICAgICAqIFNlbmQgY3VzdG9tIGV2ZW50XG4gICAgICovXG4gICAgc2VuZEV2ZW50KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZEV2ZW50UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIEhMUyBicm9hZGNhc3RpbmcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0YXJ0QnJvYWRjYXN0aW5nXG4gICAgICogU3RhcnQgSExTIGJyb2FkY2FzdGluZ1xuICAgICAqL1xuICAgIHN0YXJ0SExTQnJvYWRjYXN0aW5nUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0SExTQnJvYWRjYXN0aW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RhcnRITFNCcm9hZGNhc3RpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0YXJ0X2Jyb2FkY2FzdGluZ2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgSExTIGJyb2FkY2FzdGluZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RhcnRCcm9hZGNhc3RpbmdcbiAgICAgKiBTdGFydCBITFMgYnJvYWRjYXN0aW5nXG4gICAgICovXG4gICAgc3RhcnRITFNCcm9hZGNhc3RpbmcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdGFydEhMU0Jyb2FkY2FzdGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyByZWNvcmRpbmcgIFNlbmRzIGV2ZW50czogLSBjYWxsLnJlY29yZGluZ19zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydFJlY29yZGluZ1xuICAgICAqIFN0YXJ0IHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0YXJ0UmVjb3JkaW5nUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1N0YXJ0UmVjb3JkaW5nUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFJlY29yZGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9zdGFydF9yZWNvcmRpbmdgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1N0YXJ0UmVjb3JkaW5nUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHJlY29yZGluZyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucmVjb3JkaW5nX3N0YXJ0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0YXJ0UmVjb3JkaW5nXG4gICAgICogU3RhcnQgcmVjb3JkaW5nXG4gICAgICovXG4gICAgc3RhcnRSZWNvcmRpbmcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdGFydFJlY29yZGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0cmFuc2NyaXB0aW9uICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydFRyYW5zY3JpcHRpb25cbiAgICAgKiBTdGFydCB0cmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RhcnRUcmFuc2NyaXB0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0VHJhbnNjcmlwdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0VHJhbnNjcmlwdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1N0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1N0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RhcnRfdHJhbnNjcmlwdGlvbmAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRyYW5zY3JpcHRpb24gIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0YXJ0VHJhbnNjcmlwdGlvblxuICAgICAqIFN0YXJ0IHRyYW5zY3JpcHRpb25cbiAgICAgKi9cbiAgICBzdGFydFRyYW5zY3JpcHRpb24ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdGFydFRyYW5zY3JpcHRpb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBITFMgYnJvYWRjYXN0aW5nICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdG9wQnJvYWRjYXN0aW5nXG4gICAgICogU3RvcCBITFMgYnJvYWRjYXN0aW5nXG4gICAgICovXG4gICAgc3RvcEhMU0Jyb2FkY2FzdGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdG9wSExTQnJvYWRjYXN0aW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcEhMU0Jyb2FkY2FzdGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RvcF9icm9hZGNhc3RpbmdgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgSExTIGJyb2FkY2FzdGluZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RvcEJyb2FkY2FzdGluZ1xuICAgICAqIFN0b3AgSExTIGJyb2FkY2FzdGluZ1xuICAgICAqL1xuICAgIHN0b3BITFNCcm9hZGNhc3RpbmcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wSExTQnJvYWRjYXN0aW5nUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogU2V0IGNhbGwgYXMgbm90IGxpdmVcbiAgICAgKi9cbiAgICBzdG9wTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdG9wTGl2ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BMaXZlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9zdG9wX2xpdmVgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogU2V0IGNhbGwgYXMgbm90IGxpdmVcbiAgICAgKi9cbiAgICBzdG9wTGl2ZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnN0b3BMaXZlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgcmVjb3JkaW5nICBTZW5kcyBldmVudHM6IC0gY2FsbC5yZWNvcmRpbmdfc3RvcHBlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RvcFJlY29yZGluZ1xuICAgICAqIFN0b3AgcmVjb3JkaW5nXG4gICAgICovXG4gICAgc3RvcFJlY29yZGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdG9wUmVjb3JkaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcFJlY29yZGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RvcF9yZWNvcmRpbmdgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgcmVjb3JkaW5nICBTZW5kcyBldmVudHM6IC0gY2FsbC5yZWNvcmRpbmdfc3RvcHBlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RvcFJlY29yZGluZ1xuICAgICAqIFN0b3AgcmVjb3JkaW5nXG4gICAgICovXG4gICAgc3RvcFJlY29yZGluZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnN0b3BSZWNvcmRpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0cmFuc2NyaXB0aW9uICBTZW5kcyBldmVudHM6IC0gY2FsbC50cmFuc2NyaXB0aW9uX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BUcmFuc2NyaXB0aW9uXG4gICAgICogU3RvcCB0cmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RvcFRyYW5zY3JpcHRpb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdG9wVHJhbnNjcmlwdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RvcF90cmFuc2NyaXB0aW9uYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRyYW5zY3JpcHRpb24gIFNlbmRzIGV2ZW50czogLSBjYWxsLnRyYW5zY3JpcHRpb25fc3RvcHBlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RvcFRyYW5zY3JpcHRpb25cbiAgICAgKiBTdG9wIHRyYW5zY3JpcHRpb25cbiAgICAgKi9cbiAgICBzdG9wVHJhbnNjcmlwdGlvbihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnN0b3BUcmFuc2NyaXB0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgYmxvY2sgZm9yIGEgdXNlciBvbiBhIGNhbGwuIFRoZSB1c2VyIHdpbGwgYmUgYWJsZSB0byBqb2luIHRoZSBjYWxsIGFnYWluLiAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudW5ibG9ja2VkX3VzZXIgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJsb2NrVXNlclxuICAgICAqIFVuYmxvY2tzIHVzZXIgb24gYSBjYWxsXG4gICAgICovXG4gICAgdW5ibG9ja1VzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5ibG9ja1VzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1bmJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvVW5ibG9ja1VzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuYmxvY2tVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3VuYmxvY2tgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgYmxvY2sgZm9yIGEgdXNlciBvbiBhIGNhbGwuIFRoZSB1c2VyIHdpbGwgYmUgYWJsZSB0byBqb2luIHRoZSBjYWxsIGFnYWluLiAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudW5ibG9ja2VkX3VzZXIgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJsb2NrVXNlclxuICAgICAqIFVuYmxvY2tzIHVzZXIgb24gYSBjYWxsXG4gICAgICovXG4gICAgdW5ibG9ja1VzZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bmJsb2NrVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFxuICAgICAqIFVwZGF0ZSBDYWxsXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxcbiAgICAgKiBVcGRhdGUgQ2FsbFxuICAgICAqL1xuICAgIHVwZGF0ZUNhbGwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC5tZW1iZXJfYWRkZWQgLSBjYWxsLm1lbWJlcl9yZW1vdmVkIC0gY2FsbC5tZW1iZXJfdXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVtb3ZlQ2FsbE1lbWJlciAtIFVwZGF0ZUNhbGxNZW1iZXIgLSBVcGRhdGVDYWxsTWVtYmVyUm9sZVxuICAgICAqIFVwZGF0ZSBDYWxsIE1lbWJlclxuICAgICAqL1xuICAgIHVwZGF0ZUNhbGxNZW1iZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGxNZW1iZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbE1lbWJlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZUNhbGxNZW1iZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsTWVtYmVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9tZW1iZXJzYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubWVtYmVyX2FkZGVkIC0gY2FsbC5tZW1iZXJfcmVtb3ZlZCAtIGNhbGwubWVtYmVyX3VwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlbW92ZUNhbGxNZW1iZXIgLSBVcGRhdGVDYWxsTWVtYmVyIC0gVXBkYXRlQ2FsbE1lbWJlclJvbGVcbiAgICAgKiBVcGRhdGUgQ2FsbCBNZW1iZXJcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsTWVtYmVycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUNhbGxNZW1iZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB1c2VyIHBlcm1pc3Npb25zICBTZW5kcyBldmVudHM6IC0gY2FsbC5wZXJtaXNzaW9uc191cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsUGVybWlzc2lvbnNcbiAgICAgKiBVcGRhdGUgdXNlciBwZXJtaXNzaW9uc1xuICAgICAqL1xuICAgIHVwZGF0ZVVzZXJQZXJtaXNzaW9uc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVVc2VyUGVybWlzc2lvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVVc2VyUGVybWlzc2lvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlclBlcm1pc3Npb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3VzZXJfcGVybWlzc2lvbnNgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBwZXJtaXNzaW9ucyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucGVybWlzc2lvbnNfdXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFBlcm1pc3Npb25zXG4gICAgICogVXBkYXRlIHVzZXIgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVVc2VyUGVybWlzc2lvbnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVVc2VyUGVybWlzc2lvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlcyBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdXNlciB0byB2aWRlbyAgU2VuZHMgZXZlbnRzOiAtIGNvbm5lY3Rpb24ub2sgLSBoZWFsdGguY2hlY2tcbiAgICAgKiBWaWRlbyBDb25uZWN0IChXZWJTb2NrZXQpXG4gICAgICovXG4gICAgdmlkZW9Db25uZWN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9XU0F1dGhNZXNzYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1dTQXV0aE1lc3NhZ2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9XU0F1dGhNZXNzYWdlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9XU0F1dGhNZXNzYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHZpZGVvQ29ubmVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY29ubmVjdGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9XU0F1dGhNZXNzYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXIgdG8gdmlkZW8gIFNlbmRzIGV2ZW50czogLSBjb25uZWN0aW9uLm9rIC0gaGVhbHRoLmNoZWNrXG4gICAgICogVmlkZW8gQ29ubmVjdCAoV2ViU29ja2V0KVxuICAgICAqL1xuICAgIHZpZGVvQ29ubmVjdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy52aWRlb0Nvbm5lY3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGlucyBhIHRyYWNrIGZvciBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBQaW5DYWxsVHJhY2tcbiAgICAgKiBQaW5cbiAgICAgKi9cbiAgICB2aWRlb1BpblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1Bpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHZpZGVvUGluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUGluUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1BpblJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUGluUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHZpZGVvUGluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3BpbmAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUGluUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGlucyBhIHRyYWNrIGZvciBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBQaW5DYWxsVHJhY2tcbiAgICAgKiBQaW5cbiAgICAgKi9cbiAgICB2aWRlb1BpbihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnZpZGVvUGluUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5waW5zIGEgdHJhY2sgZm9yIGFsbCB1c2VycyBpbiB0aGUgY2FsbC4gIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFBpbkNhbGxUcmFja1xuICAgICAqIFVucGluXG4gICAgICovXG4gICAgdmlkZW9VbnBpblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1VucGluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdmlkZW9VbnBpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VucGluUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VucGluUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvVW5waW5SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VucGluUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHZpZGVvVW5waW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vdW5waW5gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VucGluUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5waW5zIGEgdHJhY2sgZm9yIGFsbCB1c2VycyBpbiB0aGUgY2FsbC4gIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFBpbkNhbGxUcmFja1xuICAgICAqIFVucGluXG4gICAgICovXG4gICAgdmlkZW9VbnBpbihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnZpZGVvVW5waW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjEwMC40LjNcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFNlcnZlclNpZGVBcGkgZXh0ZW5kcyBCYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIEV4dGVybmFsIFN0b3JhZ2VcbiAgICAgKi9cbiAgICBjaGVja0V4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja0V4dGVybmFsU3RvcmFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2V4dGVybmFsX3N0b3JhZ2Uve25hbWV9L2NoZWNrYC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIEV4dGVybmFsIFN0b3JhZ2VcbiAgICAgKi9cbiAgICBjaGVja0V4dGVybmFsU3RvcmFnZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNoZWNrRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgY3JlYXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZUNhbGxUeXBlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZUNhbGxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvQ3JlYXRlQ2FsbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZUNhbGxUeXBlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUNhbGxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZUNhbGxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgY3JlYXRlQ2FsbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVsZXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNhbGxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUNhbGxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZWxldGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgZGVsZXRlQ2FsbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogR2V0IENhbGwgVHlwZVxuICAgICAqL1xuICAgIGdldENhbGxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENhbGxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBHZXQgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgZ2V0Q2FsbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogTGlzdCBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICBsaXN0Q2FsbFR5cGVzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGx0eXBlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogTGlzdCBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICBsaXN0Q2FsbFR5cGVzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0Q2FsbFR5cGVzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvVXBkYXRlQ2FsbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUNhbGxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGUgRXh0ZXJuYWwgU3RvcmFnZVxuICAgICAqL1xuICAgIHVwZGF0ZUV4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVFeHRlcm5hbFN0b3JhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlRXh0ZXJuYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9leHRlcm5hbF9zdG9yYWdlL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXBkYXRlIEV4dGVybmFsIFN0b3JhZ2VcbiAgICAgKi9cbiAgICB1cGRhdGVFeHRlcm5hbFN0b3JhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjEwMC40LjNcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFNldHRpbmdzQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIENyZWF0ZSBleHRlcm5hbCBzdG9yYWdlXG4gICAgICovXG4gICAgY3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlRXh0ZXJuYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9leHRlcm5hbF9zdG9yYWdlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBleHRlcm5hbCBzdG9yYWdlXG4gICAgICogQ3JlYXRlIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBjcmVhdGVFeHRlcm5hbFN0b3JhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKiBEZWxldGUgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIGRlbGV0ZUV4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVFeHRlcm5hbFN0b3JhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9leHRlcm5hbF9zdG9yYWdlL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBleHRlcm5hbCBzdG9yYWdlXG4gICAgICogRGVsZXRlIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBkZWxldGVFeHRlcm5hbFN0b3JhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBleHRlcm5hbCBzdG9yYWdlXG4gICAgICogTGlzdCBleHRlcm5hbCBzdG9yYWdlXG4gICAgICovXG4gICAgbGlzdEV4dGVybmFsU3RvcmFnZVJhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9leHRlcm5hbF9zdG9yYWdlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIExpc3QgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIGxpc3RFeHRlcm5hbFN0b3JhZ2UoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RFeHRlcm5hbFN0b3JhZ2VSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBTdHJlYW1DYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1DbGllbnQsIHR5cGUsIGlkKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50ID0gc3RyZWFtQ2xpZW50O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuYmxvY2tVc2VyID0gKHZpZGVvQmxvY2tVc2VyUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LmJsb2NrVXNlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHZpZGVvQmxvY2tVc2VyUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kQ2FsbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5lbmRDYWxsKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXQgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LmdldENhbGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAocmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDoge30pKSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE9yQ3JlYXRlID0gKHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LmdldE9yQ3JlYXRlQ2FsbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdDogdmlkZW9HZXRPckNyZWF0ZUNhbGxSZXF1ZXN0ICE9PSBudWxsICYmIHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCAhPT0gdm9pZCAwID8gdmlkZW9HZXRPckNyZWF0ZUNhbGxSZXF1ZXN0IDoge30gfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IChnZXRPckNyZWF0ZUNhbGxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckNyZWF0ZShnZXRPckNyZWF0ZUNhbGxSZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nb0xpdmUgPSAodmlkZW9Hb0xpdmVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuZ29MaXZlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdmlkZW9Hb0xpdmVSZXF1ZXN0OiB2aWRlb0dvTGl2ZVJlcXVlc3QgIT09IG51bGwgJiYgdmlkZW9Hb0xpdmVSZXF1ZXN0ICE9PSB2b2lkIDAgPyB2aWRlb0dvTGl2ZVJlcXVlc3QgOiB7fSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdFJlY29yZGluZ3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQubGlzdFJlY29yZGluZ3MoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm11dGVVc2VycyA9ICh2aWRlb011dGVVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5tdXRlVXNlcnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB2aWRlb011dGVVc2Vyc1JlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnF1ZXJ5TWVtYmVycyA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQucXVlcnlNZW1iZXJzKHtcbiAgICAgICAgICAgICAgICB2aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3Q6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9KSksIHRoaXMuYmFzZVJlcXVlc3QpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZEN1c3RvbUV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc2VuZEV2ZW50KE9iamVjdC5hc3NpZ24oeyB2aWRlb1NlbmRFdmVudFJlcXVlc3Q6IHsgY3VzdG9tOiBldmVudCB9IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFydEhMU0Jyb2FkY2FzdGluZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5zdGFydEhMU0Jyb2FkY2FzdGluZyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0YXJ0UmVjb3JkaW5nKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3Q6IHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFydFRyYW5zY3JpcHRpb24gPSAodmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0ID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5zdGFydFRyYW5zY3JpcHRpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB2aWRlb1N0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3BITFNCcm9hZGNhc3RpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RvcEhMU0Jyb2FkY2FzdGluZyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RvcExpdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RvcExpdmUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RvcFJlY29yZGluZyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RvcFRyYW5zY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RvcFRyYW5zY3JpcHRpb24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuYmxvY2tVc2VyID0gKHZpZGVvVW5ibG9ja1VzZXJSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQudW5ibG9ja1VzZXIoT2JqZWN0LmFzc2lnbih7IHZpZGVvVW5ibG9ja1VzZXJSZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUgPSAodmlkZW9VcGRhdGVDYWxsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwZGF0ZUNhbGwoT2JqZWN0LmFzc2lnbih7IHZpZGVvVXBkYXRlQ2FsbFJlcXVlc3QgfSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxNZW1iZXJzID0gKHZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQudXBkYXRlQ2FsbE1lbWJlcnMoT2JqZWN0LmFzc2lnbih7IHZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVVc2VyUGVybWlzc2lvbnMgPSAodmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQudXBkYXRlVXNlclBlcm1pc3Npb25zKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3QgfSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBpblZpZGVvID0gKHZpZGVvUGluUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnZpZGVvUGluKE9iamVjdC5hc3NpZ24oeyB2aWRlb1BpblJlcXVlc3QgfSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVucGluVmlkZW8gPSAodmlkZW9VbnBpblJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC52aWRlb1VucGluKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VucGluUmVxdWVzdCB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFzZVJlcXVlc3QgPSB7IGlkOiB0aGlzLmlkLCB0eXBlOiB0aGlzLnR5cGUgfTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuc3RyZWFtQ2xpZW50LmdldENvbmZpZ3VyYXRpb24oJ3ZpZGVvJyk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gbmV3IERlZmF1bHRBcGkoY29uZmlndXJhdGlvbik7XG4gICAgfVxufVxuXG5jbGFzcyBTdHJlYW1WaWRlb0NsaWVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50ID0gc3RyZWFtQ2xpZW50O1xuICAgICAgICB0aGlzLmNhbGwgPSAodHlwZSwgaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZWFtQ2FsbCh0aGlzLnN0cmVhbUNsaWVudCwgdHlwZSwgaWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnF1ZXJ5Q2FsbHMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnF1ZXJ5Q2FsbHMoe1xuICAgICAgICAgICAgICAgIHZpZGVvUXVlcnlDYWxsc1JlcXVlc3Q6IHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlQ2FsbFR5cGUgPSAodmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvU2VydmVyU2lkZUFwaUNsaWVudC5jcmVhdGVDYWxsVHlwZSh7XG4gICAgICAgICAgICAgICAgdmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVDYWxsVHlwZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQuZGVsZXRlQ2FsbFR5cGUocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q2FsbFR5cGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LmdldENhbGxUeXBlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RDYWxsVHlwZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQubGlzdENhbGxUeXBlcygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxUeXBlID0gKG5hbWUsIHZpZGVvVXBkYXRlQ2FsbFR5cGVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQudXBkYXRlQ2FsbFR5cGUoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0RXh0ZXJuYWxTdG9yYWdlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmxpc3RFeHRlcm5hbFN0b3JhZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVFeHRlcm5hbFN0b3JhZ2UgPSAodmlkZW9DcmVhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5jcmVhdGVFeHRlcm5hbFN0b3JhZ2Uoe1xuICAgICAgICAgICAgICAgIHZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZUV4dGVybmFsU3RvcmFnZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5kZWxldGVFeHRlcm5hbFN0b3JhZ2UocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRXh0ZXJuYWxTdG9yYWdlID0gKG5hbWUsIHZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LnVwZGF0ZUV4dGVybmFsU3RvcmFnZSh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGVja0V4dGVybmFsU3RvcmFnZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQuY2hlY2tFeHRlcm5hbFN0b3JhZ2UocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLnN0cmVhbUNsaWVudC5nZXRDb25maWd1cmF0aW9uKCd2aWRlbycpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBEZWZhdWx0QXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB0aGlzLnNldHRpbmdzQXBpID0gbmV3IFNldHRpbmdzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICB0aGlzLnZpZGVvU2VydmVyU2lkZUFwaUNsaWVudCA9IG5ldyBTZXJ2ZXJTaWRlQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gSldUVXNlclRva2VuKGFwaVNlY3JldCwgdXNlcklkLCBleHRyYURhdGEgPSB7fSwgand0T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VzZXJJZCBzaG91bGQgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oeyB1c2VyX2lkOiB1c2VySWQgfSwgZXh0cmFEYXRhKTtcbiAgICAvLyBtYWtlIHN1cmUgd2UgcmV0dXJuIGEgY2xlYXIgZXJyb3Igd2hlbiBqd3QgaXMgc2hpbW1lZCAoaWUuIGJyb3dzZXIgYnVpbGQpXG4gICAgaWYgKGp3dCA9PSBudWxsIHx8IGp3dC5zaWduID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGp3dCBjcnlwdG8sIGlmIHlvdSBhcmUgZ2V0dGluZyB0aGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgeW91IGFyZSB0cnlpbmcgdG8gZ2VuZXJhdGUgdG9rZW5zIG9uIGJyb3dzZXIgb3IgUmVhY3QgTmF0aXZlIChvciBvdGhlciBlbnZpcm9ubWVudCB3aGVyZSBjcnlwdG8gZnVuY3Rpb25zIGFyZSBub3QgYXZhaWxhYmxlKS4gUGxlYXNlIE5vdGU6IHRva2VuIHNob3VsZCBvbmx5IGJlIGdlbmVyYXRlZCBzZXJ2ZXItc2lkZS5gKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBhbGdvcml0aG06ICdIUzI1NicsIG5vVGltZXN0YW1wOiB0cnVlIH0sIGp3dE9wdGlvbnMpO1xuICAgIGlmIChwYXlsb2FkLmlhdCkge1xuICAgICAgICBvcHRzLm5vVGltZXN0YW1wID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBhcGlTZWNyZXQsIG9wdHMpO1xufVxuZnVuY3Rpb24gSldUU2VydmVyVG9rZW4oYXBpU2VjcmV0LCBqd3RPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBzZXJ2ZXI6IHRydWUsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IGFsZ29yaXRobTogJ0hTMjU2Jywgbm9UaW1lc3RhbXA6IHRydWUgfSwgand0T3B0aW9ucyk7XG4gICAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIGFwaVNlY3JldCwgb3B0cyk7XG59XG5cbmNsYXNzIFN0cmVhbUNsaWVudCB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXBpS2V5XG4gICAgICogQHBhcmFtIHNlY3JldFxuICAgICAqIEBwYXJhbSBjb25maWcgY2FuIGJlIGEgc3RyaW5nLCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIGJhc2UgcGF0aCAoZGVwcmVjYXRlZCksIG9yIGEgY29uZmlnIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwaUtleSwgc2VjcmV0LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgdGhpcy5zZWNyZXQgPSBzZWNyZXQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5jcmVhdGVEZXZpY2UgPSAoY3JlYXRlRGV2aWNlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlc0FwaS5jcmVhdGVEZXZpY2UoeyBjcmVhdGVEZXZpY2VSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZURldmljZSA9IChyZXF1ZXN0UGFyYW1ldGVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlc0FwaS5kZWxldGVEZXZpY2UocmVxdWVzdFBhcmFtZXRlcnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3REZXZpY2VzID0gKHJlcXVlc3RQYXJhbWV0ZXJzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXZpY2VzQXBpLmxpc3REZXZpY2VzKHJlcXVlc3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0UHVzaFByb3ZpZGVycyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hBcGkubGlzdFB1c2hQcm92aWRlcnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVQdXNoUHJvdmlkZXIgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaEFwaS5kZWxldGVQdXNoUHJvdmlkZXIocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBzZXJ0UHVzaFByb3ZpZGVyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZlcnNpZGVBcGkudXBzZXJ0UHVzaFByb3ZpZGVyKHtcbiAgICAgICAgICAgICAgICB1cHNlcnRQdXNoUHJvdmlkZXJSZXF1ZXN0OiB7IHB1c2hfcHJvdmlkZXI6IHJlcXVlc3QgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoZWNrUHVzaCA9IChjaGVja1B1c2hSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXN0aW5nQXBpLmNoZWNrUHVzaCh7IGNoZWNrUHVzaFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlR3Vlc3QgPSAoZ3Vlc3RSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBndWVzdFJlcXVlc3QudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQoZ3Vlc3RSZXF1ZXN0LnVzZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLmNyZWF0ZUd1ZXN0KHsgZ3Vlc3RSZXF1ZXN0IH0pO1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2VyKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmFuVXNlciA9IChiYW5SZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICBiYW5SZXF1ZXN0LnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKGJhblJlcXVlc3QudXNlcik7XG4gICAgICAgICAgICBiYW5SZXF1ZXN0LmJhbm5lZF9ieSA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQoYmFuUmVxdWVzdC5iYW5uZWRfYnkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkuYmFuKHsgYmFuUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlVXNlciA9IChkZWFjdGl2YXRlVXNlclJlcXVlc3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5kZWFjdGl2YXRlVXNlcih7XG4gICAgICAgICAgICAgICAgZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHVzZXJJZDogZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0LnVzZXJfaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUocmVzcG9uc2UudXNlcik7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGVVc2VycyA9IChkZWFjdGl2YXRlVXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2Vyc0FwaS5kZWFjdGl2YXRlVXNlcnMoeyBkZWFjdGl2YXRlVXNlcnNSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIGBkZWxldGVVc2Vyc2AgaW5zdGVhZFxuICAgICAgICAgKiBAcGFyYW0gZGVsZXRlVXNlcnNSZXF1ZXN0XG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZVVzZXIgPSAocmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLmRlbGV0ZVVzZXIocmVxdWVzdCk7XG4gICAgICAgICAgICByZXNwb25zZS51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWxldGVVc2VycyA9IChkZWxldGVVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLmRlbGV0ZVVzZXJzKHsgZGVsZXRlVXNlcnNSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4cG9ydFVzZXIgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkuZXhwb3J0VXNlcihyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHBvcnRVc2VycyA9IChleHBvcnRVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLmV4cG9ydFVzZXJzKHsgZXhwb3J0VXNlcnNSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZsYWcgPSAoZmxhZ1JlcXVlc3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgICAgICBmbGFnUmVxdWVzdC51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZChmbGFnUmVxdWVzdC51c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5mbGFnKHsgZmxhZ1JlcXVlc3QgfSk7XG4gICAgICAgICAgICBpZiAoKF9iID0gcmVzcG9uc2UuZmxhZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5mbGFnLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUoKF9jID0gcmVzcG9uc2UuZmxhZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWVyeUJhbm5lZFVzZXJzID0gKHBheWxvYWQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHBheWxvYWQudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQocGF5bG9hZC51c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5xdWVyeUJhbm5lZFVzZXJzKHsgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmJhbnMuZm9yRWFjaCgoYikgPT4ge1xuICAgICAgICAgICAgICAgIGIuYmFubmVkX2J5ID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKGIuYmFubmVkX2J5KTtcbiAgICAgICAgICAgICAgICBiLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUoYi51c2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWVyeVVzZXJzID0gKHBheWxvYWQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHBheWxvYWQudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQocGF5bG9hZC51c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5xdWVyeVVzZXJzKHsgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgICAgICByZXNwb25zZS51c2VycyA9IHJlc3BvbnNlLnVzZXJzLm1hcCgodSkgPT4gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHUpKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhY3RpdmF0ZVVzZXIgPSAocmVhY3RpdmF0ZVVzZXJSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkucmVhY3RpdmF0ZVVzZXIoe1xuICAgICAgICAgICAgICAgIHJlYWN0aXZhdGVVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHJlYWN0aXZhdGVVc2VyUmVxdWVzdC51c2VyX2lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZS51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWFjdGl2YXRlVXNlcnMgPSAocmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkucmVhY3RpdmF0ZVVzZXJzKHsgcmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXN0b3JlVXNlcnMgPSAocmVzdG9yZVVzZXJzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkucmVzdG9yZVVzZXJzKHsgcmVzdG9yZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bmJhblVzZXIgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkudW5iYW4ocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5mbGFnID0gKGZsYWdSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2Q7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkudW5mbGFnKHsgZmxhZ1JlcXVlc3QgfSk7XG4gICAgICAgICAgICBpZiAoKF9kID0gcmVzcG9uc2UuZmxhZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5mbGFnLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUocmVzcG9uc2UuZmxhZy51c2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBzZXJ0VXNlcnMgPSAodXBkYXRlVXNlcnNSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh1cGRhdGVVc2Vyc1JlcXVlc3QudXNlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVVzZXJzUmVxdWVzdC51c2Vyc1trZXldID0gdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZCh1cGRhdGVVc2Vyc1JlcXVlc3QudXNlcnNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS51cGRhdGVVc2Vycyh7IHVwZGF0ZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3BvbnNlLnVzZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS51c2Vyc1trZXldID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXJzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVVzZXJzUGFydGlhbCA9IChyZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkudXBkYXRlVXNlcnNQYXJ0aWFsKHtcbiAgICAgICAgICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICAgICAgICAgIHVwZGF0ZVVzZXJQYXJ0aWFsUmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzcG9uc2UudXNlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnVzZXJzW2tleV0gPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUocmVzcG9uc2UudXNlcnNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXV0ZVVzZXIgPSAobXV0ZVVzZXJSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2UsIF9mO1xuICAgICAgICAgICAgbXV0ZVVzZXJSZXF1ZXN0LnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKG11dGVVc2VyUmVxdWVzdC51c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5tdXRlVXNlcih7IG11dGVVc2VyUmVxdWVzdCB9KTtcbiAgICAgICAgICAgIGlmICgoX2UgPSByZXNwb25zZS5tdXRlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudXNlcikge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm11dGUudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZSgoX2YgPSByZXNwb25zZS5tdXRlKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YudXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubXV0ZXMpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tdXRlcyA9IHJlc3BvbnNlLm11dGVzLm1hcCgobSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtKSwgeyB1c2VyOiB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUobS51c2VyKSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5tdXRlVXNlciA9ICh1bm11dGVVc2VyUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgdW5tdXRlVXNlclJlcXVlc3QudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQodW5tdXRlVXNlclJlcXVlc3QudXNlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2Vyc0FwaS51bm11dGVVc2VyKHsgdW5tdXRlVXNlclJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZEN1c3RvbUV2ZW50VG9Vc2VyID0gKHVzZXJJZCwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50c0FwaS5zZW5kVXNlckN1c3RvbUV2ZW50KHtcbiAgICAgICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICAgICAgc2VuZFVzZXJDdXN0b21FdmVudFJlcXVlc3Q6IHsgZXZlbnQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZVJvbGUgPSAoY3JlYXRlUm9sZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zQXBpLmNyZWF0ZVJvbGUoeyBjcmVhdGVSb2xlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVSb2xlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zQXBpLmRlbGV0ZVJvbGUocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UGVybWlzc2lvbiA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5nZXRQZXJtaXNzaW9uKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RQZXJtaXNzaW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zQXBpLmxpc3RQZXJtaXNzaW9ucygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RSb2xlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zQXBpLmxpc3RSb2xlcygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEFwcFNldHRpbmdzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuZ2V0QXBwKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlQXBwU2V0dGluZ3MgPSAodXBkYXRlQXBwUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkudXBkYXRlQXBwKHsgdXBkYXRlQXBwUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRSYXRlTGltaXRzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuZ2V0UmF0ZUxpbWl0cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFRhc2tTdGF0dXMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFza3NBcGkuZ2V0VGFzayhyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52ZXJpZnlXZWJob29rID0gKHJlcXVlc3RCb2R5LCB4U2lnbmF0dXJlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbSh0aGlzLnNlY3JldCwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG9cbiAgICAgICAgICAgICAgICAuY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KVxuICAgICAgICAgICAgICAgIC51cGRhdGUocmVxdWVzdEJvZHkpXG4gICAgICAgICAgICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8udGltaW5nU2FmZUVxdWFsKEJ1ZmZlci5mcm9tKGhhc2gpLCBCdWZmZXIuZnJvbSh4U2lnbmF0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvbmZpZ3VyYXRpb24gPSAocHJvZHVjdCA9ICdjaGF0JykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25maWd1cmF0aW9uKHtcbiAgICAgICAgICAgICAgICBhcGlLZXk6IChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnU3RyZWFtLUF1dGgtVHlwZSc6ICdqd3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpX2tleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwcGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhc2VQYXRoOiAoX2EgPSB0aGlzLm9wdGlvbnMuYmFzZVBhdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChwcm9kdWN0ID09PSAnY2hhdCdcbiAgICAgICAgICAgICAgICAgICAgPyAnaHR0cHM6Ly9jaGF0LnN0cmVhbS1pby1hcGkuY29tJ1xuICAgICAgICAgICAgICAgICAgICA6ICdodHRwczovL3ZpZGVvLnN0cmVhbS1pby1hcGkuY29tJyksXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnWC1TdHJlYW0tQ2xpZW50JzogJ3N0cmVhbS1ub2RlLScgKyBcIjAuMS4xMlwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmU6IChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbml0LmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQuaW5pdC5oZWFkZXJzKSwgeyAneC1jbGllbnQtcmVxdWVzdC1pZCc6IHY0KCksICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHRoZSBsYXN0IHBvc3QgbWlkZGxld2FyZSBiZWNhdXNlIHRoYXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIEZldGNoIEFQSSB3b24ndCB0aHJvdyBhbiBlcnJvciBmb3IgSFRUUCBlcnJvciByZXNwb25zZXMsIHdoaWNoIG1lYW5zIHRoZSBcIm9uRXJyb3JcIiBtaWRkbGV3YXJlIHdvbid0IGJlIGNhbGxlZCBzbyB3ZSBuZWVkIHRvIHRocm93IGVycm9yIGZyb20gXCJwb3N0XCIgbWlkZGxld2FyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdDogKGNvbnRleHQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbnRleHQucmVzcG9uc2UgJiYgY29udGV4dC5yZXNwb25zZS5zdGF0dXMgPCAyMDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzcG9uc2Uuc3RhdHVzID49IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBKU09OQXBpUmVzcG9uc2UoY29udGV4dC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKHlpZWxkIHJlc3BvbnNlLnZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmVhbSBlcnJvciBjb2RlICR7dmFsdWUuY29kZX06ICR7dmFsdWUubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaW5pdC5zaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMub3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjb250ZXh0LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RpbWVvdXRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IoZXJyb3IsIGBUaGUgcmVxdWVzdCB3YXMgYWJvcnRlZCBkdWUgdG8gdG8gdGhlICR7dGhpcy5vcHRpb25zLnRpbWVvdXR9bXMgdGltZW91dCwgeW91IGNhbiBzZXQgdGhlIHRpbWVvdXQgaW4gdGhlIFN0cmVhbUNsaWVudCBjb25zdHJ1Y3RvcmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbnRleHQucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9PcGVuQVBJVG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IvaXNzdWVzLzEzMjIyXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXNTdHJpbmdpZnk6IChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtc1trXSkgfHwgdHlwZW9mIHBhcmFtc1trXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXMucHVzaChgJHtrfT0ke2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShwYXJhbXNba10pKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zLnB1c2goYCR7a309JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3UGFyYW1zLmpvaW4oJyYnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzZXJ2ZWRLZXl3b3JkcyA9IFtcbiAgICAgICAgICAgICdiYW5fZXhwaXJlcycsXG4gICAgICAgICAgICAnYmFubmVkJyxcbiAgICAgICAgICAgICdpZCcsXG4gICAgICAgICAgICAnaW52aXNpYmxlJyxcbiAgICAgICAgICAgICdsYW5ndWFnZScsXG4gICAgICAgICAgICAncHVzaF9ub3RpZmljYXRpb25zJyxcbiAgICAgICAgICAgICdyZXZva2VfdG9rZW5zX2lzc3VlZF9iZWZvcmUnLFxuICAgICAgICAgICAgJ3JvbGUnLFxuICAgICAgICAgICAgJ3RlYW1zJyxcbiAgICAgICAgICAgICdjcmVhdGVkX2F0JyxcbiAgICAgICAgICAgICdkZWFjdGl2YXRlZF9hdCcsXG4gICAgICAgICAgICAnZGVsZXRlZF9hdCcsXG4gICAgICAgICAgICAnbGFzdF9hY3RpdmUnLFxuICAgICAgICAgICAgJ29ubGluZScsXG4gICAgICAgICAgICAndXBkYXRlZF9hdCcsXG4gICAgICAgICAgICAnc2hhZG93X2Jhbm5lZCcsXG4gICAgICAgICAgICAnbmFtZScsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kID0gKHVzZXIpID0+IHtcbiAgICAgICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdXNlcik7XG4gICAgICAgICAgICBkZWxldGUgY29weS5jdXN0b207XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb3B5KSwgdXNlci5jdXN0b20pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRva2VuID0gSldUU2VydmVyVG9rZW4odGhpcy5zZWNyZXQpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5iYXNlUGF0aCA9IGNvbmZpZztcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy50aW1lb3V0ID0gU3RyZWFtQ2xpZW50LkRFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudGltZW91dCA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBTdHJlYW1DbGllbnQuREVGQVVMVF9USU1FT1VUO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlkZW8gPSBuZXcgU3RyZWFtVmlkZW9DbGllbnQodGhpcyk7XG4gICAgICAgIHRoaXMuY2hhdCA9IG5ldyBTdHJlYW1DaGF0Q2xpZW50KHRoaXMpO1xuICAgICAgICBjb25zdCBjaGF0Q29uZmlndXJhdGlvbiA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnVzZXJzQXBpID0gbmV3IFVzZXJzQXBpKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5kZXZpY2VzQXBpID0gbmV3IERldmljZXNBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnB1c2hBcGkgPSBuZXcgUHVzaEFwaShjaGF0Q29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuc2VydmVyc2lkZUFwaSA9IG5ldyBTZXJ2ZXJTaWRlQXBpJDEoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnRlc3RpbmdBcGkgPSBuZXcgVGVzdGluZ0FwaShjaGF0Q29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMucGVybWlzc2lvbnNBcGkgPSBuZXcgUGVybWlzc2lvbnNWMkFwaShjaGF0Q29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuc2V0dGluZ3NBcGkgPSBuZXcgU2V0dGluZ3NBcGkkMShjaGF0Q29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuZXZlbnRzQXBpID0gbmV3IEV2ZW50c0FwaShjaGF0Q29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMudGFza3NBcGkgPSBuZXcgVGFza3NBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySURcbiAgICAgKiBAcGFyYW0gZXhwXG4gICAgICogQHBhcmFtIGlhdCBkZXByZWNhdGVkLCB0aGUgZGVmYXVsdCBkYXRlIHdpbGwgYmUgc2V0IGludGVybmFsbHlcbiAgICAgKiBAcGFyYW0gY2FsbF9jaWRzIHRoaXMgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgdXNlIGBjcmVhdGVDYWxsVG9rZW5gIGZvciBjYWxsIHRva2Vuc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgY3JlYXRlVG9rZW4odXNlcklELCBleHAgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyA2MCAqIDYwLCBpYXQgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSwgY2FsbF9jaWRzKSB7XG4gICAgICAgIGNvbnN0IGV4dHJhID0ge307XG4gICAgICAgIGlmIChleHApIHtcbiAgICAgICAgICAgIGV4dHJhLmV4cCA9IGV4cDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWF0KSB7XG4gICAgICAgICAgICBleHRyYS5pYXQgPSBpYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxfY2lkcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVc2UgY3JlYXRlQ2FsbFRva2VuIG1ldGhvZCBmb3IgY3JlYXRpbmcgY2FsbCB0b2tlbnMsIHRoZSBcImNhbGxfY2lkc1wiIHBhcmFtIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBjcmVhdGVUb2tlbiBtZXRob2Qgd2l0aCB2ZXJzaW9uIDAuMi4wYCk7XG4gICAgICAgICAgICBleHRyYS5jYWxsX2NpZHMgPSBjYWxsX2NpZHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpXVFVzZXJUb2tlbih0aGlzLnNlY3JldCwgdXNlcklELCBleHRyYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJJRFxuICAgICAqIEBwYXJhbSBjYWxsX2NpZHNcbiAgICAgKiBAcGFyYW0gZXhwXG4gICAgICogQHBhcmFtIGlhdCB0aGlzIGlzIGRlcHJlY2F0ZWQsIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBiZSBzZXQgaW50ZXJuYWxseVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgY3JlYXRlQ2FsbFRva2VuKHVzZXJJRCwgY2FsbF9jaWRzLCBleHAgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyA2MCAqIDYwLCBpYXQgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSkge1xuICAgICAgICBjb25zdCBleHRyYSA9IHt9O1xuICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICBleHRyYS5leHAgPSBleHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlhdCkge1xuICAgICAgICAgICAgZXh0cmEuaWF0ID0gaWF0O1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhLmNhbGxfY2lkcyA9IGNhbGxfY2lkcztcbiAgICAgICAgcmV0dXJuIEpXVFVzZXJUb2tlbih0aGlzLnNlY3JldCwgdXNlcklELCBleHRyYSk7XG4gICAgfVxuICAgIG1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUodXNlcikge1xuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHVzZXIpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2VydmVkS2V5d29yZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmN1c3RvbSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY3VzdG9tID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5jdXN0b21ba2V5XSA9IHVzZXJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdXNlcltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5TdHJlYW1DbGllbnQuREVGQVVMVF9USU1FT1VUID0gMzAwMDtcblxuZXhwb3J0IHsgQVBOQ29uZmlnUmVxdWVzdEF1dGhUeXBlRW51bSwgQXBwU2VhcmNoQmFja2VuZEVudW0sIEFzeW5jTW9kZXJhdGlvbkNhbGxiYWNrQ29uZmlnUmVxdWVzdE1vZGVFbnVtLCBBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0sIEJsb2NrTGlzdE9wdGlvbnNCZWhhdmlvckVudW0sIEJsb2NrTGlzdE9wdGlvbnNSZXF1ZXN0QmVoYXZpb3JFbnVtLCBDaGFubmVsQ29uZmlnQXV0b21vZEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ0F1dG9tb2RFbnVtLCBDaGFubmVsQ29uZmlnQmxvY2tsaXN0QmVoYXZpb3JFbnVtLCBDaGFubmVsQ29uZmlnUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvQXV0b21vZEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvQXV0b21vZEVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb0Jsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvUmVxdWVzdEF1dG9tb2RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kRW51bSwgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbE1lbWJlclJlcXVlc3RSb2xlRW51bSwgQ2hhbm5lbE1lbWJlclJvbGVFbnVtLCBDaGFubmVsVHlwZUNvbmZpZ0F1dG9tb2RCZWhhdmlvckVudW0sIENoYW5uZWxUeXBlQ29uZmlnQXV0b21vZEVudW0sIENoYW5uZWxUeXBlQ29uZmlnQmxvY2tsaXN0QmVoYXZpb3JFbnVtLCBDaGVja1B1c2hSZXF1ZXN0UHVzaFByb3ZpZGVyVHlwZUVudW0sIENoZWNrU05TUmVzcG9uc2VTdGF0dXNFbnVtLCBDaGVja1NRU1Jlc3BvbnNlU3RhdHVzRW51bSwgQ29uZmlnRGVmYXVsdFJvbGVFbnVtLCBDb25maWdSZXF1ZXN0RGVmYXVsdFJvbGVFbnVtLCBDcmVhdGVDYWxsUmVxdWVzdFR5cGVFbnVtLCBDcmVhdGVDaGFubmVsVHlwZVJlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtLCBDcmVhdGVDaGFubmVsVHlwZVJlcXVlc3RBdXRvbW9kRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtLCBDcmVhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEJlaGF2aW9yRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RFbnVtLCBDcmVhdGVDaGFubmVsVHlwZVJlc3BvbnNlQmxvY2tsaXN0QmVoYXZpb3JFbnVtLCBDcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSwgQ3JlYXRlSW1wb3J0UmVxdWVzdE1vZGVFbnVtLCBEZWxldGVVc2Vyc1JlcXVlc3RDb252ZXJzYXRpb25zRW51bSwgRGVsZXRlVXNlcnNSZXF1ZXN0TWVzc2FnZXNFbnVtLCBEZWxldGVVc2Vyc1JlcXVlc3RVc2VyRW51bSwgRGV2aWNlRmllbGRzUHVzaFByb3ZpZGVyRW51bSwgRGV2aWNlUHVzaFByb3ZpZGVyRW51bSwgRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0sIEltYWdlU2l6ZUNyb3BFbnVtLCBJbWFnZVNpemVSZXNpemVFbnVtLCBMYXlvdXRTZXR0aW5nc05hbWVFbnVtLCBNZXNzYWdlUmVxdWVzdDFUeXBlRW51bSwgTWVzc2FnZVJlcXVlc3RUeXBlRW51bSwgTWVzc2FnZVR5cGVFbnVtLCBQZXJtaXNzaW9uTGV2ZWxFbnVtLCBQb2xpY3lSZXF1ZXN0MUFjdGlvbkVudW0sIFBvbGljeVJlcXVlc3RBY3Rpb25FbnVtLCBQdXNoQ29uZmlnUmVxdWVzdFZlcnNpb25FbnVtLCBTdHJlYW1DYWxsLCBTdHJlYW1DaGFubmVsLCBTdHJlYW1DaGF0Q2xpZW50LCBTdHJlYW1DbGllbnQsIFN0cmVhbVZpZGVvQ2xpZW50LCBUcmFuc2NyaXB0aW9uU2V0dGluZ3NNb2RlRW51bSwgVHJhbnNsYXRlTWVzc2FnZVJlcXVlc3RMYW5ndWFnZUVudW0sIFVwZGF0ZUFwcFJlcXVlc3RFbmZvcmNlVW5pcXVlVXNlcm5hbWVzRW51bSwgVXBkYXRlQXBwUmVxdWVzdFBlcm1pc3Npb25WZXJzaW9uRW51bSwgVXBkYXRlQXBwUmVxdWVzdFZpZGVvUHJvdmlkZXJFbnVtLCBVcGRhdGVDaGFubmVsVHlwZVJlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtLCBVcGRhdGVDaGFubmVsVHlwZVJlcXVlc3RBdXRvbW9kRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtLCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEJlaGF2aW9yRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RFbnVtLCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQmxvY2tsaXN0QmVoYXZpb3JFbnVtLCBWaWRlb0F1ZGlvU2V0dGluZ3NEZWZhdWx0RGV2aWNlRW51bSwgVmlkZW9BdWRpb1NldHRpbmdzUmVxdWVzdERlZmF1bHREZXZpY2VFbnVtLCBWaWRlb0NyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtLCBWaWRlb0xheW91dFNldHRpbmdzTmFtZUVudW0sIFZpZGVvTGF5b3V0U2V0dGluZ3NSZXF1ZXN0TmFtZUVudW0sIFZpZGVvT3duQ2FwYWJpbGl0eSwgVmlkZW9SZWNvcmRTZXR0aW5nc1JlcXVlc3RNb2RlRW51bSwgVmlkZW9SZWNvcmRTZXR0aW5nc1JlcXVlc3RRdWFsaXR5RW51bSwgVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0sIFZpZGVvVHJhbnNjcmlwdGlvblNldHRpbmdzTW9kZUVudW0sIFZpZGVvVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdE1vZGVFbnVtLCBWaWRlb1ZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtLCBWaWRlb1ZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@stream-io/node-sdk/dist/index.es.js\n");

/***/ })

};
;